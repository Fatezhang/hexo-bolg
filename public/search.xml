<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[由 SpringBoot 升级到 2.4.2 引发的 Jackson 的 JsonFormat 问题排查]]></title>
    <url>%2Fblog%2F20210120%2Fspring-boot-to-2-4-2%2F</url>
    <content type="text"><![CDATA[事情是这样的在不久的以前，我们项目的 Tech Lead 决定在git repo中引入 DependaBot 来对项目中的依赖做检查并升级。我们的一个使用 SpringBoot 的服务也就这样成了待升级依赖的一份子。我们待升级的依赖包括但不限于： Bump newrelic-agent from 5.8.0 to 6.3.0 … Bump guava from 28.0-jre to 30.1-jre … Bump spring-hateoas from 1.1.0.RELEASE to 1.2.3 … Bump postgresql from 42.2.8 to 42.2.18 … Bump cloudwatch from 2.13.41 to 2.15.66 … Bump json-schema-validator from 4.2.0 to 4.3.3 … Bump org.springframework.boot from 2.2.5.RELEASE to 2.4.2 … Bump io.spring.dependency-management … Bump io.freefair.lombok from 4.1.3 to 5.3.0 … Bump org.flywaydb.flyway from 6.1.3 to 7.5.0 … 可以看到，几乎都将这些依赖升级到了最新的版本，甚至 SpringBoot2.4.2 是在这次升级的前三天 release 的。但是我们不慌，升级依赖什么的对我们来说跟喝水一样简单，因为… 1234567891011jacocoTestCoverageVerification &#123; dependsOn 'jacocoTestReport' violationRules &#123; rule &#123; element = 'CLASS' limit &#123; minimum = 1.0 &#125; &#125; &#125;&#125; 我们的代码的测试覆盖率的要求是惊人的100%🤣 这在我之前的公司是绝对无法实现的。不仅仅是 unit test， 我们还有 integration 测试覆盖，还有用到 cypress 又一次覆盖了所有的 endpoint。不就是改改代码么/升级依赖啥的么，随便玩。 于是梭哈！👨🏻‍💻👨🏻‍💻👨🏻‍💻👨🏻‍💻👨🏻‍💻👨🏻‍💻👨🏻‍💻升级，跑测试！ 几分钟后： 行嘛，不出我所料（才怪🙃）果然挂了。 打开log一看， emmm… 12Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.time.LocalDate` from String "2020-01-15": Failed to deserialize java.time.LocalDate: (java.time.format.DateTimeParseException) Text '2020-01-15' could not be parsed: Unable to obtain LocalDate from TemporalAccessor: &#123;YearOfEra=2020, MonthOfYear=1, DayOfMonth=15&#125;,ISO of type java.time.format.Parsed; nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: Cannot deserialize value of type `java.time.LocalDate` from String "2020-01-15": Failed to deserialize java.time.LocalDate: (java.time.format.DateTimeParseException) Text '2020-01-15' could not be parsed: Unable to obtain LocalDate from TemporalAccessor: &#123;YearOfEra=2020, MonthOfYear=1, DayOfMonth=15&#125;,ISO of type java.time.format.Parsed at [Source: (PushbackInputStream); line: 2, column: 18] (through reference chain: com.example.demo.Demo["localDate"])] 汪的发！？😢 用的好好的@JsonFormat怎么就突然不好使了？ 问题排查打开代码看一下：我有这么一个对象： 1234567891011121314public class Demo &#123; public Demo()&#123;&#125; public Demo(LocalDate localDate)&#123; this.localDate = localDate; &#125; @JsonFormat(pattern = "yyyy-MM-dd", lenient = OptBoolean.FALSE) private LocalDate localDate; public LocalDate getLocalDate() &#123; return localDate; &#125; public void setLocalDate(LocalDate localDate) &#123; this.localDate = localDate; &#125;&#125; 其中配置了 localDate 的反序列化为严格模式lenient = OptBoolean.FALSE，防止将 number 反序列化为日期，那样是不正确的。 有这么一个 controller： 12345678@RestControllerpublic class Controller &#123; @GetMapping("/demo") public ResponseEntity&lt;String&gt; test(@RequestBody Demo demo) &#123; var localDate = demo.getLocalDate().toString(); return ResponseEntity.ok(localDate); &#125;&#125; 代码很简单，就是有一个对象，接收一个 LocalDate 的属性，用pattern yyyy-MM-dd 接收类似于2020-01-15这样格式的日期。 但是之前用得好好的升级了 SpringBoot2.4.2之后却用不了了？emmmm… 一定是 SpringBoot 升级升了啥不该升的玩应，🧐我要去 SpringBoot 的升级日志里看看，是不是升级了 Jackson 啥的，万一找到一个大霸哥🦟，提个 PR 不就从此成为顶级开源项目的 contributor 了。。。😎 SpringBoot 2.4.2 升级日志去 GitHub 上打开 SpringBoot Release v2.4.2 ， 浏览下 Bug Fixes 、 Documentation、Dependency Upgrades， 发现一行： Upgrade to Jackson Bom 2.11.4 #24726 果然，升级了 Jackson 到2.11.4。 对比了一下发现我原先的 SpringBoot 中的 Jackson 版本是2.10.2， emm… 一般这种稍大的版本升级都伴随着很多 magic 的事情。总之接下来要去 Jackson 的升级日志里面看一下，有什么升级跨越了2.10.*和2.11.*这两个版本。 Jackson 2.11升级日志这个升级日志在它 GitHub 的 wiki 里，点击Jackson Release 2.11。 阅读一下，第一遍竟然没有找到任何线索，阿西吧🥵，通篇与@JsonFormat的字眼几乎没有。但是，功夫不负有心人，由于我这个错误是时间类型的转换问题，在如下所示的更改中，发现对于Java 8date/time有相关升级： #148: Allow strict LocalDate parsing 打开这个 issue 看一下，如他们所讨论的，在之前配置了@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, lenient = OptBoolean.FALSE), Jackson 创建的DateTimeFormatter还是会使用ResolverStyle.SMART smart 模式，并不能阻止非法日期2019-11-31的输入。 所以在2.11版本之后， 如果设置了lenient = OptBoolean.FALSE, DateTimeFormatter会使用严格模式，看看代码： 在Jackson 中的JSR310DateTimeDeserializerBase这个类中，有这么一个方法createContextual， 有这么一段代码： 123if (!deser.isLenient()) &#123; df = df.withResolverStyle(ResolverStyle.STRICT);&#125; 可是，为什么DateTimeFormatter使用了严格模式，会导致上述报错呢？ Java8 之后的 java.time 之 DateTimeFormatter严格模式下的字符串转LocalDate 举个🌰👀👀 12345678public static void main(String[] args) &#123; DateTimeFormatter formatter = DateTimeFormatter .ofPattern("yyyy-MM-dd") .withResolverStyle(ResolverStyle.STRICT); LocalDate localDate = LocalDate.parse("2021-01-20", formatter); System.out.println("localDate = " + localDate);&#125; 执行，并抛出异常，转换失败！ 1Exception in thread "main" java.time.format.DateTimeParseException: Text '2021-01-20' could not be parsed: Unable to obtain LocalDate from TemporalAccessor: &#123;YearOfEra=2021, DayOfMonth=20, MonthOfYear=1&#125;,ISO of type java.time.format.Parsed 关键字YearOfEra？🧐啊，带年代的年？沃德发😱？ 打开类DateTimeFormatter搜索一下yyyy，发现一段注释里面y: year-of-era： 1234567891011* All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters. The* following pattern letters are defined:* &lt;table class="striped"&gt;* &lt;caption&gt;Pattern Letters and Symbols&lt;/caption&gt;* &lt;thead&gt;* &lt;tr&gt;&lt;th scope="col"&gt;Symbol&lt;/th&gt; &lt;th scope="col"&gt;Meaning&lt;/th&gt; &lt;th scope="col"&gt;Presentation&lt;/th&gt; &lt;th scope="col"&gt;Examples&lt;/th&gt;* &lt;/thead&gt;* &lt;tbody&gt;* &lt;tr&gt;&lt;th scope="row"&gt;G&lt;/th&gt; &lt;td&gt;era&lt;/td&gt; &lt;td&gt;text&lt;/td&gt; &lt;td&gt;AD; Anno Domini; A&lt;/td&gt;* &lt;tr&gt;&lt;th scope="row"&gt;u&lt;/th&gt; &lt;td&gt;year&lt;/td&gt; &lt;td&gt;year&lt;/td&gt; &lt;td&gt;2004; 04&lt;/td&gt;* &lt;tr&gt;&lt;th scope="row"&gt;y&lt;/th&gt; &lt;td&gt;year-of-era&lt;/td&gt; &lt;td&gt;year&lt;/td&gt; &lt;td&gt;2004; 04&lt;/td&gt; 原来，u才是代表年的那个字母，而y是指带有纪元（era）的年，在DateTimeFormatter严格模式下使用，yyyy-MM-dd并不合法，正确的使用姿势是uuuu-MM-dd！！！ 所以yyyy要怎么用呢？如下，带上G表示一下公元前或者公元后吧。AD/BC 12345DateTimeFormatter formatter = DateTimeFormatter .ofPattern("yyyy-MM-dd G") .withResolverStyle(ResolverStyle.STRICT);LocalDate localDate = LocalDate.parse("2021-01-20 AD", formatter); 至此，大功告成，问题解决，依赖也成功升级 总结一下问题解决了心情很好，但是反思一下，Java8 都出来这么久了，新的日期时间也用了很多，但是就是忽略了y和u这么不起眼的小问题！ 在问题的排查中，实际上并不如上述流程这样顺利，我还在 Jackson 的 GitHub 里面提了 issue https://github.com/FasterXML/jackson-modules-java8/issues/199 在我排查 Jackson 的源码的时候，发现他们对于这段代码df = df.withResolverStyle(ResolverStyle.STRICT);的升级，并没有很完善的测试。在他们的源码中可以看到test case 都是只是测试了异常情况，并没有覆盖原先本应该正确的 case（可见 unit test 是多么的重要），他们的测试源码如下： 123456789101112131415161718public class LocalDateDeserTest extends ModuleTestBase &#123; private final ObjectMapper MAPPER = newMapper(); final static class StrictWrapper &#123; @JsonFormat(pattern="yyyy-MM-dd", lenient = OptBoolean.FALSE) public LocalDate value; public StrictWrapper() &#123; &#125; public StrictWrapper(LocalDate v) &#123; value = v; &#125; &#125; @Test(expected = InvalidFormatException.class) public void testStrictCustomFormat() throws Exception &#123; /*StrictWrapper w =*/ MAPPER.readValue("&#123;\"value\":\"2019-11-31\"&#125;", StrictWrapper.class); &#125;&#125; 这个测试的问题在于，将{ &quot;value&quot; : &quot;2019-11-31&quot;}改成合法的也能跑过。因为严格模式下， yyyy-MM-dd并不合法，同样会跑出InvalidFormatException异常。所以我在 Jackson 的jackson-modules-java8这个 repo 下还提了一个 PR 去修改他们的测试用例： https://github.com/FasterXML/jackson-modules-java8/pull/201 不过也只是简单覆盖一下这个 case，对于其他用到yyyy的测试并未做修改，希望我的 PR 能被合进去吧哈哈😜虽然只是单元测试并不是代码功能，但也很有用啊。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>DateTimeFormatter</tag>
        <tag>jackson</tag>
        <tag>lenient</tag>
        <tag>JsonFormat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 UPic & GitHub 做个自己的图床]]></title>
    <url>%2Fblog%2F20210113%2F%E4%BD%BF%E7%94%A8-UPic-GitHub-%E5%81%9A%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[有写过一个小小的创建步骤，不过是英文版的(在练习写英文博客)，有兴趣的可以点开看下，步骤也比较简单。点击跳转到文章]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Localstack 搭建 AWS 本地开发环境]]></title>
    <url>%2Fblog%2F20201227%2F%E4%BD%BF%E7%94%A8localstack-%E6%90%AD%E5%BB%BA-AWS-%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言相信有很多同学公司项目都有用到 AWS 或者有同学在学习 AWS，我们知道像 AWS 这样的云服务，我们不太能很方便的去在本地开发的时候连接云上的服务，更何况 staging/production 环境还会有安全方面的考虑。那么当我们创建好一个项目的时候，我们如何去搭建其本地开发环境方便我们在本地开发调试呢？没错！使用 localstack！ LocalStack - A fully functional local AWS cloud stack LocalStack provides an easy-to-use test/mocking framework for developing Cloud applications. Currently, the focus is primarily on supporting the AWS cloud stack. LocalStack 是提供给开发者一个方便去测试和 mock 服务的框架， 目前主要提供 AWS 云服务。 如何使用？例：使用 LocalStack 创建一个 SNS服务想像我们有这样一个 SpringBoot 服务，提供接口在用户提交一条记录的时候给用户发邮件，一般情况这种业务我们都会将保存数据库和发邮件异步执行。使用 AWS 的话，我们就可以在保存数据库之后调用 SNS 服务，发布一个 Event 然后等待下游邮件服务订阅对应的 topic 然后消费。 那么如何创建呢？如下在 docker-compose.yml 文件中加入localstack，SERVICES 指定好 sns： docker-compose.yml123456789101112131415version: "3.7"services: localstack: image: localstack/localstack:0.12.1 networks: - app_net ports: - "4566:4566" environment: - SERVICES=sns - DEFAULT_REGION=ap-southeast-2 - DEBUG=1 volumes: - ./auto/create-localstack-topic:/docker-entrypoint-initaws.d/create-localstack-topic.sh create-localstack-topic.sh此外，可以看到我们还 volume 了一个脚本进去，那就是创建 SNS 的脚本。实际上这个命令就是 aws cli，在其官网就可以找得到，我们只需要把 aws 换成 awslocal 123456#!/bin/bashREGION=$&#123;DEFAULT_REGION:-ap-southeast-2&#125;TOPIC_NAME=demo-events-topicawslocal sns create-topic --name=$&#123;TOPIC_NAME&#125; --region "$&#123;REGION&#125;" 启动日志当启动 docker-compose up localstack 的时候，就在该容器中创建好了 SNS 服务提供给我们使用。 12345678910111213141516171819202122232425262728293031sns_1 | Waiting for all LocalStack services to be readysns_1 | 2020-12-27 07:02:36,554 CRIT Supervisor is running as root. Privileges were not dropped because no user is specified in the config file. If you intend to run as root, you can set user=root in the config file to avoid this message.sns_1 | 2020-12-27 07:02:36,559 INFO supervisord started with pid 15sns_1 | 2020-12-27 07:02:37,566 INFO spawned: 'dashboard' with pid 21sns_1 | 2020-12-27 07:02:37,571 INFO spawned: 'infra' with pid 22sns_1 | 2020-12-27 07:02:37,577 INFO success: dashboard entered RUNNING state, process has stayed up for &gt; than 0 seconds (startsecs)sns_1 | 2020-12-27 07:02:37,577 INFO exited: dashboard (exit status 0; expected)sns_1 | (. .venv/bin/activate; exec bin/localstack start --host)sns_1 | 2020-12-27 07:02:38,591 INFO success: infra entered RUNNING state, process has stayed up for &gt; than 1 seconds (startsecs)sns_1 | LocalStack version: 0.12.1sns_1 | Starting local dev environment. CTRL-C to quit.sns_1 | 2020-12-27T07:02:39:DEBUG:bootstrap.py: Loading plugins - scope "services", module "localstack": &lt;function register_localstack_plugins at 0x7f963f120f70&gt;sns_1 | Waiting for all LocalStack services to be readysns_1 | 2020-12-27T07:02:43:INFO:localstack.utils.analytics.profiler: Execution of "load_plugin_from_path" took 4333.9550495147705mssns_1 | 2020-12-27T07:02:43:INFO:localstack.utils.analytics.profiler: Execution of "load_plugins" took 4334.24186706543mssns_1 | Starting edge router (https port 4566)...sns_1 | Starting mock SNS service on http port 4566 ...sns_1 | 2020-12-27T07:02:45:INFO:localstack.utils.analytics.profiler: Execution of "prepare_environment" took 2061.4540576934814mssns_1 | 2020-12-27T07:02:45:INFO:localstack.multiserver: Starting multi API server process on port 59903sns_1 | [2020-12-27 07:02:45 +0000] [23] [INFO] Running on https://0.0.0.0:4566 (CTRL + C to quit)sns_1 | 2020-12-27T07:02:45:INFO:hypercorn.error: Running on https://0.0.0.0:4566 (CTRL + C to quit)sns_1 | [2020-12-27 07:02:45 +0000] [23] [INFO] Running on http://0.0.0.0:59903 (CTRL + C to quit)sns_1 | 2020-12-27T07:02:45:INFO:hypercorn.error: Running on http://0.0.0.0:59903 (CTRL + C to quit)sns_1 | 2020-12-27 07:02:45,824:API: * Running on http://0.0.0.0:57589/ (Press CTRL+C to quit)sns_1 | Waiting for all LocalStack services to be readysns_1 | Ready.sns_1 | 2020-12-27T07:02:50:INFO:localstack.utils.analytics.profiler: Execution of "start_api_services" took 5102.221965789795mssns_1 | /usr/local/bin/docker-entrypoint.sh: running /docker-entrypoint-initaws.d/create-localstack-topic.shsns_1 | &#123;sns_1 | "TopicArn": "arn:aws:sns:ap-southeast-2:000000000000:demo-events-topic"sns_1 | &#125; 在命令行调用1aws --endpoint-url=http://localhost:4566 sns publish --topic-arn arn:aws:sns:ap-southeast-2:000000000000:demo-events-topic --region ap-southeast-2 --message "Hello SNS" 注意，在本地使用 aws 命令调用 localstack 中的服务的时候，需要覆盖endpoint-url, 否则回去拿着 credentials 调用实际环境的服务。 在 SpringBoot 中使用的注意点在 SpringBoot 或者其他代码库（如node）中使用的话，可以根据不同的环境创建不同的 SNSClient， 本地环境的注意要覆盖 endpoint： 12345678910111213141516@Configuration@Profile(&#123;"local", "docker"&#125;)public class LocalSnsClientConfiguration &#123; @Value("$&#123;aws.sns.endpoint&#125;") private String awsSnsEndpoint; @Bean public SnsClient snsClient() &#123; var clientBuilder = SnsClient.builder(); if (!Strings.isNullOrEmpty(awsSnsEndpoint)) &#123; clientBuilder.endpointOverride(URI.create(awsSnsEndpoint)); &#125; return clientBuilder.build(); &#125;&#125; 启动多个服务上面只是一个启动 SNS 服务的例子，实际使用中，我们都会多种服务结合使用。比如会有一个 SQS 服务， 订阅了 SNS 的 topic，然后去 trigger 一个 lambda，执行相应的一些任务，那么如何在本地实现这些服务的相互订阅与触发呢？实际上只需要在一个 localstack 中启动多个服务然后执行一些脚本建立之间的关系（具体命令和 aws cli 一样）就可以了，如下： docker-compose.yml1234567891011121314151617181920212223242526272829version: "3.7"services: localstack: image: localstack/localstack:0.12.1 privileged: true container_name: localstack networks: - app_net ports: - "4566:4566" environment: - SERVICES=sns,sqs,kms,cloudwatch,lambda - DEFAULT_REGION=ap-southeast-2 - LAMBDA_EXECUTOR=docker-reuse - LAMBDA_REMOTE_DOCKER=false - LAMBDA_DOCKER_NETWORK=host - DEBUG=1 - HOST_TMP_FOLDER=$&#123;TMPDIR&#125; - DOCKER_HOST=unix:///var/run/docker.sock - LOCAL_CODE_PATH=$&#123;PWD&#125; volumes: - $&#123;TMPDIR:-/tmp/localstack&#125;:/tmp/localstack - /var/run/docker.sock:/var/run/docker.sock - ./auto/create-localstack:/docker-entrypoint-initaws.d/create-localstack.sh - ./kms/kms_seed.yaml:/init/seed.yamlnetworks: app_net: kms_seed.yaml我在这里启动了 sns,sqs,kms,cloudwatch,lambda。 比较值得一说的除了在本地访问 sqs, sns, kms 等需要覆盖掉 endpoint-url之外， 在本地使用 kms 还需要指定一个 seed.yml 来用它进行加解密。 12345678910Keys: Symmetric: Aes: - Metadata: KeyId: 832ac356-3c82-4c4d-a3dc-7489da152197 BackingKeys: - 2bdaead27fe7da2de47945d34cd6d79e36494e73802f3cd3869f1d2cb0b5d74cAliases: - AliasName: alias/testing TargetKeyId: 832ac356-3c82-4c4d-a3dc-7489da152197 创建脚本 create-localstack.sh123456789101112131415161718192021222324252627#!/bin/bashQUEUE_NAME=demo-queueTOPIC_NAME=demo-topicFUNCTION_NAME=demo-functionAPP_ENV=devawslocal sns create-topic --name=$&#123;TOPIC_NAME&#125;awslocal sqs create-queue --queue-name=$&#123;QUEUE_NAME&#125;awslocal sns subscribe \ --topic-arn arn:aws:sns:ap-southeast-2:000000000000:$&#123;TOPIC_NAME&#125; \ --protocol sqs \ --notification-endpoint http://localhost:4566/000000000000/$&#123;QUEUE_NAME&#125;awslocal lambda create-function \ --code S3Bucket="__local__",S3Key="$&#123;LOCAL_CODE_PATH&#125;" \ --function-name $&#123;FUNCTION_NAME&#125; \ --runtime nodejs12.x \ --timeout 5 \ --handler dist/index.handler \ --role dev \ --environment "&#123;\"Variables\":&#123;\"APP_ENV\":\"$&#123;APP_ENV&#125;\"&#125;&#125;"awslocal lambda create-event-source-mapping \ --event-source-arn arn:aws:sqs:ap-southeast-2:000000000000:$&#123;QUEUE_NAME&#125; \ --function-name $&#123;FUNCTION_NAME&#125; \ --enabled 本地启动直接运行 docker-compose up localstack 本地执行现在在命令行发送一条 SNS 的消息，就可以 trigger 我们的 Lambda 执行了。 1aws --endpoint-url=http://localhost:4566 sns publish --topic-arn arn:aws:sns:ap-southeast-2:000000000000:demo-topic --region ap-southeast-2 --message "Hello SNS - SQS - Lambda" 在 Lambda 的 index.ts 写一个 handler() 方法： 123456require('./overwriteAwsLocalEndpoint'); //overwrite aws local endpoint,Please keep it here.import &#123; SQSEvent, SQSHandler &#125; from 'aws-lambda';export const handler: SQSHandler = (event: SQSEvent) =&gt; &#123; console.log(JSON.stringify(event.Records));&#125; 打印一下 SQS 的消息体。 结果如下 1234localstack | &gt; START RequestId: ce5ae5ff-054d-16e0-dc62-71161118d3bd Version: $LATESTlocalstack | &gt; 2020-12-27T09:32:56.373Z ce5ae5ff-054d-16e0-dc62-71161118d3bd INFO [&#123;"body":"&#123;\"Type\": \"Notification\", \"MessageId\": \"04c12e03-66d0-474a-a60a-f0b3c2451456\", \"Token\": null, \"TopicArn\": \"arn:aws:sns:ap-southeast-2:000000000000:demo-topic\", \"Message\": \"Hello SNS - SQS - Lambda\", \"SubscribeURL\": null, \"Timestamp\": \"2020-12-27T09:32:52.202Z\", \"SignatureVersion\": \"1\", \"Signature\": \"EXAMPLEpH+..\", \"SigningCertURL\": \"https://sns.us-east-1.amazonaws.com/SimpleNotificationService-0000000000000000000000.pem\"&#125;","receiptHandle":"exexifyylldwuznxlicibcanaqvcplpaeoztcdlltkzbsuvwiifvlyixrxwuzrmumlmkggofmiencdxilzoaluyreszdppsbycpxcowwvmeiieeplulkitfztfxzkjazucucauhuobpvlzdcnjdcmygqvbrouxkxoggcfryzqtibyquhikawczuif","md5OfBody":"d96df71c445e9282ed4c2fefbf4c8ca1","eventSourceARN":"arn:aws:sqs:ap-southeast-2:000000000000:demo-queue","eventSource":"aws:sqs","awsRegion":"ap-southeast-2","messageId":"a59f7c57-651b-54f6-70bd-a2933fa57099","attributes":&#123;"SenderId":"AIDAIT2UOQQY3AUEKVGXU","SentTimestamp":"1609061572241","ApproximateReceiveCount":"1","ApproximateFirstReceiveTimestamp":"1609061572312"&#125;,"messageAttributes":&#123;&#125;,"md5OfMessageAttributes":null,"sqs":true&#125;]localstack | &gt; END RequestId: ce5ae5ff-054d-16e0-dc62-71161118d3bdlocalstack | &gt; REPORT RequestId: ce5ae5ff-054d-16e0-dc62-71161118d3bd Init Duration: 3381.65 ms Duration: 13.13 ms Billed Duration: 100 ms Memory Size: 1536 MB Max Memory Used: 55 MB 关于 LocalStack 中 Lambda 的使用在本地创建 Lambda 运行环境是我觉得诸多 service 中比较麻烦的一个，以下是官方对于 Lambda 的创建时候的配置详解 123456789101112131415161718192021STEPFUNCTIONS_LAMBDA_ENDPOINT: URL to use as the Lambda service endpoint in Step Functions. By default this is the LocalStack Lambda endpoint. Use default to select the original AWS Lambda endpoint.LAMBDA_EXECUTOR: Method to use for executing Lambda functions. Possible values are: - local: run Lambda functions in a temporary directory on the local machine - docker: run each function invocation in a separate Docker container - docker-reuse: create one Docker container per function and reuse it across invocations For docker and docker-reuse, if LocalStack itself is started inside Docker, then the docker command needs to be available inside the container (usually requires to run the container in privileged mode). Default is docker, fallback to local if Docker is not available.LAMBDA_REMOTE_DOCKER: determines whether Lambda code is copied or mounted into containers. Possible values are: - true (default): your Lambda function definitions will be passed to the container by copying the zip file (potentially slower). It allows for remote execution, where the host and the client are not on the same machine. - false: your Lambda function definitions will be passed to the container by mounting a volume (potentially faster). This requires to have the Docker client and the Docker host on the same machine.LAMBDA_DOCKER_NETWORK: Optional Docker network for the container running your lambda function.LAMBDA_DOCKER_DNS: Optional DNS server for the container running your lambda function.LAMBDA_CONTAINER_REGISTRY: Use an alternative docker registry to pull lambda execution containers (default: lambci/lambda).LAMBDA_REMOVE_CONTAINERS: Whether to remove containers after Lambdas finished executing (default: true). FAQ 为什么我使用 SNS、KMS 总是报一些 client 的 credentials 的错误？ 因为没有覆盖 本地环境需要的 endpoint-url， 参考本文中的解释 为什么给 SNS 发消息成功了却没有触发到 Lambda？ 请检查你的创建脚本，确保你的 SQS 订阅了 SNS 的对应 topic，SQS 有能够触发 Lambda 的 Mapping 本例代码库地址？ Fatezhang/aws-localstack-demo 最后如果你在使用 localstack 的时候遇到了什么问题，欢迎告诉我一起研究讨论。]]></content>
      <categories>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>AWS</tag>
        <tag>localstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让一切被中断的重新启动]]></title>
    <url>%2Fblog%2F20200705%2FMake-everything-interrupted-reboot%2F</url>
    <content type="text"><![CDATA[2020年因为疫情原因导致自己浑浑噩噩地度过了半年时间，博客一直都没有更新，甚至都不知道自己每天在干什么。相比于 2019 年每天都拍一点视频记录一下自己干了些什么之外（其实每天也是一样枯燥无聊），2020 年这大半年好像是突然就消失掉了。 想要做的事情还有很多，所以今天打算整理一下思绪，三省一下吾身🧐。在 新公司工作 8 个月以来，好像失去了斗志，在这里每天做着一些简单的貌似无法提升自己的工作，其实有一些倦了。哎不过提升不提升都是看自己，也许是我现在太浮躁了。 从杭州回来之前想着每天工作轻松了可以做一些副业或者其他，比如视频剪辑，继续学习 POPPIN 之类的事情，但是现实是每天回到家就躺尸。西安的夏天每天8点才日落，真的感觉好浪费时间啊，大好的光阴都被自己挥霍掉了。20 年的后半年立一些F🚩L🇨🇳A🏳️‍🌈G吧，例如，多剪辑一些有趣的 VLOG（这个需要灵感），存一下钱（还好股票已经回本了），多去西安周边走一走（有驾照就方便了），谈个女朋友（这个对我来说其实是最难的，因为我发现自己其实是一个很闷的人，有时候就想一个人呆着不想和别人说话，和别人相处真的好累），还有健身（至少增重到 125 斤吧）先练出来一个好看的身体。 剪辑2019 年每天都有拍一段小视频，20 年后半年不打算这样拍了，很耗费精力。也许在遇到一些好玩的东西的时候可以不用照片记录，而用一段简短的小视频记录下来（说到这里想起来 iPhone 的实况拍照功能，长按可以播放拍摄当时的视频片段，真的非常好用）。 也许可以花点时间学习一下稍微高级一点的剪辑技巧，emmm…看天分了吧，随缘学习。 存钱过年的时候数了数自己的存款发现也有十万呢，结果 20 年大半年过去了还是这个数目，不知道自己这大半年钱都去哪儿了。不科学啊，股票也回本了呢，在朋友那里放了 5 万，自己股票中留了 6 万，最近感觉牛市快来了呢，希望能够让我赚一些吧。有个在杭州的朋友最近遇到一些棘手的事情，需要打官司，可能还得赔十几万。哎，早就劝过他脚踏实地的赚钱，他从来没有听进去过我的一句话，其实我早就已经非常失望了。 以后我管好自己就行了，不去管别人好不好。 户外回到西安以后好像就前段时间去了牛背梁。本来在五一的时候和成他们去太白山，因为一场婚礼没有去成，下一个目的地应该就是太白山了吧，和同事一起去。不过目前现阶段对我最重要的还是先尽快拿一下驾照。有了驾照会开车以后，秦岭我能每天下班去一趟哈哈。 哦对，我应该把去一些 livehouse，看糖蒜铺子脱口秀、看电影等等这种活动也算在户外这里，疫情原因有些一直都看不成，好气啊！ 健身前段时间称了下体重，57.8KG， 好气啊，可能我的饮食习惯也不太好。我们组有三个同事都是健身大神，猛的不行。也许我也需要办一个健身卡？跟着大佬们把我这核心力量，手臂背胸肌练一练哈哈。🌚 短期目标 125 斤！ 2020 年下半年就暂时立这么写 FALG 吧，希望都能够完成！]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发编程的一些总结]]></title>
    <url>%2Fblog%2F20200129%2FJava-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 关于JAVA 并发编程的学习，我已零散的并不系统地积累了一些学习博客，如下： 并发编程学习(一)：编写一个简易的可重入锁 并发编程学习(二)：使用AQS编写可重入锁 并发编程学习(三)：CountDownLatch的实现原理及使用 并发编程学习(四)：理解ThreadPoolExecutor线程池 并发编程学习(五)：Semaphore源码学习及使用案例 并发编程学习(六)：Exchanger的学习及使用场景 并发编程学习(七)：Fork/Join框架原理及demo Synchronized使用时一个不起眼的注意点 这篇博客，制作了一个 Slide，来针对 Java 并发编程做一些小小的总结： &gt; 点击查看 Slide]]></content>
      <categories>
        <category>Java基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Use Junit5 to Test You Java Application Elegantly]]></title>
    <url>%2Fblog%2F20200115%2FHow-to-use-Junit5-to-test-you-java-application-elegantly%2F</url>
    <content type="text"><![CDATA[Junit5 的一些实际开发中常用的功能【 TDD 向 】 这篇博客本来应该写于鼠年过年之前，谁想到犯了个懒，现在怀着沉重的心情写下这篇博客~ 因为中国现在正在受着新型冠状病毒疫情的危害，大过年的门都出不去，都躲在家里生怕被感染。无聊的我只能学习学习来打发一下枯燥的假期生活哈哈~ Junit5说到 JUNIT5 可能很多人都不陌生，就是一个测试框架而已。但是相信大部分的程序员都没有用过，感觉国内好多公司都没有写测试的习惯，也许是产品催需求催的太紧ε=(´ο｀*)))。我就不在这里介绍 Junit5 了，没有前置知识的话需要看一下：Junit5，我只在这篇博客介绍一下我在工作中是如何使用 Junit5 的。 基本的测试代码首先 gradle需要引入 Junit5 以及其他相关的依赖： 12345678testImplementation 'org.mockito:mockito-core:2.24.0'testImplementation 'org.junit.jupiter:junit-jupiter-api:5.2.0'testImplementation 'org.junit.jupiter:junit-jupiter-params:5.2.0'testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.2.0'testImplementation "org.testcontainers:junit-jupiter:1.12.3"testImplementation "org.testcontainers:postgresql:1.12.3"testImplementation 'org.mockito:mockito-junit-jupiter:3.1.0'testImplementation 'org.hamcrest:hamcrest:2.2' 然后编写一个简单的测试用例： 123456789@Testvoid shouldReturnObjectsGivenValidIdWhenGetObjects() &#123; when(objectService.findApplications(OBJECT_ID)).thenReturn(mockObjects); var responseEntity = objectsController.getObjects(null); assertThat(HttpStatus.OK).isEqualTo(responseEntity.getStatusCode()); assertThat(responseEntity.getBody()).isEqualTo(mockGetObjectsResponse);&#125; 说明一下，以上测试用例的编写需要注意以下几点： 方法命名一般的写测试的时候，方法的命名要求解释测试的功能，需要包含 should/given/when 条件。如以上方法的命名shouldReturnObjectsGivenValidIdWhenGetObjects是指当调用getObjects()的时候，给定一个合法的 ID，能够返回一组 Objects。 方法的条件、执行、以及对于结果的验证的代码换行隔开 使用 assertThat()验证结果：assertThat方法是包import static org.assertj.core.api.Assertions.assertThat;中的方法。它接收一个实际的值，然后再使用isEqualTo等方法判断上一个执行结果是否正确。 在类中的测试执行之前执行一次代码以下代码使用@BeforeAll注解在方法 setupMDC 上面，并且这个方法必须是 static 静态方法。是指在所有类中的测试方法执行之前只执行一次该方法。一般用于设置无状态的全局变量。 1234@BeforeAllstatic void setupMDC() &#123; MDC.put(TRANSACTION_ID, UUID.randomUUID().toString());&#125; 在每个测试方法之前都执行一些代码以下代码使用@BeforeEach注解，可以在每一个方法执行之前都执行该方法，用于每个方法执行前的初始化或者做一些共同的 mock 操作，相当于 AOP 的 Before。 1234@BeforeEachvoid setup() &#123; when(service.save(any(String.class), any(UUID.class), any(UUID.class))).thenReturn(null);&#125; 其他其他的比如@AfterAll @AfterEach等等功能依次类推。 测试分层在使用 Junit5 测试过程中，最让我觉得方便的是对于测试类的结构划分方式：内部类。通过内部类，我们可以将我们要测试的东西使用类结构的形式去进行描述（使用注解@Nested修饰），然后再在类中编写相应的测试方法进行具体的测试。 比如一个 Controller 需要测试 create/update/get 等方法，就可以将这几个方法依次编写内部类分开描述，然后再在类中对于不同的分支编写测试方法进行单元测试，如下： 123456789101112131415161718192021222324252627@ExtendWith(MockitoExtension.class)class ObjectsControllerTest &#123; @Nested class CreateObjects &#123; @Test void someTest()&#123; // some code &#125; &#125; @Nested class UpdateObjects &#123; @Test void someTest()&#123; // some code &#125; &#125; @Nested class GetObjects &#123; @Test void someTest()&#123; // some code &#125; &#125;&#125; 总结以上就是我在编写 unit 测试的时候的一些小小的总结，以后会继续加深对于测试代码编写的学习，实际上测试才是写代码过程中最重要的一环，可以保障系统的功能的正确性，还能保护重构。Junit5 为 JAVA 程序员提供了更强大、方便的测试框架，值得深入研究使用。]]></content>
      <categories>
        <category>Junit5</category>
        <category>Unit Test</category>
      </categories>
      <tags>
        <tag>Junit5</tag>
        <tag>Java 基础</tag>
        <tag>单元测试</tag>
        <tag>unit test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决@ResuestBody中的 JSON 自动转化非 Boolean 为 Boolean 值]]></title>
    <url>%2Fblog%2F20191217%2F%E8%A7%A3%E5%86%B3-ResuestBody%E4%B8%AD%E7%9A%84-JSON-%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%8C%96%E9%9D%9E-boolean-%E4%B8%BA-boolean-%E5%80%BC%2F</url>
    <content type="text"><![CDATA[问题出现当我们在 SpringBoot 中写 API 的时候，通常我们会使用@RequestBody注解一个参数将这个对象标记之后，然后我们在请求头使用application/json调用这个 API，传入 JSON 的 body 体，就可以自动的将我们的 JSON 转化成 JAVA 对象。但是，当我使用的 JAVA 对象中有个 Boolean 的字段的时候，我的 JSON 的 body 对这个对象传数值、”True”等等其他值得时候，往往会被默认转成相应的 true 或者 false。例如传入{“able”:0}的时候，我的对象中的 able 字段就是 false。但是我不想要这个功能，我希望接口调用者传的类型都是 Boolean 类型。 Debug 源码首先你要知道，在 SpringBoot 或者 SpringMVC 中对于request 和 response 的处理是使用的消息转换器处理的。所以我在 debug 源码的时候发现，SpringBoot 使用MappingJackson2HttpMessageConverter处理 JSON 转化成对象，然后实际的转化方法MappingJackson2HttpMessageConverter没有重写，而是交给父类AbstractJackson2HttpMessageConverter的方法，在该类的第239 行会发现实际上是使用的 this.objectMapper.readValue(inputMessage.getBody(), javaType); 将一个 JSON 字符串转化成 JAVA 对象。再进去看下： 12345public &lt;T&gt; T readValue(InputStream src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException&#123; return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);&#125; 而_readMapAndClose方法是这样的(重点看下 4013 行)： 12345678910111213141516171819202122232425262728protected Object _readMapAndClose(JsonParser p0, JavaType valueType) throws IOException&#123; try (JsonParser p = p0) &#123; Object result; JsonToken t = _initForReading(p, valueType); final DeserializationConfig cfg = getDeserializationConfig(); final DeserializationContext ctxt = createDeserializationContext(p, cfg); if (t == JsonToken.VALUE_NULL) &#123; // Ask JsonDeserializer what 'null value' to use: result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt); &#125; else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) &#123; result = null; &#125; else &#123; JsonDeserializer&lt;Object&gt; deser = _findRootDeserializer(ctxt, valueType); if (cfg.useRootWrapping()) &#123; result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser); &#125; else &#123; result = deser.deserialize(p, ctxt); &#125; ctxt.checkUnresolvedObjectId(); &#125; if (cfg.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) &#123; _verifyNoTrailingTokens(p, ctxt, valueType); &#125; return result; &#125;&#125; 这行代码result = deser.deserialize(p, ctxt);使用一个反序列化对象进行 JSON 的反序列化，这里如果传入的是数字转化成 Boolean的话就是用的是NumberDeserializers中的BooleanDeserializer，而它的deserialize方法是这样的： 123456789101112@Overridepublic Boolean deserialize(JsonParser p, DeserializationContext ctxt) throws IOException&#123; JsonToken t = p.getCurrentToken(); if (t == JsonToken.VALUE_TRUE) &#123; return Boolean.TRUE; &#125; if (t == JsonToken.VALUE_FALSE) &#123; return Boolean.FALSE; &#125; return _parseBoolean(p, ctxt);&#125; 然后_parseBoolean中将其他的数值转化成 Boolean。 解决方式以上就是整个 debug 的全过程了，总结一下就是AbstractJackson2HttpMessageConverter中会默认地将非 Boolean 的数值转化成 Boolean。那么如何解决这个问题呢？ 首先使用搜索引擎解决😹然后搜索不到。。。然后我在 StackOverFlow 上提了一个问题 &lt;click。简单来说就是以下这种方式： 自定义自己的反序列化工具，然后让 Spring 去管理这个配置类 1234567891011121314151617181920212223242526@Configurationpublic class SystemConfiguration &#123; @Bean public SimpleModule addDeserializer() &#123; return new SimpleModule().addDeserializer(Boolean.class, new MyDeserializer()); &#125; static class MyDeserializer extends JsonDeserializer&lt;Boolean&gt; &#123; @Override public Boolean deserialize(JsonParser p, DeserializationContext ctxt) throws IOException &#123; JsonToken t = p.getCurrentToken(); if (t == JsonToken.VALUE_TRUE) &#123; return Boolean.TRUE; &#125; if (t == JsonToken.VALUE_FALSE) &#123; return Boolean.FALSE; &#125; if (t == JsonToken.VALUE_STRING) &#123; String value = p.getValueAsString(); return value.equals("true") ? true : value.equals("false") ? false : null; &#125; return null; &#125; &#125;&#125; 这样就将所有 API 中，存在 Boolean 的情况都处理掉了。只能接受 Boolean 值或者字符串的”true”或者”false”。 但是作为一个优秀(pa ma fan)的👩‍💻coder😷，我们应该保证自己修改的代码不会影响到其他人或者其他模块，随便的修改全局的配置不太好。所以我寻找到了一个更加୧(๑•̀◡•́๑)૭的方式 —— 编写一个该属性的 set 方法即可。 因为Deserializer会将读取到的 JSON 的值通过 set 方法填入对象中，所以这种方式也是完全可行的，如下： 12345678public void setAble(Object value) &#123; if (value instanceof Boolean) &#123; able = (Boolean) value; &#125; if ("true".equals(value)) &#123; able = true; &#125;&#125; 至此，大功告成。但是实际上整个过程 debug 的时候是最有意思的，可以了解到它在转换的过程中实际上都做了些什么事情。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>JSON</tag>
        <tag>converter</tag>
        <tag>RequestBody</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在 SpringCloud 微服务项目中一键部署 Docker 启动]]></title>
    <url>%2Fblog%2F20191211%2F%E5%A6%82%E4%BD%95%E5%9C%A8-SpringCloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2-docker-%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[如何用 docker 一键启动 SpringCloud 微服务？为什么要使用 docker 启动我们的微服务？原始传统的部署方式为我们带来了太多问题，比如当你的服务在测试环境正运行的正常，但是部署到生产环境就会出现一大堆未知问题，你查了好久，debug 代码之后发现，仅仅是一个环境变量没有设置正确，导致产生了目前这么一大串问题，浪费了你的时间，拖延了项目上线的时间，甚至产生了严重的生产事故。这个时候，我们就需要一个机制来保证我们的代码在部署到本地、测试以及生产的时候，我们的代码不会受到环境不一致的影响而导致我们部署失败！ 还有就是我们可以使用 docker 打包镜像然后使用 docker-compose 编排容器一键启动，让运维自动化，极大的节省我们的工作时间。 在 Spring-Cloud 微服务项目中如何使用 DOCKER？首先我们需要将我们的每一个服务打包成镜像例如我的 Scaffold-Cloud 项目中的 eureka 服务的 pom 文件(点击链接跳转到 github 以下代码行)如下： 12345678910111213141516171819202122232425262728&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;version&gt;0.4.13&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;scaffold-cloud/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt; &lt;forceTags&gt;true&lt;/forceTags&gt; &lt;baseImage&gt;java&lt;/baseImage&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 然后其他模块也一样，在 pom 文件中加入以上 maven 插件，完整项目代码如下(觉得好用 star✨一下哦)： https://github.com/Fatezhang/scaffold-cloud/ 使用脚本一键创建 docker 镜像12345678910111213141516171819202122232425#!/bin/bashecho "============start to package with maven and recreate docker image=============="SERVICE_FOLDERS=( scaffold-eureka scaffold-zuul scaffold-tx-manager scaffold-business/scaffold-business-sys-service scaffold-business/scaffold-business-job-service scaffold-business/scaffold-business-thirdparty-service scaffold-route/scaffold-route-app scaffold-route/scaffold-route-openapi scaffold-route/scaffold-route-operate)path=for (( i = 0; i &lt; $&#123;#SERVICE_FOLDERS[@]&#125;; i++ )); do path=$&#123;SERVICE_FOLDERS[$&#123;i&#125;]&#125; echo "进入目录 &gt;&gt;&gt;&gt; cd $&#123;path&#125;" cd "$&#123;path&#125;" || exit pwd mvn clean package docker:build -Pdocker cd - || exitdoneecho "============ create end ==============" 编排 docker-compose 启动所有微服务然后只需要将所有镜像编排在 docker-compose.yml 文件中即可，其中所有的容器都在同一个网络中以访问到对方服务，如下： 12networks: - scaffold-cloud 完整的 docker-compose.yml 文件如下（注意有一个wait-for-it.sh）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132version: "3.7"services: micro-sys: entrypoint: ./wait-for-it.sh tx_manager:7970 'java -jar scaffold-business-sys-service-1.0-SNAPSHOT.jar' image: scaffold-cloud/scaffold-business-sys-service:1.0-SNAPSHOT volumes: - /tmp:/tmp - ./.scripts/wait-for-it.sh:/wait-for-it.sh ports: - 8750:8750 networks: - scaffold-cloud depends_on: - redis - eureka - mysql - rmqbroker - rmqnamesrv - tx_manager route-operate: entrypoint: ./wait-for-it.sh micro-sys:8750 'java -jar scaffold-route-operate-1.0-SNAPSHOT.jar' image: scaffold-cloud/scaffold-route-operate:1.0-SNAPSHOT volumes: - /tmp:/tmp - ./.scripts/wait-for-it.sh:/wait-for-it.sh ports: - 8850:8850 networks: - scaffold-cloud depends_on: - micro-sys eureka: entrypoint: java -jar scaffold-eureka-1.0-SNAPSHOT.jar image: scaffold-cloud/scaffold-eureka:1.0-SNAPSHOT volumes: - /tmp:/tmp ports: - 8761:8761 networks: - scaffold-cloud zuul: entrypoint: ./wait-for-it.sh eureka:8761 'java -jar scaffold-zuul-1.0-SNAPSHOT.jar' image: scaffold-cloud/scaffold-zuul:1.0-SNAPSHOT volumes: - /tmp:/tmp - ./.scripts/wait-for-it.sh:/wait-for-it.sh ports: - 8861:8861 networks: - scaffold-cloud depends_on: - eureka tx_manager: entrypoint: ./wait-for-it.sh mysql:3306,redis:6379 'java -jar scaffold-txmanager-1.0-SNAPSHOT.jar' image: scaffold-cloud/scaffold-txmanager:1.0-SNAPSHOT volumes: - /tmp:/tmp - ./.scripts/wait-for-it.sh:/wait-for-it.sh ports: - 8890:8890 - 7970:7970 networks: - scaffold-cloud depends_on: - mysql - redis - eureka mysql: image: mysql/mysql-server:5.7 ports: - 3306:3306 volumes: - ./mysql/data:/var/lib/mysql - ./mysql/config/my.cnf:/etc/my.cnf - ./mysql/init:/docker-entrypoint-initdb.d/ restart: always networks: - scaffold-cloud redis: image: redis:latest restart: always ports: - 6379:6379 command: redis-server --requirepass pwd8ok8 networks: - scaffold-cloud rmqnamesrv: image: foxiswho/rocketmq:server-4.5.2 container_name: rmqnamesrv ports: - 9876:9876 volumes: - ./rmq/logs:/opt/logs - ./rmq/store:/opt/store environment: JAVA_OPT_EXT: "-Duser.home=/opt -Xms128m -Xmx128m -Xmn128m" networks: - scaffold-cloud rmqbroker: image: foxiswho/rocketmq:broker-4.5.2 container_name: rmqbroker ports: - 10909:10909 - 10911:10911 volumes: - ./rmq/logs:/opt/logs - ./rmq/store:/opt/store - ./rmq/brokerconf/broker.conf:/etc/rocketmq/broker.conf environment: JAVA_OPT_EXT: "-Duser.home=/opt -server -Xms128m -Xmx128m -Xmn128m" command: ["/bin/bash","mqbroker","-c","/etc/rocketmq/broker.conf","-n","rmqnamesrv:9876","autoCreateTopicEnable=true"] depends_on: - rmqnamesrv networks: - scaffold-cloud rmqconsole: image: styletang/rocketmq-console-ng container_name: rmqconsole ports: - 8180:8080 environment: JAVA_OPTS: "-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false" depends_on: - rmqnamesrv networks: - scaffold-cloudnetworks: scaffold-cloud: name: scaffold-cloud driver: bridge 如何在启动所有微服务的时候按顺序启动呢？我们知道，SpringCloud 微服务中各个服务之间可能存在依赖关系，比如 tx-manager 服务需要等待 MySQL 和 Redis 都启动完成之后才能够顺利启动，但是 docker-compose.yml 文件中的 depends_on只能等待 docker 容器启动成功，而不能等待 docker 容器中的服务启动完成！ docker 官方给出的方案是使用wait-for-it.sh脚本，在容器启动之前执行脚本，判断依赖的服务和端口是否启动成功，然后再执行自己服务的启动命令。 所以我们也是这样去写一个脚本：wait-for-it.sh如下 1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/bash# shellcheck disable=SC2223: $&#123;SLEEP_SECOND:=2&#125;wait_for() &#123; echo Waiting for $1 on port $2... ... # shellcheck disable=SC2086 # shellcheck disable=SC2188 while ! &lt;/dev/tcp/$1/$2; do echo Waiting for $1 on port $2... ... sleep $SLEEP_SECOND done echo Server:"$1" on port:"$2" is running... ...&#125;SER_STRS=$1# shellcheck disable=SC2207# shellcheck disable=SC2006SERVICES_PORTS=($(echo "$SER_STRS" | tr ',' ' '))THEN_COMMAND=$2for ((i = 0; i &lt; $&#123;#SERVICES_PORTS[@]&#125;; i++)); do SERVICE_PORT=$&#123;SERVICES_PORTS[$&#123;i&#125;]&#125; # shellcheck disable=SC2207 # shellcheck disable=SC2006 array=($(echo "$SERVICE_PORT" | tr ':' ' ')) servername=$&#123;array[0]&#125; serverport=$&#123;array[1]&#125; wait_for "$servername" "$&#123;serverport&#125;"doneecho "start to run command: $THEN_COMMAND"# shellcheck disable=SC2004if [ "$THEN_COMMAND" ]; then eval "$THEN_COMMAND"else # shellcheck disable=SC2102 echo command: [$THEN_COMMAND] is invalid... ...fi 上述脚本的作用就是等待启动的服务以及端口启动成功，没有成功的话就继续 wait 等待，默认等待 2 秒，启动成功的话就执行自己的启动命令。 使用方式如下： 12tx_manager: entrypoint: ./wait-for-it.sh mysql:3306,redis:6379 'java -jar scaffold-txmanager-1.0-SNAPSHOT.jar' 所以，以上就是使用 docker 启动 SpringCloud 微服务的全部内容，如果你觉得有用，希望能够给我的项目https://github.com/Fatezhang/scaffold-cloud/点个star 哦~ 而且你也可以给我提 issue，提 PR，欢迎一起交流学习，一起开发~]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>springboot</tag>
        <tag>spring</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scaffold-Cloud —— SpringCloud微服务架构实践]]></title>
    <url>%2Fblog%2F20191025%2FSpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Scaffold-Cloud: SpringCloud微服务脚手架 幕布Scaffold-Cloud 是一个适用于开发者学习的 Spring-Cloud 微服务项目脚手架。项目期望集成大部分目前互联网公司使用的主流的Spring-Cloud微服务相关工具和服务。并结合一些实际的业务增加一些其他功能，如：分布式事务、定时任务、消息队列、日志分析等等，然后加入 CI/CD 并引入 docker 部署。 Scaffold-Cloud 基于 SpringCloud Netflix 全家桶进行微服务项目的构建，所以在这之前，使用 Scaffold-Cloud 需要先了解下 SpringCloud 以及 Netflix 工具全家桶。 Sorry, NetFlix is not available in your country yet. Spring Cloud 介绍从单体应用到微服务在早期的企业中，项目基本上都是单体应用，将一个网站部署在一台单独的服务器上对用户提供服务。但是这样的服务最大的缺点就是，当服务器断电或者服务进程挂掉，用户直接就无法访问。后来演进出集群服务，将同样的服务在多台服务器分别部署，使用负载均衡等手段让服务对于用户来说看到的都是同一个，这样当一台服务器夯机至少还有其他的服务器提供相同的应用。 但是，当企业级服务变得越来越复杂的时候，项目变得越来越庞大，有时甚至影响到了服务的部署，这个时候就应该将庞大的服务拆分成多个子系统，部署在不同的服务器上，这样的服务当遭遇高并发访问的时候也能够将请求压力分摊到多个服务器上，这就是分布式。 而当企业需要开启一个新的项目时，为了避免重复造轮子，往往一些可复用的模块会被拆分出来作为一个微小的系统，它可以独立的开发、设计、运行和运维，只需要使用 ESB企业服务总线将所有服务整合并提供统一的访问入口，就能够复用，这就是 SOA。 而微服务是对以上服务架构的最终演进结构：将服务切分成多个微小的应用，提供统一的服务访问协议HTTP(SpringCloud)/TCP(Dubbo)，强调运行时的分散解耦，在业务上也有着高度的抽离。 微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常使用HTTP资源API)。这些服务围绕业务能力构建，并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。—— Martin Fowler 但是拆分成这么微小的微服务一定会碰到各种各样的问题——如何拆分？服务之间如何发现？如何授权？如何做负载均衡？如何管理多服务配置？如何跟踪调用链路？如何实时查看服务状态等等… … SpringCloud 就是以上一系列问题的 Solver。它提供了一整套的解决方案！ SpringCloud首先，SpringCloud 并不是一个框架，而是一个微服务的规范，或者说是一个微服务工具集合。 SpringCloud特点： 约定大于配置，基于 SpringBoot 开发部署于各种环境，AWS，阿里云，PC 等 隐藏组件复杂性，声明式配置，无 xml 开箱即用，快速启动 丰富的轻量级组件 灵活选型，如注册发现可用 eureka，zookeeper 或者 Redis SpringCloud 各版本组件及版本兼容性 Component Edgware.SR6 Greenwich.SR2 Greenwich.BUILD-SNAPSHOT spring-cloud-aws 1.2.4.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-bus 1.3.4.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-cli 1.4.1.RELEASE 2.0.0.RELEASE 2.0.1.BUILD-SNAPSHOT spring-cloud-commons 1.3.6.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-contract 1.2.7.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-config 1.4.7.RELEASE 2.1.3.RELEASE 2.1.4.BUILD-SNAPSHOT spring-cloud-netflix 1.4.7.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-security 1.2.4.RELEASE 2.1.3.RELEASE 2.1.4.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.1.3.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-consul 1.3.6.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-sleuth 1.3.6.RELEASE 2.1.1.RELEASE 2.1.2.BUILD-SNAPSHOT spring-cloud-stream Ditmars.SR5 Fishtown.SR3 Fishtown.BUILD-SNAPSHOT spring-cloud-zookeeper 1.2.3.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-boot 1.5.21.RELEASE 2.1.5.RELEASE 2.1.8.BUILD-SNAPSHOT spring-cloud-task 1.2.4.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-vault 1.1.3.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-gateway 1.0.3.RELEASE 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-openfeign 2.1.2.RELEASE 2.1.3.BUILD-SNAPSHOT spring-cloud-function 1.0.2.RELEASE 2.0.2.RELEASE 2.0.3.BUILD-SNAPSHOT SpringCloud 全家桶spring-cloud-netflixeureka 原理： 服务启动时，调用 eureka 接口进行注册，Eureka Server 会存储这些信息，IP、端口、微服务名称等 微服务启动之后，会周期性的发送心跳进行“续租”，默认 30 秒 如果一定时间没有“续租”，默认 90 秒，就销毁微服务实例 默认情况下，Eureka Server 也是一个 Eureka Client，集群下会互相复制服务注册表中的信息进行同步 Eureka Client 会缓存注册表的信息，减少Eureka Server 的请求压力，以及容灾 spring-cloud-openfeignspring-cloud-zuul 微服务网关spring-cloud-config 配置中心项目创建的目的？第一个目的是为了本人能够熟悉和学习 Spring-Cloud 相关知识，不过在做了一段时间之后还是希望能够分享出来让更多的同学一起学习和讨论。 项目结构如何？ scaffold-business 业务服务提供者 端口从8850 - 8860 scaffold-business-sys-service 系统业务微服务-业务模块 端口 8850 scaffold-business-job-service 定时任务微服务-业务模块 端口 8851 scaffold-business-thirdparty-service 第三方业务微服务-业务模块 端口 8852 scaffold-business-api 业务API包 用于接口与实现分离 scaffold-business-sys-api 系统资源、菜单、权限等API封装 scaffold-business-job-api 定时任务API封装 scaffold-business-thirdparty-api 第三方服务API封装 scaffold-core 工具类以及各种公共代码 scaffold-core-code 每个模块都会用到的公共代码，Bean，config等 scaffold-core-common 工具类模块，公共代码 scaffold-core-plugin 自动代码生成插件模块 scaffold-eureka 注册中心Eureka 端口 8761 - 8771 scaffold-zuul 网关服务 端口 8861 - 8870 scaffold-config-server 配置服务端服务 端口 8871 - 8881 scaffold-config-client 配置客户端服务 端口 8880 - 8891 scaffold-tx-manager 分布式事务协调服务 端口7970 scaffold-feign Feign模块 scaffold-feign-sys feign-sys模块 scaffold-feign-job feign-job模块 scaffold-feign-thirdparty feign-thirdparty模块 scaffold-route 主业务消费者 端口从8750 - 8760 scaffold-route-operate 后台管理接口及页面 端口 8750 scaffold-route-app APP客户端接口 端口 8751 如何快速开始？1. 本地直接启动 下载/克隆项目到本地 1git clone https://github.com/Fatezhang/scaffold-cloud 安装MySql数据库并启动 创建数据库scaffold_cloud_base 和 tx_manager 修改 scaffold-cloud 中微服务的数据库链接配置，本地运行只需要修改application-local.yml 安装redis服务并启动，修改scaffold-core-code配置文件中的配置，同样只需要修改local中的 安装Rocket MQ服务，同样修改配置 如果有需要，注册阿里OSS，并修改配置中的配置 启动EurekaApplication注册中心 启动TxlcnApplication分布式事务协调服务 启动SysServiceApplication，加载数据库字典等配置到缓存、提供后台管理微服务（权限、操作员、角色、国际化配置等） 启动RouteOperateApplication服务，默认端口为8750 访问http://localhost:8750/ßß 默认账号密码为admin/admin123 2. 使用 docker 部署docker 启动 : Linux 或者 Mac 下使用如下脚本, Windows 环境自行按照脚本中的示例执行mvn clean package docker:build -Pdocker1. 进入项目所在目录 2. 执行 `./.scripts/recreate-docker-image.sh` 创建 docker 镜像 3. 执行 `./.scripts/start-docker-service.sh` 即使用 docker-compose 启动 项目未来还需要做什么？ 更改项目注册发现中心，也许用 nacos 或者 zookeeper 加入更多 spring-cloud 周边服务，包括各种监控平台等 CI/CD 使用 Jenkins 或者 BuildKite 使用 docker 容器化部署 ElasticSearch 日志收集 xxl-job 分布式定时任务 https://www.xuxueli.com/xxl-job/ 整合第三方开源库用以登录、支付等 最后，实际开发一些业务功能 参考： https://juejin.im/post/5c28f2fe51882565a15776fb https://juejin.im/post/5de740566fb9a0165721b744 https://juejin.im/post/5dc220126fb9a04aa660dcfb]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我项目中使用的分布式事务：LCN]]></title>
    <url>%2Fblog%2F20191020%2F%E6%88%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9ALCN%2F</url>
    <content type="text"><![CDATA[其他关于分布式事务的总结整理 背景由于公司项目是使用dubbo进行开发的分布式服务，所以项目中有很多涉及到分布式事务问题的场景。比如有两个模块：用户模块和账户资金模块。有一个场景是用户被邀请成为系统的新用户，需要先初始化用户信息，然后再去账户资金模块初始化用户账户信息。两个不同的模块为两个不同的RPC服务，分别被调用然后插入数据，这时候如果账户资金插入失败，不加入分布式事务的话用户直接初始化成功。我们希望这种情况下用户插入的信息被回滚，所以需要引入分布式事务来进行业务处理。 使用的框架经过调研，我们发现TX-LCN框架比较适合我们的业务场景，我们打算引入并使用LCN事务模式来进行服务中的分布式事务的业务处理。关于LCN、TCC、TXC几种事务模式的区别在下面整理。 在官网下载对应的服务，并引入项目或者单独启动： 引入依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;com.codingapi&lt;/groupId&gt; &lt;artifactId&gt;transaction-dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;lcn.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.codingapi&lt;/groupId&gt; &lt;artifactId&gt;tx-plugins-db&lt;/artifactId&gt; &lt;version&gt;$&#123;lcn.version&#125;&lt;/version&gt;&lt;/dependency&gt; 使用： 在服务的发起方使用注解@TxTransaction(isStart = true) 12345678@Override@TxTransaction(isStart = true)public ExperienceLogVO doUseExperience(Long userId, Long experienceRecordId, ExperienceLogCreateModel createModel) &#123; // ... do something ... userFacade.insert(); // ... do something ... accountFacede.insert();&#125; 在服务的参与方使用注解@TxTransaction标识即可 1234@TxTransactionpublic int insert()&#123; // ... do something ...&#125; 然后再启动项目之前，先启动tx-manager服务，作为协调者的角色存在，然后启动项目，调用接口的时候就可以使用分布式事务了。 其他关于分布式事务的总结整理关于Tx-LCN - 官网文档Tx-LCN早期是为了设计出LCN分布式事务而命名的，不过在5.0之后可以支持LCN、TXC、TCC三种分布式事务模式。LCN框架定位为不生产事务，只做事务的搬运工。即TX-LCN是一款事务协调框架，本身并不操作事务，只是基于对事务的协调从而达到事务一致性的效果。 最新版本的TX-LCN同时支持多种事务模式。并支持多种不同的数据源同时使用分布式事务，完全达到拔插效果。以下是三种事务模式的介绍、区别及优缺点。 LCN事务模式 仅仅作为事务的协调者，本身不生产事务。原理是在事务发起方创建事务分组，并通过Http/Tcp协议调用的时候将事务分组传递到事务参与方。事务参与方的本地事务执行成功之后，根据事务分组ID通知事务的发起方提交所有事务。在全部事务成功通知之前，其各个本地事务均为假关闭，等待TxManager协调完成事务之后再关闭连接。 LCN事务对于代码几乎没有嵌入性，只需要添加注解即可实现分布式事务。 LCN的事务提交与回滚都有本地事务保障，更安全的确保数据一致性。 但是LCN仅限于存在本地事务并且可以通过连接对象控制事务模块的系统。 LCN模式依赖于连接代理服务，事务的发起方与参与方要一起连接与释放，较耗性能。 TCC事务模式 TCC事务模式不依赖于资源管理器对于XA的支持，而是通过业务系统提供的业务逻辑的调度来实现分布式事务。即编写三步操作：Try：尝试执行业务（先插入一条数据，状态为Try）、Confrim：确认执行业务（成功后状态改为Confrim）、Cancel：取消执行业务（需要回滚的话根据前两个步骤的id继续更改状态或者删除数据）。 TCC模式对于代码的侵入性很高，基本上一个接口需要拆分成3个，对于程序员的编码要求很高，业务的正确性、数据一致性都由开发者来保证 优点是TCC模式对于有无本地事务的场景都适用，甚至可以跨数据源，针对MySQL、redis、Mongo等整合成一个大的事务TXC事务模式 其来源于阿里巴巴的一个分布式事务中间件，可以通过极少量的代码侵入，实现分布式事务。原理是在执行SQL之前，先查询SQL的影响数据，然后保存执行的SQL快照信息并创建锁。当需要回滚的时候就采用这些记录回滚数据库。目前实现锁使用的是redis分布式锁控制。 TXC事务模式同样对代码的侵入性低 该模式仅限于对支持SQL方式的模块支持 该模式由于每次执行SQL之前需要先查询影响数据，因此相比LCN模式更消耗性能 TXC事务模式不会占用数据库资源 关于TXC事务的详细介绍可以查看这篇博客 CAP理论和BASE理论CAP理论CAP理论即数据一致性、服务可用性和分区容错性的简称。 Consistency 数据一致性：一次完整的更新操作，所有节点在同一时刻访问到的数据是一致的 Availability 服务可用性：服务一直可用，并且是正常响应时间 Partition tolerance 分区容错性：分布式多节点在某几个节点挂掉后仍然可以对外提供正常的服务 事实上，CAP这三种并无法保证完全满足，一般只能满足其二。对于分布式系统来说，分区容错性是最基本需要满足的条件，否则不能称为分布式系统，只满足CA 其实是传统的单机服务。那么在满足P（分区容错）的时候，就需要在C和A之间权衡。事实上，分布式系统下一般会保证A（服务可用）P，放弃数据的强一致性，只保证数据的最终一致性。这样就衍生出了BASE理论。 BASE理论BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 基本可用：在分布式系统中，允许在出现不可预知故障的情况下损失部分可用性（并不是允许系统不可用），允许响应时间上的确实和部分系统功能的错误（并发场景下拒绝服务产生报错等） 软状态：即允许数据存在中间状态，允许不同节点的数据之间存在时间上的数据差异 最终一致性：强调所有数据副本能够最终一致，不需要保证数据实时强一致。 传统事务的ACID机制追求强一致性，而BASE理论为分布式系统而生，主张牺牲强一致性，使得服务达到高可用。不过在分布式系统中，不同场景下对于数据的一致性又是不同的，所以才会有分布式事务来保证数据的一致，即ACID与BASE理论结合使用。 2PC和3PC2PC - 二段式提交2PC，是Two-Phase Commit的缩写。过程如下： 阶段一：提交事务请求 协调者询问参与方是否可以执行提交操作并等待响应 参与者执行询问为止的所有事务操作 参与者响应协调者，返回事务执行成功与否 阶段二：执行事务提交 协调者收到所有第一阶段响应之后发起正式提交请求 参与者正式完成操作并释放整个事务期间占用的资源 反馈事务提交结果 协调者收到所有完成的消息后，完成事务。 如果任意参与者在第一阶段返回执行失败或者超时的消息，中断事务 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。 参与者节点向协调者节点发送”回滚完成”消息。 协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。 不管最后结果如何，第二阶段都会结束当前事务 2PC的缺点： 执行过程中所有节点都是同步阻塞的；如果协调者是单点并且发生故障，参与者将一直阻塞；如果在第二阶段协调者正式向所有参与者发送正式提交事务的请求，其中部分因为网络问题没有收到，另一部分却已经提交无法回滚，出现数据不一致的情况；协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。 由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。 3PC - 三段式提交3PC将2PC的准备阶段又划分为两次准备，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。。并且在协调者与参与者中都引入超时机制。 CanCommit阶段 同2PC的准备阶段，协调者向参与者发送事务提交请求，询问并等待响应 得到响应之后进入预备提交阶段 PreCommit阶段 所有参与者第一阶段都返回成功状态，那么就会开始事务的预执行 进入PreCommit并执行事务操作，全部成功就返回给提交者 假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。发送中断请求协调者向所有参与者发送abort请求;中断事务参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。 doCommit阶段 发送提交请求协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。 事务提交参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。 响应反馈事务提交完之后，向协调者发送Ack响应。 完成事务协调者接收到所有参与者的ack响应之后，完成事务。 中断事务协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。 发送中断请求协调者向所有参与者发送abort请求 事务回滚参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。 反馈结果参与者完成事务回滚之后，向协调者发送ACK消息 中断事务协调者接收到参与者反馈的ACK消息之后，执行事务的中断。 相比于2PC，3PC最关键要解决的就是协调者和参与者同时挂掉的问题，所以3PC把2PC的准备阶段再次一分为二。在第一阶段只是询问所有参与者是否都可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行commit或者rollback。 3PC存在的问题： 在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。这样与其他执行回滚的参与者就会出现数据不一致的情况。 参考： https://www.hollischuang.com/archives/1580 http://anruence.com/2018/03/05/tcc-2pc-3pc/ http://blog.jobbole.com/95632/ http://blog.csdn.net/zhangjq520/article/details/78433686 https://www.zhihu.com/question/48627764/answer/111983553 https://www.jianshu.com/p/d3eda795188a]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>数据库</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其实我不太想离开这里]]></title>
    <url>%2Fblog%2F20190909%2F%E5%85%B6%E5%AE%9E%E6%88%91%E4%B8%8D%E6%83%B3%E7%A6%BB%E5%BC%80%E8%BF%99%E9%87%8C%2F</url>
    <content type="text"><![CDATA[写于 2018-09-09 22:01:04 序我要离开了。离开杭州，离开这个生活了快三年的地儿。放弃要去一线大公司的欲望，放弃年薪百万的梦想，放弃温柔可爱的南方姑娘，放弃我毕业之前一直向往的自由和远方… … 最让我难受的，在杭州两年认识的几个朋友，也许以后再难见上一面。还有，回到了家乡，我是否就此过上一个安逸的生活，还能否保持目前的这份斗志。杭州被程序员论坛称为“奋斗逼之都”，源于马老师的福报，我虽不喜欢这种996的工作节奏，但是离开这里，真的要放弃很多。 辞职2019年8月21日，在被称为互联网寒冬的这年，我辞职了。因为这一年以来，公司的经营状况出了很大的问题，8月，线上服务器关闭了，这意味着理财业务此时已经完全停止，公司金融部门用仅剩的海外贷款业务维持着最后一线生机。这种时刻，但凡是觉得自己在离开之后能够找到合适工作的人，都不会想要再继续再公司呆下去。我就是其中之一，所以我向老大说，我想走了！ 后来，我们一起去吃了散伙饭，又是火锅，每次都是。为什么说“每次”呢？因为在我之前，还有5个人。我想我也不会是最后一个吧。 准备事实上半年以来我都在使用空闲时间学习、刷算法题、写博客、点亮GitHub绿点以期望自己在之后找工作能够靠着博客和GitHub的活跃程度吸引到某公司的面试官（后来事实证明，这个做法还挺管用，当然我的确有在丰富自己的知识而不只是点“绿点”）。这半年以来，在公司所做的工作几乎可以用杂活来形容！不过这些杂活，为我营造了充足的学习时间的同时，却也让我后来的简历上难以写上一些有含金量的项目。 今年以来，我写了大概30多篇博客，有段时间几乎是一周两篇，就在公司用上班时间写！博客主要学习和整理一些Java基础、多线程并发编程系列的知识，以及整理一些我在实际项目中的一些需求的解决方案。除了博客，我还在GitHub整理了自己在公司使用的一些基础框架，然后自己搭建了一个spring cloud版本的脚手架：Scaffold-Cloud。还在幕布上整理了大篇幅的Java学习大纲和一些面试题目、Java知识点、阿里Java开发手册，不过到目前还没有整理完成，因为实在是太多了，Java基础、设计模式、数据结构与算法、分布式、数据库、计算机网络等等，一点点敲下来也是非常费时间的。 面试说了这么多，你可能以为离职之后我找到了一个好工作。然而，在离职后的一周，我在某直聘APP上投递了几十家简历，在八月的最后一周，我面试了五家公司，包括一家仅有电话面试的公司。事实上在面试之前，我对自己还是很有自信的，毕竟学了半年，怎么着小公司的offer还是可以拿到手的，拿到小公司offer在开始投大公司，开启offer收割机模式。然而我的脸被现实狠狠的打肿了。我面试了鲸灵、大华、兑吧、涂鸦！现实告诉我：你就是个彩笔！还他么想拿大厂的offer？做梦去吧！ 事实上，我在面试的时候基本上都能够回答的出来面试官的问题，尤其是多线程和一些分布式相关的问题，Java基础、JVM更是一直在我的复习范围。然而，当面试官问到一些实际项目遇到的问题以及自己是如何解决的，我就歇菜了。例如实际生产中是如何做性能调优的，实际项目中遇到了哪些问题，是如何解决的？我知道面试官是想考察我解决问题的思路，然而当我将自己工作中所做的全盘托出，换来的却是面试官的鄙视！因为实在是太没有技术含量了，而我自己也确实没有在实际生产中遇到一些比较棘手的问题。这一周的面试将我的信心打压到谷底。 转机幸运的是，我在正式办好离职手续的最后一个礼拜，一个大学的时候进了西安一个比较好的外企的同学告诉我，他们公司招人，问我要不要试一下。在从同花顺离职的时候，也就是一年之前，我有尝试面试过这家公司，可惜在homework阶段由于代码没有写的很好被淘汰了。这次，我要求自己要做好充足的准备。 他们公司面试不像杭州这边的互联网公司，面试总爱问一些高并发、分布式等等只会出现在面试中而不会出现在实际工作中的问题（当然这种说法也很片面）。这个外企的面试流程是给出一道程序设计题，3天时间提交代码，审核代码的质量以及是否优雅的完成题目要求，然后二面针对所做的题目增加需求，考察应试者实际动手能力以及程序设计能力。三面针对项目经验、工作经验再进行一轮面试。 9月6日周五下午4:19，我收到了这家公司的offer，丰厚的报酬和福利，还有离家近的条件让我无法拒绝这样一个offer。再加上在杭州这边面试的不顺利，我决定回去了。在我最后一个面试——杭州涂鸦的时候，我清楚地记得涂鸦HR很明确的告诉我，公司加班严重，大小周。我想，这样的公司是我想要去为之奋斗的吗？不，对于公司来说，员工都只是公司的一颗颗的螺丝钉，都是可被替代的零件，为何要为这种血汗工厂去牺牲自己的生活，杭州的996相必在最近五年之内都会是这个城市程序员的梦魇，最让人无奈的是，有些人竟然真的认为自己是在为自己“奋斗”，殊不知他们是被压迫的社会底层的劳动者，忘记了曾经的“8小时工作制”是由一些多么向往自由的人反抗争取来的，真正宣传996“福报”的资本家已经赚足了钱退休了（写于2019年9月10日）。 回首我在写这篇博客的时候，脑中不断地回忆起17年2月底来到杭州直到现在发生的种种事情。确实由那句话所说，很多年后回想起来，你什么时候准备考研、出国留学、工作、恋爱、结婚生子、跳槽，都有可能会是人生中的一个大的转折点，而自己当时还只是认为这些事只是人生中很小的一件事情。 从同花顺跳槽去杭州的第二家公司工作，是我这两年最后悔的事情。如果我当时不从同花顺走，或者说在同花顺能有一些好的工作体验，也许目前就是另一种状态了吧。原本我跳槽后的计划是，在新的公司将自己沉淀两三年，将技术提升上去，三年后跳槽去一线大公司，但是无奈公司连支持我待够两年都做不到。2019年，其实是我最抑郁，世界最黑暗的一年。这年来，在新的公司工作，公司发展不顺利，志同道合的朋友也渐少，以前几个老朋友从每周几次在一起吃饭、玩的状态突然就变成一个月都见不了一面。也许是他们也都有了自己的女朋友，有了自己的生活，顾不上我了吧。而我每周末都想出去玩，却找不到同行的伙伴。 在杭州的两年时间，我去了周边的很多地方，刚毕业那会也许想的是，我终于获得了自己想要的自由生活，工资也足以让我到处去旅游。我曾经想，自己家要是江浙沪这一带的该有多好，西安那边真的很落后，虽然城市中不太看得出差距，但是城市周边的市、县、村，却是西北那边怎么也追赶不上来的。而且我在这边能够接触到更新的东西，一些新兴的互联网产品都会在这一带优先投放，例如共享单车、共享充电宝、智慧城市服务等等。我想杭州应该会是最优先开始智能化、互联网化的城市之一吧。 可惜了，即将离开这里，放弃两年来在这边拥有的一切。我的朋友，还有我的生活。虽然很不想说再见，但是谁又能主导自己的命运呢。 杭州，有缘再见吧！]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>个人随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程学习(七)：Fork/Join框架原理及demo]]></title>
    <url>%2Fblog%2F20190814%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%83-%EF%BC%9AFork-Join%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%8F%8Ademo%2F</url>
    <content type="text"><![CDATA[概念Fork/Join框架是jdk1.7引入的一个基于“分治”思想的多线程框架。它的功能是将一个大任务切分(fork)成多个相同逻辑的小任务，分而治之，当子任务全都执行完成之后，将结果合并(join)起来，最终成为整体任务的执行结果。原理可以抽象成下图表示： Fork/Join相关代码原理及思想Fork/Join执行步骤 进行任务分割：将任务分割成小任务，然后这个小任务有可能还需要继续分割，直到足够小。 执行并合并结果：分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。 Fork/Join使用两个类完成以上步骤： ForkJoinTask： Fork/Join提供了两个子类：RecursiveAction：用于没有返回结果的任务；RecursiveTask ：用于有返回结果的任务 ForkJoinPool ：public class ForkJoinPool extends AbstractExecutorService{ ... }ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。这种算法成为工作窃取算法(work-stealing) 工作窃取算法(work-stealing) Fork/Join框架内部实现了一个类似于LinkedBlockingDeque的双端队列用作工作线程的任务队列WorkQueue。使用ForkJoinWorkerThread保存工作线程，ForkJoinPool.WorkQueue就在其内部。 Fork/Join每个工作线程在运行中产生了新的任务(通常是调用fork方法)的时候，将任务加入WorkQueue尾部，并且工作线程每次取出任务执行也是从队尾取出执行，即LIFO 每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。 在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。 在既没有自己的任务，也没有可以窃取的任务时，进入休眠。 Fork/Join demo演示 使用Fork/Join完成大量有序数字的加和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MyCalculateTask extends RecursiveTask&lt;Integer&gt; &#123; private static final int THREADSHOLD = 50; private int start; private int end; private List&lt;String&gt; list; public MyCalculateTask(int start, int end, List&lt;String&gt; list) &#123; this.start = start; this.end = end; this.list = list; &#125; @Override protected Integer compute() &#123; int sum = 0; if (end - start &lt; THREADSHOLD) &#123; // 当两数字之间差值小于指定值 就不再查分成小任务 String so = ""; for (int i = start; i &lt; end; i++) &#123; sum += i; so += list.get(i) + ","; &#125; System.out.println(Thread.currentThread().getName() + "处理 " + so + " 的数据"); &#125; else &#123; int mid = (start + end) / 2; // 一分为二 拆分任务 final MyCalculateTask left = new MyCalculateTask(start, mid, list); final MyCalculateTask right = new MyCalculateTask(mid, end, list); left.fork(); right.fork(); sum += left.join(); sum += right.join(); &#125; return sum; &#125; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; int sum = 0; ForkJoinPool pool = new ForkJoinPool(); int count = 400; List&lt;String&gt; list = new ArrayList&lt;&gt;(count); for (int i = 0; i &lt; count; i++) &#123; list.add("i-" + i); sum += i; &#125; MyCalculateTask task = new MyCalculateTask(0, count, list); final ForkJoinTask&lt;Integer&gt; submit = pool.submit(task); System.out.println("sum = " + sum + " --- submit.get() = " + submit.get()); pool.awaitTermination(5, TimeUnit.SECONDS); pool.shutdown(); &#125;&#125; 总结Fork/Join框架可以帮助我们完成很多这种大任务可以拆分成小任务执行的场景，不过上面的方法并不是最佳执行调用方式 1234left.fork(); right.fork();替换为invokeAll(left, right); 因为对于Fork/Join模式，假如Pool里面线程数量是固定的，那么调用子任务的fork方法相当于A先分工给B，然后A当监工不干活，B去完成A交代的任务。所以上面的模式相当于浪费了一个线程。那么如果使用invokeAll相当于A分工给B后，A和B都去完成工作。这样可以更好的利用线程池，缩短执行的时间。 参考：http://ifeve.com/talk-concurrency-forkjoin/]]></content>
      <categories>
        <category>Java基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>Fork/Join框架</tag>
        <tag>ForkJoinPool</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】设计模式基本思想以及23种模式总结整理]]></title>
    <url>%2Fblog%2F20190812%2F%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8A23%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[设计模式主要思想设计模式是在长期应用开发过程中，众多开发者总结归纳出来的程序架构与设计思想。是经过实践证明的，可在实际背景下使用的一系列程序设计方案。设计模式产生的根本目的就是为了解决开发过程中重复的代码编写，以及让程序更易扩展复用。 设计模式的原则 单一职责：每个类都应该实现单一的功能，否则应该将类进行拆分 里氏替换：即继承复用/合成复用。尽量使用合成/聚合的方式而不是继承。任何父类出现的地方，子类都可以出现。派生类可以在基类的基础上扩展自己的功能实现。是对“开闭原则”的一个补充。在里氏替换原则中，尽量不要对父类进行重载或者重写，因为父类代表一个定义好的结构，通过规范好的接口与外界进行交互，子类不应该随意破坏它，而是对其进行扩展。 依赖倒置：“开闭原则”的基础。即面向接口编程。依赖于抽象而不是依赖于具体的实现，编程时遇到具体的类时，不与具体的类交互，而与抽象接口进行交互。便于增加新的具体类的时候代码可以复用。 接口隔离：每个接口不应该存在子类用不到却必须实现的方法，否则就应该将接口拆分，将职责单一化。 最少知道：即迪米特法则。一个类对于自己依赖的类知道的越少越好，无论被依赖的类多么复杂，都应该将逻辑封装在方法内部，通过一个共有的方法提供给依赖类使用，这样当被依赖类发生改变的时候，才会尽可能少的影响依赖类。 设计模式的分类 点击对应链接跳转到该设计模式的详细整理与代码示例 范围 创建型模式 结构型模式 行为型模式 对象创建 Singleton（单例模式）Prototype(原型模式)Factory Method（工厂方法模式）Abstract Factory（抽象工厂模式）Builder（建造者模式） 接口适配 Adapter（适配器模式）Bridge（桥接模式）Facade（外观模式） 对象解耦 Mediator（中介者模式）Observer（观察者模式） 抽象集合 Composite（组合模式） Iterator（迭代器模式） 行为扩展 Decorator（装饰模式） Visitor（访问者模式）Chain of Responsibility（职责链） 算法封装 Template（模板方法模式）Strategy（策略模式） 性能与对象访问 Flyweight（享元模式）Proxy（代理模式） 对象状态 Memento（备忘录模式）State（状态模式） 其他 Interpreter（解释器模式） 总结下设计模式的归类 创建型设计模式创建型设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，使调用者无需new对象，在程序中针对给定业务场景去调用特定的对象创建方法，使程序更加灵活。 行为型设计模式行为型设计模式主要关注对象之间的通信。 结构型设计模式结构型设计模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。]]></content>
      <categories>
        <category>Java基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>设计模式</tag>
        <tag>设计模式基本思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode - 52. N皇后 II 回溯算法求解]]></title>
    <url>%2Fblog%2F20190809%2FLeetcode-52-N%E7%9A%87%E5%90%8E-II-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[N皇后问题 - leetcoden 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例： 输入: 4输出: 2解释: 4 皇后问题存在如下两个不同的解法。12345678910[[".Q..", // 解法 1"...Q","Q...","..Q."],["..Q.", // 解法 2"Q...","...Q",".Q.."]] 解题思路：使用回溯算法，深度优先搜索，进行遍历查询深度优先搜索的条件是有能够判断棋盘是否能落子的依据。 我这边使用一个长度为N的数组存储第J列是否有棋子，使用两个N*2-1长度的数组分别存储左对角线和右对角线是否有棋子。 对于左右对角线来说，左对角线的每一个位置i与j的和都相同，右对角线的每一个位置的i与j的差都相同，所以可以用来判断某个位置的斜线上是否存在棋子，对应对角线的数组标志为有或者没有。 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; /** 总记录数 */ private int total = 0; /** N皇后 */ private int N; /** 判断当前位置的左对角线是否存放了棋子 */ private int[] left = new int[15]; /** 判断当前位置的右对角线是否存放了棋子 */ private int[] right = new int[15]; /** 判断当前位置的列是否存放了棋子 */ private int[] curn; public int totalNQueens(int n) &#123; this.N = n; curn = new int[n]; left = new int[2 * n - 1]; right = new int[2 * n - 1]; calResult(0); return total; &#125; private void calResult(int i) &#123; // 棋盘第i行 遍历判断第j列 for (int j = 0; j &lt; N; j++) &#123; // 开始判断第i行第j列 // 判断第j列是否已经有棋子；判断(i,j)的左对角线是否有棋子；判断右对角线是否有棋子 if (curn[j] == 0 &amp;&amp; left[i + j] == 0 &amp;&amp; right[N - 1 + i - j] == 0) &#123; // 没有棋子 就可以在(i,j)放置棋子 curn[j] = left[i + j] = right[N - 1 + i - j] = 1; // 如果N行都放置了棋子 total就加1 否则继续放置下一行 if (i &lt; N - 1) &#123; calResult(i + 1); &#125; else &#123; total++; &#125; // 放置完成之后 (i,j)位置棋子去掉，然后重新走下一步 进行深度优先搜索 curn[j] = left[i + j] = right[N - 1 + i - j] = 0; &#125; &#125; &#125; public static void main(String[] args) &#123; final Solution solution = new Solution(); solution.totalNQueens(8); System.out.println("total = " + solution.total); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode上的几个多线程编程题解]]></title>
    <url>%2Fblog%2F20190724%2FLeetCode%E4%B8%8A%E7%9A%84%E5%87%A0%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[以下所有题目的题解 - github1、按序打印 方法一：使用volatile变量控制顺序 思路：利用volatile语义，实现变量的内存可见性，使得别的线程在修改完state状态变量的时候结果对于另一个线程立即可见。这样每个线程在打印的时候就可以通过状态判断是不是该轮到自己执行了。 12345678910111213141516171819202122232425262728293031public class Foo2 &#123; private volatile int state = 1; public void first(Runnable printFirst) throws InterruptedException &#123; while (state != 1) &#123; &#125; // printFirst.run() outputs "first". Do not change or remove this line. printFirst.run(); state = 2; &#125; public void second(Runnable printSecond) throws InterruptedException &#123; while (state != 2) &#123; &#125; // printSecond.run() outputs "second". Do not change or remove this line. printSecond.run(); state = 3; &#125; public void third(Runnable printThird) throws InterruptedException &#123; while (state != 3) &#123; &#125; // printThird.run() outputs "third". Do not change or remove this line. printThird.run(); state = 1; &#125;&#125; 方法二：使用CountDownLatch控制顺序（只适用于执行一次。。。可以使用循环栅栏改一下~） CountDownLatch俗称“闭锁”。使用闭锁来控制线程是否该执行，在没有达到条件时，闭锁阻塞线程。这样在第一个线程执行完成之后打开第二个线程的闭锁，第二个执行完成之后打开第三个线程的闭锁，实现按照顺序打印。12345678910111213141516171819202122232425262728293031import java.util.concurrent.CountDownLatch;public class Foo3 &#123; private CountDownLatch countDownLatch2 = new CountDownLatch(1); private CountDownLatch countDownLatch3 = new CountDownLatch(1); public void first(Runnable printFirst) throws InterruptedException &#123; countDownLatch3.await(); countDownLatch2.await(); // printFirst.run() outputs "first". Do not change or remove this line. printFirst.run(); countDownLatch2.countDown(); &#125; public void second(Runnable printSecond) throws InterruptedException &#123; countDownLatch3.await(); countDownLatch2.await(); // printSecond.run() outputs "second". Do not change or remove this line. printSecond.run(); countDownLatch3.countDown(); &#125; public void third(Runnable printThird) throws InterruptedException &#123; countDownLatch3.await(); // printThird.run() outputs "third". Do not change or remove this line. printThird.run(); &#125;&#125; 2、交替打印FooBar 思路：使用显示可重入锁加上Condition条件阻塞机制，再加上volatile修饰的状态变量控制打印顺序。线程打印时加锁，如果状态是使当前线程打印，就打印并且转换状态，然后唤醒另一个线程。下一次再判断当前状态不适合打印，就使用第一个条件锁阻塞当前线程。以此类推。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** @Author zhangjiaheng @Description 交替打印FooBar */public class FooBar &#123; private int n; public FooBar(int n) &#123; this.n = n; &#125; private ReentrantLock lock = new ReentrantLock(); private Condition c1 = lock.newCondition(); private Condition c2 = lock.newCondition(); private volatile boolean flag = false; public void foo(Runnable printFoo) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; try &#123; lock.lock(); if (flag) &#123; c1.await(); &#125; // printFoo.run() outputs "foo". Do not change or remove this line. printFoo.run(); flag = !flag; c2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public void bar(Runnable printBar) throws InterruptedException &#123; for (int i = 0; i &lt; n; i++) &#123; try &#123; lock.lock(); if (!flag) &#123; c2.await(); &#125; // printBar.run() outputs "bar". Do not change or remove this line. printBar.run(); flag = !flag; c1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 3、打印0与奇偶数 思路：也是使用显示可重入锁加上条件阻塞机制，加上volatile修饰的状态变量控制奇偶数的打印。不符合当前执行的状态就使用condition阻塞，符合就执行并且转换状态，然后唤醒其他线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;import java.util.function.IntConsumer;/** * @Author zhangjiaheng @Description https://leetcode-cn.com/problems/print-zero-even-odd * 3个线程交替打印奇偶数和0 */public class ZeroEvenOdd &#123; private int n; public ZeroEvenOdd(int n) &#123; this.n = n; &#125; private ReentrantLock lock = new ReentrantLock(); private Condition c1 = lock.newCondition(); private Condition c2 = lock.newCondition(); private Condition c3 = lock.newCondition(); /** 0-打印0 1-打印奇数 2-打印偶数 */ private volatile int flag = 0; public void zero(IntConsumer printNumber) throws InterruptedException &#123; try &#123; lock.lock(); for (int i = 1; i &lt;= n; i++) &#123; while (flag != 0) &#123; c1.await(); &#125; printNumber.accept(0); if ((i &amp; 1) == 1) &#123; flag = 1; c3.signal(); &#125; else &#123; flag = 2; c2.signal(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void even(IntConsumer printNumber) throws InterruptedException &#123; try &#123; lock.lock(); for (int i = 2; i &lt;= n; i += 2) &#123; while (flag != 2) &#123; c2.await(); &#125; printNumber.accept(i); flag = 0; c1.signal(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void odd(IntConsumer printNumber) throws InterruptedException &#123; try &#123; lock.lock(); for (int i = 1; i &lt;= n; i += 2) &#123; while (flag != 1) &#123; c3.await(); &#125; printNumber.accept(i); flag = 0; c1.signal(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; ZeroEvenOdd zeroEvenOdd = new ZeroEvenOdd(5); ThreadPoolExecutor pools = new ThreadPoolExecutor( 3, 3, 1, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;&gt;(1), r -&gt; new Thread(r, "某线程")); pools.execute( () -&gt; &#123; try &#123; zeroEvenOdd.zero(System.out::print); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); pools.execute( () -&gt; &#123; try &#123; zeroEvenOdd.even(System.out::print); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); pools.execute( () -&gt; &#123; try &#123; zeroEvenOdd.odd(System.out::print); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;&#125; 4、H2O生成 方法一：使用显示锁和condition 思路：老生常谈的思路了，同上面一样的原理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** @Author zhangjiaheng @Description 水分子生成 */public class H2O &#123; public H2O() &#123;&#125; private ReentrantLock lock = new ReentrantLock(); private Condition H = lock.newCondition(); private Condition O = lock.newCondition(); private volatile int hCount = 0; public void hydrogen(Runnable releaseHydrogen) throws InterruptedException &#123; try &#123; lock.lock(); while (hCount == 2) &#123; H.await(); &#125; hCount++; releaseHydrogen.run(); if (hCount == 2) &#123; O.signal(); &#125; else &#123; H.signal(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void oxygen(Runnable releaseOxygen) throws InterruptedException &#123; try &#123; lock.lock(); while (hCount != 2) &#123; O.await(); &#125; hCount = 0; releaseOxygen.run(); H.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; String s = "HHOOOHHHH"; final H2O o = new H2O(); for (char c : s.toCharArray()) &#123; if (c == 'H') &#123; new Thread( () -&gt; &#123; try &#123; o.hydrogen(() -&gt; System.out.print("H")); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;) .start(); &#125; else &#123; new Thread( () -&gt; &#123; try &#123; o.oxygen(() -&gt; System.out.print("O")); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;) .start(); &#125; &#125; &#125;&#125; 方法二：使用信号量控制通知线程 思路：使用信号量控制线程间的通信。分别分为执行信号和唤醒信号，氢原子的执行信号首先为2，氧原子的执行信号首先为1。氢氧线程执行时消耗执行信号量，当一个氢原子执行后，氢原子的释放信号开始释放（只有一个氧线程等待其释放），然后等待氧原子释放信号释放（即一个氧原子已经产生），之后产生一个氢原子在释放请求信号。氧线程执行时，开始请求释放一个氧原子，成功之后氧线程释放信号开始释放（因为2个氢线程等待所以释放两个信号），然后等待氢线程释放两个信号（说明已经有两个氢原子生成）。然后再生成氧原子，成功之后在释放氧线程的请求信号。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.Random;import java.util.concurrent.*;/** @Author zhangjiaheng @Description 使用信号量控制水分子生成 */public class H2O_2 &#123; private Semaphore hAcquire, oAcquire, hRelease, oRelease; public H2O_2() &#123; // H 原子线程 请求信号 hAcquire = new Semaphore(2); // O 原子线程 请求信号 oAcquire = new Semaphore(1); // H 原子线程 释放信号 hRelease = new Semaphore(0); // O 原子线程 释放信号 oRelease = new Semaphore(0); &#125; public void hydrogen(Runnable releaseHydrogen) throws InterruptedException &#123; hAcquire.acquire(); // H线程开始请求 hRelease.release(); // 通知一个H线程即将释放 因为一个H线程释放最多只有一个O线程等待其释放 oRelease.acquire(); // 等待O线程释放 一个O线程释放就可以通过 releaseHydrogen.run(); hAcquire.release(); // 唤醒H线程请求 &#125; public void oxygen(Runnable releaseOxygen) throws InterruptedException &#123; oAcquire.acquire(); // O线程开始请求 oRelease.release(2); // 通知一个O线程即将释放 因为一个O线程释放 会有两个H线程等待其释放 hRelease.acquire(2); // 等待H线程释放 要等待两次释放 才可以通过 releaseOxygen.run(); oAcquire.release(); // 唤醒O线程请求 &#125; public static void main(String[] args) &#123; String s = "HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHOOHHOOOOOHOOOHHHOHHHHOOOHHHOOOHOHOHOHHOHOOHHHOOHOOOHHOOOOHOHHHHOOOOOHHHOOOHOHOHOOOHHOHOOHHOHHHHHHHHHHHHHHHHHHHHHHHHHHH"; final H2O_2 o = new H2O_2(); ThreadPoolExecutor pool = new ThreadPoolExecutor( 300, 300, 10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(100), (ThreadFactory) Thread::new); for (char c : s.toCharArray()) &#123; if (c == 'H') &#123; pool.execute( () -&gt; &#123; try &#123; Thread.sleep(new Random().nextInt(10)); o.hydrogen(() -&gt; System.out.print("H")); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; else &#123; pool.execute( () -&gt; &#123; try &#123; Thread.sleep(new Random().nextInt(10)); o.oxygen(() -&gt; System.out.print("O")); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized使用时一个不起眼的注意点]]></title>
    <url>%2Fblog%2F20190716%2FSynchronized%E4%BD%BF%E7%94%A8%E6%97%B6%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%B5%B7%E7%9C%BC%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Synchronized 前情提要Synchronized是Java中用来进行方法或者代码同步的一个内置锁机制。这种内置锁机制可以保证代码执行的原子性、可见性，但是并不能屏蔽代码的重排序。Synchronized可以修饰方法、对象以及代码块，并可以保证被修饰的方法或者代码块，在同一个时刻只能有一个线程能够访问得到。 修饰静态方法：锁的是当前类的class对象，修饰方法时Synchronized没有表现在字节码指令中，而是在class文件的方法表中将该方法的access_flags值置为1。表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象。 修饰普通方法：锁的是当前实例对象，修饰方法时同上。 修饰代码块：锁的是Synchronized()中的对象，编译后的字节码会在代码块前后插入monitorenter 和monitorexit。JVM需要每一个monitorenter都有一个monitorexit与之对应，任何对象都有一个monitor与之相对应，当一个monitor被持有，即线程执行到monitorenter时，对象将处于锁定状态。 Synchronized是Java内置的重量级锁，在jdk1.6之后引入了自旋锁、轻量级锁、适应性自旋、锁粗化、锁消除、偏向锁等技术来减少Synchronized的性能开销。 切入正题以上知识点想必刚开始学习并发编程的程序员都会先学习以上知识，但是很多程序员在使用Synchronized的时候有可能会发现，我明明加锁了，但是方法却并没有同步执行，这到底是什么原因？先看下如下代码： 123456789101112131415private static Integer cn = 0;private static final int size = 20;public static void main(String[] args) &#123; for (int j = 0; j &lt; size; j++) &#123; new Thread( () -&gt; &#123; for (int i = 0; i &lt; 5; i++) &#123; synchronized (cn) &#123; cn++; &#125; &#125; &#125;) .start(); &#125;&#125; 以上代码启动了20个线程，对Integer变量cn进行自增。很多人在写Synchronized的时候都有可能出现这种问题。这样的写法是错误的！ 因为cn++这句代码的原理是将cn指向一个cn+1的新的Integer对象！ 修改成如下，然后看看输出： 12345678910111213141516171819202122232425private static Integer cn = 0;private static final int size = 20;private static CountDownLatch cd = new CountDownLatch(size);public static void main(String[] args) &#123; for (int j = 0; j &lt; size; j++) &#123; int finalJ = j; new Thread( () -&gt; &#123; try &#123; cd.countDown(); cd.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int i = 0; i &lt; 5; i++) &#123; synchronized (cn) &#123; cn++; System.out.println( "cn" + finalJ + " = " + cn + "\t\t\t" + System.identityHashCode(cn)); &#125; &#125; &#125;) .start(); &#125;&#125; 以上代码输出如下 &gt;&gt; 每次输出的Integer对象的HashCode值并不相同。所以，每次锁的并不是同一个对象！既然不是同一个对象，那么这个方法在多线程访问的时候肯定就不是线程安全的！对于如上这种例子我们当然可以使用原子变量AtomicInteger来实现更高级的同步机制去解决这个问题，但是其他场景下呢？ 不仅仅是Integer对象哦！所有的对象都有可能会有这些问题存在！当你在锁这个对象的时候，一定要保证加锁的对象在线程中不被修改成另一个对象！否则就是一个假的同步代码块！]]></content>
      <categories>
        <category>Java基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个[合格]的程序员必须具备的工具和插件]]></title>
    <url>%2Fblog%2F20190714%2F%E4%B8%80%E4%B8%AA-%E5%90%88%E6%A0%BC-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E5%85%B7%E5%A4%87%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言如题… 是我标题党了，应该这样讲：“合格的程序员”不一定需要会使用哪些工具，但是会使用那些能够有效减少自己工作量的很酷的工具和插件的程序员一定会进步成一个“合格的程序员”。因为他们善于思考，并能够将繁杂的重复性工作交给工具去完成，将精力集中在核心的编码任务上。 逐个介绍那些我自己常用的工具、插件或者网站Ghelper说到工具，不会翻墙用啥子工具。Ghelper是一个谷歌浏览器插件，直接下载安装到chrome扩展即可轻松访问谷歌等服务！注意，访问谷歌的相关服务是免费的哦！如果你有需求访问其他的例如YouTuBe、Twitter之类的，可以购买会员服务！这里还有一个谷歌访问助手破解版，我没有试过，有兴趣可以装一下看看：GHelper破解版这个工具可以说是以下大部分工具的基础。 FeHelperFeHelper是一个在谷歌浏览器上我最常用的一个插件。功能如下，字符串编解码、JSON格式化、时间戳转换等等工具，在做web开发的时候查看某个JSON数据格式是否正确直接黏贴到这个框里就OK，简单暴力~ 油猴儿大名鼎鼎的油猴儿想必很多程序员都了解以及用过吧(没用过别告诉我你是个程序员，死敲代码的)。 如上图就是我的一些油猴儿插件的已安装的一部分脚本的截图。例如看各大视频网站，不想要买VIP去看，那么直接安装一个VIP视频破解脚本；或者百度网盘，拒绝启动客户端下载文件，安装个油猴脚本直接直链下载！ 油猴儿在我看来就是一个浏览器脚本的容器，网上极客众多，你可以找得到任何自己感兴趣的想要安装的插件去完成自己要做的事情。 油猴儿的安装：谷歌应用商店 - 油猴儿，安装完成之后你就可以找到任何你想要的脚本装在油猴儿里面啦！ 这边，我只告诉大家一个终极脚本：UserScript+。为啥叫它终极脚本。。。因为安装上它之后，当你打开任何网站，他都会提示你这个网站可以安装的脚本有哪些，这样你就不用在茫茫大海中去寻找自己需要的那些脚本了。 可以想象，有了这个之后，面向百度编程的程序员是不是不用再被眼花缭乱的广告所骚扰！喜欢使用掘金的程序员也可以设置自己喜欢的页面排版~ 经常水V2EX的程序员也可以在评论区盖楼了！！哈哈想想就刺激呢！ 云盘精灵 云盘精灵是一个下载百度网盘资源的神奇的网站，在这里你几乎可以找到任何您想要的资源去下载。然鹅，需要注册然后使用豆子购买。不过这也是理所应当的，毕竟知识付费的天下。但是需要付的并不多，而且你还可以将你自己的资源分享到云盘精灵，有人下载你也会赚取到相应的豆子。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将阿里Java编码规范敲成思维导图]]></title>
    <url>%2Fblog%2F20190714%2F%E5%B0%86%E9%98%BF%E9%87%8CJava%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B2%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[阿里Java编码规范 可以点击这里查看分享的笔记 或者扫描如下二维码获取我分享的《阿里Java开发手册-幕布版》 最后，思维导图效果如下，密集恐惧症慎入~~ 查看清晰完整的效果请去幕布笔记，点击查看思维导图即可]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】模板方法模式]]></title>
    <url>%2Fblog%2F20190707%2F%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是模板方法模式在计算机程序中，为了将一些具有不同实现但有相同执行步骤的类统一起来，通常我们将这些类抽象成一个模板类。模板类定义了一个算法的框架，使得子类可以不改变算法的结构而去对一些细节实现进行重新定义。 模板方法模式的核心要素抽象模板抽象模板中定义了两种方法：需要子类去实现的基本方法，以及固定的不需要子类去实现的具体算法步骤的模板方法。基本方法在模板方法中被调用，模板方法一般会是一个具体的算法框架，调度基本方法完成所有功能。 具体实现子类具体实现抽象模板中的基本方法，完成对框架中的算法细节进行重新定义。 我在实际项目中使用的案例在做某个按需查询不同类别的用户，并将其上传到OSS上，每日发邮件告诉运营人员结果的一个需求的时候，我就用到了模板方法模式。首先定义一个抽象模板，分别有查询用户(每天都不同的SQL)，上传到OSS，发邮件等几个步骤，即基本方法。在模板方法中将这几个步骤封装起来。定义7个子类分别对每天不同的查询、上传、邮件做具体的实现。最后根据策略模式，不同的星期调用不同的对象的模板方法完成核心功能。 模板方法模式代码示例如图，有个做饭的抽象模板：定义了[洗菜-炒菜-完成]三个步骤为基本方法，一个ComplateCook方法完成步骤的组装 一个西红柿炒蛋的实现类 一个鱼香肉丝的实现类 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public abstract class CookTemplate &#123; // 定义步骤为抽象方法 public abstract void wash(); public abstract void cook(); public abstract void finish(); public final void ComplateCook() &#123; System.out.println("开始做菜～"); wash(); cook(); finish(); System.out.println("完成做菜步骤～"); &#125;&#125;public class XihongshiChaoEgg extends CookTemplate&#123; @Override public void wash() &#123; System.out.println("切西红柿，准备鸡蛋～"); &#125; @Override public void cook() &#123; System.out.println("炒鸡蛋，然后再炒西红柿～"); &#125; @Override public void finish() &#123; System.out.println("西红柿炒蛋做好了，出锅～"); &#125;&#125;public class YuXiangRose extends CookTemplate&#123; @Override public void wash() &#123; System.out.println("洗胡萝卜～"); System.out.println("切肉丝～"); &#125; @Override public void cook() &#123; System.out.println("开始做鱼香肉丝～"); &#125; @Override public void finish() &#123; System.out.println("鱼香肉丝做好了 出锅～"); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; CookTemplate cook = new XihongshiChaoEgg(); cook.ComplateCook(); cook = new YuXiangRose(); cook.ComplateCook(); &#125;&#125; 模板方法模式优缺点 优点 封装了不可变的部分，扩展可变部分 提供公共代码，便于维护 具体行为父类控制，子类只管自己的细节实现，符合开闭原则 缺点 一个不同的实现都要增加一个子类，会导致代码量很庞大 父类的执行结果会受到子类的影响，在复杂代码的阅读中会给开发人员带来很多麻烦 总结模板方法模式适用于：有一个固定的算法步骤，但是细节实现存在多种可能的场景，即整体稳定但是个别易变的时候讲会变化的那一部分抽象出来。模板方法模式强调抽象类与子类之间的协作，它将调用权交给父类，是一种控制反转的设计理念。子类不再去完成核心的功能，只需要关注属于自己的那一部分的实现。 JDK中经典的模板方法模式实现：AQS]]></content>
      <categories>
        <category>Java基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>模板方法模式模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程学习(六)：Exchanger的学习及使用场景]]></title>
    <url>%2Fblog%2F20190701%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%85%AD-%EF%BC%9AExchanger%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[前言在JUC包中，除了一些常用的或者说常见的并发工具类(ReentrantLock，CountDownLatch，CyclicBarrier，Semaphore)等，还有一个不常用的线程同步器类 —— Exchanger。 Exchanger是适用在两个线程之间数据交换的并发工具类，它的作用是找到一个同步点，当两个线程都执行到了同步点(exchange方法)之后(有一个没有执行到就一直等待，也可以设置等待超时时间)，就将自身线程的数据与对方交换。 Exchanger工具类UML Exchanger类结构如上图UNML，Exchanger类中有两个内部类，一个Node，一个Participant。 Participant继承了ThreadLocal并且重写了其initialValue方法，返回一个Node对象。 1234/** The corresponding thread local class */static final class Participant extends ThreadLocal&lt;Node&gt; &#123; public Node initialValue() &#123; return new Node(); &#125;&#125; Node类封装了两个线程存储的数据对象： 1234567891011121314/** * Nodes hold partially exchanged data, plus other per-thread * bookkeeping. Padded via @sun.misc.Contended to reduce memory * contention. */@sun.misc.Contended static final class Node &#123; int index; // node 在 arena 数组下标 int bound; // 交换器的最后记录值 int collides; // 记录的 CAS 失败数 int hash; // 伪随机的自旋数 Object item; // 这个线程的数据项 volatile Object match; // 另一个线程的数据项 volatile Thread parked; // 当阻塞时，设置此线程，不阻塞的话会自旋&#125; Exchanger源码分析 123456789101112@SuppressWarnings("unchecked")public V exchange(V x) throws InterruptedException &#123; Object v; Object item = (x == null) ? NULL_ITEM : x; // translate null args if ((arena != null || // 是null就执行后面的方法 (v = slotExchange(item, false, 0L)) == null) &amp;&amp; // 如果执行slotExchange有结果就执行后面的，否则返回 ((Thread.interrupted() || // 非中断则执行后面的方法 (v = arenaExchange(item, false, 0L)) == null))) throw new InterruptedException(); return (v == NULL_ITEM) ? null : (V)v;&#125; exchange方法的步骤： 如果执行slotExchange有结果就执行后面的arenaExchange 如果solt被占用，就执行arenaExchange 返回的数据v是对方线程的数据项 总结即：如果A线程先调用，那么A的数据项存储的item中 则B线程的数据项存储在match中 当没有多线程并发操作 Exchange 的时候，使用 slotExchange 就足够了。 slot 是一个 node 对象。 当出现并发了，一个 slot 就不够了，就需要使用一个 node 数组 arena 操作了。 ​ Exchanger的使用下面的例子模拟一个队列中数据的交换使用的场景： 线程A往队列中存入数据 线程B从队列中消耗数据 当线程A存满的时候 才交换给线程B 当线程B消耗完成之后才交换给线程A。 线程A、B的生产和消耗的速率有可能不同 对方线程调用exchange之前，另一个线程执行到exchange会阻塞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** 在对方线程调用exchange之前，另一个线程执行到exchange会阻塞 直到双方都调用exchange */public class ExchangerStudy &#123; private static ArrayBlockingQueue&lt;String&gt; initialFillQueue = new ArrayBlockingQueue&lt;&gt;(5); private static ArrayBlockingQueue&lt;String&gt; initialEmptyQueue = new ArrayBlockingQueue&lt;&gt;(5); private static Exchanger&lt;ArrayBlockingQueue&lt;String&gt;&gt; exchanger = new Exchanger&lt;&gt;(); /** 填充缓存队列的线程 */ static class FillingRunnable implements Runnable &#123; @Override public void run() &#123; ArrayBlockingQueue&lt;String&gt; current = initialEmptyQueue; try &#123; while (current != null) &#123; String str = StrUtil.uuid(); System.out.println("生产了一个序列：" + str + "&gt;&gt;&gt;&gt;&gt;加入到交换区"); Thread.sleep(2000); try &#123; current.add(str); &#125; catch (IllegalStateException e) &#123; System.out.println("队列已满，换一个空的"); current = exchanger.exchange(current); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** 填充缓存队列的线程 */ static class EmptyingRunnable implements Runnable &#123; @Override public void run() &#123; ArrayBlockingQueue&lt;String&gt; current = initialFillQueue; try &#123; while (current != null) &#123; if (!current.isEmpty()) &#123; String str = current.poll(); System.out.println("消耗一个数列：" + str); &#125; else &#123; System.out.println("队列空了，换个满的"); current = exchanger.exchange(current); System.out.println("换满的成功~~~~~~~~~~~~~~~~~~~~~~"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; new Thread(new FillingRunnable()).start(); new Thread(new EmptyingRunnable()).start(); &#125;&#125; &gt;&gt;&gt;&gt;&gt; 更详细的源码解析 - 掘金]]></content>
      <categories>
        <category>Java基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>Exchanger</tag>
        <tag>线程交换器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程学习(五)：Semaphore源码学习及使用案例]]></title>
    <url>%2Fblog%2F20190623%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%94-%EF%BC%9ASemaphore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Semaphore同步工具类之信号量介绍什么是Semaphore Semaphore是JUC包中的一个很简单的工具类，用来实现多线程下对于资源的同一时刻的访问线程数限制 Semaphore中存在一个【许可】的概念，即访问资源之前，先要获得许可，如果当前许可数量为0，那么线程阻塞，直到获得许可 Semaphore内部使用AQS实现，由抽象内部类Sync继承了AQS。因为Semaphore天生就是共享的场景，所以其内部实际上类似于共享锁的实现。 Semaphore机制是提供给线程抢占式获取许可，所以他可以实现公平或者非公平，类似于ReentrantLock。 Semaphore提供两个构造方法，用来传入许可数量以及公平或者非公平：123456public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125; Semaphore的使用场景 限流：并发环境(例如有1000个线程)下只允许100个线程访问数据库某资源 亦例如实际的，停车场只有10个车位，目前有15个汽车要来停车，多出的5个需要等其他车辆离开之后才能进行停车 Semaphore源码解读分为公平与非公平 获取许可的非公平的实现在抽象类Sync中实现了非公平的消耗“许可”的方法。123456789final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125; 首先获取当前许可数量 判断消耗许可之后的剩余数量是否&gt;=0 是的话执行compareAndSetState(available, remaining)设置许可之后返回 否则返回的负数会使得其在doAcquireSharedInterruptibly中等待许可并挂起，直到被唤醒(这步骤在AQS中实现，如下) 123456789public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; //如果线程被中断了，抛出异常 if (Thread.interrupted()) throw new InterruptedException(); //获取许可失败，将线程加入到等待队列中 if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; 获取许可的公平实现首先会在获取许可之前，判断hasQueuedPredecessors()，是否有线程在等待队列中等待许可，有的话直接返回-1，这个底层实现在AQS中已经实现好了。接下来剩下的操作就和非公平的基本一致了。 123456789101112131415161718192021222324252627282930static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125;&#125;public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; // 判断头节点不等于尾节点并且（头节点的下一节点为空或者其为当前线程） return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 许可的释放许可的释放对于公平和非公平的实现都是一致的，定义在Sync类中。因为是共享式的，释放的时候没有像ReentrantLock一样去判断是否是当前线程来释放许可。释放许可也是采用原子操作将需要释放的许可加回去就完成了。 一旦线程调用releaseShared释放许可成功，就会同时调用doReleaseShared方法，其中会对阻塞的线程进行环型，下面是tryReleaseShared的源码。 12345678910111213protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; // 拿到当前的许可数量 int current = getState(); // 加上还回来的许可 int next = current + releases; if (next &lt; current) // overflow throw new Error("Maximum permit count exceeded"); // 原子操作 归还许可 if (compareAndSetState(current, next)) return true; &#125;&#125; 减少许可数量以及将剩余许可数量都取走Semaphore还提供了几个额外的操作许可的方法 减少许可数量 12345678910final void reducePermits(int reductions) &#123; for (;;) &#123; int current = getState(); int next = current - reductions; if (next &gt; current) // underflow throw new Error("Permit count underflow"); if (compareAndSetState(current, next)) return; &#125;&#125; 取走剩余全部许可 1234567final int drainPermits() &#123; for (;;) &#123; int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; &#125;&#125; 实际使用信号量的代码实例如下：使用信号量做了一个限流的功能。 在1000个线程并发访问的情况下，每次限制只有100个线程能够获取到资源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class SemaphoreStudy &#123; // 许可的数量 public static final int N = 100; // 线程数量 public static final int M = 1000; // 获取许可失败的次数 private static final AtomicInteger F = new AtomicInteger(); // 获取许可成功的次数 private static final AtomicInteger S = new AtomicInteger(); // 声明许可 private static Semaphore store = new Semaphore(N); public static void main(String[] args) throws BrokenBarrierException, InterruptedException &#123; // 使用栅栏模拟1000并发 CyclicBarrier BARRIER = new CyclicBarrier(M + 1); // 使用线程池创建线程 ExecutorService pool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; M; i++) &#123; pool.execute( () -&gt; &#123; try &#123; BARRIER.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; getData(); &#125;); &#125; System.out.println("等待2秒执行并发1000线程"); Thread.sleep(2000); // 等待两秒后打开栅栏 并发获取数据开始执行 BARRIER.await(); pool.shutdown(); &#125; /** 模拟获取数据或者业务处理 */ public static void getData() &#123; while (!store.tryAcquire()) &#123; int a = 5000 + new Random().nextInt(1000); System.out.println("没有可用资源，等待一小会儿: " + a + "，目前：" + F.incrementAndGet()); try &#123; Thread.sleep(a); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("成功拿到资源"); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; store.release(); System.out.println("释放资源，现在：" + S.incrementAndGet()); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>Semaphore</tag>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程学习(四)：理解ThreadPoolExecutor线程池]]></title>
    <url>%2Fblog%2F20190617%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%EF%BC%9A%E7%90%86%E8%A7%A3ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[前言：关于ThreadPoolExecutorThreadPoolExecutor即我们常说的线程池。《阿里巴巴Java手册》中对于线程池的使用规定如下： 3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。说明：使用线程池的好处是减少线程在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量的同类线程而导致消耗完内存或者“过度切换”的问题​ 使用线程池的好处使用线程池创建线程可以 避免在应用中频繁的创建和销毁线程 使用线程池创建线程可以复用CPU资源 提高线程的可管理性 使用线程池的风险线程饥饿死锁线程池为“死锁”这一概念带来了一种新的可能：线程饥饿死锁。在线程池中，如果一个任务将另一个任务提交到同一个Executor，那么通常会引发死锁。第二个线程停留在工作队列中等待第一个提交的任务执行完成，但是第一个任务又无法执行完成，因为它在等待第二个任务执行完成。如下代码所示。123456789101112131415161718public class MyThreadPoolDeadLock &#123; static ExecutorService singlePool = Executors.newSingleThreadExecutor(); static class MyTask implements Callable&lt;String&gt; &#123; String name; public MyTask(String name) &#123; this.name = name; &#125; @Override public String call() throws Exception &#123; Future&lt;String&gt; inner = singlePool.submit(new MyTask(&quot;inner&quot;)); return inner.get(); &#125; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; Future&lt;String&gt; result = singlePool.submit(new MyTask(&quot;outer&quot;)); System.out.println(result.get()); &#125;&#125; 在更大的线程池中，如果所有线程都由于等待其他仍处于工作队列的任务而阻塞，那么会发生同样的问题，这种情况被称为线程饥饿死锁。 内存溢出除了Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。如果线程池的大小设置的不合理就会有可能导致内存溢出的风险。还有就是Java预置线程池FixedThreadPool 和 SingleThreadPool中的阻塞队列使用的无界队列，最多可以保存2147483647个任务，如果代码编写不严谨就会堆积大量请求导致内存溢出。 线程泄漏各种线程池都会导致一种问题就是线程泄漏。当从线程池取出一个线程去执行任务时，如果任务抛出RuntimeException 或一个Error而未捕获异常时，那么线程只会退出而线程池的大小将永远减少一个，当这种情况发生多次时，线程池最终就会为空并且因为没有可用的线程来处理任务。 如果要自己实现线程池需要关注哪些点 首先要有一个存放线程的容器并设置容量 还需要一个存放用户提交的任务的容器，阻塞队列，有界还是无界 线程池创建的时候需要将指定数量的线程启动 用户提交任务的时候如果线程池没有空闲的线程如何创建线程并放入线程池 线程数量远大于用户提交的任务数量需要有一个回收线程的机制 线程全部在执行任务的时候存放的任务需要等待还是怎样或者再新加入任务时要提供一个饱和策略 ThreadPoolExecutor构造函数参数意义ThreadPoolExecutor提供了四种构造函数，总共有如下几种参数，意义为： int corePoolSize: 核心线程数的大小，在线程池创建的时候就会创建这么多线程待命，用户提交任务之后立即开始执行任务 int maximumPoolSize: 最大线程数的大小，即最多会创建这么多线程，当超过这个数目的时候可能会在执行完任务之后回收多于核心线程数的线程 long keepAliveTime: 线程最大存活时间，是相对于核心线程数来讲的。没有超过核心线程数的会一直存活的。超过的才有存活时间的限制 TimeUnit unit: 时间单位 BlockingQueue&lt;Runnable&gt; workQueue: 阻塞队列，用于存放用户提交的任务。系统预置的线程池的阻塞队列一般都是无界的LinkBlockingQueue，但是建议使用有界队列，对于非常大或者无界的线程池，可以使用同步移交队列控制避免排队，直接将任务从生产者移交到工作者线程。 ThreadFactory threadFactory: 线程工厂接口。只有一个newThread方法。便于用户根据业务需要实现自己的线程创建机制。 RejectedExecutionHandler handler: 饱和策略。默认四种，在下面讲解。 几种默认的饱和策略当有界队列被填满后，用户创建的任务无法再添加到线程池中保存，饱和策略开始发挥作用。如果某个任务被提交到已关闭的Executors时，饱和策略也会被执行。饱和策略的实现需要实现接口RejectedExecutionHandler。如上，在ThreadPoolExecutor类中有四个内部类实现了RejectedExecutionHandler接口。分别是:1234public static class AbortPolicy implements RejectedExecutionHandler &#123;...&#125;public static class DiscardPolicy implements RejectedExecutionHandler &#123;...&#125;public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;...&#125;public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;...&#125; AbortPolicy“中止”策略是默认的饱和策略，该策略将会抛出一个异常RejectedExecutionException，调用者可以捕获这个异常然后编写自己的业务代码。 DiscardPolicy“抛弃”策略会在新提交的任务无法保存在队列中等待执行时将其抛弃掉。 DiscardOldestPolicy同“抛弃”策略，这种策略会将即将执行的那个任务抛弃掉，即抛弃最老的任务然后尝试提交新的任务。如果工作队列使用的是优先队列，那么会导致优先级最高的任务被抛弃，慎用！ CallerRunsPolicy“调用者执行”策略即在队列满的时候由调用者去执行该任务。不会在线程池的某个线程中执行新的任务。 《阿里巴巴Java开发手册》中强调使用线程池的时候尽量使用ThreadPoolExecutor，目的在于让程序员更加明确线程池的工作机制，实际业务中不可能在任务满时将任务抛弃掉，所以实现自己的饱和策略是有必要的。 Java预置线程池及其使用场景如图是Executors类中的所有方法 Executors.newCachedThreadPool()12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 无限容量的线程池(最大为2147483647)，调用ThreadPoolExecutor构造传入的核心线程数为0。适合场景为创建执行时间短效快速的线程任务，线程在执行完成之后直接被回收。阻塞队列使用SynchronousQueue，这是一个不保存数据的队列，因为该线程池有任务提交就会创建线程去执行，所以不需要保存 Executors.newFixedThreadPool(nThreads)12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 创建固定数量的线程池。调用ThreadPoolExecutor的构造函数传入的核心线程数等于最大线程数。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。 Executors.newSingleThreadExecutor()：123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 每次都只有一个线程去执行任务，用户提交的任务都会排队阻塞在阻塞队列中等待上一个任务执行完之后执行下一个。适用场景为后面任务依赖前面任务的情况。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。使用这个线程池需要小心线程饥饿死锁 Executors.newWorkStealingPool()123456public static ExecutorService newWorkStealingPool() &#123; return new ForkJoinPool (Runtime.getRuntime().availableProcessors(), ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);&#125; 获取当前可用的线程数量进行创建作为并行级别，通过源码可以看出底层调用的是ForkJoinPool线程池，newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中。 Executors.newScheduledThreadPool()12345678910111213141516public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;↑↑↑↓↓↓...public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService &#123; ... public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); &#125; ...&#125; 设定延迟时间，定期执行。通过源码可以看出底层调用的是一个ScheduledThreadPoolExecutor，然后传入线程数量。同newWorkStealingPool一样也不是直接使用ThreadPoolExecutor进行扩展。可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。 优雅的关闭线程池shutdown设置线程池状态为关闭，但是只会关闭已经执行完成的线程，对于还未执行完成的线程，会等待执行完成再关闭。 当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。 shutdownNow立马关闭线程池，线程池里的任务不再执行。 如果我们调用shutdownNow方法时，线程处于从队列里读取任务而阻塞中，则会导致抛出InterruptedException异常]]></content>
      <categories>
        <category>Java基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>线程池</tag>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的几种非递归遍历]]></title>
    <url>%2Fblog%2F20190613%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的几种非递归遍历解法二叉树的递归遍历想必了解递归以及二叉树的同学都能够轻松写出正确答案，然而二叉树的非递归遍历确是很多人难以理解学会的，所以我在这里进行一下归纳总结，主要是复习巩固一下这方面的知识。 非递归先序遍历思路 首先将根节点入栈 然后循环判断栈不为空 则弹出栈顶元素 如果弹出元素的右子树不为空则入栈 如果弹出元素的左子树不为空则入栈 继续循环 解析：由于先序遍历为[根-左-右]，所以根节点应该先入栈，然后出栈的同时依次入栈右-左子树即可。 代码12345678910111213141516public static void frontPrintByLoop(TreeNode root) &#123; if (root != null) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); System.out.print(node.val + " | "); if (node.right != null) &#123; stack.push(node.right); &#125; if (node.left != null) &#123; stack.push(node.left); &#125; &#125; &#125;&#125; 非递归中序遍历思路 首先将根节点入栈 循环判断根节点是否有左子树，有则入栈继续循环，否则循环结束 然后循环判断栈不为空 则弹出栈顶元素 如果栈顶元素右子树不为空 则循环入栈右子树及其右子树的左子树 继续循环 解析：因为中序遍历为[左-根-又]，所以树的左子树应该先入栈，循环入栈左子树之后循环出栈，出栈的同时判断出栈元素是否有右子树，如果右子树不为空则对右子树执行相同的操作，即入栈右子树的左子树。 代码123456789101112131415161718192021public static void midPrintByLoop(TreeNode root) &#123; if (root != null) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; stack.push(node); while (node.left != null) &#123; stack.push(node.left); node = node.left; &#125; while (!stack.isEmpty()) &#123; node = stack.pop(); TreeNode n = node.right; while (n != null) &#123; stack.push(n); n = n.left; &#125; System.out.print(node.val + " | "); &#125; &#125;&#125; 非递归后序遍历思路 1 逆向思考先序遍历，因为后序遍历为[根-左-右]，我们可以以类似先序遍历的方式先将[右-左-根]的顺序找出来存入另一个栈，然后再依次出栈该栈元素即可 代码 11234567891011121314151617181920212223public static void lastPrintByOtherStack(TreeNode root) &#123; if (root != null) &#123; final Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); final Stack&lt;TreeNode&gt; stackReverse = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode node = stack.pop(); if (node != null) &#123; stackReverse.push(node); if (node.left != null) &#123; stack.push(node.left); &#125; if (node.right != null) &#123; stack.push(node.right); &#125; &#125; &#125; while (!stackReverse.isEmpty()) &#123; TreeNode node = stackReverse.pop(); System.out.print(node.val + " | "); &#125; &#125;&#125; 思路 2 只使用一个栈 先将根节点入栈 设置一个标识引用 h首先指向root 循环判断栈非空 在循环中判断栈顶元素node 如果node左子树不为空并且左右子树都不为h指向的元素 入栈左子树 否则再判断右子树是否为空以及右子树是否为h节点 入栈右子树 否则，弹出栈顶元素，并且将h指向该弹出的栈顶元素 代码 212345678910111213141516171819public static void lastPrintByOneStack(TreeNode root) &#123; if (null != root) &#123; TreeNode h = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(h); while (!stack.isEmpty()) &#123; TreeNode node = stack.peek(); if (node.left != null &amp;&amp; node.left != h &amp;&amp; node.right != h) &#123; stack.push(node.left); &#125; else if (null != node.right &amp;&amp; node.right != h) &#123; stack.push(node.right); &#125; else &#123; node = stack.pop(); System.out.print(node.val + " | "); h = node; &#125; &#125; &#125;&#125; 解析：使用一个栈进行后序遍历的时候需要使用一个h引用来标识上一个节点是否被遍历过，是的话就往上判断之后的树节点即可。 按层遍历二叉树思路以上前中后序遍历二叉树都是用到了栈这种数据结构，而按层遍历二叉树就非常简单了，只需要引入先入先出的队列，然后依次在出队的时候将出队元素的左右子树入队即可。 根节点入队 队列不为空则开始循环 如果队首元素左子树不为空，就入队 右子树不为空，也入队 队首元素出队输出 代码123456789101112131415161718public static void levelPrintOutTree(TreeNode root) &#123; if (null != root) &#123; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); TreeNode i = root; while (!queue.isEmpty()) &#123; if (i.left != null) &#123; queue.add(i.left); &#125; if (i.right != null) &#123; queue.add(i.right); &#125; System.out.print(i.val + " | "); queue.poll(); i = queue.peek(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度分析如何写出一个线程安全的单例]]></title>
    <url>%2Fblog%2F20190607%2F%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[什么是单例模式？单例模式是在Java编程中除了工厂模式之外最常用的创建型设计模式之一。单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。 单例模式在创建时的注意事项： 因为每个类只能创建一个实例，所以需要将其构造方法封闭起来不能被外部调用，即私有化； 需要提供一个获取类实例的公有方法，所有使用该类实例的人都通过这个方法拿到单例对象； 在多线程环境下需要注意线程安全问题，避免多个线程同时创建出多个不同的实例，违背了单例的原则。 创建单例模式的方法及其优缺点饿汉型123456789101112131415public class HungrySingleton &#123; private static final HungrySingleton INSTANCE = new HungrySingleton(); /** * 私有构造 */ private HungrySingleton() &#123;&#125; /** * 获取类在加载的时候就创建好的实例 */ public static HungrySingleton getInstance() &#123; return INSTANCE; &#125;&#125; 分析：饿汉型单例是最简单的单例创建方法，在类中维护一个该类私有不可变的实例，然后提供一个获取该实例的静态方法即可。 优点：代码编写简单，线程安全（使用类加载机制保证线程安全，classloader在加载类的时候使用synchronized同步） 缺点：无法实现懒加载，在使用较少的时候浪费资源，无法防止反射破坏以及反序列化破坏单例唯一性 普通懒汉型12345678910111213public class LazySingleton &#123; private static LazySingleton INSTANCE ; private LazySingleton()&#123;&#125; public static LazySingleton getInstance()&#123; if(null == INSTANCE)&#123; INSTANCE = new LazySingleton(); &#125; return INSTANCE; &#125;&#125; 分析：这种懒汉型单例也是一种比较简单的单例实现方式，与第一种不同在于这种实例是在调用获取实例的静态方法的时候才创建 优点：代码简单，可以实现懒加载 缺点：多线程环境下会有线程安全问题，多个线程同时走到第8行代码，判断实例未创建，则会创建出多个实例;无法防止反射破坏以及反序列化破坏 那么为了实现线程安全我们可以在方法上加上同步关键字，但是这种方式的缺点就是多线程环境调用该方法都会阻塞，导致性能存在不必要的浪费123456public synchronized static LazySingleton getInstance()&#123; if(null == INSTANCE)&#123; INSTANCE = new LazySingleton(); &#125; return INSTANCE;&#125; 双重检测锁实现懒加载单例上述懒汉型同步机制可以改进如下 1234567891011121314151617181920212223public class DoubleLockSingleton &#123; private DoubleLockSingleton() &#123; &#125; private static DoubleLockSingleton INSTANCE; public static DoubleLockSingleton getInstance() &#123; // 进入方法后先判断一次 大幅减少多线程环境同步阻塞问题 // 但是这种方式在多线程第一次调用创建实例的时候会出现线程安全问题 if (null == INSTANCE) &#123; synchronized (DoubleLockSingleton.class) &#123; if (null == INSTANCE) &#123; // 问题的根源所在 // 此处可能会出现指令重排序 // new对象并不是原子操作 INSTANCE = new DoubleLockSingleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 分析：双重检测锁机制在进入getInstance()方法的时候会判断实例是否被创建，如果被创建，那么直接返回，如果没有，进入同步代码块，创建实例。这个方法貌似没有问题，而且还大大减少线程进入同步代码块阻塞的情况（因为只有第一次判断对象还没有创建的时候才会有线程进入同步代码块）。但是这种方法仍然存在线程安全性问题。问题出在第17行：INSTANCE = new DoubleLockSingleton();由于JVM虚拟机内部会对代码进行优化，在使用new创建对象的时候并不是一个原子操作且会被虚拟机进行指令重排序。这个步骤会被分成三步：1、在堆上为对象分配空间；2、对象进行初始化；3、将引用指向该堆上的地址。 由于在虚拟机中，指令重排序优化导致第2步和第3步的执行顺序可以被打乱，那么在代码执行到第11行的时候发现，INSTANCE不为null，直接返回一个未初始化完成的对象，导致程序崩溃。注意：synchronzed关键字没有屏蔽指令重排序的功能，那么如何优化呢？答案是使用volatile关键字修饰实例变量引用，即private volatile static TripleLockSingleton INSTANCE;。volatile关键字才有屏蔽指令重排序的语义。 优点：多线程环境下大部分时间线程安全 缺点：有可能会出现线程安全问题；不能避免反射和反序列化破坏 优化：private volatile static TripleLockSingleton INSTANCE; 静态内部类单例123456789101112public class StaticInnerClassSingleton &#123; private StaticInnerClassSingleton() &#123; &#125; private static class SingletonHolder &#123; public static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton(); &#125; public static StaticInnerClassSingleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 分析：静态内部类实现单例也是借助了类加载的线程安全机制，并同时基于内部类的使用时再创建的懒加载机制实现线程安全的懒加载模式的单例 优点：线程安全，可以实现懒加载 缺点：无法防止被反射以及反序列化破坏单例的唯一性 枚举类单例12345678public enum EnumSingleton &#123; INSTANCE; public static EnumSingleton getInstance() &#123; return INSTANCE; &#125;&#125; 分析：Joshua Bloch大神说过：“单元素的枚举类型已经成为实现Singleton的最佳方法”。足以见证枚举类在创建单例中的优势。 优点：代码简单，线程安全，可以防止反射和反序列化破坏 缺点：暂无 CAS创建单例123456789101112131415161718192021222324public class CASSingleton &#123; private static final AtomicReference&lt;CASSingleton&gt; INSTANCE = new AtomicReference&lt;&gt;(); private CASSingleton() &#123;&#125; /** * 使用原子操作 实现获取唯一实例 * 理论上在大量竞争的环境中 原子操作自旋等待消耗大量性能 但是实际上当一个线程创建好实例之后其余线程不会出现死循环 * 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度 */ public static CASSingleton getInstance() &#123; for (; ; ) &#123; CASSingleton instance = INSTANCE.get(); if (null != instance) &#123; return instance; &#125; instance = new CASSingleton(); if (INSTANCE.compareAndSet(null, instance)) &#123; return instance; &#125; &#125; &#125;&#125; 分析：使用原子操作AtomicReference进行单例的创建，事实上目前相对于双重检查锁性能上差的也不是也别大 优点：线程安全，懒加载，相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度 缺点：代码编写相对复杂，不能防止被反射和反序列化破坏 防止反射和反序列化破坏单例的方式上述几个创建单例的方式中，除了使用枚举类创建单例，都会产生被反射和反序列化破坏的情况，避免该问题的方式如下，大家需要深究的话可以打开搜索引擎… 这里不再展开了~ 枚举类防止反射和反序列化破坏 参考文章：https://www.cnblogs.com/chiclee/p/9097772.html 防止反射破坏因为反射是通过class对象来调用类的构造方法创建对象的，我们只需要在构造方法中进行判断，如果实例已经存在，就抛出异常。12345678/** * 私有构造 */private Singleton() &#123; if(INSTANCE != null)&#123; throw new RuntimeException(); &#125;&#125; 防止反序列化破坏在反序列化的时候ObjectInputStream.readObject()中会去判断是否存在readResolve()方法，如果存在的话会调用该方法返回一个实例，所以在单例类中编写readResolve()方法返回INSTANCE即可。 1234// 在反序列化时，直接调用这个方法，返回指定的对象，无需再新建一个对象private Object readResolve() &#123; return INSTANCE;&#125;]]></content>
      <categories>
        <category>Java基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程学习(三)：CountDownLatch的实现原理及使用]]></title>
    <url>%2Fblog%2F20190602%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%89-%EF%BC%9ACountDownLatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是CountDownLatch？ 在本篇博客的封面，我放了一个截图，上面对于CountDownLatch的翻译是这样的：闭锁，倒计时门闩。其实顾名思义，CountDownLatch实际上就是一个计数器：计数-计数完成后做一些事。其实这个东西可以类比为一个水坝：当水还没有装满水库的时候水坝是关闭的，当水装满之后开闸放水，水库中的水”一起”涌出水库。 拥有同样功能的还有CyclicBarrier这个类，但是这个类相对较复杂，并且相对于CountDownLatch还可以重复使用，实际上前者一般被叫做线程计数器，后者被叫做循环屏障，还是有很大区别的。这个 在后面再进行源码学习。 CountDownLatch是如何实现的？ 同ReentrantLock类似，内部也是有一个实现了AbstractQueueSynchronizer的内部类。内部类做了父类的共享式的显示锁的方法实现，维护一个初始为N的状态state，每次有线程调用之后阻塞，然后state减1，直到减为0之后所有阻塞的线程重新开始执行。 首先是内部类Sync的实现 构造器接收一个int参数初始化state的值。tryAcquireShared()方法不会对state做改变，当state不为0的时候返回-1即失败，当state等于0其返回1，表示计数器已经计数完成，await()方法不再阻塞。tryReleaseShared()方法会使用原子操作当countDown()被调用的时候释放一个state的占用，即state-1。 1234567891011121314151617181920212223private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125; protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125;&#125; CountDownLatch的countDown方法 countDown方法主要作用就是使state-1 123public void countDown() &#123; sync.releaseShared(1);&#125; AQS中的releaseShared()方法的实现，如果释放成功执行doReleaseShared(); 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; CountDownLatch的await方法 await方法会等待当前state值是否是0，如果不是的话就一直阻塞。直到state为0。 12345678public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));&#125; AQS中的acquireSharedInterruptibly()方法实现如下，在AQS的实现中，判断当前线程是否中断，是的话抛出中断异常，否则判断当前线程是否继续需要阻塞，即调用tryAcquireShared()。是的话进入doAcquireSharedInterruptibly()方法，不断的判断int r = tryAcquireShared(arg);，state如果一直不等于0，r就一直是负数，就会继续进入循环。123456789101112131415161718192021222324252627282930313233343536public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125;/** * Acquires in shared interruptible mode. * @param arg the acquire argument */private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 其实以上代码的整体流程非常简单，即初始化CountDownLatch的state=N，每次调用countDown时state-1，减到0的时候停止阻塞，继续向下执行。 我可以用CountDownLatch来做什么事情？使用CountDownLatch模拟并发场景 可以使用CountDownLatch，创建多个线程并等待线程全部就绪之后唤醒所有线程。可以用这种方式测试代码的可用性，或者测试单例类等； 我在自己学习过程中也有写过类似的测试类 - github 使用CountDownLatch等待依赖线程执行 CountDownLatch用来等待其他依赖服务都启动好之后在进行自身线程的任务处理 总结 CountDownLatch是面试的时候多线程这块很容易被问到的点，实际上会考察这几个方面： 1、内部实现原理 —— 使用内部类继承AQS实现； 2、需要注意的方面 —— 计数器为0时，await后面的方法才会执行，否则一直阻塞，countDown方法尽量写在finally代码块中，避免出现异常导致死锁； 3、使用场景 —— 监控一些依赖服务启动完成之后执行代码，或者造“水坝”，即模拟大量并发场景等。]]></content>
      <categories>
        <category>Java基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>AQS</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写自己的SpringMVC框架]]></title>
    <url>%2Fblog%2F20190531%2F%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84SpringMVC%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Summer项目项目github地址 介绍 Summer项目是本人在学习Spring源码的时候按照SpringMVC的流程编写的一个简易的SpringMVC框架，主要完成以下功能： 读取配置文件进行包的扫描 对所有加入注解的bean进行装配 对加了注解的字段进行依赖自动注入 URL与相应方法的映射 请求的分发处理 项目通过实现以上流程完成SpringMVC框架工作的整体过程演示 以下是框架流程的详细步骤说明项目的结构Summer项目仅仅是一个单独的Servlet项目，没有引入Spring相关的任何依赖，仅仅使用了一些外部的工具类，我的pom.xml文件如下：12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.5.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.3.12.v20160915&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 项目使用jetty启动，所以我还配置了jetty插件12345678910111213141516171819&lt;build&gt; &lt;plugins&gt; &lt;!-- jetty插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.26&lt;/version&gt; &lt;configuration&gt; &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt; &lt;contextPath&gt;/Summer&lt;/contextPath&gt; &lt;connectors&gt; &lt;connector implementation="org.mortbay.jetty.nio.SelectChannelConnector"&gt; &lt;port&gt;4000&lt;/port&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 整体框架结构除了自定义的这几个注解之外其他的就和平常编写Controller以及Service的流程一样，我的核心代码主要在MyServlet中 MyServlet主要做了什么加载配置文件，首先读取web.xml中配置的配置文件把扫描到的所有类全链路径名保存在list中 以下是servlet的配置 1234567891011121314151617181920&lt;servlet&gt; &lt;!-- 声明Servlet对象 --&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;!-- 上面一句指定Servlet对象的名称 --&gt; &lt;servlet-class&gt;com.zhang.summer.servlet.MyServlet&lt;/servlet-class&gt; &lt;!-- 上面一句指定Servlet对象的完整位置，包含包名和类名 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config.properties&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 下面一句是在启动时加载servlet --&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;!-- 映射Servlet --&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;!--&lt;servlet-name&gt;与上面&lt;Servlet&gt;标签的&lt;servlet-name&gt;元素相对应，不可以随便起名 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!-- 上面一句话用于映射访问URL --&gt;&lt;/servlet-mapping&gt; 遍历所有类，使用反射创建对象class.forName创建对象，将所有我们声明了自己注解的类加入到一个Map中，即IOC-Map 遍历IOC-Map中的所有对象，进行依赖注入在这里我只判断是@MyController注解的类才进行依赖注入 处理URL和方法之间的映射将注解了@MyRequestMapping的类和方法路径拼接起来，对方法和拼接起来的url路径进行映射，并且对方法参数做特殊处理 请求分发在doGet或者doPost请求中通过映射好的url-method找到方法进行请求的分发处理]]></content>
      <categories>
        <category>SpringMVC框架</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程学习(二)：使用AQS编写可重入锁]]></title>
    <url>%2Fblog%2F20190525%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%EF%BC%9A%E4%BD%BF%E7%94%A8AQS%E7%BC%96%E5%86%99%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%2F</url>
    <content type="text"><![CDATA[AQS中文文档介绍 前言 上一章 我使用实现Lock接口的方式并结合Synchronized关键字实现了自己的可重入锁，学习并了解了可重入锁的原理机制。这一章我在学习了AQS之后结合AQS实现自己的显示可重入锁。 什么是AQS如上所述，Java8中文文档中描述的，AQS即AbstractQueuedSynchronizer。它提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状态。 子类必须定义改变此状态的受保护方法，以及根据该对象被获取或释放来定义该状态的含义。 给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。子类应定义为非公共内部助手类，用于实现其封闭类的同步属性。 AbstractQueuedSynchronizer类不实现任何同步接口。 相反，它定义了一些方法，如acquireInterruptibly(int) ，可以通过具体的锁和相关同步器来调用适当履行其公共方法。 其实AQS类是一个使用了模板方法模式的抽象框架类。它将核心实现封装在模板方法中，提供给程序员去实现具体的加锁和释放的机制，以便于实现一些特殊功能的锁，比如JDK提供的可重入锁和可重入读写锁等等。 如何使用AQSAQS在使用的时候主要需要重写以下方法 isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 使用AQS实现自己的可重入独占非公平锁的伪代码如下加锁步骤伪代码线程调用lock方法加锁，直接调用sync.acquire(1);，具体实现在tryAcquire 首先线程进入想要获取锁 拿到当前线程的引用 判断加锁状态，如果是未加锁状态 使用compareAndSetState自旋原子操作加锁 设置当前线程 返回true加锁成功 如果是加锁状态 判断是否是当前线程重入 如果是当前线程重入，state加1，并返回true加锁成功 最后如果都不是就返回false加锁失败 释放锁步骤伪代码线程调用unLock方法加锁，直接调用sync.release(1);，具体实现在tryRelease 首先线程进入方法想要释放锁 判断如果不是当前线程，就抛出异常 如果是当前线程，state就减1（arg一般为1），表示释放一次 当state释放到0时，设置拥有锁的线程为null，然后返回true 具体的代码实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * @Author zhangjiaheng * @Description 使用AQS重写一个可重入锁 **/public class MyReentrantLockByAQS implements Lock &#123; private Sync sync = new Sync(); // 内部类Sync ReentrantLock使用的内部抽象类 并派生两个子类实现两种(公平/非公平)锁 private class Sync extends AbstractQueuedSynchronizer &#123; @Override protected boolean tryAcquire(int arg) &#123; Thread t = Thread.currentThread(); // 如果第一个线程进来 可以拿到锁 则返回true // 如果第二个线程进来 如果不等于当前线程 返回false 否则更新当前线程值 int state = getState(); if (state == 0) &#123; while (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(t); return true; &#125; &#125; else if (t == getExclusiveOwnerThread()) &#123; // 当前线程再进来 setState(getState() + 1); return true; &#125; return false; &#125; @Override protected boolean tryRelease(int arg) &#123; // 锁的获取和释放时一一对应的 // 调用此方法的线程肯定是当前线程 if (Thread.currentThread() != getExclusiveOwnerThread()) &#123; throw new RuntimeException(); &#125; int c = getState() - arg; boolean flag = false; if (c == 0) &#123; setExclusiveOwnerThread(null); flag = true; &#125; setState(c); return flag; &#125; public Condition newCondition() &#123; return newCondition(); &#125; &#125; @Override public void lock() &#123; sync.acquire(1); &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; @Override public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(time)); &#125; @Override public void unlock() &#123; sync.release(1); &#125; @Override public Condition newCondition() &#123; return sync.newCondition(); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>AQS</tag>
        <tag>可重入锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程学习(一)：编写一个简易的可重入锁]]></title>
    <url>%2Fblog%2F20190517%2F%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[什么是可重入锁在Java多线程编程中，锁是用来控制代码操作的原子性的重要机制，即对某线程共享的数据进行操作的时候，保证该操作同一时间段只有一个线程操作，整个过程是原子操作，其他线程再操作的时候只能等待锁的释放(排他锁)。一般我们的锁都是声明在方法上或者代码块中，那么在实际编程中我们经常会出现一个类的实例方法调用另一个实例方法的情况，我们不希望这个时候同一个线程进入另一实例方法时还要再去等待锁的释放，可重入锁就是为了解决这个问题，即 线程可以进入任何一个它已经拥有的锁所同步着的代码块。 如何实现一个简单的可重入锁 首先加锁的时候需要记录当前是哪一个线程加锁，加锁之后加锁标志位标记锁已被占用 维护一个加锁计数器，线程每次加锁计数器都要加1，每释放一次计数器减1 当非占用锁的线程进来之后自旋等待锁的释放，如果锁还在被占用，就wait(); 所释放的时候只有当前获取锁的线程调用才有用，锁释放加锁计数器减1，当减到0的时候，加锁标志位置为false，然后唤醒其他等待的线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyLock implements Lock &#123; private boolean locked = false;// 当前锁是否已经被线程使用 private int lockCount;// 保存当前线程加锁的次数 private Thread thread;// 保存当前线程是哪一个 public synchronized void lock() &#123; try &#123; // 自旋等待 // 可重入：如果获取锁的不是当前线程并且当前已经有线程加锁，则等待 while (locked &amp;&amp; Thread.currentThread() != this.thread) &#123; System.out.println("我等会儿。。。"); wait(); &#125; // 如果没有线程使用锁或者获取锁的是当前线程 加锁计数器+1 然后thread指向获取锁的线程 this.thread = Thread.currentThread(); lockCount++; locked = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; &#125; /** * 释放锁的操作 */ public synchronized void unlock() &#123; try &#123; // 如果不是当前线程 不需要做任何操作 if(this.thread == Thread.currentThread())&#123; // 锁计数器减1 如果当前线程获取锁个数释放完成 lockCount--; if(lockCount == 0 )&#123; // 释放完成 加锁标志置为false 再唤醒等待锁的线程 locked = false; notifyAll(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; &#125;&#125; 在Java中常用的可重入锁 synchronized 关键字加锁 java.util.concurrent.locks.ReentrantLock java.util.concurrent.locks.ReentrantReadWriteLock 上述ReentrantLock内部实际上还是使用AQS，关于AQS，后面还要进行学习与整理]]></content>
      <categories>
        <category>Java基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>可重入锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长子串]]></title>
    <url>%2Fblog%2F20190512%2F%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[算法题解：无重复字符的最长子串leetcode地址： leetcode 题目： 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 12345示例 1:输入: "abcabcbb"输出: 3解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 解法1：暴力求解 思路：遍历字符串，以每一个字符作为子串的起始字符，向后查找直到遇到和该字符相同的字符，记录长度，依次执行直到找到最长长度。 题解如下： 12345678910111213141516171819202122 public int maxIndexStrLength(String s) &#123; int maxLength = 0; for (int index = 0; index &lt; s.length(); index++) &#123; int length = 1; int i = index + 1; for (; ; ) &#123; if (i &gt;= s.length()) &#123; break; &#125; String ts = s.substring(index, i); char c = s.charAt(i); if (ts.contains(c + "")) &#123; break; &#125; length++; i++; &#125; maxLength = maxLength &gt; length ? maxLength : length; &#125; return maxLength;&#125; 解法2：滑动窗口法 思路：在使用暴力解法时我们会发现实际上对于无重复子串来讲，我们产生了一些冗余的判断操作。例如对于串sdabcabcbb，判断了子串sdabc之后，当后面再出现字符a，那么重复字符之前的串直接舍弃就好。即直接从bca…开始判断即可。这样可以减少大量的不必要的判断与计算操作。 题解如下： 123456789101112131415161718public int maxIndexStrLength(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int start = 0, max = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); //如果当前元素与滑动窗口中的元素重复： if (map.containsKey(c) &amp;&amp; map.get(c) &gt;= start) &#123; max = Math.max(max, i - start); start = map.get(c) + 1; //如果当前元素与滑动窗口中的元素不重复，但已经遍历到了最后一个字符： &#125; else if (i == s.length() - 1) &#123; max = Math.max(max, i - start + 1); &#125; map.put(c, i); &#125; return max;&#125; 总结 滑动窗口法的思路可以用来解决很多字符串相关的问题]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化和transient关键字的理解与学习]]></title>
    <url>%2Fblog%2F20190511%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8Ctransient%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Java序列化 在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。 Java中如何进行序列化与反序列化 在Java中，对象一般是无法进行序列化与反序列化的。而使得对象能够被序列化的方式也很简单，即实现接口 Serializable 。如下代码即将对象序列化以及反序列化的过程。 123456789101112131415161718public class TestSerializable implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer age; private String name; TestSerializable() &#123; age = 20; name = "aachuanpu"; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; TestSerializable test = new TestSerializable(); File file = new File("e:/test.txt"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(test); ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); TestSerializable newTest = (TestSerializable) in.readObject(); System.out.println(newTest.name); &#125;&#125; serialVersionUID的作用 serialVersionUID作为实现序列化接口的一个非必须非必须声明的静态常量经常不被开发者所重视，忘记声明。其实serialVersionUID的作用是为了保证序列化之前和之后的对象是同一对象。我们知道JVM判断对象是否相同是根据对象的类路径全限定名确定的，而虚拟机决定一个对象是否允许序列化和反序列化成这个类还取决于其serialVersionUID是否一致。不一致的话会导致java.io.InvalidClassException的异常，也可以不指定serialVersionUID，如果不指定的话java会根据class计算serialVersionUID。 对于两个相同的类及拥有相同的serialVersionUID，如果两个类字段不一致也会序列化和反序列化成功。这时Java会在反序列化的时候忽略掉不一致的字段。 静态变量的序列化 在序列化的时候，静态变量能够被序列化成功吗？ 12345678910111213141516171819202122public class TestSerializable implements Serializable &#123; private static final long serialVersionUID = 1L; public static String staticName; private Integer age; private String name; TestSerializable() &#123; age = 20; name = "aachuanpu"; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; TestSerializable test = new TestSerializable(); TestSerializable.staticName = "name11111"; File file = new File("e:/test.txt"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(test); TestSerializable.staticName = "name222"; ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); TestSerializable newTest = (TestSerializable) in.readObject(); System.out.println(newTest.name); System.out.println(TestSerializable.staticName); &#125;&#125; 以上代码会输出什么？ 1234aachuanpuname222Process finished with exit code 0 如上所见：将对象序列化之后，修改静态变量的值，再将对象反序列化，输出的静态变量的值是修改之后的。即序列化保存的是对象的状态，静态变量属于类，因此序列化并不保存静态变量。 transient关键字与自定义序列化 对象的序列化是将对象中的数据写入本地文件或者用于网络传输的过程，但是很多时候会有一些数据无需进行序列化保存起来或者传输出去。我们可以使用transient关键字修饰成员变量。那么在Java序列化的时候就不会使用Java本身的序列化方式对其进行序列化。但是我们依然可以自定义自己的序列化行为对其进行序列化！ 自定义序列化： 定义自己的writeObject和readObject方法 对于使用transient修饰的成员变量，可以编写writeObject和readObject方法实现对于该成员变量(不仅仅只是针对该成员变量)的自定义序列化。在编写writeObject和readObject方法的时候需要注意的地方在于：这俩方法没有在Object中定义，也没有在Serializable接口中声明，JVM是如何调用到这俩方法的呢？答案是通过反射，去根据方法名和参数寻找到相应的方法，找到之后会被ObjectOutputStream调用，没有这俩方法就调用默认的序列化呗。还有就是因为ObjectOutputStream使用getPrivateMethod，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。 通过这种方法，我们实现自己的序列化与反序列化可以实现很多场景下的需求。比如网络传输的时候对于特殊字段进行加密等等。 如下，你会发现我在这俩方法中调用了defaultWriteObject()和defaultReadObject()用于处理未被transient修饰的成员变量。 1234567891011121314151617181920212223242526272829303132333435public class TestSerializable implements Serializable &#123; private static final long serialVersionUID = 1L; public static String staticName; private Integer age; private transient String name; TestSerializable() &#123; age = 20; name = "aachuanpu"; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; TestSerializable test = new TestSerializable(); TestSerializable.staticName = "name11111"; File file = new File("e:/test.txt"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(test); TestSerializable.staticName = "name222"; ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); TestSerializable newTest = (TestSerializable) in.readObject(); System.out.println(newTest.name); System.out.println(TestSerializable.staticName); &#125; private void writeObject(ObjectOutputStream oos) throws IOException &#123; oos.defaultWriteObject(); name = "自定义名称"; oos.writeObject(name); System.out.println("调用writeObject"); &#125; private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ois.defaultReadObject(); String name = (String) ois.readObject(); this.name = name; System.out.println("读出的name=" + name); System.out.println("调用readObject"); &#125;&#125; 输出如下： 1234567调用writeObject读出的name=自定义名称调用readObject自定义名称name222Process finished with exit code 0 父类的序列化 一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取 父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都 是默认声明的值。 常问：ArrayList中数组使用transient修饰为何还能被序列化 ArrayList源码： 1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。但是ArrayList又是可序行化的类，elementData是ArrayList具体存放元素的成员，用transient来修饰elementData，需要实现自己的序列化方式去处理。即对于数组中多余的空间不去进行序列化。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 其余补充来自文章 ← 点击链接查看参考博客 1.Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值; 2.Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。Serializable是内建支持的也就是直接implement即可，但Externalizable的实现类必须提供readExternal和writeExternal实现。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。 3.正如Effectvie Java中提到的，序列化就如同另外一个构造函数，只不过是有由stream进行创建的。如果字段有一些条件限制的，特别是非可变的类定义了可变的字段会反序列化可能会有问题。可以在readObject方法中添加条件限制，也可以在readResolve中做。参考56条“保护性的编写readObject”和“提供一个readResolve方法”。 4.当有非常复杂的对象需要提供deep clone时，可以考虑将其声明为可序列化，不过缺点也显而易见，性能开销。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>序列化</tag>
        <tag>transient关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用[幕布]创建Java知识体系思维导图]]></title>
    <url>%2Fblog%2F20190507%2F%E4%BD%BF%E7%94%A8-%E5%B9%95%E5%B8%83-%E5%88%9B%E5%BB%BAJava%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[昨天在V2EX上逛的时候突然发现有人推荐一个很不错的东西——幕布。我本身就是一个对一些名称很敏感的人，看到这个名字就很想知道这到底是个什么东西，没想到竟偶然发现这么一个好东西。 幕布是一个制作笔记与记录事件的文本编辑工具（这样说要把幕布开发者气死了哈哈）。编辑视图如下：一键转换成思维导图就是本文最上面的那个图片。 其实我个人是比较喜欢幕布的一键转换思维导图的功能，以及它的导出.mm文件的功能，而且可以自动同步云端。这样就可以随时随地无论是在电脑还是手机上都可以打开来编辑以及查看了。 这里是我自己编写的Java知识体系，还没有写的很完整。希望自己能够坚持不断更新知识点，总结与巩固自己的技术水平！]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树与完全二叉树]]></title>
    <url>%2Fblog%2F20190504%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[什么是二叉树？在数据结构中，对于树，每一个分支，称之为一个度。那么，度最大为2的树我们称之为二叉树。通常子树我们会称之为左子树和右子树。二叉树通常用于实现二叉查找树和二叉堆。那么在Java中如何定义一个二叉树节点？ 首先，每一个节点需要有一个值域。其次，其还应该持有两个树节点的引用，即指向自己的左子树和自己的右子树。 具体代码如下：12345678910111213141516171819202122public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123; this.val = 0; this.left = null; this.right = null; &#125; TreeNode(int val) &#123; this.val = val; this.left = null; this.right = null; &#125; @Override public String toString() &#123; return "(" + val + ")[left:" + left + ",right:" + right + "]"; &#125;&#125; 如何创建二叉树二叉树的节点的数据结构已经用Java代码表示出来了，那么如何用这些节点来构造出一个完整的二叉树呢？请看下图二叉树的结构： 如上图，对于一个二叉树，需要有一个根节点。每个节点最多有两课子树，分别区分左子树还是右子树。即就算有一个子树，还是需要区分是左子树还是右子树。创建二叉树我们只需要将每一个树节点按照这样的规则连接起来即可。 创建二叉搜索树 概念：二叉搜索树，又叫二叉查找树。他是一棵特殊的二叉树，对于二叉搜索树中的每一个节点，它的左子树都不大于父节点，右子树都不小于父节点。空树是特殊的二叉搜索树。 创建：本例根据一个已有的数组进行二叉树的创建，基本的思路就是遍历数组，每个元素创建一个树节点，然后继续根据节点值得大小向下遍历判断，最后将值域小的放在节点的左子树，将值大的放在节点的右子树即可。 12345678910111213141516171819202122232425public static TreeNode createSearchTree(int[] a) &#123; if (a.length &gt; 0) &#123; TreeNode root = new TreeNode(a[0]); for (int i = 1; i &lt; a.length; i++) &#123; TreeNode c = root; TreeNode p = c; TreeNode q = new TreeNode(a[i]); while (c != null) &#123; p = c; if (a[i] &lt;= c.val) &#123; c = c.left; &#125; else &#123; c = c.right; &#125; &#125; if (q.val &lt; p.val) &#123; p.left = q; &#125; else &#123; p.right = q; &#125; &#125; return root; &#125; return null;&#125; 特点：二叉搜索树在应用于经常查找元素的场景效率会比较快，因为它的数据结构类似于二分查找，查找元素时根据其特性向下搜索即可。 创建完全二叉树 概念：首先介绍一下满二叉树：即树中的所有节点除了叶节点都有左子树和右子树，叶节点的左右子树都为空，这样的树称之为满二叉树。而对于一棵完全二叉树，只有树的最后一层连续缺失右边节点。满二叉树一定是完全二叉树，反之则不一定成立。如图分别是一棵满二叉树和一棵完全二叉树： 创建： 完全二叉树的创建需要按层去创建。这边我们借助队列的特点，将二叉树的节点连接起来，构造成完全二叉树 123456789101112131415161718192021public static TreeNode createWholeTree(int[] a) &#123; if (a.length &gt; 0) &#123; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); TreeNode root = new TreeNode(a[0]); queue.add(root); int index = 0; for (int i = 1; i &lt; a.length; i++) &#123; TreeNode curn = queue.get(index); TreeNode ti = new TreeNode(a[i]); queue.add(ti); if (curn.left == null) &#123; curn.left = ti; &#125; else if (curn.right == null) &#123; curn.right = ti; index++; &#125; &#125; return root; &#125; return null; &#125; 特点：对于一个h层的完全二叉树，前h-1层是满的，第h层连续缺失右边节点。所以叶子结点只能出现在最下层和次下层，最下层的叶子结点集中在树的左部，倒数第二层若存在叶子结点，一定在右部连续位置，如果结点度为1，则该结点只有左孩子，即没有右子树，同样结点数目的二叉树，完全二叉树深度最小。 二叉树的遍历 前中后序递归遍历： 1234567891011121314151617181920212223242526272829303132/** * 递归先序遍历二叉树 左-根-右 */public static void frontPrintOutTree(TreeNode root) &#123; if (null != root) &#123; System.out.print(root.val); frontPrintOutTree(root.left); frontPrintOutTree(root.right); &#125;&#125;/** * 递归中序遍历二叉树 左-根-右 */public static void midPrintOutTree(TreeNode root) &#123; if (null != root) &#123; midPrintOutTree(root.left); System.out.print(root.val); midPrintOutTree(root.right); &#125;&#125;/** * 递归先序遍历二叉树 左-根-右 */public static void lastPrintOutTree(TreeNode root) &#123; if (null != root) &#123; lastPrintOutTree(root.left); lastPrintOutTree(root.right); System.out.print(root.val); &#125;&#125; 按层遍历： 123456789101112131415161718192021/** * 按层遍历二叉树 */public static void levelPrintOutTree(TreeNode root) &#123; if (null != root) &#123; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); TreeNode i = root; while (!queue.isEmpty()) &#123; if (i.left != null) &#123; queue.add(i.left); &#125; if (i.right != null) &#123; queue.add(i.right); &#125; System.out.print(i.val); queue.poll(); i = queue.peek(); &#125; &#125;&#125; 以上代码的github地址：GITHUB地址]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Springboot服务启动之后执行一些代码(三种方式)]]></title>
    <url>%2Fblog%2F20190419%2F%E5%A6%82%E4%BD%95%E5%9C%A8springboot%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81(%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F)%2F</url>
    <content type="text"><![CDATA[前言 通常的我们的项目开发中，经常会遇到那种在服务一启动就需要自动执行一些业务代码的情况。比如将数据库中的配置信息或者数据字典之类的缓存到redis，或者在服务启动的时候将一些配置化的定时任务开起来。关于spring mvc或者springboot如何在项目启动的时候就执行一些代码，方法其实有很多，我这边介绍一下我使用过的三种。 1、@PostConstruct 注解从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，@PostConstruct和@PreDestroy，这两个注解被用来修饰一个非静态的void（）方法。@PostConstruct会在所在类的构造函数执行之后执行，在init()方法执行之前执行。(@PreDestroy注解的方法会在这个类的destory()方法执行之后执行。) 使用示例：在Spring容器加载之后，我需要启动定时任务去做任务的处理（我的定时任务采用的是读取数据库配置的方式）。在这里我使用@PostConstruct 指定了需要启动的方法。12345678910111213141516171819202122232425262728293031323334@Component // 注意 这里必须有public class StartAllJobInit &#123; protected Logger logger = LoggerFactory.getLogger(getClass().getName()); @Autowired JobInfoService jobInfoService; @Autowired JobTaskUtil jobTaskUtil; @PostConstruct // 构造函数之后执行 public void init()&#123; System.out.println("容器启动后执行"); startJob(); &#125; public void startJob() &#123; List&lt;JobInfoBO&gt; list = jobInfoService.findList(); for (JobInfoBO jobinfo :list) &#123; try &#123; if("0".equals(jobinfo.getStartWithrun()))&#123; logger.info("任务&#123;&#125;未设置自动启动。", jobinfo.getJobName()); jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP); &#125;else&#123; logger.info("任务&#123;&#125;设置了自动启动。", jobinfo.getJobName()); jobTaskUtil.addOrUpdateJob(jobinfo); jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING); &#125; &#125; catch (SchedulerException e) &#123; logger.error("执行定时任务出错，任务名称 &#123;&#125; ", jobinfo.getJobName()); &#125; &#125; &#125;&#125; 2、实现CommandLineRunner接口并重写run()方法CommandLineRunner接口文档描述如下：12345678910111213141516171819202122/** * Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within * a &#123;@link SpringApplication&#125;. Multiple &#123;@link CommandLineRunner&#125; beans can be defined * within the same application context and can be ordered using the &#123;@link Ordered&#125; * interface or &#123;@link Order @Order&#125; annotation. * &lt;p&gt; * If you need access to &#123;@link ApplicationArguments&#125; instead of the raw String array * consider using &#123;@link ApplicationRunner&#125;. * * @author Dave Syer * @see ApplicationRunner */public interface CommandLineRunner &#123; /** * Callback used to run the bean. * @param args incoming main method arguments * @throws Exception on error */ void run(String... args) throws Exception;&#125; 如上所说：接口被用作加入Spring容器中时执行run(String… args)方法，通过命令行传递参数。SpringBoot在项目启动后会遍历所有实现CommandLineRunner的实体类并执行run方法，多个实现类可以并存并且根据order注解排序顺序执行。这边还有个ApplicationRunner接口，但是接收参数是使用的ApplicationArguments。这边不再赘述。 同样是启动时执行定时任务，使用这种方式我的写法如下：123456789101112131415161718192021222324252627282930@Component // 注意 这里必须有//@Order(2) 如果有多个类需要启动后执行 order注解中的值为启动的顺序public class StartAllJobInit implements CommandLineRunner &#123; protected Logger logger = LoggerFactory.getLogger(getClass().getName()); @Autowired JobInfoService jobInfoService; @Autowired JobTaskUtil jobTaskUtil; @Override public void run(String... args) &#123; List&lt;JobInfoBO&gt; list = jobInfoService.findList(); for (JobInfoBO jobinfo :list) &#123; try &#123; if("0".equals(jobinfo.getStartWithrun()))&#123; logger.info("任务&#123;&#125;未设置自动启动。", jobinfo.getJobName()); jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP); &#125;else&#123; logger.info("任务&#123;&#125;设置了自动启动。", jobinfo.getJobName()); jobTaskUtil.addOrUpdateJob(jobinfo); jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING); &#125; &#125; catch (SchedulerException e) &#123; logger.error("执行定时任务出错，任务名称 &#123;&#125; ", jobinfo.getJobName()); &#125; &#125; &#125;&#125; 3、使用ContextRefreshedEvent事件(上下文件刷新事件) ContextRefreshedEvent 官方在接口上的doc说明Event raised when an {@code ApplicationContext} gets initialized or refreshed. ContextRefreshedEvent是Spring的ApplicationContextEvent一个实现，ContextRefreshedEvent 事件会在Spring容器初始化完成后以及刷新时触发。 在这里我需要在springboot程序启动之后加载配置信息和字典信息到Redis缓存中去，我可以这样写： 12345678910111213141516171819202122232425@Component // 注意 这个也是必须有的注解 三种都需要 使spring扫描到这个类并交给它管理public class InitRedisCache implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; static final Logger logger = LoggerFactory .getLogger(InitRedisCache.class); @Autowired private SysConfigService sysConfigService; @Autowired private SysDictService sysDictService; @Override public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) &#123; logger.info("-------加载配置信息 start-------"); sysConfigService.loadConfigIntoRedis(); logger.info("-------加载配置信息 end-------"); logger.info("-------加载字典信息 start-------"); sysDictService.loadDictIntoRedis(); logger.info("-------加载字典信息 end-------"); &#125;&#125;```java**注意**：这种方式在springmvc-spring的项目中使用的时候会出现执行两次的情况。这种是因为在加载spring和springmvc的时候会创建两个容器，都会触发这个事件的执行。这时候只需要在`onApplicationEvent`方法中判断是否有父容器即可。 @Override public void onApplicationEvent(ContextRefreshedEvent event) { if(event.getApplicationContext().getParent() == null){//root application context 没有parent，他就是老大. //需要执行的逻辑代码，当spring容器初始化完成后就会执行该方法。 } }` 总结以上，就是我在实际开发中常用的三种，在项目启动时执行代码的方式，开发者可以根据不同的使用情况选择合适的方法去执行自己的业务逻辑。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存分配与垃圾回收的复习整理]]></title>
    <url>%2Fblog%2F20190414%2FJava%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[摘要众所周知Java作为一个“一次编译，到处运行”的编译型语言，JVM虚拟机当之无愧的是Java语言世界的先锋将军。作为一个Java程序员，JVM虚拟机其相关知识是我们必须要了解以及深入掌握的重点。在本篇博客我将总结一下JVM虚拟机的内存结构、对象内存分配以及垃圾回收算法。这也是经常找工作求职必问的点。 Java内存分配与垃圾回收的复习整理Java内存区域划分Java虚拟机在执行Java程序的过程中会将它所管理的内存划分为若干个不同的区域。每个区域各司其职，其创建与销毁数据的规则也都各不相同。根据《Java虚拟机规范（Java SE 7版）》的规定，主要分为如下图几个区域。 程序计数器：当前线程执行字节码的行号指示器。[线程私有] 虚拟机栈：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。平常我们所说的Java虚拟机划分为堆和栈中的“栈”中的一部分就是虚拟机栈。其中局部变量表存放着编译期可知的所有基本数据类型、对象引用等。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法所需要的帧的大小是已经确定了的。[线程私有] 本地方法栈：与虚拟机栈发挥的作用相似，只不过这个区域执行的是native方法，即由c/c++或者其他语言编写的方法。[线程私有] Java堆：用来存放对象实例，即我们最熟悉的一块区域。Java堆是垃圾收集器管理的主要区域，所以有时也叫“GC堆”。[线程共享] 方法区：用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 [线程共享] 运行时常量池：这是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。[线程共享] 常用的垃圾回收算法 在Java代码中，我们程序员通常只关注广义上的“栈”和“堆”这两种区域。上述划分的Java内存区域告诉我们，栈是朝生夕死的一块区域，当线程进入的时候，栈空间被分配，线程结束之后，栈的内存空间即被回收用来去做其他的任务，栈中的栈帧随着线程的进入与退出有条不紊的执行着入栈和出栈的操作，每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的。而堆却不同，我们只有在程序运行期间才会知道创建那些对象，这部分内存分配和回收都是动态的。都由虚拟机的垃圾回收器进行“已死”对象的回收。 如何判断对象已死 引用计数法：给对象添加一个引用计数器，每当有引用指向它时计数器加1，引用失效后计数器减1。垃圾回收器回收对象计数器为0的对象昂即可。但是当出现对象之间循环引用，而对象却无实际作用的时候，这种方式就会出现内存泄漏。 可达性分析：通过一系列的称为“GC ROOTS”的对象作为起点，向下搜索，搜索走过的路径都称为引用链，当一个对象到“GC ROOTS”没有引用链的时候，证明这个对象不可达。此时会被判定为可回收对象。（此时并非一定死亡，在此之后还会进行两次标记处理，与finalize()方法有关，此处不再整理。注意一个知识点：任何对象的finalize()方法只会被系统调用一次，并且不建议使用） 知道哪些对象是“垃圾”，接下来就是回收操作了 标记-清除法 首先标记出所有需要回收的对象，然后统一回收。是最基础的回收算法。 不足之处：1、效率低下，标记和清除的效率都不高；2、产生大量内存碎片，使得之后程序要分配大对象却没有空间，不得不除法GC。 复制 首先将内存区域划分为两等分，每次只使用其中一块内存，当用完之后，将活着的对象复制到另一块内存，然后整个回收上一半。这种按顺序分配内存，实现简单，运行高效。 不足之处：直接将内存缩小了一半，产生大量的空间浪费。然而很多垃圾收集器都是用这种方式，但是有过改进。因为堆中的对象90%都是朝生夕死的，只有10%是会长期存活下来的对象，那么对于这90%的对象，完全可以使用这种高效的复制收集算法。首先将内存区域划分三份，10%的对象存在其中较大的一分中，另外的两份等份分配，处理这90%的“死的快”的对象。这就是Form,To,Eden区域。即Eden:From:To=8:1:1 标记-整理法 标记整理的方式实际上也是先将可回收对象标记起来，然后对于这些存活着的对象，并不直接回收，而是先向一端移动，最后直接回收端边界之外的对象。这种做法解决了处理存活率较高的大对象的回收，适合老年代堆对象回收。 分代收集 当前商业虚拟机基本上都会采取分代收集算法。即根据对象存活周期的不同将内存划分为不同区域，分别使用不同的垃圾回收算法进行垃圾回收。比如在新生代使用复制算法，因为新生代大量对象都是朝生夕死需要很高的回收效率，而对于老年代则使用标记清除或者标记整理。 Java虚拟机的对象内存分配Java对象内存分配实际上就指的是将对象分配在堆上的过程。不过实际上堆还被虚拟机划分成了不同的区域，并且每个区域的分配策略都不相同。上面我们说到虚拟机根据对象存活周期的不同将对内存分为几种不同的区域，即新生代Eden,From Survivor,To Survivor和老年代。那么这几种区域是如何进行内存分配的呢？ 对象优先再Eden区域分配：大多数情况下，对象会在Eden区域分配，在Eden区域空间不够的情况下，会先进行一次MinorGC（MinorGC是新生代垃圾回收，Full GC是老年代垃圾回收）。 大对象直接进入老年代：大对象即指的是需要大量连续空间的对象，例如很长的字符串以及数组。虚拟机提供参数-XX:PretenureSizeThreadhold参数设置大于多少算是大对象，避免在新生代几个区域中发生大量的内存复制。 长期存活的对象直接进入老年代：每经过一次MinorGC对象的年龄都会加1。当年龄加到-XX:MaxTenuringThreadhold（默认15）指定的值时，判断为长期存活，对象会被移动到老年代。 动态对象年龄判断：为了适应多变的内存情况，一般虚拟机都会使用动态对象年龄判定。如果Survivor中相同年龄的所有对象大小总和大于该空间的一半，该年龄以上的对象就会直接进入老年代，无需等到年龄大于-XX:MaxTenuringThreadhold（默认15）指定的值。 空间分配担保：在发生MinorGC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，是的话MinorGC可以被认定是安全的。如果不成立，虚拟机会先检查HandlerPromotionFailure参数是否允许担保失败，不允许的话会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于的话或者HandlerPromotionFailure设置不允许冒险，那么就会执行一次FullGC。 总结 内存回收与垃圾收集很多时候都是影响系统性能和并发能力的主要因素之一，虚拟机提供了多种垃圾收集器以及大量的调节参数，方便开发人员根据实际应用调整以便程序可以获得最高的性能。这些垃圾收集器和虚拟机参数没有固定的标准的组合，需要开发人员对于内存分配与垃圾回收相当了解，才得以根据实际情况实际配置。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>内存分配</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo服务降级]]></title>
    <url>%2Fblog%2F20190412%2Fdubbo%20%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;在分布式服务或者一些微服务当中，经常性的出现各个服务之间相互调用，业务处理流程耦合起来的情况。比如当用户在平台下单时，我们需要给用户生成订单之后发站内信或者短信通知用户订单生成成功。那么很多时候代码的编写就会是：&nbsp;&nbsp;&nbsp;&nbsp;调用订单模块生成订单-&gt;调用短信模块通知用户-&gt;调用其他模块处理更多业务逻辑&nbsp;&nbsp;&nbsp;&nbsp;可是当我们无足轻重的一个短信通知模块挂掉或者报错的时候，我们当然不希望整个业务逻辑就这样停止。那么这个时候，就需要引入服务降级的机制，为整个业务逻辑进行解耦合。 &nbsp;&nbsp;&nbsp;&nbsp;使用服务降级可以防止我们服务中间不影响整体流程的模块出错导致整个业务处理雪崩。将核心业务保证完整性，非核心业务弱化。本文使用 springboot+dubbo 进行服务降级的演示 dubbo自带的mock进行服务降级，也叫本地伪装dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。具体使用 dubbo mock的使用非常简单，即在我们平时进行开发时，编写impl实现类实现接口作为服务提供者的同时，编写mock实现类并覆盖所有接口中的方法。官方更详细的文档戳这里 比如有接口：123456public interface SysOperateFacade &#123; /** * 根据用户名查询操作员信息 */ SysOperateVO findByUserName(String username);&#125; 在实现类进行相应操作12345678910@Service //这里Service是dubbo的注解public class SysOperateFacadeImpl implements SysOperateFacade &#123; @Resource SysOperateService sysOperateService; @Override public SysOperateVO findByUserName(String username) &#123; return sysOperateService.findByUserName(username); &#125;&#125; 编写mock实现类覆盖findByUserName方法 注意 mock的类名必须是 接口名+Mock1234567public class SysOperateFacadeMock implements SysOperateFacade &#123; @Override public SysOperateVO findByUserName(String username) &#123; System.out.println(&quot;调用到dubbo mock 的findByUserName方法。。。。。。。&quot;); return new SysOperateVO(); &#125;&#125; 最后，在调用的地方加上注解@Reference(mock = &quot;true&quot;)进行使用即可12345678910111213@Controller@RequestMapping(&quot;/sys/sysOperate&quot;)public class SysOperateController extends BaseController &#123; @Reference(mock = &quot;true&quot;) private SysOperateFacade sysOperateFacade; @ResponseBody @RequestMapping(&quot;/test&quot;) public SysOperateVO test(String username)&#123; return sysOperateFacade.findByUserName(username); &#125;&#125; 使用 spring cloud Hystrix进行服务降级在服务调用方模块加入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 如果出现以下报错也许是由于Springboot与这个依赖版本不对应，修改下版本1java.lang.NoSuchMethodError: org.springframework.boot.builder.SpringApplicationBuilder.&lt;init&gt;([Ljava/lang/Class;)V at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:170) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:104) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:70) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:122) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:74) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:325) at org.springframework.boot.SpringApplication.run(SpringApplication.java:296) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) at com.gjj.p2p.BasicsApplication.main(BasicsApplication.java:18) 具体使用hystrix进行服务降级hystrix的使用也是非常简单，只需要在服务调用方即消费者方springboot启动类上加上注解 @EnableHystrix 然后使用如下方式，指定服务出错或者熔断后调用的方法12345678910@ResponseBody@RequestMapping(&quot;/test&quot;)@HystrixCommand(fallbackMethod = &quot;fallback&quot;)public String test(String message)&#123; return sysMenuFacade.test(message);&#125;public String fallback(String message)&#123; return &quot;sysMenuFacade挂了 调用到fallback &quot; + message;&#125; 这样当出现问题之后就会调用得到fallback方法还可以在这个controller上直接指定注解@DefaultProperties(defaultFallback = &quot;fallback&quot;)以免编写大量重复代码 总结服务降级与熔断机制在我们实际生产以及日常开发中都是是非常有必要使用的，例如我们在日常开发中，需要调用别人的模块，但是又不是非常依赖这个模块的数据，我们可以使用以上的方式构造“假的”调用结果。这样就不用为了调试某行代码去启动大量的服务了。 最后针对dubbo的mock机制以及hystrix，我觉得hystrix更像是try{}catch{}。]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>dubbo</tag>
        <tag>分布式服务降级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务传播机制和事务隔离级别]]></title>
    <url>%2Fblog%2F20190323%2F%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[事务的四个特性(ACID) 原子性 事务执行开始之后的一系列操作都堪称是一个原子操作，要么全部做完，要么全部失败，不能出现部分操作成功的情况。“原子”顾名思义，就是一个不可分割的最小单元。 一致性 事务开始执行之后，数据的正确性需要得到保证。如A向B转账，B却未收到钱。 隔离性 同一时间只能由一个事务对数据进行修改操作，对于其他事务来说这个修改操作时透明的。 持久性 事务对数据进行修改操作完成之后，数据发生的改变是持久不变的，不会自己恢复到改变之前的状态。 spring中的事务传播机制 以及事务隔离级别在接口TransactionDefinition中，定义了7种传播机制 1234567891011121314151617181920package org.springframework.transaction;public interface TransactionDefinition &#123; // 事务传播机制 int PROPAGATION_REQUIRED = 0; int PROPAGATION_SUPPORTS = 1; int PROPAGATION_MANDATORY = 2; int PROPAGATION_REQUIRES_NEW = 3; int PROPAGATION_NOT_SUPPORTED = 4; int PROPAGATION_NEVER = 5; int PROPAGATION_NESTED = 6; // 事务隔离级别 int ISOLATION_DEFAULT = -1; // 默认级别 int ISOLATION_READ_UNCOMMITTED = 1; int ISOLATION_READ_COMMITTED = 2; int ISOLATION_REPEATABLE_READ = 4; int ISOLATION_SERIALIZABLE = 8; &#125; 各种传播机制和隔离级别详解事务传播机制 事务传播机制 作用 PROPAGATION_REQUIRED 默认的 也是最常用的 ，如果当前有事务，就加入当前这个事务，如果没有事务，就新建一个事务 PROPAGATION_SUPPORTS 如果有事务，就加入当前这个事务，如果没有事务，也不新建 PROPAGATION_MANDATORY 如果有事务，就会使用当前这个事务，如果没有就会抛出异常 PROPAGATION_REQUIRES_NEW 总是会开启一个新的事务，如果当前已经有事务，就将当前事务挂起 PROPAGATION_NOT_SUPPORTED 代码总是会在非事务的环境执行，如果当前有事务，先将事务挂起，执行完成之后再恢复 PROPAGATION_NEVER 绝对不允许代码在有事务的环境执行，有事务就抛出异常停止执行 PROPAGATION_NESTED 嵌套事务级别：如果没有父事务，就使用默认机制，如果有，子事务执行完成之后父事务才会提交 事务隔离级别 通俗名称 事务隔离级别 作用 脏读 ISOLATION_READ_UNCOMMITTED 读未提交 即脏读，可以读取别的事务已修改未提交的数据，会导致脏读、幻读和不可重复度 不可重复读 ISOLATION_READ_COMMITTED 提交读 即不可重复读，一个事物能读取到另一个事务已经提交的数据，在多次读取同一数据时，该数据被另一事务修改，读取的数据不一致 可重复读 ISOLATION_REPEATABLE_READ 可重复读 即一个事物只能读取到另一事务提交之前的数据，确保每次读取到的数据一致。但是数据又新增或者修改时不可预见 幻读 ISOLATION_SERIALIZABLE 序列化读 即事务串行读取数据，性能最差，安全性最高，保证数据准确性]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Springboot进行国际化时自定义读取数据库配置]]></title>
    <url>%2Fblog%2F20190320%2F%E4%BD%BF%E7%94%A8springboot%E8%BF%9B%E8%A1%8C%E5%9B%BD%E9%99%85%E5%8C%96%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言springboot默认就支持国际化的，而且不需要你过多的做什么配置，只需要在resources/下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。 具体的关于springboot的国际化配置我这边就不再过多介绍(包括Locale的设置以及如何根据区域设置语言等)，关于页面上得使用可以参考：springboot国际化。在这篇博客中，我要介绍的是一个很有用的功能并且绝大部分人也会用得到，就是不使用配置文件messages.properties储存国际化语言，而使用数据库进行动态配置，做到无需重启更改配置。 如何使用MessageSource介绍Spring提供了一个接口MessageSource用于获取国际化信息，ReloadableResourceBundleMessageSource和ResourceBundleMessageSource都是继承了该接口的一个抽象实现类AbstractMessageSource，在spring官网有一段这样介绍messageSource的话：图中红框画起来的意思就是，上下文加载的时候会查询messageSource的bean，如果没有就会创建一个名为messageSource放在上下文中… …等等。 在springboot中注入自定义messageSource通过上面的介绍，我们就可以自己定义自己的messageSource进行配置的读取了。 我这边是把这个放在了业务层，大家用的时候也可以直接放在控制层(一般都放在控制层，要用到)，使用@Compnent(“messageSource”)注解声明下bean名称即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// MyMessageSourceService是我自己的接口 你也可以不需要。使用@Compnent("messageSource")注解就行@Service("messageSource")public class MyMessageSource extends AbstractMessageSource implements ResourceLoaderAware, MyMessageSourceService &#123; ResourceLoader resourceLoader; // 这个是用来缓存数据库中获取到的配置的 数据库配置更改的时候可以调用reload方法重新加载 // 当然 实际使用者也可以不使用这种缓存的方式 private static final Map&lt;String, Map&lt;String, String&gt;&gt; LOCAL_CACHE = new ConcurrentHashMap&lt;&gt;(256); @Autowired SysI18nService sysI18nService; private final Logger logger = LoggerFactory.getLogger(MyMessageSource.class); /** * 初始化 */ @PostConstruct public void init() &#123; this.reload(); &#125; /** * 重新将数据库中的国际化配置加载 */ public void reload() &#123; LOCAL_CACHE.clear(); LOCAL_CACHE.putAll(loadAllMessageResourcesFromDB()); &#125; /** * 从数据库中获取所有国际化配置 这边可以根据自己数据库表结构进行相应的业务实现 * 对应的语言能够取出来对应的值就行了 无需一定要按照这个方法来 */ public Map&lt;String, Map&lt;String, String&gt;&gt; loadAllMessageResourcesFromDB() &#123; List&lt;SysI18nBO&gt; list = sysI18nService.findList(new SysI18nAO()); if (CollectionUtils.isNotEmpty(list)) &#123; final Map&lt;String, String&gt; zhCnMessageResources = new HashMap&lt;&gt;(list.size()); final Map&lt;String, String&gt; enUsMessageResources = new HashMap&lt;&gt;(list.size()); final Map&lt;String, String&gt; idIdMessageResources = new HashMap&lt;&gt;(list.size()); for (SysI18nBO bo : list) &#123; String name = bo.getModel() + "." + bo.getName(); String zhText = bo.getZhCn(); String enText = bo.getEnUs(); String idText = bo.getInId(); zhCnMessageResources.put(name, zhText); enUsMessageResources.put(name, enText); idIdMessageResources.put(name, idText); &#125; LOCAL_CACHE.put("zh", zhCnMessageResources); LOCAL_CACHE.put("en", enUsMessageResources); LOCAL_CACHE.put("in", idIdMessageResources); &#125; return MapUtils.EMPTY_MAP; &#125; /** * 从缓存中取出国际化配置对应的数据 或者从父级获取 * * @param code * @param locale * @return */ public String getSourceFromCache(String code, Locale locale) &#123; String language = locale.getLanguage(); Map&lt;String, String&gt; props = LOCAL_CACHE.get(language); if (null != props &amp;&amp; props.containsKey(code)) &#123; return props.get(code); &#125; else &#123; try &#123; if (null != this.getParentMessageSource()) &#123; return this.getParentMessageSource().getMessage(code, null, locale); &#125; &#125; catch (Exception ex) &#123; logger.error(ex.getMessage(), ex); &#125; return code; &#125; &#125; // 下面三个重写的方法是比较重要的 @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = (resourceLoader == null ? new DefaultResourceLoader() : resourceLoader); &#125; @Override protected MessageFormat resolveCode(String code, Locale locale) &#123; String msg = getSourceFromCache(code, locale); MessageFormat messageFormat = new MessageFormat(msg, locale); return messageFormat; &#125; @Override protected String resolveCodeWithoutArguments(String code, Locale locale) &#123; return getSourceFromCache(code, locale); &#125;&#125; 最后 至此，自定义国际化配置读取数据库已经完成，只需要在更新数据库配置的时候调用一下reload重置一下缓存中的信息即可。 参考博客：spring xml配置自定义读取数据库的messageSource]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Layui结合freemarker+springboot进行前端数据表格字典转义]]></title>
    <url>%2Fblog%2F20190316%2Flayui%E5%BC%80%E5%8F%91%E4%B8%AD%E7%BB%93%E5%90%88freemarker%E5%B1%95%E7%A4%BA%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。那么在layui的数据表格中，我们要展示这样的数据，写法可以是：1234567templet: function (d) &#123; if(d.status === 1)&#123; return "启用"; &#125; else if(d.status === 0)&#123; return "停用"; &#125;&#125; 但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。最后我们的写法就会简化成：&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;，接下来看看如何在springboot中配置使用吧。 freemarker自定义标签介绍及使用TemplateDirectiveModel接口是freemarker自定标签或者自定义指令的核心处理接口。当模板页面遇到用户自定义的标签指令时，execute()方法会被执行。execute()方法如下。123public void execute( Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException; 我们在使用freemarker自定义标签的时候需要实现该接口并且重写execute方法。 execute()方法参数解释 Environment env：系统环境变量，通常用它来输出相关内容，如Writer out = env.getOut(); Map params：自定义标签传过来的对象，就是从页面上获取的参数，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等。在本例使用时，我们会将map转成我们自己的对象进行数据保存。 TemplateModel[] loopVars：循环替代变量 TemplateDirectiveBody body：标签中嵌套的内容，如&lt;@tag&gt;body&lt;/@tag&gt;，就是这个body 开始使用定义接收页面参数的对象1234567891011121314151617@Getter@Setterpublic class TableThTag &#123; /** * 对象属性名【需要进行对象属性获取】 */ private String objName; /** * 字典标识 */ private String nid; /** * 类型 */ private String type;&#125; 实现TemplateDirectiveModel接口并重写execute方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component@org.springframework.context.annotation.Configurationpublic class TableThDirective implements TemplateDirectiveModel &#123; Logger logger = LoggerFactory.getLogger(getClass().getName()); /** * FreeMarker自定义指令 */ @Override public void execute(Environment environment, Map map, TemplateModel[] templateModels, TemplateDirectiveBody templateDirectiveBody) throws TemplateException, IOException &#123; TableThTag tableThTag = new TableThTag(); //校验参数 try &#123; // 用来将一些 key-value 的值（例如 hashmap）映射到 bean 中的属性 BeanUtils.populate(tableThTag, map); if (StringUtils.isEmpty(tableThTag.getNid()) || StringUtils.isEmpty(tableThTag.getType())) &#123; throw new IllegalArgumentException("nid,type不能为空"); &#125; &#125; catch (Exception e) &#123; logger.error("数据转化异常", e); &#125; StringBuilder html = new StringBuilder(); // 根据类型创建不同的HTML生成器 ThFormatterInterface thFormatterInterface = ThFormatterFactory.createThFormatter(tableThTag.getType()); if (thFormatterInterface != null) &#123; String dictHtml = thFormatterInterface.buildFormatterHtml(tableThTag.getNid(), tableThTag.getFieldName()); html.append(dictHtml); &#125; // 执行真正指令的执行部分: Writer out = environment.getOut(); out.write(html.toString()); if (templateDirectiveBody != null) &#123; templateDirectiveBody.render(environment.getOut()); &#125; &#125; public static BeansWrapper getBeansWrapper() &#123; BeansWrapper beansWrapper = new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build(); return beansWrapper; &#125;&#125; 大家可以看到，在这个方法中，我将页面上的参数转为TableThTag对象。然后再根据前端页面不同的type类型对应实现了ThFormatterInterface的工厂对象，创建不同的html生成器。（这里考虑到扩展性，可能以后不光创建数据表格会用的到，比如下拉框什么的，也可以使用这种方式创建，所以在这里使用抽象工厂依据类型动态创建。）下面就是创建html的具体工厂以及实现方法。 ThFormatterInterface抽象工厂创建html生成器接口12345678public interface ThFormatterInterface &#123; /** * 构造生成枚举html * @param nid * @return */ String buildFormatterHtml(String nid, String fieldName);&#125; 工厂1234567891011121314151617181920212223public class ThFormatterFactory &#123; private static Logger logger = LoggerFactory.getLogger(ThFormatterFactory.class); public static ThFormatterInterface createThFormatter(String type)&#123; if(StringUtils.isEmpty(type))&#123; return new ThFormatterTemplate(); &#125; // 文件名 如果type传template 就需要有一个名为ThFormatterTemplate的文件 // 并且实现了ThFormatterInterface以及重写生成html的方法 String fileName = "ThFormatter" + StringUtil.firstCharUpperCase(type); //类路径 通过反射去创建实现类 String className = "com.module.freemarker.impl."+fileName; //生成表头格式实现类 ThFormatterInterface thFormatterInterface = null; try &#123; thFormatterInterface =(ThFormatterInterface) Class.forName(className).newInstance(); &#125; catch (Exception e) &#123; logger.error(e.getMessage(),e); &#125; return thFormatterInterface; &#125;&#125; 实现类1234567891011121314151617181920public class ThFormatterTemplate implements ThFormatterInterface &#123; @Override public String buildFormatterHtml(String nid, String fieldName) &#123; Assert.notEMPTY(nid, "nid不能为空"); Assert.notEMPTY(fieldName, "objName不能为空"); SysDictService sysDictService = SpringContextHolder.getBean(SysDictService.class); // 通过nid查询字典类 这里不需要进行照抄 每个人都会有自己的实现方法 List&lt;SysDictBO&gt; sysDictModelList = sysDictService.findByPartnerNid(nid); StringBuilder dictHtml = new StringBuilder(); // 反正目的就是根据字典类生成对应的html就行了 需要生成的格式对照template原本应该有的写法就行了 dictHtml.append("templet: function(d)&#123; "); for (SysDictBO sysDict : sysDictModelList) &#123; dictHtml.append("if(d." + fieldName + " == '" + sysDict.getValue() + "')&#123; return '" + sysDict.getName() + "';&#125;"); &#125; dictHtml.append("&#125;"); return dictHtml.toString(); &#125;&#125; 最后将自定义标签注入到freemarker标签中去123456789101112131415@org.springframework.context.annotation.Configurationpublic class FreemarkerConfig &#123; @Resource private Configuration configuration; @Resource private TableThDirective tableThDirective; @PostConstruct public void setSharedVariable()&#123; configuration.setSharedVariable("th",tableThDirective); configuration.setSharedVariable("shiro",new ShiroTags()); &#125;&#125; 这样就大功告成了。 在页面上进行使用吧：&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt; 以后进行扩展什么的也方便，比如生成下拉框：&lt;@th type=&quot;select&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;这样然后自动生成html的时候查出来所有的字典，根据类型生成多个出来就行了。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>springboot</tag>
        <tag>freemarker</tag>
        <tag>工厂模式</tag>
        <tag>layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot+shiro解决session污染的问题]]></title>
    <url>%2Fblog%2F20190309%2Fspringboot%2Bshiro%E8%A7%A3%E5%86%B3session%E6%B1%A1%E6%9F%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[同一个服务器启动多个web项目造成session污染昨天在敲代码的时候遇到了一个问题，同一个项目，我创建了两个分支，分别使用不同的端口。但是在测试环境启动的时候我发现，在同一个浏览器上，我只能登陆其中的一个后台。在登陆另一个后台之后，前面那个又需要再重新登陆了。 原因找了好久，最后F12控制台查看session发现，这两个web项目，使用的都是JSessionId作为cookie的key，在登陆另一个时，浏览器的这个cookie值就会被改变，所以前者就需要在重新登陆了。 解决方法在springboot中，对shiro配置进行更改session保存时的cookie的key名称，如下。1234567@Beanpublic DefaultWebSessionManager sessionManager() &#123; DefaultWebSessionManager sessionManager = new DefaultWebSessionManager(); Cookie cookie = sessionManager.getSessionIdCookie(); cookie.setName(&quot;MySessionId&quot;); return sessionManager;&#125; 然后在securityManager中将我们的sessionManager注入进去。12345678910/** * SecurityManager，权限管理，这个类组合了登陆，登出，权限，session的处理，是个比较重要的类。 */@Beanpublic DefaultWebSecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(myShiroRealm()); securityManager.setSessionManager(sessionManager()); return securityManager;&#125; 只需要这样修改好就可以了。然后重启项目，就会发现，两个web项目都可以同时登陆了。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>shiro</tag>
        <tag>session污染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode - Z字形变换]]></title>
    <url>%2Fblog%2F20181223%2Fleetcode-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题目如下将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： 123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1: 12输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2: 12输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot; 解释: 1234L D RE O E I IE C I H NT S G 解题思路拿到这个题目，第一时间就可以想到，根据题中图示构造二维数组，先将数据按照相应的样子存储进去，最后再从数组中按行取出，但是这样会有占用更多内存空间的风险。所以，我这边还思考了第二种解法：就是直接根据规律计算出下一个要输出的字符的下标，直接输出即可，无需再创建多余的二维数组。 第一种解法：构造二维数组 构造二位数组最主要的就是计算出这个二维数组有多少列，列数有了，按照Z型规律将原字符串塞进去就行了，计算列数代码如下 123456789private int getColNum(String s, int n) &#123; int x = s.length() / (2 * n - 2); int y = s.length() % (2 * n - 2); int l = x + 1 + x * (n - 2); if (y &gt;= n) &#123; l = l + 1 + y % n; &#125; return l; &#125; 第二种解法：计算下一个要输出的字符的下标直接看github代码吧：点这里]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中map新的骚操作]]></title>
    <url>%2Fblog%2F20181209%2FJava%E4%B8%ADmap%E6%96%B0%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下： 总结computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回nullcomputeIfAbsent 就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值compute 就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package test;import java.util.HashMap;public class MapTest &#123; public static void main(String[] args) &#123; HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1,&quot;zhang&quot;); // computeIfPresent 根据之前的key/value 如果oldValue 不为null 则根据提供的方法返回一个新的值 并进行新值对旧值的替换 System.out.println(&quot; 1 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123; return key + value;//原值不为null新值不为null 新值替换旧值 &#125;)); // 否则删除键值对 System.out.println(&quot; 2 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123; return null;//原值不为null新值为null 删除键值对 &#125;)); map.put(1,null); System.out.println(&quot; 3 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123; return &quot;jiaheng&quot;;//原值为null 不做更改 &#125;)); // computeIfAbsent 根据之前的key 如果旧值为空或者key不存在 就按照方法用新值替换旧值 新值为null不做替换 map.put(1,&quot;zhang&quot;); System.out.println(&quot; 4 ---&gt; &quot; + map.computeIfAbsent(1,k-&gt;&#123; return null;// 不会被替换旧值 返回原值 &#125;)); System.out.println(&quot; 5 ---&gt; &quot; + map.computeIfAbsent(2,k-&gt;&#123; k = k*k; return k.toString();// key=2不存在 直接新建并存入新值 &#125;)); // compute类似于computeIfAbsent和computeIfPresent的合体 map.put(1,null); System.out.println(&quot; 6 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123; return &quot;张&quot;;// 原值为null新值不为null 新值替换旧值 此处与computeIfPresent不同 &#125;)); System.out.println(&quot; 7 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123; v = (k*10) + v; return v;// 新值不为null 替换旧值 &#125;)); System.out.println(&quot; 8 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123; return null;// 新值为null 删除键值对 &#125;)); // 总结 // computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null // computeIfAbsent 就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值 // compute 就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。 &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodepad++不用插件去重的方法]]></title>
    <url>%2Fblog%2F20181112%2Fnodepad-%E4%B8%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在工作中，当我们需要对一个文本中的行进行去重统计的时候，会发现对于文本的去重并不是那么好处理。而nodepad++的去重插件一般人又懒得去安装，不巧在网上找到这样一个去重的小技巧，即使用正则表达式进行去重，简直方便快捷。在这里分享出来，希望大家能够用的上。1^(.*?)$\s+?^(?=.*^\1$) 点击全部替换，就可以将重复行全部去掉喽]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>工作技巧</tag>
        <tag>nodepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Git 进行 Squash Commit]]></title>
    <url>%2Fblog%2F20181011%2F%E4%BD%BF%E7%94%A8-Git-%E8%BF%9B%E8%A1%8C-Squash-commit%2F</url>
    <content type="text"><![CDATA[Git 更改 commit 的操作 git rebase -i HEAD~&lt;number 代表需要处理几个 commit&gt; 12345678910111213141516171819202122232425# Rebase ddebba2..a54dc28 onto 9d9ba60 (15 commands)## Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# f, fixup &lt;commit&gt; = like "squash", but discard this commit's log message# x, exec &lt;command&gt; = run command (the rest of the line) using shell# b, break = stop here (continue rebase later with 'git rebase --continue')# d, drop &lt;commit&gt; = remove commit# l, label &lt;label&gt; = label current HEAD with a name# t, reset &lt;label&gt; = reset HEAD to a label# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]# . create a merge commit using the original merge commit's# . message (or the oneline, if no original merge commit was# . specified). Use -c &lt;commit&gt; to reword the commit message.## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 根据上面每一个指令操作，更改以下类似内容： 123456pick 54f205a Update README.mdpick e1deb05 Update README.mdpick 3a33ad2 Update README.mdpick 225a513 Update README.mdpick d44d34b Update README.mdpick 657d8c2 Update README.md 123456pick 54f205a Update README.mdpick e1deb05 Update README.mdsquash 3a33ad2 Update README.mdsquash 225a513 Update README.mdsquash d44d34b Update README.mdsquash 657d8c2 Update README.md 这样就可以把最上面两个 Message 保留，把后面的 Message 去掉 最后git push --force]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客文章置顶方式]]></title>
    <url>%2Fblog%2F20180904%2Fhexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[博文置顶目前已经有修改后支持置顶的仓库，可以直接用以下命令安装12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：123456---title: hexo博客置顶date: 2017-09-08 12:00:25categories: 博客搭建系列top: true--- 到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，紧接着下一行插入如下代码：12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 至此，博客置顶的方式就全部完成了]]></content>
      <categories>
        <category>hexo博客配置</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰国7天6晚自由行攻略]]></title>
    <url>%2Fblog%2F20180904%2F%E6%B3%B0%E5%9B%BD7%E5%A4%A96%E6%99%9A%E8%87%AA%E7%94%B1%E8%A1%8C%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[人生不可能是一场说走就走的旅行，但心怀远方的人，一定要时刻做着说走就走的准备！ 关于去泰国这件事情，可能发生的很突然，但是没关系，既然决定了，就把它安排在计划里。 一、出行前的准备1、护照&amp;签证我是在杭州工作，在杭州工作社保交满一年，就可以办护照了。拿着身份证在西湖区行政服务中心的出入境管理那儿就可以办理了。现在一楼自助打印下社保证明，然后去后面的楼，出入境办理区按照流程办理即可。大概一个多礼拜就能拿到护照，我也没想到有这么快。 签证是在淘宝上买的，260￥。七个工作日到手。 2、泰铢&amp;电话卡&amp;出入境&amp;去泰国的必备软件&amp;其他泰国新规定，过境签、落地签-10000泰铢或等值外币现金（每人），20000泰铢（家庭）；旅游签-20000泰铢或等值外币现金（每人），40000泰铢（家庭），抽查到概率很低，一般落地签会查的吧。但是网上说好像都不查的，或者很少查，但还是换两千的吧。 然后再淘宝买泰国7天happy卡，我买的是这家的，8天无限流量，4G。 入境时需要填写出入境卡，然后和护照一起交给海关查看盖章。下面是入境卡中文说明图： 一般情况下，在乘坐航班时常会有工作人员在抵达目的地钱给乘客发放出入境卡，以便乘客提前填好出入境卡，方便出关。护照也很重要，可以在国内出发前复印几份护照一定要放行李箱，不要随身携带。 END - 其他一些实用信息 大使馆/领事馆 中国驻泰国大使馆地址：NO.57, Racgadapisek Road, Bangkok电话：+66-02-2450088领事保护电话：+66-854833327（24小时值班手机），+66-02-2457010（工作日9：00-17：00） 中国驻清迈总领事馆地址：111 Changloh Road, Haiya District, Chiangmai电话：+66-53-280380，+66-53-276125，+66-53-276457 中国驻宋卡总领事馆（近普吉岛、苏梅岛、甲米）地址：9 Sadao Road, Songkhla电话：+66-74-322034领事保护电话：+66-817665560 中国驻宋卡总领馆驻普吉领事办公室电话：+66-76-304219领事保护电话：+66-945956168（中文、泰文），+66-945986859（中文） 中国驻孔敬总领馆地址：142/44 Moo 2，Rob-Bueng Rd.，Nai-Muang， Muang， Khon Kaen电话：+66-43-226873 紧急电话 警察:123/191火警:199救护:2460199领事:022-457010大使馆:022-457044旅游投诉:1155]]></content>
      <categories>
        <category>个人随笔</category>
      </categories>
      <tags>
        <tag>个人随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo获取注册中心的实例bean]]></title>
    <url>%2Fblog%2F20180719%2F%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-20180718%2F</url>
    <content type="text"><![CDATA[开发日记 20180718com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR Data length too large1com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR Data length too large: 11557050, max payload: 8388608 java.io.IOException: Data length too large: 11557050, max payload: 838860 在使用dubbo框架开发的时候，需要做一个导出csv文件的功能，查询大量的数据然后在提供者这边进行处理导出，其中数据达到过20万行以上，几十M的数据，抛出了这样一个异常。遇到服务提供者从数据库查询或者其他地方返回过大的对象，导致报错时，尽管有办法取消这个数据长度的限制，但是这并不符合程序开发的初衷。我们需要将对于数据的处理放在业务层，我在这里做了异步导出，给前端返回的仅仅是一个程序完成的状态，完美的解决了这个问题。 在dubbo消费者服务中写aop方法拦截工具类中的方法尽管服务的提供者和消费者都引入的工具类模块的依赖，但是拦截器的实际拦截的还是那个实际本身所在模块的方法。如果工具类是在消费者service层被使用的，那么在上层模块的拦截器是无法拦截到这个方法的。 在dubbo服务中手动获取注册的提供者的bean在这里犯的错：以为通过SpringContextHolder.getBean()可以获取，是我傻逼了，dubbo中的服务怎么能用spring上下文获取呢。这里我使用dubbo的方式完成了这个功能。1234567891011121314151617181920/** * 获取服务的代理对象 * * @return */public static &lt;T&gt; T getReferenceConfig(String appName,String address,Class&lt;?&gt; interfaceClass) &#123; String key = interfaceClass.getName(); ReferenceConfig&lt;T&gt; referenceConfig = (ReferenceConfig&lt;T&gt;)referenceCache.get(key); if(referenceConfig == null)&#123; referenceConfig = new ReferenceConfig&lt;T&gt;(); referenceConfig.setApplication(application); referenceConfig.setRegistry(getRegistryConfig(appName,address)); referenceConfig.setInterface(interfaceClass); referenceCache.put(key,referenceConfig); &#125; return referenceConfig.get();&#125;]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于IDEA再从git或者svn上导入项目时不能加载字模块的问题]]></title>
    <url>%2Fblog%2F20180708%2F%E5%85%B3%E4%BA%8EIDEA%E5%86%8D%E4%BB%8Egit%E6%88%96%E8%80%85svn%E4%B8%8A%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%8D%E8%83%BD%E5%8A%A0%E8%BD%BD%E5%AD%97%E6%A8%A1%E5%9D%97%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于IDEA再从git或者svn上导入项目时不能加载字模块的问题 最近入职新公司，很多东西也都算是要从头学起。在之前公司用的都是eclipse，这边要求用IDEA，其实很早就知道这是一个非常强大的编译器，但平时没有机会使用，现在有机会用这个还是挺开心的。 由于公司使用gitlab，在注册好账号导入代码的时候遇到一个情况，就是直接用IDEA的git工具导入的话会出现，maven项目的子模块无法被识别以及被管理的情况。事实上eclipse也有同样的问题。现在只说下使用IDEA遇到这个情况的解决办法。 有两种解决方式。1、手动将module添加到项目管理： 打开文件选项中的项目结构（快捷键ctrl+alt+shift+s） 选择 模块-加号-导入module，手动将自己需要的模块一一导入进去2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了 从eclipse转到IDEA前几天是最艰难的，因为很多习惯不是说改就能改掉的，工具的使用总得需要一个学习的时间，但是等这段时间过去，后面一定会体会到IDEA的强大。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>IDEA</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念即将结束的第一份工作]]></title>
    <url>%2Fblog%2F20180628%2F%E7%BA%AA%E5%BF%B5%E5%8D%B3%E5%B0%86%E7%BB%93%E6%9D%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[纪念即将 结束的第一份工作 我一直都不知道自己想要得到些什么东西 记得高中的时候，身边不管是家人还是老师，总会时刻不停在耳边说着：你需要如何如何学习，考上一个怎样的大学，进入一个怎么样的专业，以后找一个怎样的工作。可是当我听到这些话时总是会很反感。也许是叛逆，也许是这些对于我当时都是些虚无缥缈，很遥远的东西，我没有办法理解自己得到这些东西有什么用。但是虽然忠言不入耳，我还是得按照他们说的做。还好，大学上了一个普通的理工科一本。 当上了大学之后，没有了老师家长在耳边“絮叨”，更不知道自己要干什么了。记得当时参加各种社团，觉得在社团里面干的风风火火很牛逼，甚至课程都不上几节，最严重的时候好几周都不上课。浑浑噩噩的度过了大学的第一年之后，突然因为一个给学校编程培训班试听课凑人数的机会，让自动化专业的我接触到了软件开发这个方向。依然记得当时上课的老师，老范！当他用C语言在电脑上输出一串笑脸字符的时候，我当时的眼睛都亮了，我对和自己一块去凑人数的舍友说，这个人一定以后对我有很大的帮助，我一定要报名他的课程。后来真的觉得我是幸运的，老范是一个很有人格魅力的中年程序员 :) 。也是他让我知道了程序员是做什么的，也是他让我非常期待自己能够成为一个真正的软件开发者。 就这样我跟着老范从计算机基础，学到数据结构与算法，学计算机网络，MySQL，学习设计模式，学C++，后来又在另一个班学Java。计算机硬件方向专业的我，学完了软件专业学生要学的所有课程。终于大三，我找到了西安三星电子研究所的一份实习，写了两个月shell脚本，学习了Linux相关的知识以及自动化测试的东西，后来又在组内用PHP写了个网站，提供给大家进行会议的预定与提醒。现在想想这一切经验都是我的宝贵的财富. 实习结束后，工作却找的不是很顺利，也许是自己的实习经历没有太多做Java开发的东西，导致自己没有什么实际的项目经验。后来，我来了同※※。 或许离开这里是我最正确的选择 在拿到offer来到同※※之前，我觉得我来到了一个很好的大公司。事实上这里也没有很差，除了我所在的部门。同※※是国内最早做股票交易平台的软件公司，目前也有自己的大楼，装修的也很不错，很像一个一线的大型互联网公司。然而，只是很像而已。从一件很平常的事就看得出来：每天饭点，后勤部经理就站在食堂打饭窗口对打饭的员工喊，少打一点少打一点，他们吃不完！ … … 其实我刚来的时候觉得自己可以呆三年的，现在想想真的很抱歉，我得走了。并不是因为上面的“打饭”。我来到这里做的工作都是外包的，在B2B部门。我本来以为大公司的工作流程都很规范，没想到在这里刷新了我的三观哈哈。外包工作什么都得听客户的，乱改需求不说，自己公司的运维根本派不上用场，连tomcat的启动报错都不知道怎么解决，让我们作为开发的去同时做开发、测试、运维、项目经理、产品的活，想想就火大。项目经理把客户电话甩给你，自己沟通去，然后自己潇洒的下班。 唉ε=(′ο｀*)))，不想再说太多了，显得自己好像太小气，都要走了还要diss前公司。但是，我觉得我是真的得走了，而且我还算是忍得时间长的。我们组，比我来得晚，比我走的早的人，超过了10个。才一年啊。作为一个刚毕业一年的程序员，真的心好累。 接下来的路少交点儿朋友，否则离开时会难受 要走了要走了，却又感觉很难受。在这里，我接触过不少傻逼，但是也真的交到很多有趣的朋友。甚至有那种就算离职了，之后也不会断了联系的。在这个城市，原本独自一人的生活由他们，真的不会无聊。 天涯途上谁是客，散席时怎么分？ 也许有些人分开就不会再见，有些人想不见却总会出现在生活里。罢了，以后换到新的公司，不要再走心了。况且，真正值得走心的，也不会很多！ ✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。 ——《行歌》 · 陈鸿宇]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Git Pull 拉取不到最新记录]]></title>
    <url>%2Fblog%2F20180531%2F%E5%85%B3%E4%BA%8Egit-pull-%E6%8B%89%E5%8F%96%E4%B8%8D%E5%88%B0%E6%9C%80%E6%96%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[////1234567891011121314151617181920//~~~~~~~~~~~~~~~~~~~~~~o8888888o//~~~~~~~~~~~~~~~~~~~~~~88&quot;~.~&quot;88//~~~~~~~~~~~~~~~~~~~~~~(|~-_-~|)//~~~~~~~~~~~~~~~~~~~~~~0\~~=~~/0//~~~~~~~~~~~~~~~~~~~~___/`---&apos;\___//~~~~~~~~~~~~~~~~~~.&apos;~\\|~~~~~|//~&apos;.//~~~~~~~~~~~~~~~~~/~\\|||~~:~~|||//~\//~~~~~~~~~~~~~~~~/~_|||||~-:-~|||||-~\//~~~~~~~~~~~~~~~|~~~|~\\\~~-~~///~|~~~|//~~~~~~~~~~~~~~~|~\_|~~&apos;&apos;\---/&apos;&apos;~~|_/~|//~~~~~~~~~~~~~~~\~~.-\__~~&apos;-&apos;~~___/-.~///~~~~~~~~~~~~~___&apos;.~.&apos;~~/--.--\~~`.~.&apos;___//~~~~~~~~~~.&quot;&quot;~&apos;&lt;~~`.___\_&lt;|&gt;_/___.&apos;~&gt;&apos;~&quot;&quot;.//~~~~~~~~~|~|~:~~`-~\`.;`\~_~/`;.`/~-~`~:~|~|//~~~~~~~~~\~~\~`_.~~~\_~__\~/__~_/~~~.-`~/~~///~~~~~=====`-.____`.___~\_____/___.-`___.-&apos;=====//~~~~~~~~~~~~~~~~~~~~~~~`=---=&apos;//////~~~~~~~~~~~~~~~~~~~~~~~~~ ////~~~佛祖保佑~~~~~永无BUG////// 使用git pull 获取不到最新的记录，判断应该是某些时候未pull先commit导致的，使用命令：git pull origin master即可解决]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Boot微服务搭建]]></title>
    <url>%2Fblog%2F20180127%2Fspring-boot%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本人的csdn传送门 前言 进行web开发的时候Java程序员们难免会碰到那种很小的服务，比如就提供一个生成订单号的接口，或者一个上传文件的服务。而这时我们再去使用SpringMVC这种体量稍大、配置繁琐的框架开发难免会加大工作量，而且是不必要的。这个时候我们就可以选择使用这个微服务框架——springboot进行开发。 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 springboot框架的搭建与简单的REST风格的MVC架构demo首先，建立一个新的maven工程，pom文件主要内容如下：123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 其中核心依赖是 spring-boot-starter-web1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 访问静态资源文件可以加入模板：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 编写Application.java文件，存放于src/main/java这个目录下这里是springboot的核心启动类12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan@EnableAutoConfigurationpublic class Application&#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 事实上，这个时候已经把框架搭建好了，运行以上main方法即可启动这个项目，但是我们现在看不到效果，接下来，就可以像SpringMVC一样加入MVC三层结构的代码了，目录结构如下图： 其中各层代码如下： controller12345678910111213141516171819202122232425262728package com.zhang.controller;import java.util.HashMap;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.servlet.ModelAndView;import com.zhang.entity.Photo;import com.zhang.service.mainService;@RestController@RequestMapping("/photo")public class mainController &#123; @Autowired private mainService mainservice; @RequestMapping("/") public ModelAndView index(ModelAndView mav)&#123; mav.addObject("hello", "这是项目主页，访问根目录到达~~"); mav.setViewName("index"); return mav; &#125; @RequestMapping("/getPhoto") public Object doIt()&#123; Map&lt;String, Photo&gt; map = new HashMap&lt;String, Photo&gt;(); map.put("photo", mainservice.getPhotoById(123)); return map; &#125;&#125; service实现类12345678910111213141516171819package com.zhang.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.zhang.dao.mainDao;import com.zhang.entity.Photo;import com.zhang.service.mainService;@Service("mainservice")public class mainServiceImpl implements mainService &#123; @Autowired private mainDao maindao; @Override public Photo getPhotoById(int id) &#123; return maindao.getPhotoNameById(id); &#125;&#125; dao实现类12345678910111213141516171819package com.zhang.dao.impl;import org.springframework.stereotype.Repository;import com.zhang.dao.mainDao;import com.zhang.entity.Photo;@Repository("maindao")public class mainDaoImpl implements mainDao &#123; @Override public Photo getPhotoNameById(int id) &#123; Photo p = new Photo(); p.setId(123); p.setName("雪山行纪念照"); return p; &#125;&#125; 实体类photo1234567891011121314151617package com.zhang.entity;public class Photo &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 启动项目 项目默认端口为8080，在浏览器中访问刚才的controller会看到： 如上，一个REST风格的MVC架构的demo项目就搭建完成了。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校招面试【京东、顺丰科技、招银网络科技、去哪儿网】]]></title>
    <url>%2Fblog%2F20160927%2F%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[2017校招过的太惨了，还一度把原因怪罪在实习上，认为自己实习了4个月非Java研发的东西导致自己对于Java没有进行更加深入的学习。其实呢，还是应该怪自己不努力，怪不得其他。*从三星离职之后就开始找一些公众号内推，我是来自非985、211院校的本科生，学的还是自动化专业，偏硬件，实习内容还不是Java开发之类的东西，不知道是由于这些公众号的原因（恶意吸引粉丝）还是自己的简历确实有问题，内推一直不顺利。烦得很。之后又从9月开始海投Java软件开发岗，各种在线笔试。博主的基础（计算机网络操作系统等）本身就不强，C/C++/Java/PHP等还有HTML/CSS/JS/jQuery这些乱七八糟都学，算法和数据结构也学得不是很精，应付不来笔试编程题，感觉面试过的公司好少，妈的工作要找到十月了。 首先说下招银电面： 9月23号晚上八点正在理发染发呢电话就来了，都不预约一下。1、在Java中进行数据库连接并操作数据的步骤？最后需要进行什么操作？2、项目中使用jquery，那么on、bind、live、delegate这几个函数有什么区别？3、一个http请求所包含的数据格式是什么？4、一次http请求的详细处理过程？5、一次struts处理请求从开始到看到页面数据之间都发生了什么，整个详细过程？6、项目中都用到了什么框架？（spring+struts+mybatis）7、在自己的项目中有没有用到并发？如果让你现在考虑给你的项目中考虑并发你会怎么做？你要控制（进行同步）的数据源是哪些？还有几个吧，想不起来了，应该比较简单就没有印象。电面后预约28号下午再面试。 招银现场面===该来的就这样来了9月28号下午，不知道哪里来的自信感觉自己能够在一个半小时之内从长安赶到永宁门，坐地铁还把安远门当成了永宁门，到了安远门叫个优步，打电话让司机快一点，妈的竟然给我取消了，害我最后坐公交去，迟到了半个小时。心态爆炸！！！╮(╯▽╰)╭1、去了在房间里等着，过会儿从酒店房间出来一个，叫我进去面试。先问我要了成绩单和一些证书，感觉招银对于成绩和证书很看重。面试官是三个人，3V1，很紧张有木有。中间坐着老大，然后一个问技术的，一个HR。2、自我介绍3、介绍一下自己的项目4、项目中是使用servlet编写的后台代码，为什么不用开源框架？5、如果要给项目中添加日志，该如何做？6、一个struts请求从输入URL到显示在页面上都经过了哪些过程？7、中间老大看我写着struts1，就问为什么使用struts1而不是struts2，有研究过两者的区别吗？8、给一个string，问如何不使用任何库函数也不转化为数组，如何逆序？就这么多问题，心态爆炸！怀疑人生！阿弥陀佛！ 京东一面： 9月24日一早6点就爬起来了，昨晚一晚上都没睡好。做梦都在想着一些多线程常考的东西，果然第二天就问了。1、了解哪些常用的集合（set、list、map）？说说他们各自的特点（ArrayList和LinkedList等）？2、HashMap、HashTable的区别？HashMap扩容为什么是2倍？如何实现的？3、说一说线程调度机制？对线程池有何理解？哪里会用到线程池？好处是？4、JVM中如果有一个线程挂起了，用什么工具去查找这个线程？5、Java在什么时候会内存溢出？持久代内存溢出是什么情况？6、动态代理的实现？（从动态代理答到了springAOP）7、装饰模式了解吗？它的特点是什么？8、I/O库中都用到了什么设计模式？9、struts的一次请求是如何处理的？10、网络编程？socket？11、数据库索引了解吗？一个表中什么情况适合建立索引？如何去建立数据库索引？12、快速排序的时间复杂度、原理？13、java多态的实现原理？动态绑定底层虚拟机是如何实现的？14、forward和redirect的区别？同样。。。有很多问题没想起来，一面半个多小时，后天二面。。 京东二面： 感觉一面回答的不好，全程面试官问什么我答什么，一点互动都没有，狠狠狠紧张！二面抱着无所谓的心态去的，倒还没有一面紧张。1、了解那些算法和设计模式，说说你都用他们在什么地方？（贪心、回溯、分治、动态规划 || 单例模式、工厂模式、动态代理、装饰模式、适配器模式等，说了说单例工厂动态代理等，再说到JDK动态代理和CGLIB代理的区别，一顿乱侃）2、你的项目中那些都用到了多服务器？分布式了解吗？还问到了跨域请求。在实习的时候开发的网站也是单机吗？（从这儿开始问分布式集群服务器，高并发，这方面没怎么深入学习哎）3、设计一个抢购商品的系统需要考虑到那些问题？4、对于线程池有什么理解？5、消息队列？6、知道红黑树吗？平衡树？有什么区别？算了不写了，想不起来了，估计二面跪了。。。 顺丰技术面： 9月24日下午5点，就是京东一面的下午。。。（除了技术面就是HR）1、简单的自我介绍一下。。。2、介绍自己认为最能体现自己能力的项目，跟着项目引出很多题目，问了个透彻。。。3、觉得自己还有那些方面的能力没有体现出来，可以说一说？（在这里傻逼了，我他喵说我暂时想不起来。因为可能自己的项目有点简单了，面试官还想要看看自己其他的能力，醉醉哒）顺丰科技面试就这样，问了40多分钟，结果问完就让我走了，伤心，怪自己傻逼了。另一个西电的技术面玩就直接HR面了，让我回来等通知，4天了都没有通过不通过的通知，也是厉害。挂了也不让我安心挂！ 去哪儿网 9月29号下午3点好像感觉自己真的是，干什么事情完全不做任何准备的，很多看过的问题，在面试的时候就只能说有印象，答不详细，想抽死自己！1、去哪儿在金沙国际酒店面试，一天内面完，对去哪儿抱了很大希望，因为听学长说这个面试不难，问的比较基础，妈的现在写这段话还是想扇自己。2、刚见到面试官，他拿到简历就说，你是本科生啊？我说哦。。。然后就是自我介绍。。。3、给我了一张纸，在纸上写出自己用过的所有的类名。。。然后他在一边电脑上敲着东西。突然让写自己用过的所有的类的类名，脑子有点儿蒙了。4、说说mysql的引擎吧，说了myisam和innodb以及其区别，这个看过。5、mysql的各种连接是怎么回事？6、说说B树和B+树的区别吧。7、哈希冲突的解决算法？8、说说HashMap的实现原理？9、有什么问题问我？10、还有一些忘记了。。。/(ㄒoㄒ)/~~。。。都是些很简单的问题，妈的就是答得不好不够详细。 总结 ： 菜鸟的求职之路总是艰辛的，校招时间还长，十月份还有几家面试（觉得自己的脸火辣辣的疼。。。），看到人都拿到了很好的Offer，不服啊！哎，语言总是苍白的，只有安心敲代码！！！！！！！！！国庆七天奋发图强，多看看Java并发编程实战那书上的东西吧，问得太多了。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>个人随笔</tag>
        <tag>面试经历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个菜鸟在三星实习的那点儿感受]]></title>
    <url>%2Fblog%2F20160911%2F%E4%B8%80%E4%B8%AA%E8%8F%9C%E9%B8%9F%E5%9C%A8%E4%B8%89%E6%98%9F%E5%AE%9E%E4%B9%A0%E7%9A%84%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;2016年暑假，在大学这片沃土上的第三个学期就这样结束了，回想大学这三年，为了自己的未来迷茫过，也为自己努力过，也为了不少事情烦恼过，不知道将来自己可以在什么地方过着怎样的生活。曾经以为自己将会平凡地与大部分人一样，每天上着不知老师所云的课程，浑浑噩噩地度过这大学四年的生活，然后找一个普普通通的工作，但是也算自己运气好吧，在大一第二学期遇到了一位让自己眼前一亮的老师，慢慢学习并了解程序员这个行业，最后决定走上学习Java开发的道路。 &nbsp;&nbsp;&nbsp;&nbsp;很早就听说，在大三暑假如果能够找到一个好的专业对口的暑期实习的话，那么在大学毕业以后找工作就方便许多。于是在2016年3月，我便一边努力学习着web开发的相关知识，一边在网上投简历找着实习，终于在一个学长的内推下，我进入了西安三星半导体有限公司，原西安三星电子研究所。 &nbsp;&nbsp;&nbsp;&nbsp;三星是一个气氛非常好的公司，直到现在我都觉得能够进入这个公司是我大学期间的很幸运的一件事。在这儿我遇到了对我很好的师傅们，和那些谦逊和善的同事们。 &nbsp;&nbsp;&nbsp;&nbsp;一开始进入公司，我被派的任务是进行artik芯片的测试执行，输出测试执行报告并且开发相应的shell脚本进行自动化测试。因为之前没有过Linux开发经验，所以对于这项工作还是有很多畏惧，怕自己不能完成相应的任务。后来进过一个礼拜的熟悉以后，对于自动化测试的脚本开发和测试执行更加得心应手起来。Artik芯片包含许多模块如MQTT、wifi、TLS、ZigBee、BT/BLE、Ethernet等，在进行这些模块的测试脚本的开发的时候，不仅要熟悉脚本开发的shell语言，还要对这些协议也有一定的学习。由于我之前没有接触过Linux，所以对于shell脚本的编写知识懂一丁点儿简单的命令，后来边工作边学习，对于一些常用的Linux命令也掌握的很熟悉了。 &nbsp;&nbsp;&nbsp;&nbsp;其实作自动化测试这个工作不是我期望的工作，但是来到公司里，对于公司的安排还是要服从的，毕竟也是能够学习到很多东西的。而且有很多有常年工作经验的师傅们的带领，不管是技术方面还是工作习惯与工作流程的熟悉上我也学习了不少。由于自己在学校是主要学习WEB开发的，所以一直希望自己能够在实习时得到一些这方面的工作经验，在接下来的两个月，我便被leader调到web组进行一个公司内部的项目管理系统的开发。 &nbsp;&nbsp;&nbsp;&nbsp;在做第二个项目之前，我不会想到这个项目的短短一个多月比我之前所有时间加起来都学到的多。因为这个项目几乎是由我独自完成前端与后台代码的编写，而且使用的是我之前没有任何经验的PHP语言进行开发。领导要求一个月内完成整个项目的开发，所以压力非常大。我一边在工作中学习，工作，一边再回到寝室后仍查资料学习希望能够把这个项目做到最好。前端方面我更加熟悉了jquery和bootstrap框架以及html/css，后端方面我又掌握了新的技能–PHP。从数据库的设计到前端页面的设计，再到后台业务代码的编写，投入了自己非常大的精力。不管最后结果如何，这个项目经历的确使我对于web开发的相关技术知识增长不少。在经历了一个多月的边学边做，最后总算（不是很完美的）完成了这项工作。 &nbsp;&nbsp;&nbsp;&nbsp;9月，由于学校开学以及准备毕业找工作（想找Java开发的岗位），便不能继续在公司继续实习，对于这里很不舍，因为这儿是一个工作气氛非常舒服愉快的地方。在这里我遇到了很多和我一起在这里实习的小伙伴，也结识了很多已经毕业很多年工作近十年的朋友，我相信这些人和事在未来的日子里都是我最宝贵的财富，而这次的实习经历也希望将会是我走上成功的路上的一块踏板。希望自己的努力能够对得起自己的理想！]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
        <tag>实习</tag>
        <tag>三星</tag>
        <tag>shell自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Write a Blog in English]]></title>
    <url>%2Fblog%2F19951025%2FWrite-a-blog-in-English%2F</url>
    <content type="text"><![CDATA[Improve my spoken English now, and written, listen Wrote date: 2019-11-05 21:55:46 It’s my third week in ThoughtWorks. And today afternoon, Sam who worked in REA and on business trip here made a session. Obviously, in English. I didn’t understand most contents. Almost all of the session for me is difficully. Except English, I also cannot understand some abbreviations and I didn’t used the services and tools which he refered. Tomorrow, I’ll show a card to customers which I paired with Benqing. To tell them what we did and what we are going to do for this card. Emmm.. How to say, it’s magically, working in a foreign company. Lots of smart people and interesting colleagues. Before I entried TW I thought that this is not a company with good technology, but I’m wrong, at least I am the worst one. Keep going, man! Don’t be discouraged! When you want to do something succed, just like you want breath every second, you will success.]]></content>
      <categories>
        <category>English study</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
        <tag>English study</tag>
        <tag>English blogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Second Day on the Job in ThoughtWorks]]></title>
    <url>%2Fblog%2F19951025%2FThe-second-day-on-the-job-in-ThoughtWorks%2F</url>
    <content type="text"><![CDATA[date: 2019-10-22 20:41:42 来到了一个我曾经羡慕的公司大学毕业之后，我去了杭州，同花顺，一个说起来还是某行业顶尖的服务提供商，算是很有名的大公司吧，但是却是996。甚至不止996，我曾经一段时间连着每天2、3点下班。每当我看到一个去了TW的大学同学的朋友圈之后，我承认我酸了。 上图就是在TW的同学，出差去泰国时候的朋友圈。我当时就在想，难道大学毕业之后去一个“奋斗比”公司，真的就比在一个“养老型”公司技术提升的就快么？后来我仔细想了下，如果真的是一个好学的人，在一个轻松的公司，照样每天下班后可以学习，而如果在一个业务繁重的公司中的话，也许每天因为敲业务代码，学习、看书的时间都没有了，更何况出去玩？ 所以，我很羡慕去TW工作的，尤其是，这算是为数不多的在西安的比较好点儿的公司了。 然而也许是命运看到了我的愿望，两年后的昨天，我入职了ThoughtWorks。 入职感受第一天入职的时候，感觉公司好小好拥挤（不过后来知道是在同一层楼的三幢楼都有办公区域），而且好吵。然后工作常用语言是英语，想了想自己的英语水平，瞬间就怂了。第一天就乖乖的找个每人的角落，配置下电脑，办理一下入职流程。 今天是我入职的第二天，我被带到了一个项目组。对国外的客户做了英文的自我介绍（还好自我介绍这种东西我之前也都有准备过）。然后中午参加了一场与国外客户的英文视频会议。 其实感受就是，尽快把英语练好，然后努力工作，接下来的日子，好好生活吧。下一个目标就是出国工作喽！]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【陈年风楼】VLOG-000001 一个普通的程序员的普通的一天]]></title>
    <url>%2Fblog%2F19951025%2Fvlog-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[发布于2018-04-21 10:21:02 博客日期就不放在前面了]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的内心比拳头更强大]]></title>
    <url>%2Fblog%2F19951025%2F%E4%BD%A0%E7%9A%84%E5%86%85%E5%BF%83%E6%AF%94%E6%8B%B3%E5%A4%B4%E6%9B%B4%E5%BC%BA%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[加密博客请输入密码访问 Decrypt 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]]></content>
      <categories>
        <category>个人随笔</category>
      </categories>
      <tags>
        <tag>个人随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[突然有一种很强烈的无力感]]></title>
    <url>%2Fblog%2F19951025%2F%E7%AA%81%E7%84%B6%E6%9C%89%E4%B8%80%E7%A7%8D%E5%BE%88%E5%BC%BA%E7%83%88%E7%9A%84%E6%97%A0%E5%8A%9B%E6%84%9F%2F</url>
    <content type="text"><![CDATA[突然有一种很强烈的无力感2019-07-07 23点30分刚刚打完三把游戏很罪恶。。。因为自己应该是把晚上这些时间用来学习的但是看到网上那些厉害的大牛他们的一些阿里的面经都答得很好了，却又倒在了HR面我不知道我接下来应该去为自己制定一个怎样的计划了感觉自己应该学习的非常多，但是时间却不够我是个急性子吧？却又有拖延症，做事情又犹豫不决姥姥给家里重新装修不知道花了多少钱昨天没忍住在健身房又办了2800 的一月的私教股票里面还亏着一万多明天上班又会是用怎样摸鱼划水的方式度过？看到B站上一个在国外(加拿大)工作的女生，每天的生活朝九晚五，开着宝马上班看着也是没工作几年的样子我想国外的程序员才配叫程序员吧，国内的只能叫码农在努力进一个像阿里这样的大公司又能怎么样呢？享受福报？给领导卖命？2019年以来感觉自己活在了一个乌云笼罩的一段人生里我知道这一段人生很快会过去后面肯定会越来越舒服的只是不知道是因为习惯了这种平庸的生活而舒服还是会通过自己的努力过上一个真正舒服的生活目前的公司很烂，很烦项目很水，技术很烂，领导很无能，我依然很菜没多少进步我究竟犯了多少错误命运才会让我刚毕业的前几年过的这么坎坷我现在已经有一个中彩票的梦想了(已经被逼到这种地步了唉)如果真的让我有资本随便辞职，我回去拿着钱环游世界的看遍地球上每一个角落，领略那些享受着福报的人永远看不到的风景阿门！]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>个人随笔</tag>
      </tags>
  </entry>
</search>
