<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈年风楼 | 博客</title>
  
  <subtitle>当你看到了一座山，一定会想再看看山的后面是什么！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangjiaheng.cn/"/>
  <updated>2019-06-13T12:42:36.178Z</updated>
  <id>http://zhangjiaheng.cn/</id>
  
  <author>
    <name>陈年风楼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树的几种非递归遍历</title>
    <link href="http://zhangjiaheng.cn/blog/20190613/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <id>http://zhangjiaheng.cn/blog/20190613/二叉树的几种非递归遍历/</id>
    <published>2019-06-13T09:36:48.000Z</published>
    <updated>2019-06-13T12:42:36.178Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190613/二叉树的几种非递归遍历/fm.jpg" alt="封面"></p><a id="more"></a><h2 id="二叉树的几种非递归遍历解法"><a href="#二叉树的几种非递归遍历解法" class="headerlink" title="二叉树的几种非递归遍历解法"></a>二叉树的几种非递归遍历解法</h2><p>二叉树的递归遍历想必了解递归以及二叉树的同学都能够轻松写出正确答案，然而二叉树的非递归遍历确是很多人难以理解学会的，所以我在这里进行一下归纳总结，主要是复习巩固一下这方面的知识。</p><h3 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将根节点入栈</li><li>然后循环判断栈不为空</li><li>则弹出栈顶元素</li><li>如果弹出元素的右子树不为空则入栈</li><li>如果弹出元素的左子树不为空则入栈</li><li>继续循环</li></ul><p>解析：由于先序遍历为[根-左-右]，所以根节点应该先入栈，然后出栈的同时依次入栈右-左子树即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void frontPrintByLoop(TreeNode root) &#123;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + &quot; | &quot;);</span><br><span class="line">            if (node.right != null) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left != null) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将根节点入栈</li><li>循环判断根节点是否有左子树，有则入栈继续循环，否则循环结束</li><li>然后循环判断栈不为空</li><li>则弹出栈顶元素</li><li>如果栈顶元素右子树不为空</li><li>则循环入栈右子树及其右子树的左子树</li><li>继续循环</li></ul><p>解析：因为中序遍历为[左-根-又]，所以树的左子树应该先入栈，循环入栈左子树之后循环出栈，出栈的同时判断出栈元素是否有右子树，如果右子树不为空则对右子树执行相同的操作，即入栈右子树的左子树。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void midPrintByLoop(TreeNode root) &#123;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        while (node.left != null) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            TreeNode n = node.right;</span><br><span class="line">            while (n != null) &#123;</span><br><span class="line">                stack.push(n);</span><br><span class="line">                n = n.left;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(node.val + &quot; | &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h4><ul><li>逆向思考先序遍历，因为后序遍历为[根-左-右]，我们可以以类似先序遍历的方式先将[右-左-根]的顺序找出来存入另一个栈，然后再依次出栈该栈元素即可</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void lastPrintByOtherStack(TreeNode root) &#123;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">        final Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        final Stack&lt;TreeNode&gt; stackReverse = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">                stackReverse.push(node);</span><br><span class="line">                if (node.left != null) &#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node.right != null) &#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!stackReverse.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stackReverse.pop();</span><br><span class="line">            System.out.print(node.val + &quot; | &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h4><ul><li>只使用一个栈</li><li>先将根节点入栈</li><li>设置一个标识引用 h首先指向root</li><li>循环判断栈非空</li><li>在循环中判断栈顶元素node</li><li>如果node左子树不为空并且左右子树都不为h指向的元素</li><li>入栈左子树</li><li>否则再判断右子树是否为空以及右子树是否为h节点</li><li>入栈右子树</li><li>否则，弹出栈顶元素，并且将h指向该弹出的栈顶元素</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码 2"></a>代码 2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void lastPrintByOneStack(TreeNode root) &#123;</span><br><span class="line">    if (null != root) &#123;</span><br><span class="line">        TreeNode h = root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            if (node.left != null &amp;&amp; node.left != h &amp;&amp; node.right != h) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; else if (null != node.right &amp;&amp; node.right != h) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                System.out.print(node.val + &quot; | &quot;);</span><br><span class="line">                h = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：使用一个栈进行后序遍历的时候需要使用一个h引用来标识上一个节点是否被遍历过，是的话就往上判断之后的树节点即可。</p><h3 id="按层遍历二叉树"><a href="#按层遍历二叉树" class="headerlink" title="按层遍历二叉树"></a>按层遍历二叉树</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>以上前中后序遍历二叉树都是用到了栈这种数据结构，而按层遍历二叉树就非常简单了，只需要引入先入先出的队列，然后依次在出队的时候将出队元素的左右子树入队即可。</p><ul><li>根节点入队</li><li>队列不为空则开始循环</li><li>如果队首元素左子树不为空，就入队</li><li>右子树不为空，也入队</li><li>队首元素出队输出</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void levelPrintOutTree(TreeNode root) &#123;</span><br><span class="line">    if (null != root) &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        TreeNode i = root;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            if (i.left != null) &#123;</span><br><span class="line">                queue.add(i.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (i.right != null) &#123;</span><br><span class="line">                queue.add(i.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i.val + &quot; | &quot;);</span><br><span class="line">            queue.poll();</span><br><span class="line">            i = queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190613/二叉树的几种非递归遍历/fm.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>深度分析如何写出一个线程安全的单例</title>
    <link href="http://zhangjiaheng.cn/blog/20190607/%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B/"/>
    <id>http://zhangjiaheng.cn/blog/20190607/深度分析如何写出一个线程安全的单例/</id>
    <published>2019-06-07T12:51:33.000Z</published>
    <updated>2019-06-10T16:07:17.237Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190607/深度分析如何写出一个线程安全的单例/fm.png" alt="封面"></p><a id="more"></a><h3 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h3><p>单例模式是在Java编程中除了工厂模式之外最常用的创建型设计模式之一。单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。</p><p><strong>单例模式在创建时的注意事项：</strong></p><ul><li>因为每个类只能创建一个实例，所以需要将其构造方法封闭起来不能被外部调用，即私有化；</li><li>需要提供一个获取类实例的公有方法，所有使用该类实例的人都通过这个方法拿到单例对象；</li><li>在多线程环境下需要注意线程安全问题，避免多个线程同时创建出多个不同的实例，违背了单例的原则。</li></ul><h3 id="创建单例模式的方法及其优缺点"><a href="#创建单例模式的方法及其优缺点" class="headerlink" title="创建单例模式的方法及其优缺点"></a>创建单例模式的方法及其优缺点</h3><h4 id="饿汉型"><a href="#饿汉型" class="headerlink" title="饿汉型"></a>饿汉型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line">private static final HungrySingleton INSTANCE = new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 私有构造</span><br><span class="line">     */</span><br><span class="line">    private HungrySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取类在加载的时候就创建好的实例</span><br><span class="line">     */</span><br><span class="line">    public static HungrySingleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：饿汉型单例是最简单的单例创建方法，在类中维护一个该类私有不可变的实例，然后提供一个获取该实例的静态方法即可。</li><li>优点：代码编写简单，线程安全（使用类加载机制保证线程安全，classloader在加载类的时候使用synchronized同步）</li><li>缺点：无法实现懒加载，在使用较少的时候浪费资源，无法防止反射破坏以及反序列化破坏单例唯一性</li></ul><h4 id="普通懒汉型"><a href="#普通懒汉型" class="headerlink" title="普通懒汉型"></a>普通懒汉型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static LazySingleton INSTANCE ;</span><br><span class="line"></span><br><span class="line">    private LazySingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance()&#123;</span><br><span class="line">        if(null == INSTANCE)&#123;</span><br><span class="line">            INSTANCE = new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：这种懒汉型单例也是一种比较简单的单例实现方式，与第一种不同在于这种实例是在调用获取实例的静态方法的时候才创建</li><li>优点：代码简单，可以实现懒加载</li><li>缺点：多线程环境下会有线程安全问题，多个线程同时走到第8行代码，判断实例未创建，则会创建出多个实例;无法防止反射破坏以及反序列化破坏</li></ul><p><em>那么为了实现线程安全我们可以在方法上加上同步关键字，但是这种方式的缺点就是多线程环境调用该方法都会阻塞，导致性能存在不必要的浪费</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public synchronized static LazySingleton getInstance()&#123;</span><br><span class="line">if(null == INSTANCE)&#123;</span><br><span class="line">INSTANCE = new LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line">return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="双重检测锁实现懒加载单例"><a href="#双重检测锁实现懒加载单例" class="headerlink" title="双重检测锁实现懒加载单例"></a>双重检测锁实现懒加载单例</h4><p>上述懒汉型同步机制可以改进如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleLockSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private DoubleLockSingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static DoubleLockSingleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    public static DoubleLockSingleton getInstance() &#123;</span><br><span class="line">// 进入方法后先判断一次 大幅减少多线程环境同步阻塞问题 </span><br><span class="line">// 但是这种方式在多线程第一次调用创建实例的时候会出现线程安全问题</span><br><span class="line">        if (null == INSTANCE) &#123;</span><br><span class="line">            synchronized (DoubleLockSingleton.class) &#123;</span><br><span class="line">                if (null == INSTANCE) &#123;</span><br><span class="line">// 问题的根源所在</span><br><span class="line">// 此处可能会出现指令重排序 </span><br><span class="line">// new对象并不是原子操作</span><br><span class="line">INSTANCE = new DoubleLockSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：双重检测锁机制在进入<code>getInstance()</code>方法的时候会判断实例是否被创建，如果被创建，那么直接返回，如果没有，进入同步代码块，创建实例。这个方法貌似没有问题，而且还大大减少线程进入同步代码块阻塞的情况（因为只有第一次判断对象还没有创建的时候才会有线程进入同步代码块）。但是这种方法仍然存在线程安全性问题。<font color="#db1414">问题出在第17行：<code>INSTANCE = new DoubleLockSingleton();</code>由于JVM虚拟机内部会对代码进行优化，在使用new创建对象的时候并不是一个原子操作且会被虚拟机进行指令重排序。这个步骤会被分成三步：<strong>1、在堆上为对象分配空间；2、对象进行初始化；3、将引用指向该堆上的地址。 </strong>由于在虚拟机中，指令重排序优化导致第2步和第3步的执行顺序可以被打乱，那么在代码执行到第11行的时候发现，INSTANCE不为null，直接返回一个未初始化完成的对象，导致程序崩溃。</font><strong>注意：synchronzed关键字没有屏蔽指令重排序的功能</strong>，那么如何优化呢？答案是使用<code>volatile</code>关键字修饰实例变量引用，即<code>private volatile static TripleLockSingleton INSTANCE;</code>。<code>volatile</code>关键字才有屏蔽指令重排序的语义。</li><li>优点：多线程环境下大部分时间线程安全</li><li>缺点：有可能会出现线程安全问题；不能避免反射和反序列化破坏</li><li>优化：<code>private volatile static TripleLockSingleton INSTANCE;</code></li></ul><h4 id="静态内部类单例"><a href="#静态内部类单例" class="headerlink" title="静态内部类单例"></a>静态内部类单例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StaticInnerClassSingleton &#123;</span><br><span class="line">    private StaticInnerClassSingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        public static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static StaticInnerClassSingleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：静态内部类实现单例也是借助了类加载的线程安全机制，并同时基于内部类的使用时再创建的懒加载机制实现线程安全的懒加载模式的单例</li><li>优点：线程安全，可以实现懒加载</li><li>缺点：无法防止被反射以及反序列化破坏单例的唯一性</li></ul><h4 id="枚举类单例"><a href="#枚举类单例" class="headerlink" title="枚举类单例"></a>枚举类单例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public static EnumSingleton getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：<strong>Joshua Bloch</strong>大神说过：“单元素的枚举类型已经成为实现Singleton的最佳方法”。足以见证枚举类在创建单例中的优势。</li><li>优点：代码简单，线程安全，可以防止反射和反序列化破坏</li><li>缺点：暂无</li></ul><h4 id="CAS创建单例"><a href="#CAS创建单例" class="headerlink" title="CAS创建单例"></a>CAS创建单例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CASSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static final AtomicReference&lt;CASSingleton&gt; INSTANCE = new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private CASSingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用原子操作 实现获取唯一实例</span><br><span class="line">     * 理论上在大量竞争的环境中 原子操作自旋等待消耗大量性能 但是实际上当一个线程创建好实例之后其余线程不会出现死循环</span><br><span class="line">     * 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</span><br><span class="line">     */</span><br><span class="line">    public static CASSingleton getInstance() &#123;</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            CASSingleton instance = INSTANCE.get();</span><br><span class="line">            if (null != instance) &#123;</span><br><span class="line">                return instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = new CASSingleton();</span><br><span class="line">            if (INSTANCE.compareAndSet(null, instance)) &#123;</span><br><span class="line">                return instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：使用原子操作<code>AtomicReference</code>进行单例的创建，事实上目前相对于双重检查锁性能上差的也不是也别大</li><li>优点：线程安全，懒加载，相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</li><li>缺点：代码编写相对复杂，不能防止被反射和反序列化破坏</li></ul><h3 id="防止反射和反序列化破坏单例的方式"><a href="#防止反射和反序列化破坏单例的方式" class="headerlink" title="防止反射和反序列化破坏单例的方式"></a>防止反射和反序列化破坏单例的方式</h3><p>上述几个创建单例的方式中，除了使用枚举类创建单例，都会产生被反射和反序列化破坏的情况，避免该问题的方式如下，大家需要深究的话可以打开搜索引擎… 这里不再展开了~</p><h4 id="枚举类防止反射和反序列化破坏"><a href="#枚举类防止反射和反序列化破坏" class="headerlink" title="枚举类防止反射和反序列化破坏"></a>枚举类防止反射和反序列化破坏</h4><blockquote><p><strong> 参考文章：<a href="https://www.cnblogs.com/chiclee/p/9097772.html" target="_blank" rel="noopener">https://www.cnblogs.com/chiclee/p/9097772.html</a> </strong></p></blockquote><h4 id="防止反射破坏"><a href="#防止反射破坏" class="headerlink" title="防止反射破坏"></a>防止反射破坏</h4><p>因为反射是通过class对象来调用类的构造方法创建对象的，我们只需要在构造方法中进行判断，如果实例已经存在，就抛出异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 私有构造</span><br><span class="line"> */</span><br><span class="line">private Singleton() &#123;</span><br><span class="line">if(INSTANCE != null)&#123;</span><br><span class="line">throw new RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="防止反序列化破坏"><a href="#防止反序列化破坏" class="headerlink" title="防止反序列化破坏"></a>防止反序列化破坏</h4><p>在反序列化的时候<code>ObjectInputStream.readObject()</code>中会去判断是否存在<code>readResolve()</code>方法，如果存在的话会调用该方法返回一个实例，所以在单例类中编写<code>readResolve()</code>方法返回<code>INSTANCE</code>即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在反序列化时，直接调用这个方法，返回指定的对象，无需再新建一个对象</span><br><span class="line">private Object readResolve() &#123;</span><br><span class="line">return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190607/深度分析如何写出一个线程安全的单例/fm.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="单例模式" scheme="http://zhangjiaheng.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(三)：CountDownLatch的实现原理及使用</title>
    <link href="http://zhangjiaheng.cn/blog/20190602/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%89-%EF%BC%9ACountDownLatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://zhangjiaheng.cn/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/</id>
    <published>2019-06-02T13:36:53.000Z</published>
    <updated>2019-06-16T15:50:23.830Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png" alt="什么是CountDownLatch？"></p><a id="more"></a><h3 id="什么是CountDownLatch？"><a href="#什么是CountDownLatch？" class="headerlink" title="什么是CountDownLatch？"></a>什么是<code>CountDownLatch</code>？</h3><p>  在本篇博客的封面，我放了一个截图，上面对于<code>CountDownLatch</code>的翻译是这样的：<em>闭锁，倒计时门闩</em>。其实顾名思义，<code>CountDownLatch</code>实际上就是一个计数器：<strong>计数-计数完成后做一些事</strong>。其实这个东西可以类比为一个水坝：当水还没有装满水库的时候水坝是关闭的，当水装满之后开闸放水，水库中的水”一起”涌出水库。</p><p>  拥有同样功能的还有<code>CyclicBarrier</code>这个类，但是这个类相对较复杂，并且相对于<code>CountDownLatch</code>还可以重复使用，实际上前者一般被叫做线程计数器，后者被叫做循环屏障，还是有很大区别的。这个 <strong>在后面再进行源码学习</strong>。</p><h3 id="CountDownLatch是如何实现的？"><a href="#CountDownLatch是如何实现的？" class="headerlink" title="CountDownLatch是如何实现的？"></a><code>CountDownLatch</code>是如何实现的？</h3><p>  同<code>ReentrantLock</code>类似，内部也是有一个实现了<code>AbstractQueueSynchronizer</code>的内部类。内部类做了父类的共享式的显示锁的方法实现，维护一个初始为N的状态<code>state</code>，每次有线程调用之后阻塞，然后<code>state</code>减1，直到减为0之后所有阻塞的线程重新开始执行。</p><h4 id="首先是内部类Sync的实现"><a href="#首先是内部类Sync的实现" class="headerlink" title="首先是内部类Sync的实现"></a>首先是内部类Sync的实现</h4><p>  构造器接收一个int参数初始化state的值。<code>tryAcquireShared()</code>方法不会对state做改变，当state不为0的时候返回-1即失败，当state等于0其返回1，表示计数器已经计数完成，<code>await()</code>方法不再阻塞。<code>tryReleaseShared()</code>方法会使用原子操作当<code>countDown()</code>被调用的时候释放一个state的占用，即state-1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">      private static final long serialVersionUID = 4982264981922014374L;</span><br><span class="line">      Sync(int count) &#123;</span><br><span class="line">          setState(count);</span><br><span class="line">      &#125;</span><br><span class="line">      int getCount() &#123;</span><br><span class="line">          return getState();</span><br><span class="line">      &#125;</span><br><span class="line">      protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">          return (getState() == 0) ? 1 : -1;</span><br><span class="line">      &#125;</span><br><span class="line">      protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">          // Decrement count; signal when transition to zero</span><br><span class="line">          for (;;) &#123;</span><br><span class="line">              int c = getState();</span><br><span class="line">              if (c == 0)</span><br><span class="line">                  return false;</span><br><span class="line">              int nextc = c-1;</span><br><span class="line">              if (compareAndSetState(c, nextc))</span><br><span class="line">                  return nextc == 0;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch的countDown方法"><a href="#CountDownLatch的countDown方法" class="headerlink" title="CountDownLatch的countDown方法"></a>CountDownLatch的countDown方法</h4><p>  countDown方法主要作用就是使state-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AQS中的<code>releaseShared()</code>方法的实现，如果释放成功执行<code>doReleaseShared();</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch的await方法"><a href="#CountDownLatch的await方法" class="headerlink" title="CountDownLatch的await方法"></a>CountDownLatch的await方法</h4><p>  await方法会等待当前state值是否是0，如果不是的话就一直阻塞。直到state为0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean await(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AQS中的<code>acquireSharedInterruptibly()</code>方法实现如下，在AQS的实现中，判断当前线程是否中断，是的话抛出中断异常，否则判断当前线程是否继续需要阻塞，即调用<code>tryAcquireShared()</code>。是的话进入<code>doAcquireSharedInterruptibly()</code>方法，不断的判断<code>int r = tryAcquireShared(arg);</code>，state如果一直不等于0，r就一直是负数，就会继续进入循环。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * Acquires in shared interruptible mode.</span><br><span class="line"> * @param arg the acquire argument</span><br><span class="line"> */</span><br><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实以上代码的整体流程非常简单，即初始化<code>CountDownLatch</code>的state=N，每次调用countDown时state-1，减到0的时候停止阻塞，继续向下执行。</p><h3 id="我可以用CountDownLatch来做什么事情？"><a href="#我可以用CountDownLatch来做什么事情？" class="headerlink" title="我可以用CountDownLatch来做什么事情？"></a>我可以用<code>CountDownLatch</code>来做什么事情？</h3><h4 id="使用CountDownLatch模拟并发场景"><a href="#使用CountDownLatch模拟并发场景" class="headerlink" title="使用CountDownLatch模拟并发场景"></a>使用<code>CountDownLatch</code>模拟并发场景</h4><ul><li>可以使用<code>CountDownLatch</code>，创建多个线程并等待线程全部就绪之后唤醒所有线程。可以用这种方式测试代码的可用性，或者测试单例类等；</li></ul><p>我在自己学习过程中也有写过类似的测试类 - <a href="https://github.com/Fatezhang/Concurrent/tree/master/src/main/java/com/mime/concurrent/CountDownLatchStudy" target="_blank" rel="noopener">github</a></p><h4 id="使用CountDownLatch等待依赖线程执行"><a href="#使用CountDownLatch等待依赖线程执行" class="headerlink" title="使用CountDownLatch等待依赖线程执行"></a>使用<code>CountDownLatch</code>等待依赖线程执行</h4><ul><li><code>CountDownLatch</code>用来等待其他依赖服务都启动好之后在进行自身线程的任务处理</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  <code>CountDownLatch</code>是面试的时候多线程这块很容易被问到的点，实际上会考察这几个方面：</p><ul><li>1、内部实现原理 <strong>——</strong> 使用内部类继承AQS实现；</li><li>2、需要注意的方面 <strong>——</strong> 计数器为0时，await后面的方法才会执行，否则一直阻塞，countDown方法尽量写在finally代码块中，避免出现异常导致死锁；</li><li>3、使用场景 <strong>——</strong> 监控一些依赖服务启动完成之后执行代码，或者造“水坝”，即模拟大量并发场景等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png&quot; alt=&quot;什么是CountDownLatch？&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AQS" scheme="http://zhangjiaheng.cn/tags/AQS/"/>
    
      <category term="CountDownLatch" scheme="http://zhangjiaheng.cn/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>编写自己的SpringMVC框架</title>
    <link href="http://zhangjiaheng.cn/blog/20190531/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84SpringMVC%E6%A1%86%E6%9E%B6/"/>
    <id>http://zhangjiaheng.cn/blog/20190531/编写自己的SpringMVC框架/</id>
    <published>2019-05-31T07:25:00.000Z</published>
    <updated>2019-06-09T02:45:01.420Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190531/编写自己的SpringMVC框架/aaa.jpeg" alt="封面"><br><a id="more"></a></p><h2 id="Summer项目"><a href="#Summer项目" class="headerlink" title="Summer项目"></a>Summer项目</h2><p><strong><a href="https://github.com/Fatezhang/Summer" target="_blank" rel="noopener">项目github地址</a></strong></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>Summer项目是本人在学习Spring源码的时候按照SpringMVC的流程编写的一个简易的SpringMVC框架，主要完成以下功能：<ul><li>读取配置文件进行包的扫描</li><li>对所有加入注解的bean进行装配</li><li>对加了注解的字段进行依赖自动注入</li><li>URL与相应方法的映射</li><li>请求的分发处理</li></ul></li></ul><p>项目通过实现以上流程完成SpringMVC框架工作的整体过程演示</p><h3 id="以下是框架流程的详细步骤说明"><a href="#以下是框架流程的详细步骤说明" class="headerlink" title="以下是框架流程的详细步骤说明"></a>以下是框架流程的详细步骤说明</h3><h4 id="项目的结构"><a href="#项目的结构" class="headerlink" title="项目的结构"></a>项目的结构</h4><p>Summer项目仅仅是一个单独的Servlet项目，没有引入Spring相关的任何依赖，仅仅使用了一些外部的工具类，我的pom.xml文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.10&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;9.3.12.v20160915&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><p>项目使用jetty启动，所以我还配置了jetty插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;!-- jetty插件 --&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.1.26&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt;</span><br><span class="line">          &lt;contextPath&gt;/Summer&lt;/contextPath&gt;</span><br><span class="line">          &lt;connectors&gt;</span><br><span class="line">            &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt;</span><br><span class="line">              &lt;port&gt;4000&lt;/port&gt;</span><br><span class="line">            &lt;/connector&gt;</span><br><span class="line">          &lt;/connectors&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br></pre></td></tr></table></figure></p><h4 id="整体框架结构"><a href="#整体框架结构" class="headerlink" title="整体框架结构"></a>整体框架结构</h4><p><img src="/blog/20190531/编写自己的SpringMVC框架/zj.png" alt="注解"><br>除了自定义的这几个注解之外其他的就和平常编写Controller以及Service的流程一样，我的核心代码主要在MyServlet中</p><h4 id="MyServlet主要做了什么"><a href="#MyServlet主要做了什么" class="headerlink" title="MyServlet主要做了什么"></a>MyServlet主要做了什么</h4><h5 id="加载配置文件，首先读取web-xml中配置的配置文件"><a href="#加载配置文件，首先读取web-xml中配置的配置文件" class="headerlink" title="加载配置文件，首先读取web.xml中配置的配置文件"></a>加载配置文件，首先读取web.xml中配置的配置文件</h5><p>把扫描到的所有类全链路径名保存在list中</p><blockquote><p>以下是servlet的配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;!-- 声明Servlet对象 --&gt;</span><br><span class="line">    &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!-- 上面一句指定Servlet对象的名称 --&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.zhang.summer.servlet.MyServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;!-- 上面一句指定Servlet对象的完整位置，包含包名和类名 --&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:config.properties&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;!-- 下面一句是在启动时加载servlet --&gt;</span><br><span class="line">    &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;!-- 映射Servlet --&gt;</span><br><span class="line">    &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!--&lt;servlet-name&gt;与上面&lt;Servlet&gt;标签的&lt;servlet-name&gt;元素相对应，不可以随便起名  --&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;!-- 上面一句话用于映射访问URL --&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><h5 id="遍历所有类，使用反射创建对象class-forName"><a href="#遍历所有类，使用反射创建对象class-forName" class="headerlink" title="遍历所有类，使用反射创建对象class.forName"></a>遍历所有类，使用反射创建对象<code>class.forName</code></h5><p>创建对象，将所有我们声明了自己注解的类加入到一个Map中，即IOC-Map</p><h5 id="遍历IOC-Map中的所有对象，进行依赖注入"><a href="#遍历IOC-Map中的所有对象，进行依赖注入" class="headerlink" title="遍历IOC-Map中的所有对象，进行依赖注入"></a>遍历IOC-Map中的所有对象，进行依赖注入</h5><p>在这里我只判断是<code>@MyController</code>注解的类才进行依赖注入</p><h5 id="处理URL和方法之间的映射"><a href="#处理URL和方法之间的映射" class="headerlink" title="处理URL和方法之间的映射"></a>处理URL和方法之间的映射</h5><p>将注解了<code>@MyRequestMapping</code>的类和方法路径拼接起来，对方法和拼接起来的url路径进行映射，并且对方法参数做特殊处理</p><h5 id="请求分发"><a href="#请求分发" class="headerlink" title="请求分发"></a>请求分发</h5><p>在doGet或者doPost请求中通过映射好的url-method找到方法进行请求的分发处理</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190531/编写自己的SpringMVC框架/aaa.jpeg&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringMVC框架" scheme="http://zhangjiaheng.cn/categories/SpringMVC%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Spring" scheme="http://zhangjiaheng.cn/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://zhangjiaheng.cn/tags/SpringMVC/"/>
    
      <category term="Servlet" scheme="http://zhangjiaheng.cn/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(二)：使用AQS编写可重入锁</title>
    <link href="http://zhangjiaheng.cn/blog/20190525/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%EF%BC%9A%E4%BD%BF%E7%94%A8AQS%E7%BC%96%E5%86%99%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <id>http://zhangjiaheng.cn/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/</id>
    <published>2019-05-25T06:07:35.000Z</published>
    <updated>2019-06-16T15:50:27.102Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/aqs.png" alt="AQS中文文档介绍"></p><div style="width:100%;text-align: center;"><a href="http://www.matools.com/api/java8" target="_blank" rel="noopener">AQS中文文档介绍</a></div><a id="more"></a><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong> <a href="/blog/20190517/编写一个简易的可重入锁-一/">上一章</a> </strong> 我使用实现<code>Lock</code>接口的方式并结合<code>Synchronized</code>关键字实现了自己的可重入锁，学习并了解了可重入锁的原理机制。这一章我在学习了AQS之后结合AQS实现自己的显示可重入锁。</p><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>如上所述，Java8中文文档中描述的，AQS即<code>AbstractQueuedSynchronizer</code>。它提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状态。 子类必须定义改变此状态的受保护方法，以及根据该对象被获取或释放来定义该状态的含义。 给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。<strong>子类应定义为非公共内部助手类，用于实现其封闭类的同步属性。 AbstractQueuedSynchronizer类不实现任何同步接口。 相反，它定义了一些方法，如acquireInterruptibly(int) ，可以通过具体的锁和相关同步器来调用适当履行其公共方法。</strong></p><p>其实AQS类是一个使用了模板方法模式的抽象框架类。它将核心实现封装在模板方法中，提供给程序员去实现具体的加锁和释放的机制，以便于实现一些特殊功能的锁，比如JDK提供的可重入锁和可重入读写锁等等。</p><h3 id="如何使用AQS"><a href="#如何使用AQS" class="headerlink" title="如何使用AQS"></a>如何使用AQS</h3><p><strong>AQS在使用的时候主要需要重写以下方法</strong></p><ul><li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><h3 id="使用AQS实现自己的可重入独占非公平锁的伪代码如下"><a href="#使用AQS实现自己的可重入独占非公平锁的伪代码如下" class="headerlink" title="使用AQS实现自己的可重入独占非公平锁的伪代码如下"></a>使用AQS实现自己的可重入独占非公平锁的伪代码如下</h3><h4 id="加锁步骤伪代码"><a href="#加锁步骤伪代码" class="headerlink" title="加锁步骤伪代码"></a>加锁步骤伪代码</h4><p>线程调用<code>lock</code>方法加锁，直接调用<code>sync.acquire(1);</code>，具体实现在<code>tryAcquire</code></p><ul><li>首先线程进入想要获取锁</li><li>拿到当前线程的引用</li><li>判断加锁状态，如果是未加锁状态<ul><li>使用<code>compareAndSetState</code>自旋原子操作加锁</li><li>设置当前线程</li><li>返回true加锁成功</li></ul></li><li>如果是加锁状态<ul><li>判断是否是当前线程重入</li><li>如果是当前线程重入，state加1，并返回true加锁成功</li></ul></li><li>最后如果都不是就返回false加锁失败</li></ul><h4 id="释放锁步骤伪代码"><a href="#释放锁步骤伪代码" class="headerlink" title="释放锁步骤伪代码"></a>释放锁步骤伪代码</h4><p>线程调用<code>unLock</code>方法加锁，直接调用<code>sync.release(1);</code>，具体实现在<code>tryRelease</code></p><ul><li>首先线程进入方法想要释放锁</li><li>判断如果不是当前线程，就抛出异常</li><li>如果是当前线程，state就减1（arg一般为1），表示释放一次</li><li>当state释放到0时，设置拥有锁的线程为null，然后返回true</li></ul><p><strong>具体的代码实现如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author zhangjiaheng</span><br><span class="line"> * @Description 使用AQS重写一个可重入锁</span><br><span class="line"> **/</span><br><span class="line">public class MyReentrantLockByAQS implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    private Sync sync = new Sync();</span><br><span class="line"></span><br><span class="line">    // 内部类Sync ReentrantLock使用的内部抽象类 并派生两个子类实现两种(公平/非公平)锁</span><br><span class="line">    private class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">            Thread t = Thread.currentThread();</span><br><span class="line">            // 如果第一个线程进来 可以拿到锁 则返回true</span><br><span class="line"></span><br><span class="line">            // 如果第二个线程进来 如果不等于当前线程 返回false 否则更新当前线程值</span><br><span class="line"></span><br><span class="line">            int state = getState();</span><br><span class="line">            if (state == 0) &#123;</span><br><span class="line">                while (compareAndSetState(0, 1)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(t);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (t == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                // 当前线程再进来</span><br><span class="line">                setState(getState() + 1);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected boolean tryRelease(int arg) &#123;</span><br><span class="line">            // 锁的获取和释放时一一对应的</span><br><span class="line">            // 调用此方法的线程肯定是当前线程</span><br><span class="line">            if (Thread.currentThread() != getExclusiveOwnerThread()) &#123;</span><br><span class="line">                throw new RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">            int c = getState() - arg;</span><br><span class="line">            boolean flag = false;</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">                flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            return flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Condition newCondition() &#123;</span><br><span class="line">            return newCondition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.tryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/aqs.png&quot; alt=&quot;AQS中文文档介绍&quot;&gt;&lt;/p&gt;
&lt;div style=&quot;width:100%;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.matools.com/api/java8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AQS中文文档介绍&lt;/a&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AQS" scheme="http://zhangjiaheng.cn/tags/AQS/"/>
    
      <category term="可重入锁" scheme="http://zhangjiaheng.cn/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(一)：编写一个简易的可重入锁</title>
    <link href="http://zhangjiaheng.cn/blog/20190517/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E4%B8%80/"/>
    <id>http://zhangjiaheng.cn/blog/20190517/编写一个简易的可重入锁-一/</id>
    <published>2019-05-17T12:22:23.000Z</published>
    <updated>2019-06-16T15:50:20.607Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190517/编写一个简易的可重入锁-一/nullIsMistake.jpg" alt="封面"></p><a id="more"></a><h4 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h4><p>在Java多线程编程中，锁是用来控制代码操作的原子性的重要机制，即对某线程共享的数据进行操作的时候，保证该操作同一时间段只有一个线程操作，整个过程是原子操作，其他线程再操作的时候只能等待锁的释放(排他锁)。一般我们的锁都是声明在方法上或者代码块中，那么在实际编程中我们经常会出现一个类的实例方法调用另一个实例方法的情况，我们不希望这个时候同一个线程进入另一实例方法时还要再去等待锁的释放，可重入锁就是为了解决这个问题，即 <strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>。</p><h4 id="如何实现一个简单的可重入锁"><a href="#如何实现一个简单的可重入锁" class="headerlink" title="如何实现一个简单的可重入锁"></a>如何实现一个简单的可重入锁</h4><ul><li>首先加锁的时候需要记录当前是哪一个线程加锁，加锁之后加锁标志位标记锁已被占用</li><li>维护一个加锁计数器，线程每次加锁计数器都要加1，每释放一次计数器减1</li><li>当非占用锁的线程进来之后自旋等待锁的释放，如果锁还在被占用，就wait();</li><li>所释放的时候只有当前获取锁的线程调用才有用，锁释放加锁计数器减1，当减到0的时候，加锁标志位置为false，然后唤醒其他等待的线程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class MyLock implements Lock &#123;</span><br><span class="line"></span><br><span class="line">    private boolean locked = false;// 当前锁是否已经被线程使用</span><br><span class="line"></span><br><span class="line">    private int lockCount;// 保存当前线程加锁的次数</span><br><span class="line"></span><br><span class="line">    private Thread thread;// 保存当前线程是哪一个</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 自旋等待</span><br><span class="line">            // 可重入：如果获取锁的不是当前线程并且当前已经有线程加锁，则等待</span><br><span class="line">            while (locked &amp;&amp; Thread.currentThread() != this.thread) &#123;</span><br><span class="line">                System.out.println(&quot;我等会儿。。。&quot;);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果没有线程使用锁或者获取锁的是当前线程 加锁计数器+1 然后thread指向获取锁的线程</span><br><span class="line">            this.thread = Thread.currentThread();</span><br><span class="line">            lockCount++;</span><br><span class="line">            locked = true;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放锁的操作</span><br><span class="line">     */</span><br><span class="line">    public synchronized void unlock() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果不是当前线程 不需要做任何操作</span><br><span class="line">            if(this.thread == Thread.currentThread())&#123;</span><br><span class="line">                // 锁计数器减1 如果当前线程获取锁个数释放完成</span><br><span class="line">                lockCount--;</span><br><span class="line">                if(lockCount == 0 )&#123;</span><br><span class="line">                    // 释放完成 加锁标志置为false 再唤醒等待锁的线程</span><br><span class="line">                    locked = false;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在Java中常用的可重入锁"><a href="#在Java中常用的可重入锁" class="headerlink" title="在Java中常用的可重入锁"></a>在Java中常用的可重入锁</h4><ul><li>synchronized 关键字加锁</li><li>java.util.concurrent.locks.ReentrantLock</li><li>java.util.concurrent.locks.ReentrantReadWriteLock<blockquote><p>上述ReentrantLock内部实际上还是使用AQS，关于AQS，后面还要进行学习与整理</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190517/编写一个简易的可重入锁-一/nullIsMistake.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="可重入锁" scheme="http://zhangjiaheng.cn/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://zhangjiaheng.cn/blog/20190512/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://zhangjiaheng.cn/blog/20190512/无重复字符的最长子串/</id>
    <published>2019-05-12T06:36:15.000Z</published>
    <updated>2019-05-24T12:17:00.767Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190512/无重复字符的最长子串/bb.png" alt="封面"></p><h4 id="算法题解：无重复字符的最长子串"><a href="#算法题解：无重复字符的最长子串" class="headerlink" title="算法题解：无重复字符的最长子串"></a>算法题解：无重复字符的最长子串</h4><p>leetcode地址： <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">leetcode</a></p><blockquote><p><strong>题目：</strong> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="解法1：暴力求解"><a href="#解法1：暴力求解" class="headerlink" title="解法1：暴力求解"></a>解法1：暴力求解</h4><ul><li><p>思路：遍历字符串，以每一个字符作为子串的起始字符，向后查找直到遇到和该字符相同的字符，记录长度，依次执行直到找到最长长度。</p></li><li><p>题解如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> public int maxIndexStrLength(String s) &#123;</span><br><span class="line">   int maxLength = 0;</span><br><span class="line">   for (int index = 0; index &lt; s.length(); index++) &#123;</span><br><span class="line"></span><br><span class="line">       int length = 1;</span><br><span class="line">       int i = index + 1;</span><br><span class="line">       for (; ; ) &#123;</span><br><span class="line">           if (i &gt;= s.length()) &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           String ts = s.substring(index, i);</span><br><span class="line">           char c = s.charAt(i);</span><br><span class="line">           if (ts.contains(c + &quot;&quot;)) &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           length++;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       maxLength = maxLength &gt; length ? maxLength : length;</span><br><span class="line">   &#125;</span><br><span class="line">   return maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="解法2：滑动窗口法"><a href="#解法2：滑动窗口法" class="headerlink" title="解法2：滑动窗口法"></a>解法2：滑动窗口法</h4><ul><li>思路：在使用暴力解法时我们会发现实际上对于无重复子串来讲，我们产生了一些冗余的判断操作。例如对于串<code>sdabcabcbb</code>，判断了子串<code>sdabc</code>之后，当后面再出现字符<code>a</code>，那么重复字符之前的串直接舍弃就好。即直接从<code>bca</code>…开始判断即可。这样可以减少大量的不必要的判断与计算操作。</li><li>题解如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int maxIndexStrLength(String s) &#123;</span><br><span class="line">  HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">  int start = 0, max = 0;</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">      char c = s.charAt(i);</span><br><span class="line">      //如果当前元素与滑动窗口中的元素重复：</span><br><span class="line">      if (map.containsKey(c) &amp;&amp; map.get(c) &gt;= start) &#123;</span><br><span class="line">          max = Math.max(max, i - start);</span><br><span class="line">          start = map.get(c) + 1;</span><br><span class="line">          //如果当前元素与滑动窗口中的元素不重复，但已经遍历到了最后一个字符：</span><br><span class="line">      &#125; else if (i == s.length() - 1) &#123;</span><br><span class="line">          max = Math.max(max, i - start + 1);</span><br><span class="line">      &#125;</span><br><span class="line">      map.put(c, i);</span><br><span class="line">  &#125;</span><br><span class="line">  return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>滑动窗口法的思路可以用来解决很多字符串相关的问题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190512/无重复字符的最长子串/bb.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;算法题解：无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#算法题解：无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;算法题解：无重复字符的最长子串&quot;&gt;&lt;/a&gt;算法题解：无重复字符的最长子串&lt;/h4&gt;&lt;p&gt;leetcode地址： &lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt; 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;abcabcbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化和transient关键字的理解与学习</title>
    <link href="http://zhangjiaheng.cn/blog/20190511/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8Ctransient%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zhangjiaheng.cn/blog/20190511/Java序列化和transient关键字的理解与学习/</id>
    <published>2019-05-11T12:44:31.000Z</published>
    <updated>2019-05-14T14:25:03.211Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h4><p><img src="/blog/20190511/Java序列化和transient关键字的理解与学习/xuliehua.png" alt="Java序列化过程"></p><blockquote><p>在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。</p></blockquote><a id="more"></a><h5 id="Java中如何进行序列化与反序列化"><a href="#Java中如何进行序列化与反序列化" class="headerlink" title="Java中如何进行序列化与反序列化"></a>Java中如何进行序列化与反序列化</h5><ul><li><p>在Java中，对象一般是无法进行序列化与反序列化的。而使得对象能够被序列化的方式也很简单，即实现接口 <code>Serializable</code> 。如下代码即将对象序列化以及反序列化的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestSerializable implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String name;</span><br><span class="line">    TestSerializable() &#123;</span><br><span class="line">        age = 20;</span><br><span class="line">        name = &quot;aachuanpu&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        TestSerializable test = new TestSerializable();</span><br><span class="line">        File file = new File(&quot;e:/test.txt&quot;);</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class="line">        System.out.println(newTest.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h5><ul><li>serialVersionUID作为实现序列化接口的一个非必须非必须声明的静态常量经常不被开发者所重视，忘记声明。其实serialVersionUID的作用是为了保证序列化之前和之后的对象是同一对象。我们知道JVM判断对象是否相同是根据对象的类路径全限定名确定的，而虚拟机决定一个对象是否允许序列化和反序列化成这个类还取决于其serialVersionUID是否一致。不一致的话会导致<code>java.io.InvalidClassException的异常</code>，也可以不指定serialVersionUID，如果不指定的话java会根据class计算serialVersionUID。</li><li>对于两个相同的类及拥有相同的serialVersionUID，如果两个类字段不一致也会序列化和反序列化成功。这时Java会在反序列化的时候忽略掉不一致的字段。</li></ul><h5 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h5><ul><li><p>在序列化的时候，静态变量能够被序列化成功吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TestSerializable implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    public static String staticName;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String name;</span><br><span class="line">    TestSerializable() &#123;</span><br><span class="line">        age = 20;</span><br><span class="line">        name = &quot;aachuanpu&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        TestSerializable test = new TestSerializable();</span><br><span class="line">        TestSerializable.staticName = &quot;name11111&quot;;</span><br><span class="line">        File file = new File(&quot;e:/test.txt&quot;);</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        TestSerializable.staticName = &quot;name222&quot;;</span><br><span class="line">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class="line">        System.out.println(newTest.name);</span><br><span class="line">        System.out.println(TestSerializable.staticName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上代码会输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aachuanpu</span><br><span class="line">name222</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li><li><p>如上所见：将对象序列化之后，修改静态变量的值，再将对象反序列化，输出的静态变量的值是修改之后的。即序列化保存的是对象的状态，静态变量属于类，因此序列化并不保存静态变量。</p></li></ul><h5 id="transient关键字与自定义序列化"><a href="#transient关键字与自定义序列化" class="headerlink" title="transient关键字与自定义序列化"></a>transient关键字与自定义序列化</h5><ul><li><p>对象的序列化是将对象中的数据写入本地文件或者用于网络传输的过程，但是很多时候会有一些数据无需进行序列化保存起来或者传输出去。我们可以使用<code>transient</code>关键字修饰成员变量。那么在Java序列化的时候就<strong>不会使用Java本身的序列化方式对其进行序列化</strong>。但是我们依然可以自定义自己的序列化行为对其进行序列化！</p><p><strong>自定义序列化：</strong> 定义自己的<code>writeObject</code>和<code>readObject</code>方法</p></li><li><p>对于使用transient修饰的成员变量，可以编写<code>writeObject</code>和<code>readObject</code>方法实现对于该成员变量(不仅仅只是针对该成员变量)的自定义序列化。在编写<code>writeObject</code>和<code>readObject</code>方法的时候需要注意的地方在于：这俩方法没有在Object中定义，也没有在<code>Serializable</code>接口中声明，JVM是如何调用到这俩方法的呢？答案是通过反射，去根据方法名和参数寻找到相应的方法，找到之后会被ObjectOutputStream调用，没有这俩方法就调用默认的序列化呗。还有就是因为ObjectOutputStream使用getPrivateMethod，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。</p></li><li><p>通过这种方法，我们实现自己的序列化与反序列化可以实现很多场景下的需求。比如网络传输的时候对于特殊字段进行加密等等。</p></li><li><p>如下，你会发现我在这俩方法中调用了defaultWriteObject()和defaultReadObject()用于处理未被transient修饰的成员变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class TestSerializable implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    public static String staticName;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private transient String name;</span><br><span class="line">    TestSerializable() &#123;</span><br><span class="line">        age = 20;</span><br><span class="line">        name = &quot;aachuanpu&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        TestSerializable test = new TestSerializable();</span><br><span class="line">        TestSerializable.staticName = &quot;name11111&quot;;</span><br><span class="line">        File file = new File(&quot;e:/test.txt&quot;);</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        TestSerializable.staticName = &quot;name222&quot;;</span><br><span class="line">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class="line">        System.out.println(newTest.name);</span><br><span class="line">        System.out.println(TestSerializable.staticName);</span><br><span class="line">    &#125;</span><br><span class="line">    private void writeObject(ObjectOutputStream oos) throws IOException &#123;</span><br><span class="line">        oos.defaultWriteObject();</span><br><span class="line">        name = &quot;自定义名称&quot;;</span><br><span class="line">        oos.writeObject(name);</span><br><span class="line">        System.out.println(&quot;调用writeObject&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ois.defaultReadObject();</span><br><span class="line">        String name = (String) ois.readObject();</span><br><span class="line">        this.name = name;</span><br><span class="line">        System.out.println(&quot;读出的name=&quot; + name);</span><br><span class="line">        System.out.println(&quot;调用readObject&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">调用writeObject</span><br><span class="line">读出的name=自定义名称</span><br><span class="line">调用readObject</span><br><span class="line">自定义名称</span><br><span class="line">name222</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li></ul><h5 id="父类的序列化"><a href="#父类的序列化" class="headerlink" title="父类的序列化"></a>父类的序列化</h5><ul><li>一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取 父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都 是默认声明的值。</li></ul><h5 id="常问：ArrayList中数组使用transient修饰为何还能被序列化"><a href="#常问：ArrayList中数组使用transient修饰为何还能被序列化" class="headerlink" title="常问：ArrayList中数组使用transient修饰为何还能被序列化"></a>常问：ArrayList中数组使用transient修饰为何还能被序列化</h5><p>  <strong>ArrayList源码：</strong><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br></pre></td></tr></table></figure></p><p>  transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。但是ArrayList又是可序行化的类，elementData是ArrayList具体存放元素的成员，用transient来修饰elementData，需要实现自己的序列化方式去处理。即对于数组中多余的空间不去进行序列化。如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span><br><span class="line"> * is, serialize it).</span><br><span class="line"> *</span><br><span class="line"> * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span><br><span class="line"> *             instance is emitted (int), followed by all of its elements</span><br><span class="line"> *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span><br><span class="line"> */</span><br><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    throws java.io.IOException&#123;</span><br><span class="line">    // Write out element count, and any hidden stuff</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    // Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    // Write out all elements in the proper order.</span><br><span class="line">    for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (modCount != expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span><br><span class="line"> * deserialize it).</span><br><span class="line"> */</span><br><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">    throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    // Read in size, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    // Read in capacity</span><br><span class="line">    s.readInt(); // ignored</span><br><span class="line"></span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        // be like clone(), allocate array based upon size not capacity</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        // Read in all elements in the proper order.</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  <strong>elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。</strong></p><h5 id="其余补充"><a href="#其余补充" class="headerlink" title="其余补充"></a>其余补充</h5><p><a href="https://bluepopopo.iteye.com/blog/486548" target="_blank" rel="noopener">来自文章</a> ← 点击链接查看参考博客</p><blockquote><p>1.Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值;</p></blockquote><blockquote><p>2.Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。Serializable是内建支持的也就是直接implement即可，但Externalizable的实现类必须提供readExternal和writeExternal实现。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。</p></blockquote><blockquote><p>3.正如Effectvie Java中提到的，序列化就如同另外一个构造函数，只不过是有由stream进行创建的。如果字段有一些条件限制的，特别是非可变的类定义了可变的字段会反序列化可能会有问题。可以在readObject方法中添加条件限制，也可以在readResolve中做。参考56条“保护性的编写readObject”和“提供一个readResolve方法”。</p></blockquote><blockquote><p>4.当有非常复杂的对象需要提供deep clone时，可以考虑将其声明为可序列化，不过缺点也显而易见，性能开销。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Java序列化&quot;&gt;&lt;a href=&quot;#Java序列化&quot; class=&quot;headerlink&quot; title=&quot;Java序列化&quot;&gt;&lt;/a&gt;Java序列化&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/blog/20190511/Java序列化和transient关键字的理解与学习/xuliehua.png&quot; alt=&quot;Java序列化过程&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="序列化" scheme="http://zhangjiaheng.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="transient关键字" scheme="http://zhangjiaheng.cn/tags/transient%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>你的内心比拳头更强大</title>
    <link href="http://zhangjiaheng.cn/blog/20190509/%E4%BD%A0%E7%9A%84%E5%86%85%E5%BF%83%E6%AF%94%E6%8B%B3%E5%A4%B4%E6%9B%B4%E5%BC%BA%E5%A4%A7/"/>
    <id>http://zhangjiaheng.cn/blog/20190509/你的内心比拳头更强大/</id>
    <published>2019-05-09T15:37:36.000Z</published>
    <updated>2019-05-11T13:05:40.677Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">加密博客请输入密码访问</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      最近真的很不开心，将烦躁的感受记录下来吧~
    
    </summary>
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>使用[幕布]创建Java知识体系思维导图</title>
    <link href="http://zhangjiaheng.cn/blog/20190507/%E4%BD%BF%E7%94%A8-%E5%B9%95%E5%B8%83-%E5%88%9B%E5%BB%BAJava%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://zhangjiaheng.cn/blog/20190507/使用-幕布-创建Java知识体系思维导图/</id>
    <published>2019-05-07T11:24:43.000Z</published>
    <updated>2019-05-07T14:05:50.990Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190507/使用-幕布-创建Java知识体系思维导图/java_core.png" alt="Java思维导图"></p><a id="more"></a><p><strong>昨天在V2EX上逛的时候突然发现有人推荐一个很不错的东西——幕布。我本身就是一个对一些名称很敏感的人，看到这个名字就很想知道这到底是个什么东西，没想到竟偶然发现这么一个好东西。</strong></p><p>幕布是一个制作笔记与记录事件的文本编辑工具（这样说要把幕布开发者气死了哈哈）。编辑视图如下：<br><img src="/blog/20190507/使用-幕布-创建Java知识体系思维导图/mb.png" alt="幕布"><br>一键转换成思维导图就是本文最上面的那个图片。</p><p>其实我个人是比较喜欢幕布的一键转换思维导图的功能，以及它的导出.mm文件的功能，而且可以自动同步云端。这样就可以随时随地无论是在电脑还是手机上都可以打开来编辑以及查看了。</p><p>这里是我自己编写的<a href="https://mubu.com/doc/hpBd1e5h6z" target="_blank" rel="noopener">Java知识体系</a>，还没有写的很完整。希望自己能够坚持不断更新知识点，总结与巩固自己的技术水平！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190507/使用-幕布-创建Java知识体系思维导图/java_core.png&quot; alt=&quot;Java思维导图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树与完全二叉树</title>
    <link href="http://zhangjiaheng.cn/blog/20190504/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://zhangjiaheng.cn/blog/20190504/二叉搜索树与完全二叉树/</id>
    <published>2019-05-04T02:29:36.000Z</published>
    <updated>2019-06-13T12:42:36.178Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h4><p>在数据结构中，对于树，每一个分支，称之为一个度。那么，度最大为2的树我们称之为二叉树。通常子树我们会称之为左子树和右子树。二叉树通常用于实现二叉查找树和二叉堆。那么在Java中如何定义一个二叉树节点？</p><p>首先，每一个节点需要有一个值域。其次，其还应该持有两个树节点的引用，即指向自己的左子树和自己的右子树。</p><a id="more"></a><p>具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">        this.val = 0;</span><br><span class="line">        this.left = null;</span><br><span class="line">        this.right = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = null;</span><br><span class="line">        this.right = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;(&quot; + val + &quot;)[left:&quot; + left + &quot;,right:&quot; + right + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="如何创建二叉树"><a href="#如何创建二叉树" class="headerlink" title="如何创建二叉树"></a>如何创建二叉树</h4><p>二叉树的节点的数据结构已经用Java代码表示出来了，那么如何用这些节点来构造出一个完整的二叉树呢？请看下图二叉树的结构：</p><p><img src="/blog/20190504/二叉搜索树与完全二叉树/ecs.png" alt="二叉树结构"></p><p>如上图，对于一个二叉树，需要有一个根节点。每个节点最多有两课子树，分别区分左子树还是右子树。即就算有一个子树，还是需要区分是左子树还是右子树。创建二叉树我们只需要将每一个树节点按照这样的规则连接起来即可。</p><h5 id="创建二叉搜索树"><a href="#创建二叉搜索树" class="headerlink" title="创建二叉搜索树"></a>创建二叉搜索树</h5><ul><li>概念：二叉搜索树，又叫二叉查找树。他是一棵特殊的二叉树，对于二叉搜索树中的每一个节点，它的左子树都不大于父节点，右子树都不小于父节点。空树是特殊的二叉搜索树。</li><li><p>创建：本例根据一个已有的数组进行二叉树的创建，基本的思路就是遍历数组，每个元素创建一个树节点，然后继续根据节点值得大小向下遍历判断，最后将值域小的放在节点的左子树，将值大的放在节点的右子树即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static TreeNode createSearchTree(int[] a) &#123;</span><br><span class="line">    if (a.length &gt; 0) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(a[0]);</span><br><span class="line">        for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">            TreeNode c = root;</span><br><span class="line">            TreeNode p = c;</span><br><span class="line">            TreeNode q = new TreeNode(a[i]);</span><br><span class="line">            while (c != null) &#123;</span><br><span class="line">                p = c;</span><br><span class="line">                if (a[i] &lt;= c.val) &#123;</span><br><span class="line">                    c = c.left;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = c.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (q.val &lt; p.val) &#123;</span><br><span class="line">                p.left = q;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p.right = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特点：二叉搜索树在应用于经常查找元素的场景效率会比较快，因为它的数据结构类似于二分查找，查找元素时根据其特性向下搜索即可。</p></li></ul><h5 id="创建完全二叉树"><a href="#创建完全二叉树" class="headerlink" title="创建完全二叉树"></a>创建完全二叉树</h5><ul><li><p>概念：首先介绍一下满二叉树：即树中的所有节点除了叶节点都有左子树和右子树，叶节点的左右子树都为空，这样的树称之为满二叉树。而对于一棵完全二叉树，只有树的最后一层连续缺失右边节点。满二叉树一定是完全二叉树，反之则不一定成立。如图分别是一棵满二叉树和一棵完全二叉树：<br><img src="/blog/20190504/二叉搜索树与完全二叉树/mecs.png" alt="满二叉树"><br><img src="/blog/20190504/二叉搜索树与完全二叉树/wqecs.png" alt="完全二叉树"></p></li><li><p>创建： 完全二叉树的创建需要按层去创建。这边我们借助队列的特点，将二叉树的节点连接起来，构造成完全二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static TreeNode createWholeTree(int[] a) &#123;</span><br><span class="line">        if (a.length &gt; 0) &#123;</span><br><span class="line">            LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">            TreeNode root = new TreeNode(a[0]);</span><br><span class="line">            queue.add(root);</span><br><span class="line">            int index = 0;</span><br><span class="line">            for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">                TreeNode curn = queue.get(index);</span><br><span class="line">                TreeNode ti = new TreeNode(a[i]);</span><br><span class="line">                queue.add(ti);</span><br><span class="line">                if (curn.left == null) &#123;</span><br><span class="line">                    curn.left = ti;</span><br><span class="line">                &#125; else if (curn.right == null) &#123;</span><br><span class="line">                    curn.right = ti;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>特点：对于一个h层的完全二叉树，前h-1层是满的，第h层连续缺失右边节点。所以叶子结点只能出现在最下层和次下层，最下层的叶子结点集中在树的左部，倒数第二层若存在叶子结点，一定在右部连续位置，如果结点度为1，则该结点只有左孩子，即没有右子树，同样结点数目的二叉树，完全二叉树深度最小。</p></li></ul><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><ul><li><p>前中后序递归遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 递归先序遍历二叉树 左-根-右</span><br><span class="line"> */</span><br><span class="line">public static void frontPrintOutTree(TreeNode root) &#123;</span><br><span class="line">    if (null != root) &#123;</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        frontPrintOutTree(root.left);</span><br><span class="line">        frontPrintOutTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递归中序遍历二叉树 左-根-右</span><br><span class="line"> */</span><br><span class="line">public static void midPrintOutTree(TreeNode root) &#123;</span><br><span class="line">    if (null != root) &#123;</span><br><span class="line">        midPrintOutTree(root.left);</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        midPrintOutTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递归先序遍历二叉树 左-根-右</span><br><span class="line"> */</span><br><span class="line">public static void lastPrintOutTree(TreeNode root) &#123;</span><br><span class="line">    if (null != root) &#123;</span><br><span class="line">        lastPrintOutTree(root.left);</span><br><span class="line">        lastPrintOutTree(root.right);</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按层遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 按层遍历二叉树</span><br><span class="line"> */</span><br><span class="line">public static void levelPrintOutTree(TreeNode root) &#123;</span><br><span class="line">    if (null != root) &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        TreeNode i = root;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            if (i.left != null) &#123;</span><br><span class="line">                queue.add(i.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (i.right != null) &#123;</span><br><span class="line">                queue.add(i.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i.val);</span><br><span class="line">            queue.poll();</span><br><span class="line">            i = queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="以上代码的github地址：GITHUB地址"><a href="#以上代码的github地址：GITHUB地址" class="headerlink" title="以上代码的github地址：GITHUB地址"></a>以上代码的github地址：<a href="https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/src/main/java/DataStructure/Tree" target="_blank" rel="noopener">GITHUB地址</a></h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是二叉树？&quot;&gt;&lt;a href=&quot;#什么是二叉树？&quot; class=&quot;headerlink&quot; title=&quot;什么是二叉树？&quot;&gt;&lt;/a&gt;什么是二叉树？&lt;/h4&gt;&lt;p&gt;在数据结构中，对于树，每一个分支，称之为一个度。那么，度最大为2的树我们称之为二叉树。通常子树我们会称之为左子树和右子树。二叉树通常用于实现二叉查找树和二叉堆。那么在Java中如何定义一个二叉树节点？&lt;/p&gt;
&lt;p&gt;首先，每一个节点需要有一个值域。其次，其还应该持有两个树节点的引用，即指向自己的左子树和自己的右子树。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>如何在Springboot服务启动之后执行一些代码(三种方式)</title>
    <link href="http://zhangjiaheng.cn/blog/20190419/%E5%A6%82%E4%BD%95%E5%9C%A8springboot%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81(%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F)/"/>
    <id>http://zhangjiaheng.cn/blog/20190419/如何在springboot服务启动之后执行一些代码(三种方式)/</id>
    <published>2019-04-19T09:01:21.000Z</published>
    <updated>2019-05-07T09:48:29.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  通常的我们的项目开发中，经常会遇到那种在服务一启动就需要自动执行一些业务代码的情况。比如将数据库中的配置信息或者数据字典之类的缓存到redis，或者在服务启动的时候将一些配置化的定时任务开起来。关于spring mvc或者springboot如何在项目启动的时候就执行一些代码，方法其实有很多，我这边介绍一下我使用过的三种。</p>  <a id="more"></a><h4 id="1、-PostConstruct-注解"><a href="#1、-PostConstruct-注解" class="headerlink" title="1、@PostConstruct 注解"></a>1、<code>@PostConstruct</code> 注解</h4><p>从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，<code>@PostConstruct</code>和<code>@PreDestroy</code>，这两个注解被用来修饰一个非静态的void（）方法。<code>@PostConstruct</code>会在所在类的构造函数执行之后执行，在init()方法执行之前执行。(<code>@PreDestroy</code>注解的方法会在这个类的destory()方法执行之后执行。)</p><ul><li>使用示例：在Spring容器加载之后，我需要启动定时任务去做任务的处理（我的定时任务采用的是读取数据库配置的方式）。在这里我使用<code>@PostConstruct</code> 指定了需要启动的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Component // 注意 这里必须有</span><br><span class="line">public class StartAllJobInit &#123;</span><br><span class="line"></span><br><span class="line">    protected Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class="line">    @Autowired</span><br><span class="line">    JobInfoService jobInfoService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    JobTaskUtil jobTaskUtil;</span><br><span class="line"></span><br><span class="line">    @PostConstruct // 构造函数之后执行</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        System.out.println(&quot;容器启动后执行&quot;);</span><br><span class="line">        startJob();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void startJob() &#123;</span><br><span class="line">        List&lt;JobInfoBO&gt; list = jobInfoService.findList();</span><br><span class="line">        for (JobInfoBO jobinfo :list) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if(&quot;0&quot;.equals(jobinfo.getStartWithrun()))&#123;</span><br><span class="line">                    logger.info(&quot;任务&#123;&#125;未设置自动启动。&quot;, jobinfo.getJobName());</span><br><span class="line">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    logger.info(&quot;任务&#123;&#125;设置了自动启动。&quot;, jobinfo.getJobName());</span><br><span class="line">                    jobTaskUtil.addOrUpdateJob(jobinfo);</span><br><span class="line">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SchedulerException e) &#123;</span><br><span class="line">                logger.error(&quot;执行定时任务出错，任务名称 &#123;&#125; &quot;, jobinfo.getJobName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、实现CommandLineRunner接口并重写run-方法"><a href="#2、实现CommandLineRunner接口并重写run-方法" class="headerlink" title="2、实现CommandLineRunner接口并重写run()方法"></a>2、实现<code>CommandLineRunner</code>接口并重写run()方法</h4><p><code>CommandLineRunner</code>接口文档描述如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within</span><br><span class="line"> * a &#123;@link SpringApplication&#125;. Multiple &#123;@link CommandLineRunner&#125; beans can be defined</span><br><span class="line"> * within the same application context and can be ordered using the &#123;@link Ordered&#125;</span><br><span class="line"> * interface or &#123;@link Order @Order&#125; annotation.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * If you need access to &#123;@link ApplicationArguments&#125; instead of the raw String array</span><br><span class="line"> * consider using &#123;@link ApplicationRunner&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @author Dave Syer</span><br><span class="line"> * @see ApplicationRunner</span><br><span class="line"> */</span><br><span class="line">public interface CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Callback used to run the bean.</span><br><span class="line"> * @param args incoming main method arguments</span><br><span class="line"> * @throws Exception on error</span><br><span class="line"> */</span><br><span class="line">void run(String... args) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所说：接口被用作加入Spring容器中时执行run(String… args)方法，通过命令行传递参数。SpringBoot在项目启动后会遍历所有实现CommandLineRunner的实体类并执行run方法，多个实现类可以并存并且根据order注解排序顺序执行。这边还有个<code>ApplicationRunner</code>接口，但是接收参数是使用的<code>ApplicationArguments</code>。这边不再赘述。</p><p><strong>同样是启动时执行定时任务，使用这种方式我的写法如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Component // 注意 这里必须有</span><br><span class="line">//@Order(2) 如果有多个类需要启动后执行 order注解中的值为启动的顺序</span><br><span class="line">public class StartAllJobInit implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    protected Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class="line">    @Autowired</span><br><span class="line">    JobInfoService jobInfoService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    JobTaskUtil jobTaskUtil;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) &#123;</span><br><span class="line">        List&lt;JobInfoBO&gt; list = jobInfoService.findList();</span><br><span class="line">        for (JobInfoBO jobinfo :list) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if(&quot;0&quot;.equals(jobinfo.getStartWithrun()))&#123;</span><br><span class="line">                    logger.info(&quot;任务&#123;&#125;未设置自动启动。&quot;, jobinfo.getJobName());</span><br><span class="line">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    logger.info(&quot;任务&#123;&#125;设置了自动启动。&quot;, jobinfo.getJobName());</span><br><span class="line">                    jobTaskUtil.addOrUpdateJob(jobinfo);</span><br><span class="line">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SchedulerException e) &#123;</span><br><span class="line">                logger.error(&quot;执行定时任务出错，任务名称 &#123;&#125; &quot;, jobinfo.getJobName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、使用ContextRefreshedEvent事件-上下文件刷新事件"><a href="#3、使用ContextRefreshedEvent事件-上下文件刷新事件" class="headerlink" title="3、使用ContextRefreshedEvent事件(上下文件刷新事件)"></a>3、使用<code>ContextRefreshedEvent</code>事件(上下文件刷新事件)</h4><blockquote><p>ContextRefreshedEvent 官方在接口上的doc说明<br><br>Event raised when an {@code ApplicationContext} gets initialized or refreshed.</p></blockquote><p>ContextRefreshedEvent是Spring的ApplicationContextEvent一个实现，ContextRefreshedEvent 事件会在Spring容器初始化完成后以及刷新时触发。</p><p><strong>在这里我需要在springboot程序启动之后加载配置信息和字典信息到Redis缓存中去，我可以这样写：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component // 注意 这个也是必须有的注解 三种都需要 使spring扫描到这个类并交给它管理</span><br><span class="line">public class InitRedisCache implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">    static final Logger logger = LoggerFactory</span><br><span class="line">            .getLogger(InitRedisCache.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SysConfigService sysConfigService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SysDictService sysDictService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) &#123;</span><br><span class="line">        logger.info(&quot;-------加载配置信息 start-------&quot;);</span><br><span class="line">        sysConfigService.loadConfigIntoRedis();</span><br><span class="line">        logger.info(&quot;-------加载配置信息 end-------&quot;);</span><br><span class="line"></span><br><span class="line">        logger.info(&quot;-------加载字典信息 start-------&quot;);</span><br><span class="line">        sysDictService.loadDictIntoRedis();</span><br><span class="line">        logger.info(&quot;-------加载字典信息 end-------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这种方式在springmvc-spring的项目中使用的时候会出现执行两次的情况。这种是因为在加载spring和springmvc的时候会创建两个容器，都会触发这个事件的执行。这时候只需要在<code>onApplicationEvent</code>方法中判断是否有父容器即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">  public void onApplicationEvent(ContextRefreshedEvent event) &#123;  </span><br><span class="line">      if(event.getApplicationContext().getParent() == null)&#123;//root application context 没有parent，他就是老大.  </span><br><span class="line">           //需要执行的逻辑代码，当spring容器初始化完成后就会执行该方法。  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上，就是我在实际开发中常用的三种，在项目启动时执行代码的方式，开发者可以根据不同的使用情况选择合适的方法去执行自己的业务逻辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;  通常的我们的项目开发中，经常会遇到那种在服务一启动就需要自动执行一些业务代码的情况。比如将数据库中的配置信息或者数据字典之类的缓存到redis，或者在服务启动的时候将一些配置化的定时任务开起来。关于spring mvc或者springboot如何在项目启动的时候就执行一些代码，方法其实有很多，我这边介绍一下我使用过的三种。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="spring" scheme="http://zhangjiaheng.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Java内存分配与垃圾回收的复习整理</title>
    <link href="http://zhangjiaheng.cn/blog/20190414/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <id>http://zhangjiaheng.cn/blog/20190414/Java内存分配与垃圾回收的复习整理/</id>
    <published>2019-04-14T13:18:36.000Z</published>
    <updated>2019-05-22T12:36:48.900Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190414/Java内存分配与垃圾回收的复习整理/zy.png" alt="摘要"></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>众所周知Java作为一个“一次编译，到处运行”的编译型语言，JVM虚拟机当之无愧的是Java语言世界的先锋将军。作为一个Java程序员，JVM虚拟机其相关知识是我们必须要了解以及深入掌握的重点。在本篇博客我将总结一下JVM虚拟机的内存结构、对象内存分配以及垃圾回收算法。这也是经常找工作求职必问的点。</p><a id="more"></a><h3 id="Java内存分配与垃圾回收的复习整理"><a href="#Java内存分配与垃圾回收的复习整理" class="headerlink" title="Java内存分配与垃圾回收的复习整理"></a>Java内存分配与垃圾回收的复习整理</h3><h4 id="Java内存区域划分"><a href="#Java内存区域划分" class="headerlink" title="Java内存区域划分"></a>Java内存区域划分</h4><p>Java虚拟机在执行Java程序的过程中会将它所管理的内存划分为若干个不同的区域。每个区域各司其职，其创建与销毁数据的规则也都各不相同。根据《Java虚拟机规范（Java SE 7版）》的规定，主要分为如下图几个区域。</p><p><img src="/blog/20190414/Java内存分配与垃圾回收的复习整理/jvm.png" alt="Java内存划分"></p><ul><li><strong>程序计数器</strong>：当前线程执行字节码的行号指示器。[<em>线程私有</em>]</li><li><strong>虚拟机栈</strong>：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。平常我们所说的Java虚拟机划分为堆和栈中的“栈”中的一部分就是虚拟机栈。其中局部变量表存放着编译期可知的所有基本数据类型、对象引用等。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法所需要的帧的大小是已经确定了的。[<em>线程私有</em>]</li><li><strong>本地方法栈</strong>：与虚拟机栈发挥的作用相似，只不过这个区域执行的是native方法，即由c/c++或者其他语言编写的方法。[<em>线程私有</em>]</li><li><strong>Java堆</strong>：用来存放对象实例，即我们最熟悉的一块区域。Java堆是垃圾收集器管理的主要区域，所以有时也叫“GC堆”。[<em>线程共享</em>]</li><li><strong>方法区</strong>：用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 [<em>线程共享</em>]</li><li><strong>运行时常量池</strong>：这是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。[<em>线程共享</em>]</li></ul><h4 id="常用的垃圾回收算法"><a href="#常用的垃圾回收算法" class="headerlink" title="常用的垃圾回收算法"></a>常用的垃圾回收算法</h4><blockquote><p>在Java代码中，我们程序员通常只关注广义上的“栈”和“堆”这两种区域。上述划分的Java内存区域告诉我们，栈是朝生夕死的一块区域，当线程进入的时候，栈空间被分配，线程结束之后，栈的内存空间即被回收用来去做其他的任务，栈中的栈帧随着线程的进入与退出有条不紊的执行着入栈和出栈的操作，每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的。而堆却不同，我们只有在程序运行期间才会知道创建那些对象，这部分内存分配和回收都是动态的。都由虚拟机的垃圾回收器进行“已死”对象的回收。</p></blockquote><h5 id="如何判断对象已死"><a href="#如何判断对象已死" class="headerlink" title="如何判断对象已死"></a>如何判断对象已死</h5><ul><li><strong>引用计数法</strong>：给对象添加一个引用计数器，每当有引用指向它时计数器加1，引用失效后计数器减1。垃圾回收器回收对象计数器为0的对象昂即可。但是当出现对象之间循环引用，而对象却无实际作用的时候，这种方式就会出现内存泄漏。</li><li><strong>可达性分析</strong>：通过一系列的称为“GC ROOTS”的对象作为起点，向下搜索，搜索走过的路径都称为引用链，当一个对象到“GC ROOTS”没有引用链的时候，证明这个对象不可达。此时会被判定为可回收对象。（此时并非一定死亡，在此之后还会进行两次标记处理，与finalize()方法有关，此处不再整理。注意一个知识点：任何对象的finalize()方法只会被系统调用一次，并且不建议使用）</li></ul><blockquote><p>知道哪些对象是“垃圾”，接下来就是回收操作了</p></blockquote><h5 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h5><ul><li>首先标记出所有需要回收的对象，然后统一回收。是最基础的回收算法。</li><li>不足之处：1、效率低下，标记和清除的效率都不高；2、产生大量内存碎片，使得之后程序要分配大对象却没有空间，不得不除法GC。</li></ul><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><ul><li>首先将内存区域划分为两等分，每次只使用其中一块内存，当用完之后，将活着的对象复制到另一块内存，然后整个回收上一半。这种按顺序分配内存，实现简单，运行高效。</li><li>不足之处：直接将内存缩小了一半，产生大量的空间浪费。然而很多垃圾收集器都是用这种方式，但是有过改进。因为堆中的对象90%都是朝生夕死的，只有10%是会长期存活下来的对象，那么对于这90%的对象，完全可以使用这种高效的复制收集算法。首先将内存区域划分三份，10%的对象存在其中较大的一分中，另外的两份等份分配，处理这90%的“死的快”的对象。这就是Form,To,Eden区域。即Eden:From:To=8:1:1</li></ul><h5 id="标记-整理法"><a href="#标记-整理法" class="headerlink" title="标记-整理法"></a>标记-整理法</h5><ul><li>标记整理的方式实际上也是先将可回收对象标记起来，然后对于这些存活着的对象，并不直接回收，而是先向一端移动，最后直接回收端边界之外的对象。这种做法解决了处理存活率较高的大对象的回收，适合老年代堆对象回收。</li></ul><h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><ul><li>当前商业虚拟机基本上都会采取分代收集算法。即根据对象存活周期的不同将内存划分为不同区域，分别使用不同的垃圾回收算法进行垃圾回收。比如在新生代使用复制算法，因为新生代大量对象都是朝生夕死需要很高的回收效率，而对于老年代则使用标记清除或者标记整理。</li></ul><h4 id="Java虚拟机的对象内存分配"><a href="#Java虚拟机的对象内存分配" class="headerlink" title="Java虚拟机的对象内存分配"></a>Java虚拟机的对象内存分配</h4><p>Java对象内存分配实际上就指的是将对象分配在堆上的过程。不过实际上堆还被虚拟机划分成了不同的区域，并且每个区域的分配策略都不相同。上面我们说到虚拟机根据对象存活周期的不同将对内存分为几种不同的区域，即新生代Eden,From Survivor,To Survivor和老年代。那么这几种区域是如何进行内存分配的呢？</p><ul><li>对象优先再Eden区域分配：大多数情况下，对象会在Eden区域分配，在Eden区域空间不够的情况下，会先进行一次MinorGC（MinorGC是新生代垃圾回收，Full GC是老年代垃圾回收）。</li><li>大对象直接进入老年代：大对象即指的是需要大量连续空间的对象，例如很长的字符串以及数组。虚拟机提供参数<code>-XX:PretenureSizeThreadhold</code>参数设置大于多少算是大对象，避免在新生代几个区域中发生大量的内存复制。</li><li>长期存活的对象直接进入老年代：每经过一次MinorGC对象的年龄都会加1。当年龄加到<code>-XX:MaxTenuringThreadhold</code>（默认15）指定的值时，判断为长期存活，对象会被移动到老年代。</li><li>动态对象年龄判断：为了适应多变的内存情况，一般虚拟机都会使用动态对象年龄判定。如果Survivor中相同年龄的所有对象大小总和大于该空间的一半，该年龄以上的对象就会直接进入老年代，无需等到年龄大于<code>-XX:MaxTenuringThreadhold</code>（默认15）指定的值。</li><li>空间分配担保：在发生MinorGC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，是的话MinorGC可以被认定是安全的。如果不成立，虚拟机会先检查<code>HandlerPromotionFailure</code>参数是否允许担保失败，不允许的话会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于的话或者<code>HandlerPromotionFailure</code>设置不允许冒险，那么就会执行一次FullGC。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>内存回收与垃圾收集很多时候都是影响系统性能和并发能力的主要因素之一，虚拟机提供了多种垃圾收集器以及大量的调节参数，方便开发人员根据实际应用调整以便程序可以获得最高的性能。这些垃圾收集器和虚拟机参数没有固定的标准的组合，需要开发人员对于内存分配与垃圾回收相当了解，才得以根据实际情况实际配置。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190414/Java内存分配与垃圾回收的复习整理/zy.png&quot; alt=&quot;摘要&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;众所周知Java作为一个“一次编译，到处运行”的编译型语言，JVM虚拟机当之无愧的是Java语言世界的先锋将军。作为一个Java程序员，JVM虚拟机其相关知识是我们必须要了解以及深入掌握的重点。在本篇博客我将总结一下JVM虚拟机的内存结构、对象内存分配以及垃圾回收算法。这也是经常找工作求职必问的点。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="内存分配" scheme="http://zhangjiaheng.cn/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="垃圾回收" scheme="http://zhangjiaheng.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo服务降级</title>
    <link href="http://zhangjiaheng.cn/blog/20190412/dubbo%20%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
    <id>http://zhangjiaheng.cn/blog/20190412/dubbo 服务降级/</id>
    <published>2019-04-12T03:48:06.000Z</published>
    <updated>2019-05-07T09:48:29.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在分布式服务或者一些微服务当中，经常性的出现各个服务之间相互调用，业务处理流程耦合起来的情况。比如当用户在平台下单时，我们需要给用户生成订单之后发站内信或者短信通知用户订单生成成功。那么很多时候代码的编写就会是：<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>调用订单模块生成订单-&gt;调用短信模块通知用户-&gt;调用其他模块处理更多业务逻辑</code><br>&nbsp;&nbsp;&nbsp;&nbsp;可是当我们无足轻重的一个短信通知模块挂掉或者报错的时候，我们当然不希望整个业务逻辑就这样停止。那么这个时候，就需要引入服务降级的机制，为整个业务逻辑进行解耦合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;使用服务降级可以防止我们服务中间不影响整体流程的模块出错导致整个业务处理雪崩。将核心业务保证完整性，非核心业务弱化。<br><a id="more"></a><br><em><font style="color: red">本文使用  <code>springboot+dubbo</code> 进行服务降级的演示</font></em></p><h3 id="dubbo自带的mock进行服务降级，也叫本地伪装"><a href="#dubbo自带的mock进行服务降级，也叫本地伪装" class="headerlink" title="dubbo自带的mock进行服务降级，也叫本地伪装"></a>dubbo自带的mock进行服务降级，也叫本地伪装</h3><h5 id="dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。"><a href="#dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。" class="headerlink" title="dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。"></a>dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。</h5><p>具体使用</p><p>dubbo mock的使用非常简单，即在我们平时进行开发时，编写impl实现类实现接口作为服务提供者的同时，编写mock实现类并覆盖所有接口中的方法。<br>官方更详细的文档<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html" target="_blank" rel="noopener">戳这里</a></p><p>比如有接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface SysOperateFacade &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据用户名查询操作员信息</span><br><span class="line">     */</span><br><span class="line">    SysOperateVO findByUserName(String username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在实现类进行相应操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service //这里Service是dubbo的注解</span><br><span class="line">public class SysOperateFacadeImpl implements SysOperateFacade &#123;</span><br><span class="line">  @Resource</span><br><span class="line">  SysOperateService sysOperateService;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public SysOperateVO findByUserName(String username) &#123;</span><br><span class="line">      return sysOperateService.findByUserName(username);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编写mock实现类覆盖findByUserName方法 注意 mock的类名必须是 接口名+Mock<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SysOperateFacadeMock implements SysOperateFacade &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public SysOperateVO findByUserName(String username) &#123;</span><br><span class="line">        System.out.println(&quot;调用到dubbo mock 的findByUserName方法。。。。。。。&quot;);</span><br><span class="line">        return new SysOperateVO();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，在调用的地方加上注解<code>@Reference(mock = &quot;true&quot;)</code>进行使用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/sys/sysOperate&quot;)</span><br><span class="line">public class SysOperateController extends BaseController &#123;</span><br><span class="line"></span><br><span class="line">    @Reference(mock = &quot;true&quot;)</span><br><span class="line">    private SysOperateFacade sysOperateFacade;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public SysOperateVO test(String username)&#123;</span><br><span class="line">        return sysOperateFacade.findByUserName(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用-spring-cloud-Hystrix进行服务降级"><a href="#使用-spring-cloud-Hystrix进行服务降级" class="headerlink" title="使用 spring cloud Hystrix进行服务降级"></a>使用 spring cloud Hystrix进行服务降级</h3><p>在服务调用方模块加入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>如果出现以下报错也许是由于Springboot与这个依赖版本不对应，修改下版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: org.springframework.boot.builder.SpringApplicationBuilder.&lt;init&gt;([Ljava/lang/Class;)V at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:170) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:104) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:70) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:122) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:74) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:325) at org.springframework.boot.SpringApplication.run(SpringApplication.java:296) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) at com.gjj.p2p.BasicsApplication.main(BasicsApplication.java:18)</span><br></pre></td></tr></table></figure></p><h5 id="具体使用hystrix进行服务降级"><a href="#具体使用hystrix进行服务降级" class="headerlink" title="具体使用hystrix进行服务降级"></a>具体使用<code>hystrix</code>进行服务降级</h5><p><code>hystrix</code>的使用也是非常简单，只需要在服务调用方即消费者方springboot启动类上加上注解 <code>@EnableHystrix</code></p><p>然后使用如下方式，指定服务出错或者熔断后调用的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(&quot;/test&quot;)</span><br><span class="line">@HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span><br><span class="line">public String test(String message)&#123;</span><br><span class="line">    return sysMenuFacade.test(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String fallback(String message)&#123;</span><br><span class="line">    return &quot;sysMenuFacade挂了 调用到fallback &quot; + message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样当出现问题之后就会调用得到fallback方法<br>还可以在这个controller上直接指定注解<code>@DefaultProperties(defaultFallback = &quot;fallback&quot;)</code>以免编写大量重复代码</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>服务降级与熔断机制在我们实际生产以及日常开发中都是是非常有必要使用的，例如我们在日常开发中，需要调用别人的模块，但是又不是非常依赖这个模块的数据，我们可以使用以上的方式构造“假的”调用结果。这样就不用为了调试某行代码去启动大量的服务了。</p><p>最后针对dubbo的mock机制以及<code>hystrix</code>，我觉得<code>hystrix</code>更像是try{}catch{}。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在分布式服务或者一些微服务当中，经常性的出现各个服务之间相互调用，业务处理流程耦合起来的情况。比如当用户在平台下单时，我们需要给用户生成订单之后发站内信或者短信通知用户订单生成成功。那么很多时候代码的编写就会是：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;调用订单模块生成订单-&amp;gt;调用短信模块通知用户-&amp;gt;调用其他模块处理更多业务逻辑&lt;/code&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可是当我们无足轻重的一个短信通知模块挂掉或者报错的时候，我们当然不希望整个业务逻辑就这样停止。那么这个时候，就需要引入服务降级的机制，为整个业务逻辑进行解耦合。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用服务降级可以防止我们服务中间不影响整体流程的模块出错导致整个业务处理雪崩。将核心业务保证完整性，非核心业务弱化。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="dubbo" scheme="http://zhangjiaheng.cn/categories/dubbo/"/>
    
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="dubbo" scheme="http://zhangjiaheng.cn/tags/dubbo/"/>
    
      <category term="分布式服务降级" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>事务传播机制和事务隔离级别</title>
    <link href="http://zhangjiaheng.cn/blog/20190323/%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://zhangjiaheng.cn/blog/20190323/事务传播机制以及隔离级别/</id>
    <published>2019-03-23T13:41:16.000Z</published>
    <updated>2019-05-07T09:48:29.931Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事务的四个特性-ACID"><a href="#事务的四个特性-ACID" class="headerlink" title="事务的四个特性(ACID)"></a>事务的四个特性(ACID)</h4><ul><li><p>原子性<br>  事务执行开始之后的一系列操作都堪称是一个原子操作，要么全部做完，要么全部失败，不能出现部分操作成功的情况。“原子”顾名思义，就是一个不可分割的最小单元。</p></li><li><p>一致性<br>  事务开始执行之后，数据的正确性需要得到保证。如A向B转账，B却未收到钱。</p></li><li><p>隔离性<br>  同一时间只能由一个事务对数据进行修改操作，对于其他事务来说这个修改操作时透明的。</p></li><li><p>持久性<br>  事务对数据进行修改操作完成之后，数据发生的改变是持久不变的，不会自己恢复到改变之前的状态。</p></li></ul><a id="more"></a><h4 id="spring中的事务传播机制-以及事务隔离级别"><a href="#spring中的事务传播机制-以及事务隔离级别" class="headerlink" title="spring中的事务传播机制 以及事务隔离级别"></a>spring中的事务传播机制 以及事务隔离级别</h4><p><strong>在接口TransactionDefinition中，定义了7种传播机制</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.transaction;</span><br><span class="line"></span><br><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line">    </span><br><span class="line">// 事务传播机制</span><br><span class="line">int PROPAGATION_REQUIRED = 0;// 默认的 也是最常用的 ，如果当前有事务，就加入当前这个事务，如果没有事务，就新建一个事务</span><br><span class="line">    int PROPAGATION_SUPPORTS = 1;// 如果有事务，就加入当前这个事务，如果没有事务，也不新建</span><br><span class="line">    int PROPAGATION_MANDATORY = 2;// 如果有事务，就会使用当前这个事务，如果没有就会抛出异常</span><br><span class="line">    int PROPAGATION_REQUIRES_NEW = 3;// 总是会开启一个新的事务，如果当前已经有事务，就将当前事务挂起</span><br><span class="line">    int PROPAGATION_NOT_SUPPORTED = 4;// 代码总是会在非事务的环境执行，如果当前有事务，先将事务挂起，执行完成之后再恢复</span><br><span class="line">    int PROPAGATION_NEVER = 5;// 绝对不允许代码在有事务的环境执行，有事务就抛出异常停止执行</span><br><span class="line">    int PROPAGATION_NESTED = 6;// 嵌套事务级别：如果没有父事务，就使用默认机制，如果有，子事务执行完成之后父事务才会提交</span><br><span class="line"></span><br><span class="line">// 事务隔离级别</span><br><span class="line">    int ISOLATION_DEFAULT = -1;// 默认级别 </span><br><span class="line">    int ISOLATION_READ_UNCOMMITTED = 1;// 读未提交 即脏读，可以读取别的事务已修改未提交的数据，会导致脏读、幻读和不可重复度</span><br><span class="line">    int ISOLATION_READ_COMMITTED = 2;// 提交读即不可重复读，一个事物能读取到另一个事务已经提交的数据，在多次读取同一数据时，该数据被另一事务修改，读取的数据不一致</span><br><span class="line">    int ISOLATION_REPEATABLE_READ = 4;// 可重复读 即一个事物只能读取到另一事务提交之前的数据，确保每次读取到的数据一致。但是数据又新增或者修改时不可预见</span><br><span class="line">    int ISOLATION_SERIALIZABLE = 8;// 序列化读 即事务串行读取数据，性能最差，安全性最高，保证数据准确性</span><br><span class="line">    int TIMEOUT_DEFAULT = -1;</span><br><span class="line"></span><br><span class="line">    int getPropagationBehavior();</span><br><span class="line"></span><br><span class="line">    int getIsolationLevel();</span><br><span class="line"></span><br><span class="line">    int getTimeout();</span><br><span class="line"></span><br><span class="line">    boolean isReadOnly();</span><br><span class="line"></span><br><span class="line">    String getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事务的四个特性-ACID&quot;&gt;&lt;a href=&quot;#事务的四个特性-ACID&quot; class=&quot;headerlink&quot; title=&quot;事务的四个特性(ACID)&quot;&gt;&lt;/a&gt;事务的四个特性(ACID)&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原子性&lt;br&gt;  事务执行开始之后的一系列操作都堪称是一个原子操作，要么全部做完，要么全部失败，不能出现部分操作成功的情况。“原子”顾名思义，就是一个不可分割的最小单元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一致性&lt;br&gt;  事务开始执行之后，数据的正确性需要得到保证。如A向B转账，B却未收到钱。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离性&lt;br&gt;  同一时间只能由一个事务对数据进行修改操作，对于其他事务来说这个修改操作时透明的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持久性&lt;br&gt;  事务对数据进行修改操作完成之后，数据发生的改变是持久不变的，不会自己恢复到改变之前的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="事务" scheme="http://zhangjiaheng.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="数据库" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>使用Springboot进行国际化时自定义读取数据库配置</title>
    <link href="http://zhangjiaheng.cn/blog/20190320/%E4%BD%BF%E7%94%A8springboot%E8%BF%9B%E8%A1%8C%E5%9B%BD%E9%99%85%E5%8C%96%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/"/>
    <id>http://zhangjiaheng.cn/blog/20190320/使用springboot进行国际化时自定义读取数据库配置/</id>
    <published>2019-03-20T11:27:02.000Z</published>
    <updated>2019-05-07T09:48:29.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>springboot默认就支持国际化的，而且不需要你过多的做什么配置，只需要在<code>resources/</code>下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。 具体的关于springboot的国际化配置我这边就不再过多介绍(包括Locale的设置以及如何根据区域设置语言等)，关于页面上得使用可以参考：<a href="!https://www.baidu.com/s?word=springboot+%E5%9B%BD%E9%99%85%E5%8C%96">springboot国际化</a>。在这篇博客中，我要介绍的是一个很有用的功能并且绝大部分人也会用得到，就是<br><strong><font color="#0099ff" size="5" face="黑体">不使用配置文件<code>messages.properties</code>储存国际化语言，而使用数据库进行动态配置，做到无需重启更改配置。</font></strong><br><a id="more"></a></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h4 id="MessageSource介绍"><a href="#MessageSource介绍" class="headerlink" title="MessageSource介绍"></a>MessageSource介绍</h4><p>Spring提供了一个接口MessageSource用于获取国际化信息，ReloadableResourceBundleMessageSource和ResourceBundleMessageSource都是继承了该接口的一个抽象实现类AbstractMessageSource，在spring官网有一段这样介绍messageSource的话：<br><img src="https://img-blog.csdn.net/20180116154941287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDcyMTEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="spring官网对于messageSource的介绍" title="spring官网对于messageSource的介绍"><br>图中红框画起来的意思就是，上下文加载的时候会查询messageSource的bean，如果没有就会创建一个名为<code>messageSource</code>放在上下文中… …等等。</p><h4 id="在springboot中注入自定义messageSource"><a href="#在springboot中注入自定义messageSource" class="headerlink" title="在springboot中注入自定义messageSource"></a>在springboot中注入自定义messageSource</h4><p>通过上面的介绍，我们就可以自己定义自己的messageSource进行配置的读取了。<br> <strong> 我这边是把这个放在了业务层，大家用的时候也可以直接放在控制层(一般都放在控制层，要用到)，使用@Compnent(“messageSource”)注解声明下bean名称即可 </strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// MyMessageSourceService是我自己的接口 你也可以不需要。使用@Compnent(&quot;messageSource&quot;)注解就行</span><br><span class="line">@Service(&quot;messageSource&quot;)</span><br><span class="line">public class MyMessageSource extends AbstractMessageSource implements ResourceLoaderAware, MyMessageSourceService &#123;</span><br><span class="line"></span><br><span class="line">    ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    // 这个是用来缓存数据库中获取到的配置的 数据库配置更改的时候可以调用reload方法重新加载</span><br><span class="line">    // 当然 实际使用者也可以不使用这种缓存的方式</span><br><span class="line">    private static final Map&lt;String, Map&lt;String, String&gt;&gt; LOCAL_CACHE = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    SysI18nService sysI18nService;</span><br><span class="line"></span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(MyMessageSource.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化</span><br><span class="line">     */</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        this.reload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重新将数据库中的国际化配置加载</span><br><span class="line">     */</span><br><span class="line">    public void reload() &#123;</span><br><span class="line">        LOCAL_CACHE.clear();</span><br><span class="line">        LOCAL_CACHE.putAll(loadAllMessageResourcesFromDB());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从数据库中获取所有国际化配置 这边可以根据自己数据库表结构进行相应的业务实现</span><br><span class="line">     * 对应的语言能够取出来对应的值就行了 无需一定要按照这个方法来</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String, Map&lt;String, String&gt;&gt; loadAllMessageResourcesFromDB() &#123;</span><br><span class="line">        List&lt;SysI18nBO&gt; list = sysI18nService.findList(new SysI18nAO());</span><br><span class="line">        if (CollectionUtils.isNotEmpty(list)) &#123;</span><br><span class="line">            final Map&lt;String, String&gt; zhCnMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class="line">            final Map&lt;String, String&gt; enUsMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class="line">            final Map&lt;String, String&gt; idIdMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class="line">            for (SysI18nBO bo : list) &#123;</span><br><span class="line">                String name = bo.getModel() + &quot;.&quot; + bo.getName();</span><br><span class="line">                String zhText = bo.getZhCn();</span><br><span class="line">                String enText = bo.getEnUs();</span><br><span class="line">                String idText = bo.getInId();</span><br><span class="line">                zhCnMessageResources.put(name, zhText);</span><br><span class="line">                enUsMessageResources.put(name, enText);</span><br><span class="line">                idIdMessageResources.put(name, idText);</span><br><span class="line">            &#125;</span><br><span class="line">            LOCAL_CACHE.put(&quot;zh&quot;, zhCnMessageResources);</span><br><span class="line">            LOCAL_CACHE.put(&quot;en&quot;, enUsMessageResources);</span><br><span class="line">            LOCAL_CACHE.put(&quot;in&quot;, idIdMessageResources);</span><br><span class="line">        &#125;</span><br><span class="line">        return MapUtils.EMPTY_MAP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从缓存中取出国际化配置对应的数据 或者从父级获取</span><br><span class="line">     *</span><br><span class="line">     * @param code</span><br><span class="line">     * @param locale</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getSourceFromCache(String code, Locale locale) &#123;</span><br><span class="line">        String language = locale.getLanguage();</span><br><span class="line">        Map&lt;String, String&gt; props = LOCAL_CACHE.get(language);</span><br><span class="line">        if (null != props &amp;&amp; props.containsKey(code)) &#123;</span><br><span class="line">            return props.get(code);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (null != this.getParentMessageSource()) &#123;</span><br><span class="line">                    return this.getParentMessageSource().getMessage(code, null, locale);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                logger.error(ex.getMessage(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">            return code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 下面三个重写的方法是比较重要的</span><br><span class="line">    @Override</span><br><span class="line">    public void setResourceLoader(ResourceLoader resourceLoader) &#123;</span><br><span class="line">        this.resourceLoader = (resourceLoader == null ? new DefaultResourceLoader() : resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected MessageFormat resolveCode(String code, Locale locale) &#123;</span><br><span class="line">        String msg = getSourceFromCache(code, locale);</span><br><span class="line">        MessageFormat messageFormat = new MessageFormat(msg, locale);</span><br><span class="line">        return messageFormat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String resolveCodeWithoutArguments(String code, Locale locale) &#123;</span><br><span class="line">        return getSourceFromCache(code, locale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p> 至此，自定义国际化配置读取数据库已经完成，只需要在更新数据库配置的时候调用一下reload重置一下缓存中的信息即可。</p><blockquote><p><a href="!https://blog.csdn.net/u014721131/article/details/79075802">参考博客：spring xml配置自定义读取数据库的messageSource</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;springboot默认就支持国际化的，而且不需要你过多的做什么配置，只需要在&lt;code&gt;resources/&lt;/code&gt;下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。 具体的关于springboot的国际化配置我这边就不再过多介绍(包括Locale的设置以及如何根据区域设置语言等)，关于页面上得使用可以参考：&lt;a href=&quot;!https://www.baidu.com/s?word=springboot+%E5%9B%BD%E9%99%85%E5%8C%96&quot;&gt;springboot国际化&lt;/a&gt;。在这篇博客中，我要介绍的是一个很有用的功能并且绝大部分人也会用得到，就是&lt;br&gt;&lt;strong&gt;&lt;font color=&quot;#0099ff&quot; size=&quot;5&quot; face=&quot;黑体&quot;&gt;不使用配置文件&lt;code&gt;messages.properties&lt;/code&gt;储存国际化语言，而使用数据库进行动态配置，做到无需重启更改配置。&lt;/font&gt;&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="国际化" scheme="http://zhangjiaheng.cn/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Layui结合freemarker+springboot进行前端数据表格字典转义</title>
    <link href="http://zhangjiaheng.cn/blog/20190316/layui%E5%BC%80%E5%8F%91%E4%B8%AD%E7%BB%93%E5%90%88freemarker%E5%B1%95%E7%A4%BA%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE/"/>
    <id>http://zhangjiaheng.cn/blog/20190316/layui开发中结合freemarker展示字典数据/</id>
    <published>2019-03-16T11:51:53.000Z</published>
    <updated>2019-05-07T09:48:29.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。<br>那么在layui的数据表格中，我们要展示这样的数据，写法可以是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">templet: function (d) &#123;</span><br><span class="line">  if(d.status === 1)&#123;</span><br><span class="line">      return &quot;启用&quot;;</span><br><span class="line">  &#125; else if(d.status === 0)&#123;</span><br><span class="line">      return &quot;停用&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。<br>在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。<br>最后我们的写法就会简化成：<code>&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code>，接下来看看如何在springboot中配置使用吧。<br><a id="more"></a></p><h3 id="freemarker自定义标签介绍及使用"><a href="#freemarker自定义标签介绍及使用" class="headerlink" title="freemarker自定义标签介绍及使用"></a>freemarker自定义标签介绍及使用</h3><p><code>TemplateDirectiveModel</code>接口是freemarker自定标签或者自定义指令的核心处理接口。当模板页面遇到用户自定义的标签指令时，<code>execute()</code>方法会被执行。<code>execute()</code>方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void execute(</span><br><span class="line">  Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body</span><br><span class="line">) throws TemplateException, IOException;</span><br></pre></td></tr></table></figure></p><p>我们在使用freemarker自定义标签的时候需要实现该接口并且重写execute方法。</p><h4 id="execute-方法参数解释"><a href="#execute-方法参数解释" class="headerlink" title="execute()方法参数解释"></a><code>execute()</code>方法参数解释</h4><ul><li><em>Environment env</em>：系统环境变量，通常用它来输出相关内容，如<code>Writer out = env.getOut();</code></li><li><em>Map params</em>：自定义标签传过来的对象，就是从页面上获取的参数，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等。<br>在本例使用时，我们会将map转成我们自己的对象进行数据保存。</li><li><em>TemplateModel[] loopVars</em>：循环替代变量</li><li><em>TemplateDirectiveBody body</em>：标签中嵌套的内容，如<code>&lt;@tag&gt;body&lt;/@tag&gt;</code>，就是这个body</li></ul><h4 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h4><h6 id="定义接收页面参数的对象"><a href="#定义接收页面参数的对象" class="headerlink" title="定义接收页面参数的对象"></a>定义接收页面参数的对象</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">public class TableThTag &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 对象属性名【需要进行对象属性获取】</span><br><span class="line">     */</span><br><span class="line">    private String objName;</span><br><span class="line">    /**</span><br><span class="line">     * 字典标识</span><br><span class="line">     */</span><br><span class="line">    private String nid;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类型</span><br><span class="line">     */</span><br><span class="line">    private String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="实现TemplateDirectiveModel接口并重写execute方法"><a href="#实现TemplateDirectiveModel接口并重写execute方法" class="headerlink" title="实现TemplateDirectiveModel接口并重写execute方法"></a>实现<code>TemplateDirectiveModel</code>接口并重写<code>execute</code>方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@org.springframework.context.annotation.Configuration</span><br><span class="line">public class TableThDirective implements TemplateDirectiveModel &#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * FreeMarker自定义指令</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void execute(Environment environment, Map map, TemplateModel[] templateModels,</span><br><span class="line">                        TemplateDirectiveBody templateDirectiveBody) throws TemplateException, IOException &#123;</span><br><span class="line">        TableThTag tableThTag = new TableThTag();</span><br><span class="line">        //校验参数</span><br><span class="line">        try &#123;</span><br><span class="line">            //  用来将一些 key-value 的值（例如 hashmap）映射到 bean 中的属性</span><br><span class="line">            BeanUtils.populate(tableThTag, map);</span><br><span class="line">            if (StringUtils.isEmpty(tableThTag.getNid()) || StringUtils.isEmpty(tableThTag.getType())) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;nid,type不能为空&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;数据转化异常&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder html = new StringBuilder();</span><br><span class="line">        // 根据类型创建不同的HTML生成器</span><br><span class="line">        ThFormatterInterface thFormatterInterface = ThFormatterFactory.createThFormatter(tableThTag.getType());</span><br><span class="line">        if (thFormatterInterface != null) &#123;</span><br><span class="line">            String dictHtml = thFormatterInterface.buildFormatterHtml(tableThTag.getNid(), tableThTag.getFieldName());</span><br><span class="line">            html.append(dictHtml);</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行真正指令的执行部分:</span><br><span class="line">        Writer out = environment.getOut();</span><br><span class="line">        out.write(html.toString());</span><br><span class="line">        if (templateDirectiveBody != null) &#123;</span><br><span class="line">            templateDirectiveBody.render(environment.getOut());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BeansWrapper getBeansWrapper() &#123;</span><br><span class="line">        BeansWrapper beansWrapper =</span><br><span class="line">                new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build();</span><br><span class="line">        return beansWrapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，在这个方法中，我将页面上的参数转为<code>TableThTag</code>对象。然后再根据前端页面不同的type类型对应<br>实现了<code>ThFormatterInterface</code>的工厂对象，创建不同的html生成器。（这里考虑到扩展性，可能以后不光创建数据表格会用的到，比如下拉框什么的，也可以使用这种方式创建，所以在这里使用抽象工厂依据类型动态创建。）<br>下面就是创建html的具体工厂以及实现方法。</p><h6 id="ThFormatterInterface抽象工厂创建html生成器"><a href="#ThFormatterInterface抽象工厂创建html生成器" class="headerlink" title="ThFormatterInterface抽象工厂创建html生成器"></a><code>ThFormatterInterface</code>抽象工厂创建html生成器</h6><p>接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface ThFormatterInterface &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 构造生成枚举html</span><br><span class="line">     * @param nid</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String buildFormatterHtml(String nid, String fieldName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>工厂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ThFormatterFactory &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(ThFormatterFactory.class);</span><br><span class="line"></span><br><span class="line">    public static ThFormatterInterface createThFormatter(String type)&#123;</span><br><span class="line">        if(StringUtils.isEmpty(type))&#123;</span><br><span class="line">            return  new ThFormatterTemplate();</span><br><span class="line">        &#125;</span><br><span class="line">        // 文件名 如果type传template 就需要有一个名为ThFormatterTemplate的文件</span><br><span class="line">        // 并且实现了ThFormatterInterface以及重写生成html的方法</span><br><span class="line">        String fileName = &quot;ThFormatter&quot; + StringUtil.firstCharUpperCase(type);</span><br><span class="line">        //类路径 通过反射去创建实现类</span><br><span class="line">        String className = &quot;com.module.freemarker.impl.&quot;+fileName;</span><br><span class="line">        //生成表头格式实现类</span><br><span class="line">        ThFormatterInterface thFormatterInterface = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            thFormatterInterface =(ThFormatterInterface) Class.forName(className).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">        return thFormatterInterface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ThFormatterTemplate implements ThFormatterInterface &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String buildFormatterHtml(String nid, String fieldName) &#123;</span><br><span class="line">        Assert.notEMPTY(nid, &quot;nid不能为空&quot;);</span><br><span class="line">        Assert.notEMPTY(fieldName, &quot;objName不能为空&quot;);</span><br><span class="line">        SysDictService sysDictService = SpringContextHolder.getBean(SysDictService.class);</span><br><span class="line">        // 通过nid查询字典类 这里不需要进行照抄 每个人都会有自己的实现方法</span><br><span class="line">        List&lt;SysDictBO&gt; sysDictModelList = sysDictService.findByPartnerNid(nid);</span><br><span class="line">        StringBuilder dictHtml = new StringBuilder();</span><br><span class="line">        // 反正目的就是根据字典类生成对应的html就行了 需要生成的格式对照template原本应该有的写法就行了</span><br><span class="line">        dictHtml.append(&quot;templet: function(d)&#123; &quot;);</span><br><span class="line">        for (SysDictBO sysDict : sysDictModelList) &#123;</span><br><span class="line">            dictHtml.append(&quot;if(d.&quot; + fieldName + &quot; == &apos;&quot; + sysDict.getValue() + &quot;&apos;)&#123; return &apos;&quot; + sysDict.getName() + &quot;&apos;;&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        dictHtml.append(&quot;&#125;&quot;);</span><br><span class="line"></span><br><span class="line">        return dictHtml.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="最后将自定义标签注入到freemarker标签中去"><a href="#最后将自定义标签注入到freemarker标签中去" class="headerlink" title="最后将自定义标签注入到freemarker标签中去"></a>最后将自定义标签注入到freemarker标签中去</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@org.springframework.context.annotation.Configuration</span><br><span class="line">public class FreemarkerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private Configuration configuration;</span><br><span class="line">    @Resource</span><br><span class="line">    private TableThDirective tableThDirective;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void setSharedVariable()&#123;</span><br><span class="line">        configuration.setSharedVariable(&quot;th&quot;,tableThDirective);</span><br><span class="line">        configuration.setSharedVariable(&quot;shiro&quot;,new ShiroTags());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这样就大功告成了。</p><p>在页面上进行使用吧：<code>&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code></p><p>以后进行扩展什么的也方便，比如生成下拉框：<code>&lt;@th type=&quot;select&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code>这样然后自动生成html的时候查出来所有的字典，根据类型生成多个<option>出来就行了。</option></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。&lt;br&gt;那么在layui的数据表格中，我们要展示这样的数据，写法可以是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;templet: function (d) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if(d.status === 1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;quot;启用&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; else if(d.status === 0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;quot;停用&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。&lt;br&gt;在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。&lt;br&gt;最后我们的写法就会简化成：&lt;code&gt;&amp;lt;@th type=&amp;quot;template&amp;quot; nid=&amp;quot;basics_sys_status&amp;quot; objName=&amp;quot;status&amp;quot;&amp;gt;&amp;lt;/@th&amp;gt;&lt;/code&gt;，接下来看看如何在springboot中配置使用吧。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/categories/springboot/"/>
    
    
      <category term="开发日记" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="freemarker" scheme="http://zhangjiaheng.cn/tags/freemarker/"/>
    
      <category term="工厂模式" scheme="http://zhangjiaheng.cn/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="layui" scheme="http://zhangjiaheng.cn/tags/layui/"/>
    
  </entry>
  
  <entry>
    <title>Springboot+shiro解决session污染的问题</title>
    <link href="http://zhangjiaheng.cn/blog/20190309/springboot+shiro%E8%A7%A3%E5%86%B3session%E6%B1%A1%E6%9F%93%E9%97%AE%E9%A2%98/"/>
    <id>http://zhangjiaheng.cn/blog/20190309/springboot+shiro解决session污染问题/</id>
    <published>2019-03-09T07:26:49.000Z</published>
    <updated>2019-05-07T09:48:29.924Z</updated>
    
    <content type="html"><![CDATA[<h4 id="同一个服务器启动多个web项目造成session污染"><a href="#同一个服务器启动多个web项目造成session污染" class="headerlink" title="同一个服务器启动多个web项目造成session污染"></a>同一个服务器启动多个web项目造成session污染</h4><p>昨天在敲代码的时候遇到了一个问题，同一个项目，我创建了两个分支，分别使用不同的端口。<br>但是在测试环境启动的时候我发现，在同一个浏览器上，我只能登陆其中的一个后台。在登陆另一个后台之后，前面那个<br>又需要再重新登陆了。</p><p>原因找了好久，最后F12控制台查看session发现，这两个web项目，使用的都是JSessionId作为cookie的key，在登陆另一个时，浏览器的这个cookie值就会被改变，所以前者就需要在重新登陆了。</p><a id="more"></a><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>在springboot中，对shiro配置进行更改session保存时的cookie的key名称，如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DefaultWebSessionManager sessionManager() &#123;</span><br><span class="line">    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();</span><br><span class="line">    Cookie cookie = sessionManager.getSessionIdCookie();</span><br><span class="line">    cookie.setName(&quot;MySessionId&quot;);</span><br><span class="line">    return sessionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在<code>securityManager</code>中将我们的<code>sessionManager</code>注入进去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * SecurityManager，权限管理，这个类组合了登陆，登出，权限，session的处理，是个比较重要的类。</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public DefaultWebSecurityManager securityManager() &#123;</span><br><span class="line">    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class="line">    securityManager.setRealm(myShiroRealm());</span><br><span class="line">    securityManager.setSessionManager(sessionManager());</span><br><span class="line">    return securityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要这样修改好就可以了。然后重启项目，就会发现，两个web项目都可以同时登陆了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;同一个服务器启动多个web项目造成session污染&quot;&gt;&lt;a href=&quot;#同一个服务器启动多个web项目造成session污染&quot; class=&quot;headerlink&quot; title=&quot;同一个服务器启动多个web项目造成session污染&quot;&gt;&lt;/a&gt;同一个服务器启动多个web项目造成session污染&lt;/h4&gt;&lt;p&gt;昨天在敲代码的时候遇到了一个问题，同一个项目，我创建了两个分支，分别使用不同的端口。&lt;br&gt;但是在测试环境启动的时候我发现，在同一个浏览器上，我只能登陆其中的一个后台。在登陆另一个后台之后，前面那个&lt;br&gt;又需要再重新登陆了。&lt;/p&gt;
&lt;p&gt;原因找了好久，最后F12控制台查看session发现，这两个web项目，使用的都是JSessionId作为cookie的key，在登陆另一个时，浏览器的这个cookie值就会被改变，所以前者就需要在重新登陆了。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="shiro" scheme="http://zhangjiaheng.cn/tags/shiro/"/>
    
      <category term="session污染" scheme="http://zhangjiaheng.cn/tags/session%E6%B1%A1%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>leetcode:Z字形变换</title>
    <link href="http://zhangjiaheng.cn/blog/20181223/leetcode-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://zhangjiaheng.cn/blog/20181223/leetcode-Z字形变换/</id>
    <published>2018-12-23T11:43:02.000Z</published>
    <updated>2019-05-07T09:48:29.918Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下</h4><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。<br><a id="more"></a><br>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br></pre></td></tr></table></figure><p>解释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>拿到这个题目，第一时间就可以想到，根据题中图示构造二维数组，先将数据按照相应的样子存储进去，最后再从数组中按行取出，但是这样会有占用更多内存空间的风险。所以，我这边还思考了第二种解法：就是直接根据规律计算出下一个要输出的字符的下标，直接输出即可，无需再创建多余的二维数组。</p><ul><li>第一种解法：构造二维数组</li></ul><p>构造二位数组最主要的就是计算出这个二维数组有多少列，列数有了，按照Z型规律将原字符串塞进去就行了，计算列数代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int getColNum(String s, int n) &#123;</span><br><span class="line">        int x = s.length() / (2 * n - 2);</span><br><span class="line">        int y = s.length() % (2 * n - 2);</span><br><span class="line">        int l = x + 1 + x * (n - 2);</span><br><span class="line">        if (y &gt;= n) &#123;</span><br><span class="line">            l = l + 1 + y % n;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>第二种解法：计算下一个要输出的字符的下标<br>直接看github代码吧：<a href="https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/Algorithm/src/main/java/Alogrithm/Alogrithm/ZigZagConversion" target="_blank" rel="noopener">点这里</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目如下&quot;&gt;&lt;a href=&quot;#题目如下&quot; class=&quot;headerlink&quot; title=&quot;题目如下&quot;&gt;&lt;/a&gt;题目如下&lt;/h4&gt;&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;L   C   I   R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E T O E S I I G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E   D   H   N&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java中map新的骚操作</title>
    <link href="http://zhangjiaheng.cn/blog/20181209/Java%E4%B8%ADmap%E6%96%B0%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    <id>http://zhangjiaheng.cn/blog/20181209/Java中map新的骚操作/</id>
    <published>2018-12-09T15:03:05.000Z</published>
    <updated>2019-05-07T09:48:29.898Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下："><a href="#在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：" class="headerlink" title="在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下："></a>在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：</h4><blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>computeIfPresent</code> 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null<br><code>computeIfAbsent</code>  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值<br><code>compute</code>          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class MapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(1,&quot;zhang&quot;);</span><br><span class="line">        // computeIfPresent 根据之前的key/value 如果oldValue 不为null 则根据提供的方法返回一个新的值 并进行新值对旧值的替换</span><br><span class="line">        System.out.println(&quot; 1 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class="line">            return key + value;//原值不为null新值不为null 新值替换旧值</span><br><span class="line">        &#125;));</span><br><span class="line">        // 否则删除键值对</span><br><span class="line">        System.out.println(&quot; 2 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class="line">            return null;//原值不为null新值为null 删除键值对</span><br><span class="line">        &#125;));</span><br><span class="line">        map.put(1,null);</span><br><span class="line">        System.out.println(&quot; 3 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class="line">            return &quot;jiaheng&quot;;//原值为null 不做更改</span><br><span class="line">        &#125;));</span><br><span class="line">        // computeIfAbsent 根据之前的key 如果旧值为空或者key不存在 就按照方法用新值替换旧值 新值为null不做替换</span><br><span class="line">        map.put(1,&quot;zhang&quot;);</span><br><span class="line">        System.out.println(&quot; 4 ---&gt; &quot; + map.computeIfAbsent(1,k-&gt;&#123;</span><br><span class="line">            return null;// 不会被替换旧值 返回原值</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(&quot; 5 ---&gt; &quot; + map.computeIfAbsent(2,k-&gt;&#123;</span><br><span class="line">            k = k*k;</span><br><span class="line">            return k.toString();// key=2不存在 直接新建并存入新值</span><br><span class="line">        &#125;));</span><br><span class="line">        // compute类似于computeIfAbsent和computeIfPresent的合体</span><br><span class="line">        map.put(1,null);</span><br><span class="line">        System.out.println(&quot; 6 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class="line">            return &quot;张&quot;;// 原值为null新值不为null 新值替换旧值 此处与computeIfPresent不同</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(&quot; 7 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class="line">            v = (k*10) + v;</span><br><span class="line">            return v;// 新值不为null 替换旧值</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(&quot; 8 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class="line">            return null;// 新值为null 删除键值对</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        // 总结</span><br><span class="line">        // computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null</span><br><span class="line">        // computeIfAbsent  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值</span><br><span class="line">        // compute          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：&quot;&gt;&lt;a href=&quot;#在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：&quot; class=&quot;headerlink&quot; title=&quot;在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：&quot;&gt;&lt;/a&gt;在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：&lt;/h4&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;p&gt;&lt;code&gt;computeIfPresent&lt;/code&gt; 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null&lt;br&gt;&lt;code&gt;computeIfAbsent&lt;/code&gt;  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值&lt;br&gt;&lt;code&gt;compute&lt;/code&gt;          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="开发日记" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
