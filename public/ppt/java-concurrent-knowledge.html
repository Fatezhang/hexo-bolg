<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Java 并发编程（一）</title>

    <link href="https://cdn.bootcss.com/reveal.js/3.8.0/css/reveal.css" rel="stylesheet">
    <link href="https://cdn.bootcss.com/reveal.js/1.4.0/css/reset.css" rel="stylesheet">
    <link href="https://cdn.bootcss.com/reveal.js/3.8.0/css/theme/black.css" rel="stylesheet">
    <link href="https://cdn.bootcss.com/reveal.js/3.8.0/lib/css/monokai.css" rel="stylesheet">
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ?
            'https://cdn.bootcss.com/reveal.js/3.8.0/css/print/pdf.css' :
            'https://cdn.bootcss.com/reveal.js/3.8.0/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-markdown>
            # 如何编写一个线程安全的单例？
            ![单身狗](images/dsg.jpg)
        </section>
        <section>
            <section data-markdown>
                ## 什么是线程？
            </section>
            <section data-transition="zoom">
                <p class="fragment fade-left">线程是操作系统进行运算调度的最小单位。包含在进程之中，属于进程中任务的实际运作单元。</p>
                <p class="fragment fade-right">一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
                <p class="fragment fade-left">线程的实现可以使用内核线程（操作系统内核调度）或用户线程（用户自行调度）或内核线程混合用户线程</p>
                <p class="fragment fade-right">同一个进程中的多个线程，可以共享该进程所拥有的资源，以此可以实现线程中的相互通信</p>
            </section>
            <section data-markdown>
                ## 多线程的好处？
                ![海贼王 罗宾](images/luobin.jpg)
            </section>
            <section>
                <p class="fragment fade-up">多核多处理器的普及，使得计算机进行多任务处理成为一项必备技能</p>
                <p class="fragment fade-up">计算机的运算能力远大于进行 I/O 操作，网络通信，数据库操作</p>
                <p class="fragment fade-up">将等待计算机进行 I/O 操作（存储、通信）的时间节约出来去同时处理其他任务</p>
                <p class="fragment fade-up">并行处理多个互不依赖的任务</p>
            </section>
        </section>
        <section>
            <section data-markdown>## 什么是线程安全？</section>
            <section data-markdown>
                <script type="text/template">
                    ```java
                    public class NumberMachine {

                        private int number = 0;

                        public int getNextNumber(){
                            return number++;
                        }
                    }
                    ```
                    ![slt](images/dsg.jpg) <!-- .element: class="fragment" data-fragment-index="1" -->
                </script>
            </section>
            <section data-markdown>
                ## 如何确保线程安全？
            </section>
<!--            <section>-->
<!--                <p class="fragment fade-up">原子性</p>-->
<!--                <p class="fragment fade-up">可见性</p>-->
<!--                <p class="fragment fade-up">有序性</p>-->
<!--            </section>-->
        </section>
        <section>
            <section data-markdown>
                ## CPU 如何去执行一个线程任务？
            </section>
            <section data-markdown>

            </section>
        </section>
        <section>
            <section>
                <h2>Java 内存模型 -- Java Memory Model</h2>
            </section>
            <section data-transition="zoom">

            </section>
        </section>
        <section>
            <section><h2>能够实现线程安全的相关的关键字和类</h2></section>
            <section data-markdown>
                <script type="text/template">
                    - synchronized <!-- .element: class="fragment" -->
                    - final <!-- .element: class="fragment" -->
                    - volatile <!-- .element: class="fragment" -->
                    - CAS <!-- .element: class="fragment" -->
                    - J.U.C 包 <!-- .element: class="fragment" -->
                        - Lock <!-- .element: class="fragment" -->
                        - ConcurrentHashMap <!-- .element: class="fragment" -->
                        - ... <!-- .element: class="fragment" -->
                    - ... <!-- .element: class="fragment" -->
                </script>
            </section>
        </section>
        <section>
            <section>
                <h2>Happen-Before 原则</h2>
            </section>
            <section data-markdown>
                - 程序次序原则：同一个线程内按照程序控制流顺序执行
                - 管程锁定原则：加锁在解锁后执行
                - volatile 原则：对于 volatile 变量的读操作必定发生在其写操作之后
                - 线程启动原则：Thread 的 start() 方法必定发生在该线程执行其他代码之前
                - 线程终止原则：线程终止检测必定发生在其他操作之后
                - 线程中断原则：对线程的 interrupt() 方法先行发生于其中断检测
                - 对象终结原则：对象的初始化完成先行发生于它的 finalize() 方法的开始
                - 传递性：以上先行发生操作具有传递性
            </section>
        </section>
        <section data-markdown>
            ## [编写线程安全的单例类](/blog/20190607/深度分析如何写出一个线程安全的单例)
        </section>
        <section>
            使用 CountDownLatch 进行并发测试
        </section>
    </div>
</div>
<script src="https://cdn.bootcss.com/reveal.js/3.8.0/js/reveal.js"></script>

<script>
    Reveal.initialize({
        dependencies: [
            {src: 'https://cdn.bootcss.com/reveal.js/3.8.0/plugin/markdown/marked.js'},
            {src: 'https://cdn.bootcss.com/reveal.js/3.7.0/plugin/markdown/markdown.js'},
            {src: 'https://cdn.bootcss.com/reveal.js/3.8.0/plugin/notes/notes.js', async: true},
            {src: 'https://cdn.bootcss.com/reveal.js/3.7.0/plugin/highlight/highlight.js', async: true},
            {src: "https://cdn.bootcss.com/reveal.js/3.8.0/plugin/highlight/highlight.min.js", async: true},
            {src: "https://cdn.bootcss.com/reveal.js/3.8.0/plugin/zoom-js/zoom.min.js", async: true}
        ],
        slideNumber: 'c/t',
        transaction: 'convex',
        width: 1280,
        height: 1080,
        markdown: {
            smartypants: true
        }
    });
</script>
</body>
</html>
