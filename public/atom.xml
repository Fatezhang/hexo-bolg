<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈年风楼 | 博客</title>
  
  <subtitle>一个人一只壶一杯茶，一座山一汪水一世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangjiaheng.cn/"/>
  <updated>2019-04-18T15:33:37.038Z</updated>
  <id>http://zhangjiaheng.cn/</id>
  
  <author>
    <name>陈年风楼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode:Z字形变换</title>
    <link href="http://zhangjiaheng.cn/blog/20190413/leetcode-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://zhangjiaheng.cn/blog/20190413/leetcode-Z字形变换/</id>
    <published>2019-04-13T11:43:02.000Z</published>
    <updated>2019-04-18T15:33:37.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下</h4><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。<br><a id="more"></a><br>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br></pre></td></tr></table></figure><p>解释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>拿到这个题目，第一时间就可以想到，根据题中图示构造二维数组，先将数据按照相应的样子存储进去，最后再从数组中按行取出，但是这样会有占用更多内存空间的风险。所以，我这边还思考了第二种解法：就是直接根据规律计算出下一个要输出的字符的下标，直接输出即可，无需再创建多余的二维数组。</p><ul><li>第一种解法：构造二维数组</li></ul><p>构造二位数组最主要的就是计算出这个二维数组有多少列，列数有了，按照Z型规律将原字符串塞进去就行了，计算列数代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int getColNum(String s, int n) &#123;</span><br><span class="line">        int x = s.length() / (2 * n - 2);</span><br><span class="line">        int y = s.length() % (2 * n - 2);</span><br><span class="line">        int l = x + 1 + x * (n - 2);</span><br><span class="line">        if (y &gt;= n) &#123;</span><br><span class="line">            l = l + 1 + y % n;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>第二种解法：计算下一个要输出的字符的下标<br>直接看github代码吧：<a href="https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/Algorithm/src/main/java/Alogrithm/Alogrithm/ZigZagConversion" target="_blank" rel="noopener">点这里</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;题目如下&quot;&gt;&lt;a href=&quot;#题目如下&quot; class=&quot;headerlink&quot; title=&quot;题目如下&quot;&gt;&lt;/a&gt;题目如下&lt;/h4&gt;&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;L   C   I   R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E T O E S I I G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E   D   H   N&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。&lt;br&gt;
    
    </summary>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>dubbo服务降级</title>
    <link href="http://zhangjiaheng.cn/blog/20190412/dubbo%20%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
    <id>http://zhangjiaheng.cn/blog/20190412/dubbo 服务降级/</id>
    <published>2019-04-12T03:48:06.000Z</published>
    <updated>2019-04-22T14:14:44.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在分布式服务或者一些微服务当中，经常性的出现各个服务之间相互调用，业务处理流程耦合起来的情况。比如当用户在平台下单时，我们需要给用户生成订单之后发站内信或者短信通知用户订单生成成功。那么很多时候代码的编写就会是：<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>调用订单模块生成订单-&gt;调用短信模块通知用户-&gt;调用其他模块处理更多业务逻辑</code><br>&nbsp;&nbsp;&nbsp;&nbsp;可是当我们无足轻重的一个短信通知模块挂掉或者报错的时候，我们当然不希望整个业务逻辑就这样停止。那么这个时候，就需要引入服务降级的机制，为整个业务逻辑进行解耦合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;使用服务降级可以防止我们服务中间不影响整体流程的模块出错导致整个业务处理雪崩。将核心业务保证完整性，非核心业务弱化。<br><a id="more"></a><br><em><font style="color: red">本文使用  <code>springboot+dubbo</code> 进行服务降级的演示</font></em></p><h3 id="dubbo自带的mock进行服务降级，也叫本地伪装"><a href="#dubbo自带的mock进行服务降级，也叫本地伪装" class="headerlink" title="dubbo自带的mock进行服务降级，也叫本地伪装"></a>dubbo自带的mock进行服务降级，也叫本地伪装</h3><h5 id="dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。"><a href="#dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。" class="headerlink" title="dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。"></a>dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。</h5><p>具体使用</p><p>dubbo mock的使用非常简单，即在我们平时进行开发时，编写impl实现类实现接口作为服务提供者的同时，编写mock实现类并覆盖所有接口中的方法。<br>官方更详细的文档<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html" target="_blank" rel="noopener">戳这里</a></p><p>比如有接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface SysOperateFacade &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据用户名查询操作员信息</span><br><span class="line">     */</span><br><span class="line">    SysOperateVO findByUserName(String username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在实现类进行相应操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service //这里Service是dubbo的注解</span><br><span class="line">public class SysOperateFacadeImpl implements SysOperateFacade &#123;</span><br><span class="line">  @Resource</span><br><span class="line">  SysOperateService sysOperateService;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public SysOperateVO findByUserName(String username) &#123;</span><br><span class="line">      return sysOperateService.findByUserName(username);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编写mock实现类覆盖findByUserName方法 注意 mock的类名必须是 接口名+Mock<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SysOperateFacadeMock implements SysOperateFacade &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public SysOperateVO findByUserName(String username) &#123;</span><br><span class="line">        System.out.println(&quot;调用到dubbo mock 的findByUserName方法。。。。。。。&quot;);</span><br><span class="line">        return new SysOperateVO();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，在调用的地方加上注解<code>@Reference(mock = &quot;true&quot;)</code>进行使用即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/sys/sysOperate&quot;)</span><br><span class="line">public class SysOperateController extends BaseController &#123;</span><br><span class="line"></span><br><span class="line">    @Reference(mock = &quot;true&quot;)</span><br><span class="line">    private SysOperateFacade sysOperateFacade;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public SysOperateVO test(String username)&#123;</span><br><span class="line">        return sysOperateFacade.findByUserName(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用-spring-cloud-Hystrix进行服务降级"><a href="#使用-spring-cloud-Hystrix进行服务降级" class="headerlink" title="使用 spring cloud Hystrix进行服务降级"></a>使用 spring cloud Hystrix进行服务降级</h3><p>在服务调用方模块加入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>如果出现以下报错也许是由于Springboot与这个依赖版本不对应，修改下版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: org.springframework.boot.builder.SpringApplicationBuilder.&lt;init&gt;([Ljava/lang/Class;)V at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:170) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:104) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:70) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:122) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:74) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:325) at org.springframework.boot.SpringApplication.run(SpringApplication.java:296) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) at com.gjj.p2p.BasicsApplication.main(BasicsApplication.java:18)</span><br></pre></td></tr></table></figure></p><h5 id="具体使用hystrix进行服务降级"><a href="#具体使用hystrix进行服务降级" class="headerlink" title="具体使用hystrix进行服务降级"></a>具体使用<code>hystrix</code>进行服务降级</h5><p><code>hystrix</code>的使用也是非常简单，只需要在服务调用方即消费者方springboot启动类上加上注解 <code>@EnableHystrix</code></p><p>然后使用如下方式，指定服务出错或者熔断后调用的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(&quot;/test&quot;)</span><br><span class="line">@HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span><br><span class="line">public String test(String message)&#123;</span><br><span class="line">    return sysMenuFacade.test(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String fallback(String message)&#123;</span><br><span class="line">    return &quot;sysMenuFacade挂了 调用到fallback &quot; + message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样当出现问题之后就会调用得到fallback方法<br>还可以在这个controller上直接指定注解<code>@DefaultProperties(defaultFallback = &quot;fallback&quot;)</code>以免编写大量重复代码</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>服务降级与熔断机制在我们实际生产以及日常开发中都是是非常有必要使用的，例如我们在日常开发中，需要调用别人的模块，但是又不是非常依赖这个模块的数据，我们可以使用以上的方式构造“假的”调用结果。这样就不用为了调试某行代码去启动大量的服务了。</p><p>最后针对dubbo的mock机制以及<code>hystrix</code>，我觉得<code>hystrix</code>更像是try{}catch{}。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在分布式服务或者一些微服务当中，经常性的出现各个服务之间相互调用，业务处理流程耦合起来的情况。比如当用户在平台下单时，我们需要给用户生成订单之后发站内信或者短信通知用户订单生成成功。那么很多时候代码的编写就会是：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;调用订单模块生成订单-&amp;gt;调用短信模块通知用户-&amp;gt;调用其他模块处理更多业务逻辑&lt;/code&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可是当我们无足轻重的一个短信通知模块挂掉或者报错的时候，我们当然不希望整个业务逻辑就这样停止。那么这个时候，就需要引入服务降级的机制，为整个业务逻辑进行解耦合。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用服务降级可以防止我们服务中间不影响整体流程的模块出错导致整个业务处理雪崩。将核心业务保证完整性，非核心业务弱化。&lt;br&gt;
    
    </summary>
    
      <category term="dubbo" scheme="http://zhangjiaheng.cn/categories/dubbo/"/>
    
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="dubbo" scheme="http://zhangjiaheng.cn/tags/dubbo/"/>
    
      <category term="分布式服务降级" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>使用springboot进行国际化时自定义读取数据库配置</title>
    <link href="http://zhangjiaheng.cn/blog/20190320/%E4%BD%BF%E7%94%A8springboot%E8%BF%9B%E8%A1%8C%E5%9B%BD%E9%99%85%E5%8C%96%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/"/>
    <id>http://zhangjiaheng.cn/blog/20190320/使用springboot进行国际化时自定义读取数据库配置/</id>
    <published>2019-03-20T11:27:02.000Z</published>
    <updated>2019-04-22T14:13:00.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>springboot默认就支持国际化的，而且不需要你过多的做什么配置，只需要在<code>resources/</code>下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。 具体的关于springboot的国际化配置我这边就不再过多介绍(包括Locale的设置以及如何根据区域设置语言等)，关于页面上得使用可以参考：<a href="!https://www.baidu.com/s?word=springboot+%E5%9B%BD%E9%99%85%E5%8C%96">springboot国际化</a>。在这篇博客中，我要介绍的是一个很有用的功能并且绝大部分人也会用得到，就是<br><strong><font color="#0099ff" size="5" face="黑体">不使用配置文件<code>messages.properties</code>储存国际化语言，而使用数据库进行动态配置，做到无需重启更改配置。</font></strong><br><a id="more"></a></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h4 id="MessageSource介绍"><a href="#MessageSource介绍" class="headerlink" title="MessageSource介绍"></a>MessageSource介绍</h4><p>Spring提供了一个接口MessageSource用于获取国际化信息，ReloadableResourceBundleMessageSource和ResourceBundleMessageSource都是继承了该接口的一个抽象实现类AbstractMessageSource，在spring官网有一段这样介绍messageSource的话：<br><img src="https://img-blog.csdn.net/20180116154941287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDcyMTEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="spring官网对于messageSource的介绍" title="spring官网对于messageSource的介绍"><br>图中红框画起来的意思就是，上下文加载的时候会查询messageSource的bean，如果没有就会创建一个名为<code>messageSource</code>放在上下文中… …等等。</p><h4 id="在springboot中注入自定义messageSource"><a href="#在springboot中注入自定义messageSource" class="headerlink" title="在springboot中注入自定义messageSource"></a>在springboot中注入自定义messageSource</h4><p>通过上面的介绍，我们就可以自己定义自己的messageSource进行配置的读取了。<br> <strong> 我这边是把这个放在了业务层，大家用的时候也可以直接放在控制层(一般都放在控制层，要用到)，使用@Compnent(“messageSource”)注解声明下bean名称即可 </strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">// MyMessageSourceService是我自己的接口 你也可以不需要。使用@Compnent(&quot;messageSource&quot;)注解就行</span><br><span class="line">@Service(&quot;messageSource&quot;)</span><br><span class="line">public class MyMessageSource extends AbstractMessageSource implements ResourceLoaderAware, MyMessageSourceService &#123;</span><br><span class="line"></span><br><span class="line">    ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    // 这个是用来缓存数据库中获取到的配置的 数据库配置更改的时候可以调用reload方法重新加载</span><br><span class="line">    // 当然 实际使用者也可以不使用这种缓存的方式</span><br><span class="line">    private static final Map&lt;String, Map&lt;String, String&gt;&gt; LOCAL_CACHE = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    SysI18nService sysI18nService;</span><br><span class="line"></span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(MyMessageSource.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化</span><br><span class="line">     */</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        this.reload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重新将数据库中的国际化配置加载</span><br><span class="line">     */</span><br><span class="line">    public void reload() &#123;</span><br><span class="line">        LOCAL_CACHE.clear();</span><br><span class="line">        LOCAL_CACHE.putAll(loadAllMessageResourcesFromDB());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从数据库中获取所有国际化配置 这边可以根据自己数据库表结构进行相应的业务实现</span><br><span class="line">     * 对应的语言能够取出来对应的值就行了 无需一定要按照这个方法来</span><br><span class="line">     */</span><br><span class="line">    public Map&lt;String, Map&lt;String, String&gt;&gt; loadAllMessageResourcesFromDB() &#123;</span><br><span class="line">        List&lt;SysI18nBO&gt; list = sysI18nService.findList(new SysI18nAO());</span><br><span class="line">        if (CollectionUtils.isNotEmpty(list)) &#123;</span><br><span class="line">            final Map&lt;String, String&gt; zhCnMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class="line">            final Map&lt;String, String&gt; enUsMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class="line">            final Map&lt;String, String&gt; idIdMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class="line">            for (SysI18nBO bo : list) &#123;</span><br><span class="line">                String name = bo.getModel() + &quot;.&quot; + bo.getName();</span><br><span class="line">                String zhText = bo.getZhCn();</span><br><span class="line">                String enText = bo.getEnUs();</span><br><span class="line">                String idText = bo.getInId();</span><br><span class="line">                zhCnMessageResources.put(name, zhText);</span><br><span class="line">                enUsMessageResources.put(name, enText);</span><br><span class="line">                idIdMessageResources.put(name, idText);</span><br><span class="line">            &#125;</span><br><span class="line">            LOCAL_CACHE.put(&quot;zh&quot;, zhCnMessageResources);</span><br><span class="line">            LOCAL_CACHE.put(&quot;en&quot;, enUsMessageResources);</span><br><span class="line">            LOCAL_CACHE.put(&quot;in&quot;, idIdMessageResources);</span><br><span class="line">        &#125;</span><br><span class="line">        return MapUtils.EMPTY_MAP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从缓存中取出国际化配置对应的数据 或者从父级获取</span><br><span class="line">     *</span><br><span class="line">     * @param code</span><br><span class="line">     * @param locale</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getSourceFromCache(String code, Locale locale) &#123;</span><br><span class="line">        String language = locale.getLanguage();</span><br><span class="line">        Map&lt;String, String&gt; props = LOCAL_CACHE.get(language);</span><br><span class="line">        if (null != props &amp;&amp; props.containsKey(code)) &#123;</span><br><span class="line">            return props.get(code);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (null != this.getParentMessageSource()) &#123;</span><br><span class="line">                    return this.getParentMessageSource().getMessage(code, null, locale);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                logger.error(ex.getMessage(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">            return code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 下面三个重写的方法是比较重要的</span><br><span class="line">    @Override</span><br><span class="line">    public void setResourceLoader(ResourceLoader resourceLoader) &#123;</span><br><span class="line">        this.resourceLoader = (resourceLoader == null ? new DefaultResourceLoader() : resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected MessageFormat resolveCode(String code, Locale locale) &#123;</span><br><span class="line">        String msg = getSourceFromCache(code, locale);</span><br><span class="line">        MessageFormat messageFormat = new MessageFormat(msg, locale);</span><br><span class="line">        return messageFormat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String resolveCodeWithoutArguments(String code, Locale locale) &#123;</span><br><span class="line">        return getSourceFromCache(code, locale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p> 至此，自定义国际化配置读取数据库已经完成，只需要在更新数据库配置的时候调用一下reload重置一下缓存中的信息即可。</p><blockquote><p><a href="!https://blog.csdn.net/u014721131/article/details/79075802">参考博客：spring xml配置自定义读取数据库的messageSource</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;springboot默认就支持国际化的，而且不需要你过多的做什么配置，只需要在&lt;code&gt;resources/&lt;/code&gt;下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。 具体的关于springboot的国际化配置我这边就不再过多介绍(包括Locale的设置以及如何根据区域设置语言等)，关于页面上得使用可以参考：&lt;a href=&quot;!https://www.baidu.com/s?word=springboot+%E5%9B%BD%E9%99%85%E5%8C%96&quot;&gt;springboot国际化&lt;/a&gt;。在这篇博客中，我要介绍的是一个很有用的功能并且绝大部分人也会用得到，就是&lt;br&gt;&lt;strong&gt;&lt;font color=&quot;#0099ff&quot; size=&quot;5&quot; face=&quot;黑体&quot;&gt;不使用配置文件&lt;code&gt;messages.properties&lt;/code&gt;储存国际化语言，而使用数据库进行动态配置，做到无需重启更改配置。&lt;/font&gt;&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="国际化" scheme="http://zhangjiaheng.cn/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>layui结合freemarker+springboot进行前端数据表格字典转义</title>
    <link href="http://zhangjiaheng.cn/blog/20190316/layui%E5%BC%80%E5%8F%91%E4%B8%AD%E7%BB%93%E5%90%88freemarker%E5%B1%95%E7%A4%BA%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE/"/>
    <id>http://zhangjiaheng.cn/blog/20190316/layui开发中结合freemarker展示字典数据/</id>
    <published>2019-03-16T11:51:53.000Z</published>
    <updated>2019-04-22T14:14:22.946Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。<br>那么在layui的数据表格中，我们要展示这样的数据，写法可以是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">templet: function (d) &#123;</span><br><span class="line">  if(d.status === 1)&#123;</span><br><span class="line">      return &quot;启用&quot;;</span><br><span class="line">  &#125; else if(d.status === 0)&#123;</span><br><span class="line">      return &quot;停用&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。<br>在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。<br>最后我们的写法就会简化成：<code>&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code>，接下来看看如何在springboot中配置使用吧。<br><a id="more"></a></p><h3 id="freemarker自定义标签介绍及使用"><a href="#freemarker自定义标签介绍及使用" class="headerlink" title="freemarker自定义标签介绍及使用"></a>freemarker自定义标签介绍及使用</h3><p><code>TemplateDirectiveModel</code>接口是freemarker自定标签或者自定义指令的核心处理接口。当模板页面遇到用户自定义的标签指令时，<code>execute()</code>方法会被执行。<code>execute()</code>方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void execute(</span><br><span class="line">  Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body</span><br><span class="line">) throws TemplateException, IOException;</span><br></pre></td></tr></table></figure></p><p>我们在使用freemarker自定义标签的时候需要实现该接口并且重写execute方法。</p><h4 id="execute-方法参数解释"><a href="#execute-方法参数解释" class="headerlink" title="execute()方法参数解释"></a><code>execute()</code>方法参数解释</h4><ul><li><em>Environment env</em>：系统环境变量，通常用它来输出相关内容，如<code>Writer out = env.getOut();</code></li><li><em>Map params</em>：自定义标签传过来的对象，就是从页面上获取的参数，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等。<br>在本例使用时，我们会将map转成我们自己的对象进行数据保存。</li><li><em>TemplateModel[] loopVars</em>：循环替代变量</li><li><em>TemplateDirectiveBody body</em>：标签中嵌套的内容，如<code>&lt;@tag&gt;body&lt;/@tag&gt;</code>，就是这个body</li></ul><h4 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h4><h6 id="定义接收页面参数的对象"><a href="#定义接收页面参数的对象" class="headerlink" title="定义接收页面参数的对象"></a>定义接收页面参数的对象</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">public class TableThTag &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 对象属性名【需要进行对象属性获取】</span><br><span class="line">     */</span><br><span class="line">    private String objName;</span><br><span class="line">    /**</span><br><span class="line">     * 字典标识</span><br><span class="line">     */</span><br><span class="line">    private String nid;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类型</span><br><span class="line">     */</span><br><span class="line">    private String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="实现TemplateDirectiveModel接口并重写execute方法"><a href="#实现TemplateDirectiveModel接口并重写execute方法" class="headerlink" title="实现TemplateDirectiveModel接口并重写execute方法"></a>实现<code>TemplateDirectiveModel</code>接口并重写<code>execute</code>方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@org.springframework.context.annotation.Configuration</span><br><span class="line">public class TableThDirective implements TemplateDirectiveModel &#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * FreeMarker自定义指令</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void execute(Environment environment, Map map, TemplateModel[] templateModels,</span><br><span class="line">                        TemplateDirectiveBody templateDirectiveBody) throws TemplateException, IOException &#123;</span><br><span class="line">        TableThTag tableThTag = new TableThTag();</span><br><span class="line">        //校验参数</span><br><span class="line">        try &#123;</span><br><span class="line">            //  用来将一些 key-value 的值（例如 hashmap）映射到 bean 中的属性</span><br><span class="line">            BeanUtils.populate(tableThTag, map);</span><br><span class="line">            if (StringUtils.isEmpty(tableThTag.getNid()) || StringUtils.isEmpty(tableThTag.getType())) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;nid,type不能为空&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;数据转化异常&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder html = new StringBuilder();</span><br><span class="line">        // 根据类型创建不同的HTML生成器</span><br><span class="line">        ThFormatterInterface thFormatterInterface = ThFormatterFactory.createThFormatter(tableThTag.getType());</span><br><span class="line">        if (thFormatterInterface != null) &#123;</span><br><span class="line">            String dictHtml = thFormatterInterface.buildFormatterHtml(tableThTag.getNid(), tableThTag.getFieldName());</span><br><span class="line">            html.append(dictHtml);</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行真正指令的执行部分:</span><br><span class="line">        Writer out = environment.getOut();</span><br><span class="line">        out.write(html.toString());</span><br><span class="line">        if (templateDirectiveBody != null) &#123;</span><br><span class="line">            templateDirectiveBody.render(environment.getOut());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BeansWrapper getBeansWrapper() &#123;</span><br><span class="line">        BeansWrapper beansWrapper =</span><br><span class="line">                new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build();</span><br><span class="line">        return beansWrapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，在这个方法中，我将页面上的参数转为<code>TableThTag</code>对象。然后再根据前端页面不同的type类型对应<br>实现了<code>ThFormatterInterface</code>的工厂对象，创建不同的html生成器。（这里考虑到扩展性，可能以后不光创建数据表格会用的到，比如下拉框什么的，也可以使用这种方式创建，所以在这里使用抽象工厂依据类型动态创建。）<br>下面就是创建html的具体工厂以及实现方法。</p><h6 id="ThFormatterInterface抽象工厂创建html生成器"><a href="#ThFormatterInterface抽象工厂创建html生成器" class="headerlink" title="ThFormatterInterface抽象工厂创建html生成器"></a><code>ThFormatterInterface</code>抽象工厂创建html生成器</h6><p>接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface ThFormatterInterface &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 构造生成枚举html</span><br><span class="line">     * @param nid</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String buildFormatterHtml(String nid, String fieldName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>工厂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ThFormatterFactory &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(ThFormatterFactory.class);</span><br><span class="line"></span><br><span class="line">    public static ThFormatterInterface createThFormatter(String type)&#123;</span><br><span class="line">        if(StringUtils.isEmpty(type))&#123;</span><br><span class="line">            return  new ThFormatterTemplate();</span><br><span class="line">        &#125;</span><br><span class="line">        // 文件名 如果type传template 就需要有一个名为ThFormatterTemplate的文件</span><br><span class="line">        // 并且实现了ThFormatterInterface以及重写生成html的方法</span><br><span class="line">        String fileName = &quot;ThFormatter&quot; + StringUtil.firstCharUpperCase(type);</span><br><span class="line">        //类路径 通过反射去创建实现类</span><br><span class="line">        String className = &quot;com.module.freemarker.impl.&quot;+fileName;</span><br><span class="line">        //生成表头格式实现类</span><br><span class="line">        ThFormatterInterface thFormatterInterface = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            thFormatterInterface =(ThFormatterInterface) Class.forName(className).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">        return thFormatterInterface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ThFormatterTemplate implements ThFormatterInterface &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String buildFormatterHtml(String nid, String fieldName) &#123;</span><br><span class="line">        Assert.notEMPTY(nid, &quot;nid不能为空&quot;);</span><br><span class="line">        Assert.notEMPTY(fieldName, &quot;objName不能为空&quot;);</span><br><span class="line">        SysDictService sysDictService = SpringContextHolder.getBean(SysDictService.class);</span><br><span class="line">        // 通过nid查询字典类 这里不需要进行照抄 每个人都会有自己的实现方法</span><br><span class="line">        List&lt;SysDictBO&gt; sysDictModelList = sysDictService.findByPartnerNid(nid);</span><br><span class="line">        StringBuilder dictHtml = new StringBuilder();</span><br><span class="line">        // 反正目的就是根据字典类生成对应的html就行了 需要生成的格式对照template原本应该有的写法就行了</span><br><span class="line">        dictHtml.append(&quot;templet: function(d)&#123; &quot;);</span><br><span class="line">        for (SysDictBO sysDict : sysDictModelList) &#123;</span><br><span class="line">            dictHtml.append(&quot;if(d.&quot; + fieldName + &quot; == &apos;&quot; + sysDict.getValue() + &quot;&apos;)&#123; return &apos;&quot; + sysDict.getName() + &quot;&apos;;&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        dictHtml.append(&quot;&#125;&quot;);</span><br><span class="line"></span><br><span class="line">        return dictHtml.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="最后将自定义标签注入到freemarker标签中去"><a href="#最后将自定义标签注入到freemarker标签中去" class="headerlink" title="最后将自定义标签注入到freemarker标签中去"></a>最后将自定义标签注入到freemarker标签中去</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@org.springframework.context.annotation.Configuration</span><br><span class="line">public class FreemarkerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private Configuration configuration;</span><br><span class="line">    @Resource</span><br><span class="line">    private TableThDirective tableThDirective;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void setSharedVariable()&#123;</span><br><span class="line">        configuration.setSharedVariable(&quot;th&quot;,tableThDirective);</span><br><span class="line">        configuration.setSharedVariable(&quot;shiro&quot;,new ShiroTags());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这样就大功告成了。</p><p>在页面上进行使用吧：<code>&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code></p><p>以后进行扩展什么的也方便，比如生成下拉框：<code>&lt;@th type=&quot;select&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code>这样然后自动生成html的时候查出来所有的字典，根据类型生成多个<option>出来就行了。</option></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。&lt;br&gt;那么在layui的数据表格中，我们要展示这样的数据，写法可以是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;templet: function (d) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if(d.status === 1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;quot;启用&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; else if(d.status === 0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return &amp;quot;停用&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。&lt;br&gt;在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。&lt;br&gt;最后我们的写法就会简化成：&lt;code&gt;&amp;lt;@th type=&amp;quot;template&amp;quot; nid=&amp;quot;basics_sys_status&amp;quot; objName=&amp;quot;status&amp;quot;&amp;gt;&amp;lt;/@th&amp;gt;&lt;/code&gt;，接下来看看如何在springboot中配置使用吧。&lt;br&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/categories/springboot/"/>
    
    
      <category term="开发日记" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="freemarker" scheme="http://zhangjiaheng.cn/tags/freemarker/"/>
    
      <category term="工厂模式" scheme="http://zhangjiaheng.cn/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="layui" scheme="http://zhangjiaheng.cn/tags/layui/"/>
    
  </entry>
  
  <entry>
    <title>springboot+shiro解决session污染的问题</title>
    <link href="http://zhangjiaheng.cn/blog/20190309/springboot+shiro%E8%A7%A3%E5%86%B3session%E6%B1%A1%E6%9F%93%E9%97%AE%E9%A2%98/"/>
    <id>http://zhangjiaheng.cn/blog/20190309/springboot+shiro解决session污染问题/</id>
    <published>2019-03-09T07:26:49.000Z</published>
    <updated>2019-04-22T14:13:54.943Z</updated>
    
    <content type="html"><![CDATA[<h4 id="同一个服务器启动多个web项目造成session污染"><a href="#同一个服务器启动多个web项目造成session污染" class="headerlink" title="同一个服务器启动多个web项目造成session污染"></a>同一个服务器启动多个web项目造成session污染</h4><p>昨天在敲代码的时候遇到了一个问题，同一个项目，我创建了两个分支，分别使用不同的端口。<br>但是在测试环境启动的时候我发现，在同一个浏览器上，我只能登陆其中的一个后台。在登陆另一个后台之后，前面那个<br>又需要再重新登陆了。</p><p>原因找了好久，最后F12控制台查看session发现，这两个web项目，使用的都是JSessionId作为cookie的key，在登陆另一个时，浏览器的这个cookie值就会被改变，所以前者就需要在重新登陆了。</p><a id="more"></a><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>在springboot中，对shiro配置进行更改session保存时的cookie的key名称，如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DefaultWebSessionManager sessionManager() &#123;</span><br><span class="line">    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();</span><br><span class="line">    Cookie cookie = sessionManager.getSessionIdCookie();</span><br><span class="line">    cookie.setName(&quot;MySessionId&quot;);</span><br><span class="line">    return sessionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在<code>securityManager</code>中将我们的<code>sessionManager</code>注入进去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * SecurityManager，权限管理，这个类组合了登陆，登出，权限，session的处理，是个比较重要的类。</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public DefaultWebSecurityManager securityManager() &#123;</span><br><span class="line">    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class="line">    securityManager.setRealm(myShiroRealm());</span><br><span class="line">    securityManager.setSessionManager(sessionManager());</span><br><span class="line">    return securityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要这样修改好就可以了。然后重启项目，就会发现，两个web项目都可以同时登陆了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;同一个服务器启动多个web项目造成session污染&quot;&gt;&lt;a href=&quot;#同一个服务器启动多个web项目造成session污染&quot; class=&quot;headerlink&quot; title=&quot;同一个服务器启动多个web项目造成session污染&quot;&gt;&lt;/a&gt;同一个服务器启动多个web项目造成session污染&lt;/h4&gt;&lt;p&gt;昨天在敲代码的时候遇到了一个问题，同一个项目，我创建了两个分支，分别使用不同的端口。&lt;br&gt;但是在测试环境启动的时候我发现，在同一个浏览器上，我只能登陆其中的一个后台。在登陆另一个后台之后，前面那个&lt;br&gt;又需要再重新登陆了。&lt;/p&gt;
&lt;p&gt;原因找了好久，最后F12控制台查看session发现，这两个web项目，使用的都是JSessionId作为cookie的key，在登陆另一个时，浏览器的这个cookie值就会被改变，所以前者就需要在重新登陆了。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="shiro" scheme="http://zhangjiaheng.cn/tags/shiro/"/>
    
      <category term="session污染" scheme="http://zhangjiaheng.cn/tags/session%E6%B1%A1%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Java中map新的骚操作</title>
    <link href="http://zhangjiaheng.cn/blog/20181209/Java%E4%B8%ADmap%E6%96%B0%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C/"/>
    <id>http://zhangjiaheng.cn/blog/20181209/Java中map新的骚操作/</id>
    <published>2018-12-09T15:03:05.000Z</published>
    <updated>2019-04-05T04:46:27.297Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下："><a href="#在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：" class="headerlink" title="在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下："></a>在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：</h4><blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>computeIfPresent</code> 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null<br><code>computeIfAbsent</code>  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值<br><code>compute</code>          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。</p></blockquote><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class MapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(1,&quot;zhang&quot;);</span><br><span class="line">        // computeIfPresent 根据之前的key/value 如果oldValue 不为null 则根据提供的方法返回一个新的值 并进行新值对旧值的替换</span><br><span class="line">        System.out.println(&quot; 1 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class="line">            return key + value;//原值不为null新值不为null 新值替换旧值</span><br><span class="line">        &#125;));</span><br><span class="line">        // 否则删除键值对</span><br><span class="line">        System.out.println(&quot; 2 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class="line">            return null;//原值不为null新值为null 删除键值对</span><br><span class="line">        &#125;));</span><br><span class="line">        map.put(1,null);</span><br><span class="line">        System.out.println(&quot; 3 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class="line">            return &quot;jiaheng&quot;;//原值为null 不做更改</span><br><span class="line">        &#125;));</span><br><span class="line">        // computeIfAbsent 根据之前的key 如果旧值为空或者key不存在 就按照方法用新值替换旧值 新值为null不做替换</span><br><span class="line">        map.put(1,&quot;zhang&quot;);</span><br><span class="line">        System.out.println(&quot; 4 ---&gt; &quot; + map.computeIfAbsent(1,k-&gt;&#123;</span><br><span class="line">            return null;// 不会被替换旧值 返回原值</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(&quot; 5 ---&gt; &quot; + map.computeIfAbsent(2,k-&gt;&#123;</span><br><span class="line">            k = k*k;</span><br><span class="line">            return k.toString();// key=2不存在 直接新建并存入新值</span><br><span class="line">        &#125;));</span><br><span class="line">        // compute类似于computeIfAbsent和computeIfPresent的合体</span><br><span class="line">        map.put(1,null);</span><br><span class="line">        System.out.println(&quot; 6 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class="line">            return &quot;张&quot;;// 原值为null新值不为null 新值替换旧值 此处与computeIfPresent不同</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(&quot; 7 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class="line">            v = (k*10) + v;</span><br><span class="line">            return v;// 新值不为null 替换旧值</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(&quot; 8 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class="line">            return null;// 新值为null 删除键值对</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        // 总结</span><br><span class="line">        // computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null</span><br><span class="line">        // computeIfAbsent  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值</span><br><span class="line">        // compute          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：&quot;&gt;&lt;a href=&quot;#在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：&quot; class=&quot;headerlink&quot; title=&quot;在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：&quot;&gt;&lt;/a&gt;在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：&lt;/h4&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h4&gt;&lt;p&gt;&lt;code&gt;computeIfPresent&lt;/code&gt; 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null&lt;br&gt;&lt;code&gt;computeIfAbsent&lt;/code&gt;  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值&lt;br&gt;&lt;code&gt;compute&lt;/code&gt;          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="开发日记" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>nodepad++不用插件去重的方法</title>
    <link href="http://zhangjiaheng.cn/blog/20181112/nodepad-%E4%B8%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://zhangjiaheng.cn/blog/20181112/nodepad-不用插件去重的方法/</id>
    <published>2018-11-12T05:54:14.000Z</published>
    <updated>2019-04-05T04:46:27.305Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中，当我们需要对一个文本中的行进行去重统计的时候，会发现对于文本的去重并不是那么好处理。而nodepad++的去重插件一般人又懒得去安装，不巧在网上找到这样一个去重的小技巧，即使用正则表达式进行去重，简直方便快捷。<br>在这里分享出来，希望大家能够用的上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(.*?)$\s+?^(?=.*^\1$)</span><br></pre></td></tr></table></figure></p><p><img src="https://blog.yimik.com/wp-content/uploads/2015/11/rm_duplicate_rows.png" alt="使用nodepad++去重"></p><p>点击全部替换，就可以将重复行全部去掉喽</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在工作中，当我们需要对一个文本中的行进行去重统计的时候，会发现对于文本的去重并不是那么好处理。而nodepad++的去重插件一般人又懒得去安装，不巧在网上找到这样一个去重的小技巧，即使用正则表达式进行去重，简直方便快捷。&lt;br&gt;在这里分享出来，希望大家能够用的上。&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发日记" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="工作技巧" scheme="http://zhangjiaheng.cn/tags/%E5%B7%A5%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
      <category term="nodepad++" scheme="http://zhangjiaheng.cn/tags/nodepad/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客文章置顶方式</title>
    <link href="http://zhangjiaheng.cn/blog/20180904/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6%E6%96%B9%E5%BC%8F/"/>
    <id>http://zhangjiaheng.cn/blog/20180904/hexo博客文章置顶方式/</id>
    <published>2018-09-04T11:51:53.000Z</published>
    <updated>2019-04-05T04:46:27.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h3><h4 id="目前已经有修改后支持置顶的仓库，可以直接用以下命令安装"><a href="#目前已经有修改后支持置顶的仓库，可以直接用以下命令安装" class="headerlink" title="目前已经有修改后支持置顶的仓库，可以直接用以下命令安装"></a>目前已经有修改后支持置顶的仓库，可以直接用以下命令安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="然后在需要置顶的文章的Front-matter中加上top-true即可。比如下面这篇文章："><a href="#然后在需要置顶的文章的Front-matter中加上top-true即可。比如下面这篇文章：" class="headerlink" title="然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章："></a>然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo博客置顶</span><br><span class="line">date: 2017-09-08 12:00:25</span><br><span class="line">categories: 博客搭建系列</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志："><a href="#到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：" class="headerlink" title="到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志："></a>到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：</h4><h5 id="打开：-blog-themes-next-layout-macro-目录下的post-swig文件，定位到-lt-div-class-quot-post-meta-quot-gt-标签下，紧接着下一行插入如下代码："><a href="#打开：-blog-themes-next-layout-macro-目录下的post-swig文件，定位到-lt-div-class-quot-post-meta-quot-gt-标签下，紧接着下一行插入如下代码：" class="headerlink" title="打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，紧接着下一行插入如下代码："></a>打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，紧接着下一行插入如下代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><hr><p>至此，博客置顶的方式就全部完成了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;博文置顶&quot;&gt;&lt;a href=&quot;#博文置顶&quot; class=&quot;headerlink&quot; title=&quot;博文置顶&quot;&gt;&lt;/a&gt;博文置顶&lt;/h3&gt;&lt;h4 id=&quot;目前已经有修改后支持置顶的仓库，可以直接用以下命令安装&quot;&gt;&lt;a href=&quot;#目前已经有修改后支持置顶的仓库，可以直接用以下命令安装&quot; class=&quot;headerlink&quot; title=&quot;目前已经有修改后支持置顶的仓库，可以直接用以下命令安装&quot;&gt;&lt;/a&gt;目前已经有修改后支持置顶的仓库，可以直接用以下命令安装&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm uninstall hexo-generator-index --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-generator-index-pin-top --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="hexo博客配置" scheme="http://zhangjiaheng.cn/categories/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="开发日记" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="hexo" scheme="http://zhangjiaheng.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>泰国7天6晚自由行攻略</title>
    <link href="http://zhangjiaheng.cn/blog/20180904/%E6%B3%B0%E5%9B%BD7%E5%A4%A96%E6%99%9A%E8%87%AA%E7%94%B1%E8%A1%8C%E6%94%BB%E7%95%A5/"/>
    <id>http://zhangjiaheng.cn/blog/20180904/泰国7天6晚自由行攻略/</id>
    <published>2018-09-04T11:38:45.000Z</published>
    <updated>2019-04-18T15:32:18.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人生不可能是一场说走就走的旅行，但心怀远方的人，一定要时刻做着说走就走的准备！</p></blockquote><font face="STCAIYUN">关于去泰国这件事情，可能发生的很突然，但是没关系，既然决定了，就把它安排在计划里。</font><h3 id="一、出行前的准备"><a href="#一、出行前的准备" class="headerlink" title="一、出行前的准备"></a>一、出行前的准备</h3><h4 id="1、护照-amp-签证"><a href="#1、护照-amp-签证" class="headerlink" title="1、护照&amp;签证"></a>1、护照&amp;签证</h4><p>我是在杭州工作，在杭州工作社保交满一年，就可以办护照了。拿着身份证在西湖区行政服务中心的出入境管理那儿就可以办理了。现在一楼自助打印下社保证明，然后去后面的楼，出入境办理区按照流程办理即可。大概一个多礼拜就能拿到护照，我也没想到有这么快。</p><p>签证是在淘宝上买的，260￥。七个工作日到手。</p><h4 id="2、泰铢-amp-电话卡-amp-出入境-amp-去泰国的必备软件-amp-其他"><a href="#2、泰铢-amp-电话卡-amp-出入境-amp-去泰国的必备软件-amp-其他" class="headerlink" title="2、泰铢&amp;电话卡&amp;出入境&amp;去泰国的必备软件&amp;其他"></a>2、泰铢&amp;电话卡&amp;出入境&amp;去泰国的必备软件&amp;其他</h4><p>泰国新规定，过境签、落地签-10000泰铢或等值外币现金（每人），20000泰铢（家庭）；<br>旅游签-20000泰铢或等值外币现金（每人），40000泰铢（家庭），抽查到概率很低，一般落地签会查的吧。但是网上说好像都不查的，或者很少查，但还是换两千的吧。</p><p>然后再淘宝买泰国7天happy卡，<a href="https://traveldetail.fliggy.com/item.htm?spm=a230r.1.14.1.42f77cb9MwHKZ4&amp;id=38255797452&amp;ns=1&amp;abbucket=7&amp;smToken=ef69fda777d249bab6581b59d4cb9a82&amp;smSign=twzGgFTirKEEIRtKkNLrYQ%3D%3D" target="_blank" rel="noopener">我买的是这家的</a>，8天无限流量，4G。</p><p>入境时需要填写出入境卡，然后和护照一起交给海关查看盖章。下面是入境卡中文说明图：<br><img src="http://ol3d80aa0.bkt.clouddn.com/%E6%B3%B0%E5%9B%BD%E5%87%BA%E5%85%A5%E5%A2%83%E5%8D%A1%E4%B8%AD%E6%96%87.jpg" alt="出入境卡"></p><p>一般情况下，在乘坐航班时常会有工作人员在抵达目的地钱给乘客发放出入境卡，以便乘客提前填好出入境卡，方便出关。护照也很重要，可以在国内出发前复印几份护照一定要放行李箱，不要随身携带。</p><a id="more"></a><h3 id="END-其他一些实用信息"><a href="#END-其他一些实用信息" class="headerlink" title="END - 其他一些实用信息"></a>END - 其他一些实用信息</h3><blockquote><h4 id="大使馆-领事馆"><a href="#大使馆-领事馆" class="headerlink" title="大使馆/领事馆"></a>大使馆/领事馆</h4></blockquote><p>中国驻泰国大使馆<br>地址：NO.57, Racgadapisek Road, Bangkok<br>电话：+66-02-2450088<br>领事保护电话：+66-854833327（24小时值班手机），+66-02-2457010（工作日9：00-17：00）</p><p>中国驻清迈总领事馆<br>地址：111 Changloh Road, Haiya District, Chiangmai<br>电话：+66-53-280380，+66-53-276125，+66-53-276457</p><p>中国驻宋卡总领事馆（近普吉岛、苏梅岛、甲米）<br>地址：9 Sadao Road, Songkhla<br>电话：+66-74-322034<br>领事保护电话：+66-817665560</p><p>中国驻宋卡总领馆驻普吉领事办公室<br>电话：+66-76-304219<br>领事保护电话：+66-945956168（中文、泰文），+66-945986859（中文）</p><p>中国驻孔敬总领馆<br>地址：142/44 Moo 2，Rob-Bueng Rd.，Nai-Muang， Muang， Khon Kaen<br>电话：+66-43-226873</p><blockquote><h4 id="紧急电话"><a href="#紧急电话" class="headerlink" title="紧急电话"></a>紧急电话</h4></blockquote><p>警察:123/191<br>火警:199<br>救护:2460199<br>领事:022-457010<br>大使馆:022-457044<br>旅游投诉:1155</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人生不可能是一场说走就走的旅行，但心怀远方的人，一定要时刻做着说走就走的准备！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;font face=&quot;STCAIYUN&quot;&gt;关于去泰国这件事情，可能发生的很突然，但是没关系，既然决定了，就把它安排在计划里。&lt;/font&gt;

&lt;h3 id=&quot;一、出行前的准备&quot;&gt;&lt;a href=&quot;#一、出行前的准备&quot; class=&quot;headerlink&quot; title=&quot;一、出行前的准备&quot;&gt;&lt;/a&gt;一、出行前的准备&lt;/h3&gt;&lt;h4 id=&quot;1、护照-amp-签证&quot;&gt;&lt;a href=&quot;#1、护照-amp-签证&quot; class=&quot;headerlink&quot; title=&quot;1、护照&amp;amp;签证&quot;&gt;&lt;/a&gt;1、护照&amp;amp;签证&lt;/h4&gt;&lt;p&gt;我是在杭州工作，在杭州工作社保交满一年，就可以办护照了。拿着身份证在西湖区行政服务中心的出入境管理那儿就可以办理了。现在一楼自助打印下社保证明，然后去后面的楼，出入境办理区按照流程办理即可。大概一个多礼拜就能拿到护照，我也没想到有这么快。&lt;/p&gt;
&lt;p&gt;签证是在淘宝上买的，260￥。七个工作日到手。&lt;/p&gt;
&lt;h4 id=&quot;2、泰铢-amp-电话卡-amp-出入境-amp-去泰国的必备软件-amp-其他&quot;&gt;&lt;a href=&quot;#2、泰铢-amp-电话卡-amp-出入境-amp-去泰国的必备软件-amp-其他&quot; class=&quot;headerlink&quot; title=&quot;2、泰铢&amp;amp;电话卡&amp;amp;出入境&amp;amp;去泰国的必备软件&amp;amp;其他&quot;&gt;&lt;/a&gt;2、泰铢&amp;amp;电话卡&amp;amp;出入境&amp;amp;去泰国的必备软件&amp;amp;其他&lt;/h4&gt;&lt;p&gt;泰国新规定，过境签、落地签-10000泰铢或等值外币现金（每人），20000泰铢（家庭）；&lt;br&gt;旅游签-20000泰铢或等值外币现金（每人），40000泰铢（家庭），抽查到概率很低，一般落地签会查的吧。但是网上说好像都不查的，或者很少查，但还是换两千的吧。&lt;/p&gt;
&lt;p&gt;然后再淘宝买泰国7天happy卡，&lt;a href=&quot;https://traveldetail.fliggy.com/item.htm?spm=a230r.1.14.1.42f77cb9MwHKZ4&amp;amp;id=38255797452&amp;amp;ns=1&amp;amp;abbucket=7&amp;amp;smToken=ef69fda777d249bab6581b59d4cb9a82&amp;amp;smSign=twzGgFTirKEEIRtKkNLrYQ%3D%3D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我买的是这家的&lt;/a&gt;，8天无限流量，4G。&lt;/p&gt;
&lt;p&gt;入境时需要填写出入境卡，然后和护照一起交给海关查看盖章。下面是入境卡中文说明图：&lt;br&gt;&lt;img src=&quot;http://ol3d80aa0.bkt.clouddn.com/%E6%B3%B0%E5%9B%BD%E5%87%BA%E5%85%A5%E5%A2%83%E5%8D%A1%E4%B8%AD%E6%96%87.jpg&quot; alt=&quot;出入境卡&quot;&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，在乘坐航班时常会有工作人员在抵达目的地钱给乘客发放出入境卡，以便乘客提前填好出入境卡，方便出关。护照也很重要，可以在国内出发前复印几份护照一定要放行李箱，不要随身携带。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>MySql数据库group by</title>
    <link href="http://zhangjiaheng.cn/blog/20180811/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-20180828/"/>
    <id>http://zhangjiaheng.cn/blog/20180811/开发日记-20180828/</id>
    <published>2018-08-11T03:02:37.000Z</published>
    <updated>2019-04-05T04:46:27.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mysql数据库根据多个字段进行分组统计"><a href="#Mysql数据库根据多个字段进行分组统计" class="headerlink" title="Mysql数据库根据多个字段进行分组统计"></a>Mysql数据库根据多个字段进行分组统计</h3><p>如下图，表order为订单表，字段以及数据如下：</p><p><img src="http://ol3d80aa0.bkt.clouddn.com/order.png" alt="order.png"><br>现在想要根据表中的信息，查询每天不同的商户有多少笔订单，以及订单的总金额。<br><a id="more"></a><br>需要完成以上查询，就需要进行group by多个字段统计，统计sql如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">store_name,</span><br><span class="line">DATE_FORMAT(add_time, &apos;%Y-%m-%d&apos;) AS addDate,</span><br><span class="line">count(1) AS total,</span><br><span class="line">sum(order_money) AS total_money</span><br><span class="line">FROM</span><br><span class="line">`order`</span><br><span class="line">GROUP BY</span><br><span class="line">DATE_FORMAT(add_time, &apos;%Y-%m-%d&apos;),</span><br><span class="line">store_name;</span><br></pre></td></tr></table></figure></p><p>统计查询得到的数据结果如下：</p><p><img src="http://ol3d80aa0.bkt.clouddn.com/a.png" alt="a.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mysql数据库根据多个字段进行分组统计&quot;&gt;&lt;a href=&quot;#Mysql数据库根据多个字段进行分组统计&quot; class=&quot;headerlink&quot; title=&quot;Mysql数据库根据多个字段进行分组统计&quot;&gt;&lt;/a&gt;Mysql数据库根据多个字段进行分组统计&lt;/h3&gt;&lt;p&gt;如下图，表order为订单表，字段以及数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ol3d80aa0.bkt.clouddn.com/order.png&quot; alt=&quot;order.png&quot;&gt;&lt;br&gt;现在想要根据表中的信息，查询每天不同的商户有多少笔订单，以及订单的总金额。&lt;br&gt;
    
    </summary>
    
      <category term="数据库基础" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="开发日记" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="MySql" scheme="http://zhangjiaheng.cn/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>dubbo获取注册中心的实例bean</title>
    <link href="http://zhangjiaheng.cn/blog/20180719/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-20180718/"/>
    <id>http://zhangjiaheng.cn/blog/20180719/开发日记-20180718/</id>
    <published>2018-07-18T18:07:56.000Z</published>
    <updated>2019-04-22T14:13:13.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发日记-20180718"><a href="#开发日记-20180718" class="headerlink" title="开发日记 20180718"></a>开发日记 20180718</h2><h3 id="com-alibaba-dubbo-remoting-transport-AbstractCodec-checkPayload-ERROR-Data-length-too-large"><a href="#com-alibaba-dubbo-remoting-transport-AbstractCodec-checkPayload-ERROR-Data-length-too-large" class="headerlink" title="com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large"></a>com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large: 11557050, max payload: 8388608 java.io.IOException: Data length too large: 11557050, max payload: 838860</span><br></pre></td></tr></table></figure><p>在使用dubbo框架开发的时候，需要做一个导出csv文件的功能，查询大量的数据然后在提供者这边进行处理导出，其中数据达到过20万行以上，几十M的数据，抛出了这样一个异常。遇到服务提供者从数据库查询或者其他地方返回过大的对象，导致报错时，尽管有办法取消这个数据长度的限制，但是这并不符合程序开发的初衷。我们需要将对于数据的处理放在业务层，我在这里做了异步导出，给前端返回的仅仅是一个程序完成的状态，完美的解决了这个问题。</p><a id="more"></a><h3 id="在dubbo消费者服务中写aop方法拦截工具类中的方法"><a href="#在dubbo消费者服务中写aop方法拦截工具类中的方法" class="headerlink" title="在dubbo消费者服务中写aop方法拦截工具类中的方法"></a>在dubbo消费者服务中写aop方法拦截工具类中的方法</h3><p>尽管服务的提供者和消费者都引入的工具类模块的依赖，但是拦截器的实际拦截的还是那个实际本身所在模块的方法。如果工具类是在消费者service层被使用的，那么在上层模块的拦截器是无法拦截到这个方法的。</p><h3 id="在dubbo服务中手动获取注册的提供者的bean"><a href="#在dubbo服务中手动获取注册的提供者的bean" class="headerlink" title="在dubbo服务中手动获取注册的提供者的bean"></a>在dubbo服务中手动获取注册的提供者的bean</h3><p>在这里犯的错：以为通过SpringContextHolder.getBean()可以获取，是我傻逼了，dubbo中的服务怎么能用spring上下文获取呢。这里我使用dubbo的方式完成了这个功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取服务的代理对象</span><br><span class="line"> *</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static &lt;T&gt; T getReferenceConfig(String appName,String address,Class&lt;?&gt; interfaceClass) &#123;</span><br><span class="line">    String key  = interfaceClass.getName();</span><br><span class="line">    ReferenceConfig&lt;T&gt; referenceConfig =  (ReferenceConfig&lt;T&gt;)referenceCache.get(key);</span><br><span class="line">    if(referenceConfig == null)&#123;</span><br><span class="line">        referenceConfig = new ReferenceConfig&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">        referenceConfig.setApplication(application);</span><br><span class="line">        referenceConfig.setRegistry(getRegistryConfig(appName,address));</span><br><span class="line">        referenceConfig.setInterface(interfaceClass);</span><br><span class="line"></span><br><span class="line">        referenceCache.put(key,referenceConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return referenceConfig.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开发日记-20180718&quot;&gt;&lt;a href=&quot;#开发日记-20180718&quot; class=&quot;headerlink&quot; title=&quot;开发日记 20180718&quot;&gt;&lt;/a&gt;开发日记 20180718&lt;/h2&gt;&lt;h3 id=&quot;com-alibaba-dubbo-remoting-transport-AbstractCodec-checkPayload-ERROR-Data-length-too-large&quot;&gt;&lt;a href=&quot;#com-alibaba-dubbo-remoting-transport-AbstractCodec-checkPayload-ERROR-Data-length-too-large&quot; class=&quot;headerlink&quot; title=&quot;com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large&quot;&gt;&lt;/a&gt;com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large: 11557050, max payload: 8388608 java.io.IOException: Data length too large: 11557050, max payload: 838860&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在使用dubbo框架开发的时候，需要做一个导出csv文件的功能，查询大量的数据然后在提供者这边进行处理导出，其中数据达到过20万行以上，几十M的数据，抛出了这样一个异常。遇到服务提供者从数据库查询或者其他地方返回过大的对象，导致报错时，尽管有办法取消这个数据长度的限制，但是这并不符合程序开发的初衷。我们需要将对于数据的处理放在业务层，我在这里做了异步导出，给前端返回的仅仅是一个程序完成的状态，完美的解决了这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="dubbo" scheme="http://zhangjiaheng.cn/categories/dubbo/"/>
    
    
      <category term="开发日记" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="dubbo" scheme="http://zhangjiaheng.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>关于IDEA再从git或者svn上导入项目时不能加载字模块的问题</title>
    <link href="http://zhangjiaheng.cn/blog/20180708/%E5%85%B3%E4%BA%8EIDEA%E5%86%8D%E4%BB%8Egit%E6%88%96%E8%80%85svn%E4%B8%8A%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%8D%E8%83%BD%E5%8A%A0%E8%BD%BD%E5%AD%97%E6%A8%A1%E5%9D%97%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://zhangjiaheng.cn/blog/20180708/关于IDEA再从git或者svn上导入项目时不能加载字模块的问题/</id>
    <published>2018-07-08T15:26:49.000Z</published>
    <updated>2019-04-05T04:46:27.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于IDEA再从git或者svn上导入项目时不能加载字模块的问题"><a href="#关于IDEA再从git或者svn上导入项目时不能加载字模块的问题" class="headerlink" title="关于IDEA再从git或者svn上导入项目时不能加载字模块的问题"></a>关于IDEA再从git或者svn上导入项目时不能加载字模块的问题</h3><blockquote><p>最近入职新公司，很多东西也都算是要从头学起。在之前公司用的都是eclipse，这边要求用IDEA，其实很早就知道这是一个非常强大的编译器，但平时没有机会使用，现在有机会用这个还是挺开心的。</p></blockquote><p>由于公司使用gitlab，在注册好账号导入代码的时候遇到一个情况，就是直接用IDEA的git工具导入的话会出现，maven项目的子模块无法被识别以及被管理的情况。事实上eclipse也有同样的问题。现在只说下使用IDEA遇到这个情况的解决办法。</p><a id="more"></a><h4 id="有两种解决方式。"><a href="#有两种解决方式。" class="headerlink" title="有两种解决方式。"></a>有两种解决方式。</h4><h5 id="1、手动将module添加到项目管理："><a href="#1、手动将module添加到项目管理：" class="headerlink" title="1、手动将module添加到项目管理："></a>1、手动将module添加到项目管理：</h5><ul><li>打开文件选项中的项目结构（快捷键ctrl+alt+shift+s）<br><a href="https://simimg.com/i/oLFwe" target="_blank" rel="noopener"><img src="https://s1.ax2x.com/2018/07/08/oLFwe.png" alt="oLFwe.png"></a></li><li>选择 模块-加号-导入module，手动将自己需要的模块一一导入进去<br><a href="https://simimg.com/i/oLTGd" target="_blank" rel="noopener"><img src="https://s1.ax2x.com/2018/07/08/oLTGd.png" alt="oLTGd.png"></a><h5 id="2、先将项目通过命令行导入到本机，然后通过IDEA的New-Project-from-Existing-Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了"><a href="#2、先将项目通过命令行导入到本机，然后通过IDEA的New-Project-from-Existing-Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了" class="headerlink" title="2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了"></a>2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了</h5><a href="https://simimg.com/i/oLXER" target="_blank" rel="noopener"><img src="https://s1.ax2x.com/2018/07/08/oLXER.md.png" alt="oLXER.md.png"></a><br><a href="https://simimg.com/i/oLm7r" target="_blank" rel="noopener"><img src="https://s1.ax2x.com/2018/07/08/oLm7r.md.png" alt="oLm7r.md.png"></a></li></ul><blockquote><p>从eclipse转到IDEA前几天是最艰难的，因为很多习惯不是说改就能改掉的，工具的使用总得需要一个学习的时间，但是等这段时间过去，后面一定会体会到IDEA的强大。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于IDEA再从git或者svn上导入项目时不能加载字模块的问题&quot;&gt;&lt;a href=&quot;#关于IDEA再从git或者svn上导入项目时不能加载字模块的问题&quot; class=&quot;headerlink&quot; title=&quot;关于IDEA再从git或者svn上导入项目时不能加载字模块的问题&quot;&gt;&lt;/a&gt;关于IDEA再从git或者svn上导入项目时不能加载字模块的问题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;最近入职新公司，很多东西也都算是要从头学起。在之前公司用的都是eclipse，这边要求用IDEA，其实很早就知道这是一个非常强大的编译器，但平时没有机会使用，现在有机会用这个还是挺开心的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于公司使用gitlab，在注册好账号导入代码的时候遇到一个情况，就是直接用IDEA的git工具导入的话会出现，maven项目的子模块无法被识别以及被管理的情况。事实上eclipse也有同样的问题。现在只说下使用IDEA遇到这个情况的解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发日记" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
      <category term="IDEA" scheme="http://zhangjiaheng.cn/tags/IDEA/"/>
    
      <category term="git" scheme="http://zhangjiaheng.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>纪念即将结束的第一份工作</title>
    <link href="http://zhangjiaheng.cn/blog/20180628/%E7%BA%AA%E5%BF%B5%E5%8D%B3%E5%B0%86%E7%BB%93%E6%9D%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%B7%A5%E4%BD%9C/"/>
    <id>http://zhangjiaheng.cn/blog/20180628/纪念即将结束的第一份工作/</id>
    <published>2018-06-28T14:20:45.000Z</published>
    <updated>2019-04-05T04:46:27.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="纪念即将-结束的第一份工作"><a href="#纪念即将-结束的第一份工作" class="headerlink" title="纪念即将 结束的第一份工作"></a>纪念<em><del>即将</del></em> 结束的第一份工作</h2><ol><li><h4 id="我一直都不知道自己想要得到些什么东西"><a href="#我一直都不知道自己想要得到些什么东西" class="headerlink" title="我一直都不知道自己想要得到些什么东西"></a>我一直都不知道自己想要得到些什么东西</h4><blockquote><ul><li>记得高中的时候，身边不管是家人还是老师，总会时刻不停在耳边说着：你需要如何如何学习，考上一个怎样的大学，进入一个怎么样的专业，以后找一个怎样的工作。可是当我听到这些话时总是会很反感。也许是叛逆，也许是这些对于我当时都是些虚无缥缈，很遥远的东西，我没有办法理解自己得到这些东西有什么用。但是虽然忠言不入耳，我还是得按照他们说的做。还好，大学上了一个普通的理工科一本。</li><li>当上了大学之后，没有了老师家长在耳边“絮叨”，更不知道自己要干什么了。记得当时参加各种社团，觉得在社团里面干的风风火火很牛逼，甚至课程都不上几节，最严重的时候好几周都不上课。浑浑噩噩的度过了大学的第一年之后，突然因为一个给学校编程培训班试听课凑人数的机会，让自动化专业的我接触到了软件开发这个方向。依然记得当时上课的老师，老范！当他用C语言在电脑上输出一串笑脸字符的时候，我当时的眼睛都亮了，我对和自己一块去凑人数的舍友说，这个人一定以后对我有很大的帮助，我一定要报名他的课程。后来真的觉得我是幸运的，老范是一个很有人格魅力的中年程序员 :) 。也是他让我知道了程序员是做什么的，也是他让我非常期待自己能够成为一个真正的软件开发者。<a id="more"></a></li><li>就这样我跟着老范从计算机基础，学到数据结构与算法，学计算机网络，MySQL，学习设计模式，学C++，后来又在另一个班学Java。计算机硬件方向专业的我，学完了软件专业学生要学的所有课程。终于大三，我找到了西安三星电子研究所的一份实习，写了两个月shell脚本，学习了Linux相关的知识以及自动化测试的东西，后来又在组内用PHP写了个网站，提供给大家进行会议的预定与提醒。现在想想这一切经验都是我的宝贵的财富.</li><li>实习结束后，工作却找的不是很顺利，也许是自己的实习经历没有太多做Java开发的东西，导致自己没有什么实际的项目经验。后来，我来了同※※。</li></ul></blockquote></li></ol><ol start="2"><li><h4 id="或许离开这里是我最正确的选择"><a href="#或许离开这里是我最正确的选择" class="headerlink" title="或许离开这里是我最正确的选择"></a>或许离开这里是我最正确的选择</h4><blockquote><ul><li>在拿到offer来到同※※之前，我觉得我来到了一个很好的大公司。事实上这里也没有很差，除了我所在的部门。同※※是国内最早做股票交易平台的软件公司，目前也有自己的大楼，装修的也很不错，很像一个一线的大型互联网公司。然而，只是很像而已。从一件很平常的事就看得出来：每天饭点，后勤部经理就站在食堂打饭窗口对打饭的员工喊，少打一点少打一点，他们吃不完！ … …</li><li>其实我刚来的时候觉得自己可以呆三年的，现在想想真的很抱歉，我得走了。并不是因为上面的“打饭”。我来到这里做的工作都是外包的，在B2B部门。我本来以为大公司的工作流程都很规范，没想到在这里刷新了我的三观哈哈。外包工作什么都得听客户的，乱改需求不说，自己公司的运维根本派不上用场，连tomcat的启动报错都不知道怎么解决，让我们作为开发的去同时做开发、测试、运维、项目经理、产品的活，想想就火大。项目经理把客户电话甩给你，自己沟通去，然后自己潇洒的下班。</li><li>唉ε=(′ο｀*)))，不想再说太多了，显得自己好像太小气，都要走了还要diss前公司。但是，我觉得我是真的得走了，而且我还算是忍得时间长的。我们组，比我来得晚，比我走的早的人，超过了10个。才一年啊。作为一个刚毕业一年的程序员，真的心好累。</li></ul></blockquote></li></ol><ol start="3"><li><h4 id="接下来的路少交点儿朋友，否则离开时会难受"><a href="#接下来的路少交点儿朋友，否则离开时会难受" class="headerlink" title="接下来的路少交点儿朋友，否则离开时会难受"></a>接下来的路少交点儿朋友，否则离开时会难受</h4><blockquote><ul><li>要走了要走了，却又感觉很难受。在这里，我接触过不少傻逼，但是也真的交到很多有趣的朋友。甚至有那种就算离职了，之后也不会断了联系的。在这个城市，原本独自一人的生活由他们，真的不会无聊。</li><li>天涯途上谁是客，散席时怎么分？ 也许有些人分开就不会再见，有些人想不见却总会出现在生活里。罢了，以后换到新的公司，不要再走心了。况且，真正值得走心的，也不会很多！</li></ul></blockquote></li></ol><h6 id="✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。-——《行歌》-·-陈鸿宇"><a href="#✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。-——《行歌》-·-陈鸿宇" class="headerlink" title="✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。  ——《行歌》 · 陈鸿宇"></a>✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。  ——《行歌》 · 陈鸿宇</h6>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;纪念即将-结束的第一份工作&quot;&gt;&lt;a href=&quot;#纪念即将-结束的第一份工作&quot; class=&quot;headerlink&quot; title=&quot;纪念即将 结束的第一份工作&quot;&gt;&lt;/a&gt;纪念&lt;em&gt;&lt;del&gt;即将&lt;/del&gt;&lt;/em&gt; 结束的第一份工作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;我一直都不知道自己想要得到些什么东西&quot;&gt;&lt;a href=&quot;#我一直都不知道自己想要得到些什么东西&quot; class=&quot;headerlink&quot; title=&quot;我一直都不知道自己想要得到些什么东西&quot;&gt;&lt;/a&gt;我一直都不知道自己想要得到些什么东西&lt;/h4&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;记得高中的时候，身边不管是家人还是老师，总会时刻不停在耳边说着：你需要如何如何学习，考上一个怎样的大学，进入一个怎么样的专业，以后找一个怎样的工作。可是当我听到这些话时总是会很反感。也许是叛逆，也许是这些对于我当时都是些虚无缥缈，很遥远的东西，我没有办法理解自己得到这些东西有什么用。但是虽然忠言不入耳，我还是得按照他们说的做。还好，大学上了一个普通的理工科一本。&lt;/li&gt;
&lt;li&gt;当上了大学之后，没有了老师家长在耳边“絮叨”，更不知道自己要干什么了。记得当时参加各种社团，觉得在社团里面干的风风火火很牛逼，甚至课程都不上几节，最严重的时候好几周都不上课。浑浑噩噩的度过了大学的第一年之后，突然因为一个给学校编程培训班试听课凑人数的机会，让自动化专业的我接触到了软件开发这个方向。依然记得当时上课的老师，老范！当他用C语言在电脑上输出一串笑脸字符的时候，我当时的眼睛都亮了，我对和自己一块去凑人数的舍友说，这个人一定以后对我有很大的帮助，我一定要报名他的课程。后来真的觉得我是幸运的，老范是一个很有人格魅力的中年程序员 :) 。也是他让我知道了程序员是做什么的，也是他让我非常期待自己能够成为一个真正的软件开发者。
    
    </summary>
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于git pull 拉取不到最新记录</title>
    <link href="http://zhangjiaheng.cn/blog/20180531/%E5%85%B3%E4%BA%8Egit-pull-%E6%8B%89%E5%8F%96%E4%B8%8D%E5%88%B0%E6%9C%80%E6%96%B0%E8%AE%B0%E5%BD%95/"/>
    <id>http://zhangjiaheng.cn/blog/20180531/关于git-pull-拉取不到最新记录/</id>
    <published>2018-05-31T03:39:17.000Z</published>
    <updated>2019-04-05T04:46:27.325Z</updated>
    
    <content type="html"><![CDATA[<p>//<br>//<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//~~~~~~~~~~~~~~~~~~~~~~o8888888o</span><br><span class="line">//~~~~~~~~~~~~~~~~~~~~~~88&quot;~.~&quot;88</span><br><span class="line">//~~~~~~~~~~~~~~~~~~~~~~(|~-_-~|)</span><br><span class="line">//~~~~~~~~~~~~~~~~~~~~~~0\~~=~~/0</span><br><span class="line">//~~~~~~~~~~~~~~~~~~~~___/`---&apos;\___</span><br><span class="line">//~~~~~~~~~~~~~~~~~~.&apos;~\\|~~~~~|//~&apos;.</span><br><span class="line">//~~~~~~~~~~~~~~~~~/~\\|||~~:~~|||//~\</span><br><span class="line">//~~~~~~~~~~~~~~~~/~_|||||~-:-~|||||-~\</span><br><span class="line">//~~~~~~~~~~~~~~~|~~~|~\\\~~-~~///~|~~~|</span><br><span class="line">//~~~~~~~~~~~~~~~|~\_|~~&apos;&apos;\---/&apos;&apos;~~|_/~|</span><br><span class="line">//~~~~~~~~~~~~~~~\~~.-\__~~&apos;-&apos;~~___/-.~/</span><br><span class="line">//~~~~~~~~~~~~~___&apos;.~.&apos;~~/--.--\~~`.~.&apos;___</span><br><span class="line">//~~~~~~~~~~.&quot;&quot;~&apos;&lt;~~`.___\_&lt;|&gt;_/___.&apos;~&gt;&apos;~&quot;&quot;.</span><br><span class="line">//~~~~~~~~~|~|~:~~`-~\`.;`\~_~/`;.`/~-~`~:~|~|</span><br><span class="line">//~~~~~~~~~\~~\~`_.~~~\_~__\~/__~_/~~~.-`~/~~/</span><br><span class="line">//~~~~~=====`-.____`.___~\_____/___.-`___.-&apos;=====</span><br><span class="line">//~~~~~~~~~~~~~~~~~~~~~~~`=---=&apos;</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//~~~~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure></p><p>//<br>//<del>~</del><del>~</del><del>~</del>佛祖保佑<del>~</del>~~~~永无BUG<br>//<br>//<br>//</p><blockquote><p>使用<code>git pull</code> 获取不到最新的记录，判断应该是某些时候未pull先commit导致的，使用命令：<code>git pull origin master</code>即可解决</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;//&lt;br&gt;//&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="git" scheme="http://zhangjiaheng.cn/categories/git/"/>
    
    
      <category term="开发日记" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【陈年风楼】VLOG-000001 一个普通的程序员的普通的一天</title>
    <link href="http://zhangjiaheng.cn/blog/20180421/vlog-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
    <id>http://zhangjiaheng.cn/blog/20180421/vlog-程序员的一天/</id>
    <published>2018-04-21T02:21:02.000Z</published>
    <updated>2019-04-05T04:46:27.314Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=22367659&cid=37047708&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%;height: 700px"> </iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=22367659&amp;cid=37047708&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot;
      
    
    </summary>
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot微服务搭建</title>
    <link href="http://zhangjiaheng.cn/blog/20180327/spring-boot%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <id>http://zhangjiaheng.cn/blog/20180327/spring-boot微服务搭建/</id>
    <published>2018-03-27T09:01:21.000Z</published>
    <updated>2019-04-22T14:13:38.835Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/qq_26627671/article/details/76563127" target="_blank" rel="noopener">本人的csdn传送门</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>进行web开发的时候Java程序员们难免会碰到那种很小的服务，比如就提供一个生成订单号的接口，或者一个上传文件的服务。而这时我们再去使用SpringMVC这种体量稍大、配置繁琐的框架开发难免会加大工作量，而且是不必要的。这个时候我们就可以选择使用这个微服务框架——springboot进行开发。</p></blockquote><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p><a id="more"></a><hr><h3 id="springboot框架的搭建与简单的REST风格的MVC架构demo"><a href="#springboot框架的搭建与简单的REST风格的MVC架构demo" class="headerlink" title="springboot框架的搭建与简单的REST风格的MVC架构demo"></a>springboot框架的搭建与简单的REST风格的MVC架构demo</h3><h4 id="首先，建立一个新的maven工程，pom文件主要内容如下："><a href="#首先，建立一个新的maven工程，pom文件主要内容如下：" class="headerlink" title="首先，建立一个新的maven工程，pom文件主要内容如下："></a>首先，建立一个新的maven工程，pom文件主要内容如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br></pre></td></tr></table></figure><p>其中核心依赖是    <code>spring-boot-starter-web</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>访问静态资源文件可以加入模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h4 id="编写Application-java文件，存放于src-main-java这个目录下"><a href="#编写Application-java文件，存放于src-main-java这个目录下" class="headerlink" title="编写Application.java文件，存放于src/main/java这个目录下"></a>编写Application.java文件，存放于src/main/java这个目录下</h4><h5 id="这里是springboot的核心启动类"><a href="#这里是springboot的核心启动类" class="headerlink" title="这里是springboot的核心启动类"></a>这里是springboot的核心启动类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">public class Application&#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，这个时候已经把框架搭建好了，运行以上main方法即可启动这个项目，但是我们现在看不到效果，接下来，就可以像SpringMVC一样加入MVC三层结构的代码了，目录结构如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/3327380-fb0da321cb7b5abb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="REST风格的MVC架构demo项目目录结构"></p><p>其中各层代码如下：</p><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.controller;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line">import com.zhang.entity.Photo;</span><br><span class="line">import com.zhang.service.mainService;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/photo&quot;)</span><br><span class="line">public class mainController &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private mainService mainservice;</span><br><span class="line">@RequestMapping(&quot;/&quot;)</span><br><span class="line">public ModelAndView index(ModelAndView mav)&#123;</span><br><span class="line">mav.addObject(&quot;hello&quot;, &quot;这是项目主页，访问根目录到达~~&quot;);</span><br><span class="line">mav.setViewName(&quot;index&quot;);</span><br><span class="line">return mav;</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/getPhoto&quot;)</span><br><span class="line">public Object doIt()&#123;</span><br><span class="line">Map&lt;String, Photo&gt; map = new HashMap&lt;String, Photo&gt;();</span><br><span class="line">map.put(&quot;photo&quot;, mainservice.getPhotoById(123));</span><br><span class="line">return map;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service实现类"><a href="#service实现类" class="headerlink" title="service实现类"></a>service实现类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.service.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">import com.zhang.dao.mainDao;</span><br><span class="line">import com.zhang.entity.Photo;</span><br><span class="line">import com.zhang.service.mainService;</span><br><span class="line">@Service(&quot;mainservice&quot;)</span><br><span class="line">public class mainServiceImpl implements mainService &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private mainDao maindao;</span><br><span class="line">@Override</span><br><span class="line">public Photo getPhotoById(int id) &#123;</span><br><span class="line">return maindao.getPhotoNameById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dao实现类"><a href="#dao实现类" class="headerlink" title="dao实现类"></a>dao实现类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.dao.impl;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">import com.zhang.dao.mainDao;</span><br><span class="line">import com.zhang.entity.Photo;</span><br><span class="line"></span><br><span class="line">@Repository(&quot;maindao&quot;)</span><br><span class="line">public class mainDaoImpl implements mainDao &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Photo getPhotoNameById(int id) &#123;</span><br><span class="line">Photo p = new Photo();</span><br><span class="line">p.setId(123);</span><br><span class="line">p.setName(&quot;雪山行纪念照&quot;);</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实体类photo"><a href="#实体类photo" class="headerlink" title="实体类photo"></a>实体类photo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.zhang.entity;</span><br><span class="line">public class Photo &#123;</span><br><span class="line">private int id;</span><br><span class="line">private String name;</span><br><span class="line">public int getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(int id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p><img src="http://upload-images.jianshu.io/upload_images/3327380-8ed38aa7e3e43e40?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目启动日志"></p><h4 id="项目默认端口为8080，在浏览器中访问刚才的controller会看到："><a href="#项目默认端口为8080，在浏览器中访问刚才的controller会看到：" class="headerlink" title="项目默认端口为8080，在浏览器中访问刚才的controller会看到："></a>项目默认端口为8080，在浏览器中访问刚才的controller会看到：</h4><p><img src="http://upload-images.jianshu.io/upload_images/3327380-75812c968f3ff846?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="访问结果"></p><hr><h3 id="如上，一个REST风格的MVC架构的demo项目就搭建完成了。"><a href="#如上，一个REST风格的MVC架构的demo项目就搭建完成了。" class="headerlink" title="如上，一个REST风格的MVC架构的demo项目就搭建完成了。"></a>如上，一个REST风格的MVC架构的demo项目就搭建完成了。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qq_26627671/article/details/76563127&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本人的csdn传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;进行web开发的时候Java程序员们难免会碰到那种很小的服务，比如就提供一个生成订单号的接口，或者一个上传文件的服务。而这时我们再去使用SpringMVC这种体量稍大、配置繁琐的框架开发难免会加大工作量，而且是不必要的。这个时候我们就可以选择使用这个微服务框架——springboot进行开发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>校招面试【京东、顺丰科技、招银网络科技、去哪儿网】</title>
    <link href="http://zhangjiaheng.cn/blog/20160927/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    <id>http://zhangjiaheng.cn/blog/20160927/校招面试经历/</id>
    <published>2016-09-27T11:38:45.000Z</published>
    <updated>2019-04-05T04:46:27.335Z</updated>
    
    <content type="html"><![CDATA[<ul><li>2017校招过的太惨了，还一度把原因怪罪在实习上，认为自己实习了4个月非Java研发的东西导致自己对于Java没有进行更加深入的学习，其实呢，还是应该怪自己不努力，怪不得其他。*<br>从三星离职之后就开始找一些公众号内推，我是来自非985、211院校的本科生，学的还是自动化专业，偏硬件，实习内容还不是Java开发之类的东西，不知道是由于这些公众号的原因（恶意吸引粉丝）还是自己的简历确实有问题，内推一直不顺利。烦得很。<br>之后又从9月开始海投Java软件开发岗，各种在线笔试。博主的基础（计算机网络操作系统等）本身就不强，C/C++/Java/PHP等还有HTML/CSS/JS/jQuery这些乱七八糟都学，算法和数据结构也学得不是很精，应付不来笔试编程题，感觉面试过的公司好少，妈的工作要找到十月了。</li></ul><a id="more"></a><p><strong> 首先说下招银电面：</strong> 9月23号晚上八点正在理发染发呢电话就来了，都不预约一下。<br>1、在Java中进行数据库连接并操作数据的步骤？最后需要进行什么操作？<br>2、项目中使用jquery，那么on、bind、live、delegate这几个函数有什么区别？<br>3、一个http请求所包含的数据格式是什么？<br>4、一次http请求的详细处理过程？<br>5、一次struts处理请求从开始到看到页面数据之间都发生了什么，整个详细过程？<br>6、项目中都用到了什么框架？（spring+struts+mybatis）<br>7、在自己的项目中有没有用到并发？如果让你现在考虑给你的项目中考虑并发你会怎么做？你要控制（进行同步）的数据源是哪些？<br><em>还有几个吧，想不起来了，应该比较简单就没有印象。电面后预约28号下午再面试。</em></p><hr><p><strong>招银现场面</strong>===该来的就这样来了<br><em>9月28号下午，不知道哪里来的自信感觉自己能够在一个半小时之内从长安赶到永宁门，坐地铁还把安远门当成了永宁门，到了安远门叫个优步，打电话让司机快一点，妈的竟然给我取消了，害我最后坐公交去，迟到了半个小时。心态爆炸！！！╮(╯▽╰)╭</em><br>1、去了在房间里等着，过会儿从酒店房间出来一个，叫我进去面试。先问我要了成绩单和一些证书，感觉招银对于成绩和证书很看重。面试官是三个人，3V1，很紧张有木有。中间坐着老大，然后一个问技术的，一个HR。<br>2、自我介绍<br>3、介绍一下自己的项目<br>4、项目中是使用servlet编写的后台代码，为什么不用开源框架？<br>5、如果要给项目中添加日志，该如何做？<br>6、一个struts请求从输入URL到显示在页面上都经过了哪些过程？<br>7、中间老大看我写着struts1，就问为什么使用struts1而不是struts2，有研究过两者的区别吗？<br>8、给一个string，问如何不使用任何库函数也不转化为数组，如何逆序？<br>就这么多问题，心态爆炸！怀疑人生！阿弥陀佛！</p><hr><p><strong> 京东一面：</strong> 9月24日一早6点就爬起来了，昨晚一晚上都没睡好。做梦都在想着一些多线程常考的东西，果然第二天就问了。<br>1、了解哪些常用的集合（set、list、map）？说说他们各自的特点（ArrayList和LinkedList等）？<br>2、HashMap、HashTable的区别？HashMap扩容为什么是2倍？如何实现的？<br>3、说一说线程调度机制？对线程池有何理解？哪里会用到线程池？好处是？<br>4、JVM中如果有一个线程挂起了，用什么工具去查找这个线程？<br>5、Java在什么时候会内存溢出？持久代内存溢出是什么情况？<br>6、动态代理的实现？（从动态代理答到了springAOP）<br>7、装饰模式了解吗？它的特点是什么？<br>8、I/O库中都用到了什么设计模式？<br>9、struts的一次请求是如何处理的？<br>10、网络编程？socket？<br>11、数据库索引了解吗？一个表中什么情况适合建立索引？如何去建立数据库索引？<br>12、快速排序的时间复杂度、原理？<br>13、java多态的实现原理？动态绑定底层虚拟机是如何实现的？<br>14、forward和redirect的区别？<br><em>同样。。。有很多问题没想起来，一面半个多小时，后天二面。。</em></p><hr><p><strong> 京东二面： </strong> 感觉一面回答的不好，全程面试官问什么我答什么，一点互动都没有，狠狠狠紧张！二面抱着无所谓的心态去的，倒还没有一面紧张。<br>1、了解那些算法和设计模式，说说你都用他们在什么地方？（贪心、回溯、分治、动态规划  ||  单例模式、工厂模式、动态代理、装饰模式、适配器模式等，说了说单例工厂动态代理等，再说到JDK动态代理和CGLIB代理的区别，一顿乱侃）<br>2、你的项目中那些都用到了多服务器？分布式了解吗？还问到了跨域请求。在实习的时候开发的网站也是单机吗？（从这儿开始问分布式集群服务器，高并发，这方面没怎么深入学习哎）<br>3、设计一个抢购商品的系统需要考虑到那些问题？<br>4、对于线程池有什么理解？<br>5、消息队列？<br>6、知道红黑树吗？平衡树？有什么区别？<br><em>算了不写了，想不起来了，估计二面跪了。。。</em></p><hr><p><strong> 顺丰技术面： </strong> 9月24日下午5点，就是京东一面的下午。。。（除了技术面就是HR）<br>1、简单的自我介绍一下。。。<br>2、介绍自己认为最能体现自己能力的项目，跟着项目引出很多题目，问了个透彻。。。<br>3、觉得自己还有那些方面的能力没有体现出来，可以说一说？（在这里傻逼了，我他喵说我暂时想不起来。因为可能自己的项目有点简单了，面试官还想要看看自己其他的能力，醉醉哒）<br>顺丰科技面试就这样，问了40多分钟，结果问完就让我走了，伤心，怪自己傻逼了。另一个西电的技术面玩就直接HR面了，让我回来等通知，4天了都没有通过不通过的通知，也是厉害。挂了也不让我安心挂！</p><hr><p><strong> 去哪儿网</strong> 9月29号下午3点好像<br>感觉自己真的是，干什么事情完全不做任何准备的，很多看过的问题，在面试的时候就只能说有印象，答不详细，想抽死自己！<br>1、去哪儿在金沙国际酒店面试，一天内面完，对去哪儿抱了很大希望，因为听学长说这个面试不难，问的比较基础，妈的现在写这段话还是想扇自己。<br>2、刚见到面试官，他拿到简历就说，你是本科生啊？我说哦。。。然后就是自我介绍。。。<br>3、给我了一张纸，在纸上写出自己用过的所有的类名。。。然后他在一边电脑上敲着东西。突然让写自己用过的所有的类的类名，脑子有点儿蒙了。<br>4、说说mysql的引擎吧，说了myisam和innodb以及其区别，这个看过。<br>5、mysql的各种连接是怎么回事？<br>6、说说B树和B+树的区别吧。<br>7、哈希冲突的解决算法？<br>8、说说HashMap的实现原理？<br>9、有什么问题问我？<br>10、还有一些忘记了。。。<br>/(ㄒoㄒ)/~~。。。都是些很简单的问题，妈的就是答得不好不够详细。</p><hr><p><strong> 总结 ： </strong> 菜鸟的求职之路总是艰辛的，校招时间还长，十月份还有几家面试（觉得自己的脸火辣辣的疼。。。），看到人都拿到了很好的Offer，不服啊！哎，语言总是苍白的，只有安心敲代码！！！！！！！！！国庆七天奋发图强，多看看Java并发编程实战那书上的东西吧，问得太多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;2017校招过的太惨了，还一度把原因怪罪在实习上，认为自己实习了4个月非Java研发的东西导致自己对于Java没有进行更加深入的学习，其实呢，还是应该怪自己不努力，怪不得其他。*&lt;br&gt;从三星离职之后就开始找一些公众号内推，我是来自非985、211院校的本科生，学的还是自动化专业，偏硬件，实习内容还不是Java开发之类的东西，不知道是由于这些公众号的原因（恶意吸引粉丝）还是自己的简历确实有问题，内推一直不顺利。烦得很。&lt;br&gt;之后又从9月开始海投Java软件开发岗，各种在线笔试。博主的基础（计算机网络操作系统等）本身就不强，C/C++/Java/PHP等还有HTML/CSS/JS/jQuery这些乱七八糟都学，算法和数据结构也学得不是很精，应付不来笔试编程题，感觉面试过的公司好少，妈的工作要找到十月了。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="面试经历" scheme="http://zhangjiaheng.cn/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>一个菜鸟在三星实习的那点儿感受</title>
    <link href="http://zhangjiaheng.cn/blog/20160911/%E4%B8%80%E4%B8%AA%E8%8F%9C%E9%B8%9F%E5%9C%A8%E4%B8%89%E6%98%9F%E5%AE%9E%E4%B9%A0%E7%9A%84%E6%84%9F%E5%8F%97/"/>
    <id>http://zhangjiaheng.cn/blog/20160911/一个菜鸟在三星实习的感受/</id>
    <published>2016-09-11T12:20:45.000Z</published>
    <updated>2019-04-05T04:46:27.317Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;2016年暑假，在大学这片沃土上的第三个学期就这样结束了，回想大学这三年，为了自己的未来迷茫过，也为自己努力过，也为了不少事情烦恼过，不知道将来自己可以在什么地方过着怎样的生活。曾经以为自己将会平凡地与大部分人一样，每天上着不知老师所云的课程，浑浑噩噩地度过这大学四年的生活，然后找一个普普通通的工作，但是也算自己运气好吧，在大一第二学期遇到了一位让自己眼前一亮的老师，慢慢学习并了解程序员这个行业，最后决定走上学习Java开发的道路。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;很早就听说，在大三暑假如果能够找到一个好的专业对口的暑期实习的话，那么在大学毕业以后找工作就方便许多。于是在2016年3月，我便一边努力学习着web开发的相关知识，一边在网上投简历找着实习，终于在一个学长的内推下，我进入了西安三星半导体有限公司，原西安三星电子研究所。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;三星是一个气氛非常好的公司，直到现在我都觉得能够进入这个公司是我大学期间的很幸运的一件事。在这儿我遇到了对我很好的师傅们，和那些谦逊和善的同事们。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;一开始进入公司，我被派的任务是进行artik芯片的测试执行，输出测试执行报告并且开发相应的shell脚本进行自动化测试。因为之前没有过Linux开发经验，所以对于这项工作还是有很多畏惧，怕自己不能完成相应的任务。后来进过一个礼拜的熟悉以后，对于自动化测试的脚本开发和测试执行更加得心应手起来。Artik芯片包含许多模块如MQTT、wifi、TLS、ZigBee、BT/BLE、Ethernet等，在进行这些模块的测试脚本的开发的时候，不仅要熟悉脚本开发的shell语言，还要对这些协议也有一定的学习。由于我之前没有接触过Linux，所以对于shell脚本的编写知识懂一丁点儿简单的命令，后来边工作边学习，对于一些常用的Linux命令也掌握的很熟悉了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;其实作自动化测试这个工作不是我期望的工作，但是来到公司里，对于公司的安排还是要服从的，毕竟也是能够学习到很多东西的。而且有很多有常年工作经验的师傅们的带领，不管是技术方面还是工作习惯与工作流程的熟悉上我也学习了不少。由于自己在学校是主要学习WEB开发的，所以一直希望自己能够在实习时得到一些这方面的工作经验，在接下来的两个月，我便被leader调到web组进行一个公司内部的项目管理系统的开发。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在做第二个项目之前，我不会想到这个项目的短短一个多月比我之前所有时间加起来都学到的多。因为这个项目几乎是由我独自完成前端与后台代码的编写，而且使用的是我之前没有任何经验的PHP语言进行开发。领导要求一个月内完成整个项目的开发，所以压力非常大。我一边在工作中学习，工作，一边再回到寝室后仍查资料学习希望能够把这个项目做到最好。前端方面我更加熟悉了jquery和bootstrap框架以及html/css，后端方面我又掌握了新的技能–PHP。从数据库的设计到前端页面的设计，再到后台业务代码的编写，投入了自己非常大的精力。不管最后结果如何，这个项目经历的确使我对于web开发的相关技术知识增长不少。在经历了一个多月的边学边做，最后总算（不是很完美的）完成了这项工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;9月，由于学校开学以及准备毕业找工作（想找Java开发的岗位），便不能继续在公司继续实习，对于这里很不舍，因为这儿是一个工作气氛非常舒服愉快的地方。在这里我遇到了很多和我一起在这里实习的小伙伴，也结识了很多已经毕业很多年工作近十年的朋友，我相信这些人和事在未来的日子里都是我最宝贵的财富，而这次的实习经历也希望将会是我走上成功的路上的一块踏板。希望自己的努力能够对得起自己的理想！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2016年暑假，在大学这片沃土上的第三个学期就这样结束了，回想大学这三年，为了自己的未来迷茫过，也为自己努力过，也为了不少事情烦恼过，不知道将来自己可以在什么地方过着怎样的生活。曾经以为自己将会平凡地与大部分人一样，每天上着不
      
    
    </summary>
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
      <category term="实习" scheme="http://zhangjiaheng.cn/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="三星" scheme="http://zhangjiaheng.cn/tags/%E4%B8%89%E6%98%9F/"/>
    
      <category term="shell自动化测试" scheme="http://zhangjiaheng.cn/tags/shell%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
