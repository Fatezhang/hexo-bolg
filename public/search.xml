<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深度分析如何写出一个线程安全的单例]]></title>
    <url>%2Fblog%2F20190607%2F%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[什么是单例模式？单例模式是在Java编程中除了工厂模式之外最常用的创建型设计模式之一。单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。 单例模式在创建时的注意事项： 因为每个类只能创建一个实例，所以需要将其构造方法封闭起来不能被外部调用，即私有化； 需要提供一个获取类实例的公有方法，所有使用该类实例的人都通过这个方法拿到单例对象； 在多线程环境下需要注意线程安全问题，避免多个线程同时创建出多个不同的实例，违背了单例的原则。 创建单例模式的方法及其优缺点饿汉型123456789101112131415public class HungrySingleton &#123; private static final HungrySingleton INSTANCE = new HungrySingleton(); /** * 私有构造 */ private HungrySingleton() &#123;&#125; /** * 获取类在加载的时候就创建好的实例 */ public static HungrySingleton getInstance() &#123; return INSTANCE; &#125;&#125; 分析：饿汉型单例是最简单的单例创建方法，在类中维护一个该类私有不可变的实例，然后提供一个获取该实例的静态方法即可。 优点：代码编写简单，线程安全（使用类加载机制保证线程安全，classloader在加载类的时候使用synchronized同步） 缺点：无法实现懒加载，在使用较少的时候浪费资源，无法防止反射破坏以及反序列化破坏单例唯一性 普通懒汉型12345678910111213public class LazySingleton &#123; private static LazySingleton INSTANCE ; private LazySingleton()&#123;&#125; public static LazySingleton getInstance()&#123; if(null == INSTANCE)&#123; INSTANCE = new LazySingleton(); &#125; return INSTANCE; &#125;&#125; 分析：这种懒汉型单例也是一种比较简单的单例实现方式，与第一种不同在于这种实例是在调用获取实例的静态方法的时候才创建 优点：代码简单，可以实现懒加载 缺点：多线程环境下会有线程安全问题，多个线程同时走到第8行代码，判断实例未创建，则会创建出多个实例;无法防止反射破坏以及反序列化破坏 那么为了实现线程安全我们可以在方法上加上同步关键字，但是这种方式的缺点就是多线程环境调用该方法都会阻塞，导致性能存在不必要的浪费123456public synchronized static LazySingleton getInstance()&#123; if(null == INSTANCE)&#123; INSTANCE = new LazySingleton(); &#125; return INSTANCE;&#125; 双重检测锁实现懒加载单例上述懒汉型同步机制可以改进如下 1234567891011121314151617181920212223public class DoubleLockSingleton &#123; private DoubleLockSingleton() &#123; &#125; private static DoubleLockSingleton INSTANCE; public static DoubleLockSingleton getInstance() &#123; // 进入方法后先判断一次 大幅减少多线程环境同步阻塞问题 // 但是这种方式在多线程第一次调用创建实例的时候会出现线程安全问题 if (null == INSTANCE) &#123; synchronized (DoubleLockSingleton.class) &#123; if (null == INSTANCE) &#123; // 问题的根源所在 // 此处可能会出现指令重排序 // new对象并不是原子操作 INSTANCE = new DoubleLockSingleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 分析：双重检测锁机制在进入getInstance()方法的时候会判断实例是否被创建，如果被创建，那么直接返回，如果没有，进入同步代码块，创建实例。这个方法貌似没有问题，而且还大大减少线程进入同步代码块阻塞的情况（因为只有第一次判断对象还没有创建的时候才会有线程进入同步代码块）。但是这种方法仍然存在线程安全性问题。问题出在第17行：INSTANCE = new DoubleLockSingleton();由于JVM虚拟机内部会对代码进行优化，在使用new创建对象的时候并不是一个原子操作且会被虚拟机进行指令重排序。这个步骤会被分成三步：1、在堆上为对象分配空间；2、对象进行初始化；3、将引用指向该堆上的地址。 由于在虚拟机中，指令重排序优化导致第2步和第3步的执行顺序可以被打乱，那么在代码执行到第11行的时候发现，INSTANCE不为null，直接返回一个未初始化完成的对象，导致程序崩溃。注意：synchronzed关键字没有屏蔽指令重排序的功能，那么如何优化呢？答案是使用volatile关键字修饰实例变量引用，即private volatile static TripleLockSingleton INSTANCE;。volatile关键字才有屏蔽指令重排序的语义。 优点：多线程环境下大部分时间线程安全 缺点：有可能会出现线程安全问题；不能避免反射和反序列化破坏 优化：private volatile static TripleLockSingleton INSTANCE; 静态内部类单例123456789101112public class StaticInnerClassSingleton &#123; private StaticInnerClassSingleton() &#123; &#125; private static class SingletonHolder &#123; public static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton(); &#125; public static StaticInnerClassSingleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 分析：静态内部类实现单例也是借助了类加载的线程安全机制，并同时基于内部类的使用时再创建的懒加载机制实现线程安全的懒加载模式的单例 优点：线程安全，可以实现懒加载 缺点：无法防止被反射以及反序列化破坏单例的唯一性 枚举类单例12345678public enum EnumSingleton &#123; INSTANCE; public static EnumSingleton getInstance() &#123; return INSTANCE; &#125;&#125; 分析：Joshua Bloch大神说过：“单元素的枚举类型已经成为实现Singleton的最佳方法”。足以见证枚举类在创建单例中的优势。 优点：代码简单，线程安全，可以防止反射和反序列化破坏 缺点：暂无 CAS创建单例123456789101112131415161718192021222324public class CASSingleton &#123; private static final AtomicReference&lt;CASSingleton&gt; INSTANCE = new AtomicReference&lt;&gt;(); private CASSingleton() &#123;&#125; /** * 使用原子操作 实现获取唯一实例 * 理论上在大量竞争的环境中 原子操作自旋等待消耗大量性能 但是实际上当一个线程创建好实例之后其余线程不会出现死循环 * 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度 */ public static CASSingleton getInstance() &#123; for (; ; ) &#123; CASSingleton instance = INSTANCE.get(); if (null != instance) &#123; return instance; &#125; instance = new CASSingleton(); if (INSTANCE.compareAndSet(null, instance)) &#123; return instance; &#125; &#125; &#125;&#125; 分析：使用原子操作AtomicReference进行单例的创建，事实上目前相对于双重检查锁性能上差的也不是也别大 优点：线程安全，懒加载，相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度 缺点：代码编写相对复杂，不能防止被反射和反序列化破坏 防止反射和反序列化破坏单例的方式上述几个创建单例的方式中，除了使用枚举类创建单例，都会产生被反射和反序列化破坏的情况，避免该问题的方式如下，大家需要深究的话可以打开搜索引擎… 这里不再展开了~ 枚举类防止反射和反序列化破坏 参考文章：https://www.cnblogs.com/chiclee/p/9097772.html 防止反射破坏因为反射是通过class对象来调用类的构造方法创建对象的，我们只需要在构造方法中进行判断，如果实例已经存在，就抛出异常。12345678/** * 私有构造 */private Singleton() &#123; if(INSTANCE != null)&#123; throw new RuntimeException(); &#125;&#125; 防止反序列化破坏在反序列化的时候ObjectInputStream.readObject()中会去判断是否存在readResolve()方法，如果存在的话会调用该方法返回一个实例，所以在单例类中编写readResolve()方法返回INSTANCE即可。 1234// 在反序列化时，直接调用这个方法，返回指定的对象，无需再新建一个对象private Object readResolve() &#123; return INSTANCE;&#125;]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>单例模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程学习(三)：CountDownLatch的实现原理及使用]]></title>
    <url>%2Fblog%2F20190602%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%89-%EF%BC%9ACountDownLatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是CountDownLatch？ 在本篇博客的封面，我放了一个截图，上面对于CountDownLatch的翻译是这样的：闭锁，倒计时门闩。其实顾名思义，CountDownLatch实际上就是一个计数器：计数-计数完成后做一些事。其实这个东西可以类比为一个水坝：当水还没有装满水库的时候水坝是关闭的，当水装满之后开闸放水，水库中的水”一起”涌出水库。 拥有同样功能的还有CyclicBarrier这个类，但是这个类相对较复杂，并且相对于CountDownLatch还可以重复使用，实际上前者一般被叫做线程计数器，后者被叫做循环屏障，还是有很大区别的。这个 在后面再进行源码学习。 CountDownLatch是如何实现的？ 同ReentrantLock类似，内部也是有一个实现了AbstractQueueSynchronizer的内部类。内部类做了父类的共享式的显示锁的方法实现，维护一个初始为N的状态state，每次有线程调用之后阻塞，然后state减1，直到减为0之后所有阻塞的线程重新开始执行。 首先是内部类Sync的实现 构造器接收一个int参数初始化state的值。tryAcquireShared()方法不会对state做改变，当state不为0的时候返回-1即失败，当state等于0其返回1，表示计数器已经计数完成，await()方法不再阻塞。tryReleaseShared()方法会使用原子操作当countDown()被调用的时候释放一个state的占用，即state-1。 1234567891011121314151617181920212223private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125; protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125;&#125; CountDownLatch的countDown方法 countDown方法主要作用就是使state-1 123public void countDown() &#123; sync.releaseShared(1);&#125; AQS中的releaseShared()方法的实现，如果释放成功执行doReleaseShared(); 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; CountDownLatch的await方法 await方法会等待当前state值是否是0，如果不是的话就一直阻塞。直到state为0。 12345678public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));&#125; AQS中的acquireSharedInterruptibly()方法实现如下，在AQS的实现中，判断当前线程是否中断，是的话抛出中断异常，否则判断当前线程是否继续需要阻塞，即调用tryAcquireShared()。是的话进入doAcquireSharedInterruptibly()方法，不断的判断int r = tryAcquireShared(arg);，state如果一直不等于0，r就一直是负数，就会继续进入循环。123456789101112131415161718192021222324252627282930313233343536public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125;/** * Acquires in shared interruptible mode. * @param arg the acquire argument */private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 其实以上代码的整体流程非常简单，即初始化CountDownLatch的state=N，每次调用countDown时state-1，减到0的时候停止阻塞，继续向下执行。 我可以用CountDownLatch来做什么事情？使用CountDownLatch模拟并发场景 可以使用CountDownLatch，创建多个线程并等待线程全部就绪之后唤醒所有线程。可以用这种方式测试代码的可用性，或者测试单例类等； 我在自己学习过程中也有写过类似的测试类 - github 使用CountDownLatch等待依赖线程执行 CountDownLatch用来等待其他依赖服务都启动好之后在进行自身线程的任务处理 总结 CountDownLatch是面试的时候多线程这块很容易被问到的点，实际上会考察这几个方面： 1、内部实现原理 —— 使用内部类继承AQS实现； 2、需要注意的方面 —— 计数器为0时，await后面的方法才会执行，否则一直阻塞，countDown方法尽量写在finally代码块中，避免出现异常导致死锁； 3、使用场景 —— 监控一些依赖服务启动完成之后执行代码，或者造“水坝”，即模拟大量并发场景等。]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>AQS</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写自己的SpringMVC框架]]></title>
    <url>%2Fblog%2F20190531%2F%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84SpringMVC%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Summer项目项目github地址 介绍 Summer项目是本人在学习Spring源码的时候按照SpringMVC的流程编写的一个简易的SpringMVC框架，主要完成以下功能： 读取配置文件进行包的扫描 对所有加入注解的bean进行装配 对加了注解的字段进行依赖自动注入 URL与相应方法的映射 请求的分发处理 项目通过实现以上流程完成SpringMVC框架工作的整体过程演示 以下是框架流程的详细步骤说明项目的结构Summer项目仅仅是一个单独的Servlet项目，没有引入Spring相关的任何依赖，仅仅使用了一些外部的工具类，我的pom.xml文件如下：12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.5.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.3.12.v20160915&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 项目使用jetty启动，所以我还配置了jetty插件12345678910111213141516171819&lt;build&gt; &lt;plugins&gt; &lt;!-- jetty插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.26&lt;/version&gt; &lt;configuration&gt; &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt; &lt;contextPath&gt;/Summer&lt;/contextPath&gt; &lt;connectors&gt; &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt; &lt;port&gt;4000&lt;/port&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 整体框架结构除了自定义的这几个注解之外其他的就和平常编写Controller以及Service的流程一样，我的核心代码主要在MyServlet中 MyServlet主要做了什么加载配置文件，首先读取web.xml中配置的配置文件把扫描到的所有类全链路径名保存在list中 以下是servlet的配置 1234567891011121314151617181920&lt;servlet&gt; &lt;!-- 声明Servlet对象 --&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;!-- 上面一句指定Servlet对象的名称 --&gt; &lt;servlet-class&gt;com.zhang.summer.servlet.MyServlet&lt;/servlet-class&gt; &lt;!-- 上面一句指定Servlet对象的完整位置，包含包名和类名 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config.properties&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 下面一句是在启动时加载servlet --&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;!-- 映射Servlet --&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;!--&lt;servlet-name&gt;与上面&lt;Servlet&gt;标签的&lt;servlet-name&gt;元素相对应，不可以随便起名 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!-- 上面一句话用于映射访问URL --&gt;&lt;/servlet-mapping&gt; 遍历所有类，使用反射创建对象class.forName创建对象，将所有我们声明了自己注解的类加入到一个Map中，即IOC-Map 遍历IOC-Map中的所有对象，进行依赖注入在这里我只判断是@MyController注解的类才进行依赖注入 处理URL和方法之间的映射将注解了@MyRequestMapping的类和方法路径拼接起来，对方法和拼接起来的url路径进行映射，并且对方法参数做特殊处理 请求分发在doGet或者doPost请求中通过映射好的url-method找到方法进行请求的分发处理]]></content>
      <categories>
        <category>SpringMVC框架</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程学习(二)：使用AQS编写可重入锁]]></title>
    <url>%2Fblog%2F20190525%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%EF%BC%9A%E4%BD%BF%E7%94%A8AQS%E7%BC%96%E5%86%99%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%2F</url>
    <content type="text"><![CDATA[AQS中文文档介绍 前言 上一章 我使用实现Lock接口的方式并结合Synchronized关键字实现了自己的可重入锁，学习并了解了可重入锁的原理机制。这一章我在学习了AQS之后结合AQS实现自己的显示可重入锁。 什么是AQS如上所述，Java8中文文档中描述的，AQS即AbstractQueuedSynchronizer。它提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状态。 子类必须定义改变此状态的受保护方法，以及根据该对象被获取或释放来定义该状态的含义。 给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。子类应定义为非公共内部助手类，用于实现其封闭类的同步属性。 AbstractQueuedSynchronizer类不实现任何同步接口。 相反，它定义了一些方法，如acquireInterruptibly(int) ，可以通过具体的锁和相关同步器来调用适当履行其公共方法。 其实AQS类是一个使用了模板方法模式的抽象框架类。它将核心实现封装在模板方法中，提供给程序员去实现具体的加锁和释放的机制，以便于实现一些特殊功能的锁，比如JDK提供的可重入锁和可重入读写锁等等。 如何使用AQSAQS在使用的时候主要需要重写以下方法 isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 使用AQS实现自己的可重入独占非公平锁的伪代码如下加锁步骤伪代码线程调用lock方法加锁，直接调用sync.acquire(1);，具体实现在tryAcquire 首先线程进入想要获取锁 拿到当前线程的引用 判断加锁状态，如果是未加锁状态 使用compareAndSetState自旋原子操作加锁 设置当前线程 返回true加锁成功 如果是加锁状态 判断是否是当前线程重入 如果是当前线程重入，state加1，并返回true加锁成功 最后如果都不是就返回false加锁失败 释放锁步骤伪代码线程调用unLock方法加锁，直接调用sync.release(1);，具体实现在tryRelease 首先线程进入方法想要释放锁 判断如果不是当前线程，就抛出异常 如果是当前线程，state就减1（arg一般为1），表示释放一次 当state释放到0时，设置拥有锁的线程为null，然后返回true 具体的代码实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * @Author zhangjiaheng * @Description 使用AQS重写一个可重入锁 **/public class MyReentrantLockByAQS implements Lock &#123; private Sync sync = new Sync(); // 内部类Sync ReentrantLock使用的内部抽象类 并派生两个子类实现两种(公平/非公平)锁 private class Sync extends AbstractQueuedSynchronizer &#123; @Override protected boolean tryAcquire(int arg) &#123; Thread t = Thread.currentThread(); // 如果第一个线程进来 可以拿到锁 则返回true // 如果第二个线程进来 如果不等于当前线程 返回false 否则更新当前线程值 int state = getState(); if (state == 0) &#123; while (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(t); return true; &#125; &#125; else if (t == getExclusiveOwnerThread()) &#123; // 当前线程再进来 setState(getState() + 1); return true; &#125; return false; &#125; @Override protected boolean tryRelease(int arg) &#123; // 锁的获取和释放时一一对应的 // 调用此方法的线程肯定是当前线程 if (Thread.currentThread() != getExclusiveOwnerThread()) &#123; throw new RuntimeException(); &#125; int c = getState() - arg; boolean flag = false; if (c == 0) &#123; setExclusiveOwnerThread(null); flag = true; &#125; setState(c); return flag; &#125; public Condition newCondition() &#123; return newCondition(); &#125; &#125; @Override public void lock() &#123; sync.acquire(1); &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; @Override public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(time)); &#125; @Override public void unlock() &#123; sync.release(1); &#125; @Override public Condition newCondition() &#123; return sync.newCondition(); &#125;&#125;]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>AQS</tag>
        <tag>可重入锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程学习(一)：编写一个简易的可重入锁]]></title>
    <url>%2Fblog%2F20190517%2F%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[什么是可重入锁在Java多线程编程中，锁是用来控制代码操作的原子性的重要机制，即对某线程共享的数据进行操作的时候，保证该操作同一时间段只有一个线程操作，整个过程是原子操作，其他线程再操作的时候只能等待锁的释放(排他锁)。一般我们的锁都是声明在方法上或者代码块中，那么在实际编程中我们经常会出现一个类的实例方法调用另一个实例方法的情况，我们不希望这个时候同一个线程进入另一实例方法时还要再去等待锁的释放，可重入锁就是为了解决这个问题，即 线程可以进入任何一个它已经拥有的锁所同步着的代码块。 如何实现一个简单的可重入锁 首先加锁的时候需要记录当前是哪一个线程加锁，加锁之后加锁标志位标记锁已被占用 维护一个加锁计数器，线程每次加锁计数器都要加1，每释放一次计数器减1 当非占用锁的线程进来之后自旋等待锁的释放，如果锁还在被占用，就wait(); 所释放的时候只有当前获取锁的线程调用才有用，锁释放加锁计数器减1，当减到0的时候，加锁标志位置为false，然后唤醒其他等待的线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyLock implements Lock &#123; private boolean locked = false;// 当前锁是否已经被线程使用 private int lockCount;// 保存当前线程加锁的次数 private Thread thread;// 保存当前线程是哪一个 public synchronized void lock() &#123; try &#123; // 自旋等待 // 可重入：如果获取锁的不是当前线程并且当前已经有线程加锁，则等待 while (locked &amp;&amp; Thread.currentThread() != this.thread) &#123; System.out.println(&quot;我等会儿。。。&quot;); wait(); &#125; // 如果没有线程使用锁或者获取锁的是当前线程 加锁计数器+1 然后thread指向获取锁的线程 this.thread = Thread.currentThread(); lockCount++; locked = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; &#125; /** * 释放锁的操作 */ public synchronized void unlock() &#123; try &#123; // 如果不是当前线程 不需要做任何操作 if(this.thread == Thread.currentThread())&#123; // 锁计数器减1 如果当前线程获取锁个数释放完成 lockCount--; if(lockCount == 0 )&#123; // 释放完成 加锁标志置为false 再唤醒等待锁的线程 locked = false; notifyAll(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; &#125; &#125;&#125; 在Java中常用的可重入锁 synchronized 关键字加锁 java.util.concurrent.locks.ReentrantLock java.util.concurrent.locks.ReentrantReadWriteLock 上述ReentrantLock内部实际上还是使用AQS，关于AQS，后面还要进行学习与整理]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>并发编程</tag>
        <tag>可重入锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长子串]]></title>
    <url>%2Fblog%2F20190512%2F%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[算法题解：无重复字符的最长子串leetcode地址： leetcode 题目： 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 12345示例 1:输入: &quot;abcabcbb&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 解法1：暴力求解 思路：遍历字符串，以每一个字符作为子串的起始字符，向后查找直到遇到和该字符相同的字符，记录长度，依次执行直到找到最长长度。 题解如下： 12345678910111213141516171819202122 public int maxIndexStrLength(String s) &#123; int maxLength = 0; for (int index = 0; index &lt; s.length(); index++) &#123; int length = 1; int i = index + 1; for (; ; ) &#123; if (i &gt;= s.length()) &#123; break; &#125; String ts = s.substring(index, i); char c = s.charAt(i); if (ts.contains(c + &quot;&quot;)) &#123; break; &#125; length++; i++; &#125; maxLength = maxLength &gt; length ? maxLength : length; &#125; return maxLength;&#125; 解法2：滑动窗口法 思路：在使用暴力解法时我们会发现实际上对于无重复子串来讲，我们产生了一些冗余的判断操作。例如对于串sdabcabcbb，判断了子串sdabc之后，当后面再出现字符a，那么重复字符之前的串直接舍弃就好。即直接从bca…开始判断即可。这样可以减少大量的不必要的判断与计算操作。 题解如下： 123456789101112131415161718public int maxIndexStrLength(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int start = 0, max = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); //如果当前元素与滑动窗口中的元素重复： if (map.containsKey(c) &amp;&amp; map.get(c) &gt;= start) &#123; max = Math.max(max, i - start); start = map.get(c) + 1; //如果当前元素与滑动窗口中的元素不重复，但已经遍历到了最后一个字符： &#125; else if (i == s.length() - 1) &#123; max = Math.max(max, i - start + 1); &#125; map.put(c, i); &#125; return max;&#125; 总结 滑动窗口法的思路可以用来解决很多字符串相关的问题]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化和transient关键字的理解与学习]]></title>
    <url>%2Fblog%2F20190511%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8Ctransient%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Java序列化 在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。 Java中如何进行序列化与反序列化 在Java中，对象一般是无法进行序列化与反序列化的。而使得对象能够被序列化的方式也很简单，即实现接口 Serializable 。如下代码即将对象序列化以及反序列化的过程。 123456789101112131415161718public class TestSerializable implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer age; private String name; TestSerializable() &#123; age = 20; name = &quot;aachuanpu&quot;; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; TestSerializable test = new TestSerializable(); File file = new File(&quot;e:/test.txt&quot;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(test); ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); TestSerializable newTest = (TestSerializable) in.readObject(); System.out.println(newTest.name); &#125;&#125; serialVersionUID的作用 serialVersionUID作为实现序列化接口的一个非必须非必须声明的静态常量经常不被开发者所重视，忘记声明。其实serialVersionUID的作用是为了保证序列化之前和之后的对象是同一对象。我们知道JVM判断对象是否相同是根据对象的类路径全限定名确定的，而虚拟机决定一个对象是否允许序列化和反序列化成这个类还取决于其serialVersionUID是否一致。不一致的话会导致java.io.InvalidClassException的异常，也可以不指定serialVersionUID，如果不指定的话java会根据class计算serialVersionUID。 对于两个相同的类及拥有相同的serialVersionUID，如果两个类字段不一致也会序列化和反序列化成功。这时Java会在反序列化的时候忽略掉不一致的字段。 静态变量的序列化 在序列化的时候，静态变量能够被序列化成功吗？ 12345678910111213141516171819202122public class TestSerializable implements Serializable &#123; private static final long serialVersionUID = 1L; public static String staticName; private Integer age; private String name; TestSerializable() &#123; age = 20; name = &quot;aachuanpu&quot;; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; TestSerializable test = new TestSerializable(); TestSerializable.staticName = &quot;name11111&quot;; File file = new File(&quot;e:/test.txt&quot;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(test); TestSerializable.staticName = &quot;name222&quot;; ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); TestSerializable newTest = (TestSerializable) in.readObject(); System.out.println(newTest.name); System.out.println(TestSerializable.staticName); &#125;&#125; 以上代码会输出什么？ 1234aachuanpuname222Process finished with exit code 0 如上所见：将对象序列化之后，修改静态变量的值，再将对象反序列化，输出的静态变量的值是修改之后的。即序列化保存的是对象的状态，静态变量属于类，因此序列化并不保存静态变量。 transient关键字与自定义序列化 对象的序列化是将对象中的数据写入本地文件或者用于网络传输的过程，但是很多时候会有一些数据无需进行序列化保存起来或者传输出去。我们可以使用transient关键字修饰成员变量。那么在Java序列化的时候就不会使用Java本身的序列化方式对其进行序列化。但是我们依然可以自定义自己的序列化行为对其进行序列化！ 自定义序列化： 定义自己的writeObject和readObject方法 对于使用transient修饰的成员变量，可以编写writeObject和readObject方法实现对于该成员变量(不仅仅只是针对该成员变量)的自定义序列化。在编写writeObject和readObject方法的时候需要注意的地方在于：这俩方法没有在Object中定义，也没有在Serializable接口中声明，JVM是如何调用到这俩方法的呢？答案是通过反射，去根据方法名和参数寻找到相应的方法，找到之后会被ObjectOutputStream调用，没有这俩方法就调用默认的序列化呗。还有就是因为ObjectOutputStream使用getPrivateMethod，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。 通过这种方法，我们实现自己的序列化与反序列化可以实现很多场景下的需求。比如网络传输的时候对于特殊字段进行加密等等。 如下，你会发现我在这俩方法中调用了defaultWriteObject()和defaultReadObject()用于处理未被transient修饰的成员变量。 1234567891011121314151617181920212223242526272829303132333435public class TestSerializable implements Serializable &#123; private static final long serialVersionUID = 1L; public static String staticName; private Integer age; private transient String name; TestSerializable() &#123; age = 20; name = &quot;aachuanpu&quot;; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; TestSerializable test = new TestSerializable(); TestSerializable.staticName = &quot;name11111&quot;; File file = new File(&quot;e:/test.txt&quot;); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); out.writeObject(test); TestSerializable.staticName = &quot;name222&quot;; ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); TestSerializable newTest = (TestSerializable) in.readObject(); System.out.println(newTest.name); System.out.println(TestSerializable.staticName); &#125; private void writeObject(ObjectOutputStream oos) throws IOException &#123; oos.defaultWriteObject(); name = &quot;自定义名称&quot;; oos.writeObject(name); System.out.println(&quot;调用writeObject&quot;); &#125; private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ois.defaultReadObject(); String name = (String) ois.readObject(); this.name = name; System.out.println(&quot;读出的name=&quot; + name); System.out.println(&quot;调用readObject&quot;); &#125;&#125; 输出如下： 1234567调用writeObject读出的name=自定义名称调用readObject自定义名称name222Process finished with exit code 0 父类的序列化 一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取 父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都 是默认声明的值。 常问：ArrayList中数组使用transient修饰为何还能被序列化 ArrayList源码： 1234567/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。但是ArrayList又是可序行化的类，elementData是ArrayList具体存放元素的成员，用transient来修饰elementData，需要实现自己的序列化方式去处理。即对于数组中多余的空间不去进行序列化。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。 其余补充来自文章 ← 点击链接查看参考博客 1.Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值; 2.Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。Serializable是内建支持的也就是直接implement即可，但Externalizable的实现类必须提供readExternal和writeExternal实现。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。 3.正如Effectvie Java中提到的，序列化就如同另外一个构造函数，只不过是有由stream进行创建的。如果字段有一些条件限制的，特别是非可变的类定义了可变的字段会反序列化可能会有问题。可以在readObject方法中添加条件限制，也可以在readResolve中做。参考56条“保护性的编写readObject”和“提供一个readResolve方法”。 4.当有非常复杂的对象需要提供deep clone时，可以考虑将其声明为可序列化，不过缺点也显而易见，性能开销。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>序列化</tag>
        <tag>transient关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的内心比拳头更强大]]></title>
    <url>%2Fblog%2F20190509%2F%E4%BD%A0%E7%9A%84%E5%86%85%E5%BF%83%E6%AF%94%E6%8B%B3%E5%A4%B4%E6%9B%B4%E5%BC%BA%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[加密博客请输入密码访问 Decrypt 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]]></content>
      <categories>
        <category>个人随笔</category>
      </categories>
      <tags>
        <tag>个人随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用[幕布]创建Java知识体系思维导图]]></title>
    <url>%2Fblog%2F20190507%2F%E4%BD%BF%E7%94%A8-%E5%B9%95%E5%B8%83-%E5%88%9B%E5%BB%BAJava%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[昨天在V2EX上逛的时候突然发现有人推荐一个很不错的东西——幕布。我本身就是一个对一些名称很敏感的人，看到这个名字就很想知道这到底是个什么东西，没想到竟偶然发现这么一个好东西。 幕布是一个制作笔记与记录事件的文本编辑工具（这样说要把幕布开发者气死了哈哈）。编辑视图如下：一键转换成思维导图就是本文最上面的那个图片。 其实我个人是比较喜欢幕布的一键转换思维导图的功能，以及它的导出.mm文件的功能，而且可以自动同步云端。这样就可以随时随地无论是在电脑还是手机上都可以打开来编辑以及查看了。 这里是我自己编写的Java知识体系，还没有写的很完整。希望自己能够坚持不断更新知识点，总结与巩固自己的技术水平！]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树与完全二叉树]]></title>
    <url>%2Fblog%2F20190504%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[什么是二叉树？在数据结构中，对于树，每一个分支，称之为一个度。那么，度最大为2的树我们称之为二叉树。通常子树我们会称之为左子树和右子树。二叉树通常用于实现二叉查找树和二叉堆。那么在Java中如何定义一个二叉树节点？ 首先，每一个节点需要有一个值域。其次，其还应该持有两个树节点的引用，即指向自己的左子树和自己的右子树。 具体代码如下：12345678910111213141516171819202122public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode() &#123; this.val = 0; this.left = null; this.right = null; &#125; TreeNode(int val) &#123; this.val = val; this.left = null; this.right = null; &#125; @Override public String toString() &#123; return &quot;(&quot; + val + &quot;)[left:&quot; + left + &quot;,right:&quot; + right + &quot;]&quot;; &#125;&#125; 如何创建二叉树二叉树的节点的数据结构已经用Java代码表示出来了，那么如何用这些节点来构造出一个完整的二叉树呢？请看下图二叉树的结构： 如上图，对于一个二叉树，需要有一个根节点。每个节点最多有两课子树，分别区分左子树还是右子树。即就算有一个子树，还是需要区分是左子树还是右子树。创建二叉树我们只需要将每一个树节点按照这样的规则连接起来即可。 创建二叉搜索树 概念：二叉搜索树，又叫二叉查找树。他是一棵特殊的二叉树，对于二叉搜索树中的每一个节点，它的左子树都不大于父节点，右子树都不小于父节点。空树是特殊的二叉搜索树。 创建：本例根据一个已有的数组进行二叉树的创建，基本的思路就是遍历数组，每个元素创建一个树节点，然后继续根据节点值得大小向下遍历判断，最后将值域小的放在节点的左子树，将值大的放在节点的右子树即可。 12345678910111213141516171819202122232425public static TreeNode createSearchTree(int[] a) &#123; if (a.length &gt; 0) &#123; TreeNode root = new TreeNode(a[0]); for (int i = 1; i &lt; a.length; i++) &#123; TreeNode c = root; TreeNode p = c; TreeNode q = new TreeNode(a[i]); while (c != null) &#123; p = c; if (a[i] &lt;= c.val) &#123; c = c.left; &#125; else &#123; c = c.right; &#125; &#125; if (q.val &lt; p.val) &#123; p.left = q; &#125; else &#123; p.right = q; &#125; &#125; return root; &#125; return null;&#125; 特点：二叉搜索树在应用于经常查找元素的场景效率会比较快，因为它的数据结构类似于二分查找，查找元素时根据其特性向下搜索即可。 创建完全二叉树 概念：首先介绍一下满二叉树：即树中的所有节点除了叶节点都有左子树和右子树，叶节点的左右子树都为空，这样的树称之为满二叉树。而对于一棵完全二叉树，只有树的最后一层连续缺失右边节点。满二叉树一定是完全二叉树，反之则不一定成立。如图分别是一棵满二叉树和一棵完全二叉树： 创建： 完全二叉树的创建需要按层去创建。这边我们借助队列的特点，将二叉树的节点连接起来，构造成完全二叉树 123456789101112131415161718192021public static TreeNode createWholeTree(int[] a) &#123; if (a.length &gt; 0) &#123; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); TreeNode root = new TreeNode(a[0]); queue.add(root); int index = 0; for (int i = 1; i &lt; a.length; i++) &#123; TreeNode curn = queue.get(index); TreeNode ti = new TreeNode(a[i]); queue.add(ti); if (curn.left == null) &#123; curn.left = ti; &#125; else if (curn.right == null) &#123; curn.right = ti; index++; &#125; &#125; return root; &#125; return null; &#125; 特点：对于一个h层的完全二叉树，前h-1层是满的，第h层连续缺失右边节点。所以叶子结点只能出现在最下层和次下层，最下层的叶子结点集中在树的左部，倒数第二层若存在叶子结点，一定在右部连续位置，如果结点度为1，则该结点只有左孩子，即没有右子树，同样结点数目的二叉树，完全二叉树深度最小。 二叉树的遍历 前中后序递归遍历： 1234567891011121314151617181920212223242526272829303132/** * 递归先序遍历二叉树 左-根-右 */public static void frontPrintOutTree(TreeNode root) &#123; if (null != root) &#123; System.out.print(root.val); frontPrintOutTree(root.left); frontPrintOutTree(root.right); &#125;&#125;/** * 递归中序遍历二叉树 左-根-右 */public static void midPrintOutTree(TreeNode root) &#123; if (null != root) &#123; midPrintOutTree(root.left); System.out.print(root.val); midPrintOutTree(root.right); &#125;&#125;/** * 递归先序遍历二叉树 左-根-右 */public static void lastPrintOutTree(TreeNode root) &#123; if (null != root) &#123; lastPrintOutTree(root.left); lastPrintOutTree(root.right); System.out.print(root.val); &#125;&#125; 按层遍历： 123456789101112131415161718192021/** * 按层遍历二叉树 */public static void levelPrintOutTree(TreeNode root) &#123; if (null != root) &#123; LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); TreeNode i = root; while (!queue.isEmpty()) &#123; if (i.left != null) &#123; queue.add(i.left); &#125; if (i.right != null) &#123; queue.add(i.right); &#125; System.out.print(i.val); queue.poll(); i = queue.peek(); &#125; &#125;&#125; 以上代码的github地址：GITHUB地址]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Springboot服务启动之后执行一些代码(三种方式)]]></title>
    <url>%2Fblog%2F20190419%2F%E5%A6%82%E4%BD%95%E5%9C%A8springboot%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81(%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F)%2F</url>
    <content type="text"><![CDATA[前言 通常的我们的项目开发中，经常会遇到那种在服务一启动就需要自动执行一些业务代码的情况。比如将数据库中的配置信息或者数据字典之类的缓存到redis，或者在服务启动的时候将一些配置化的定时任务开起来。关于spring mvc或者springboot如何在项目启动的时候就执行一些代码，方法其实有很多，我这边介绍一下我使用过的三种。 1、@PostConstruct 注解从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，@PostConstruct和@PreDestroy，这两个注解被用来修饰一个非静态的void（）方法。@PostConstruct会在所在类的构造函数执行之后执行，在init()方法执行之前执行。(@PreDestroy注解的方法会在这个类的destory()方法执行之后执行。) 使用示例：在Spring容器加载之后，我需要启动定时任务去做任务的处理（我的定时任务采用的是读取数据库配置的方式）。在这里我使用@PostConstruct 指定了需要启动的方法。12345678910111213141516171819202122232425262728293031323334@Component // 注意 这里必须有public class StartAllJobInit &#123; protected Logger logger = LoggerFactory.getLogger(getClass().getName()); @Autowired JobInfoService jobInfoService; @Autowired JobTaskUtil jobTaskUtil; @PostConstruct // 构造函数之后执行 public void init()&#123; System.out.println(&quot;容器启动后执行&quot;); startJob(); &#125; public void startJob() &#123; List&lt;JobInfoBO&gt; list = jobInfoService.findList(); for (JobInfoBO jobinfo :list) &#123; try &#123; if(&quot;0&quot;.equals(jobinfo.getStartWithrun()))&#123; logger.info(&quot;任务&#123;&#125;未设置自动启动。&quot;, jobinfo.getJobName()); jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP); &#125;else&#123; logger.info(&quot;任务&#123;&#125;设置了自动启动。&quot;, jobinfo.getJobName()); jobTaskUtil.addOrUpdateJob(jobinfo); jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING); &#125; &#125; catch (SchedulerException e) &#123; logger.error(&quot;执行定时任务出错，任务名称 &#123;&#125; &quot;, jobinfo.getJobName()); &#125; &#125; &#125;&#125; 2、实现CommandLineRunner接口并重写run()方法CommandLineRunner接口文档描述如下：12345678910111213141516171819202122/** * Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within * a &#123;@link SpringApplication&#125;. Multiple &#123;@link CommandLineRunner&#125; beans can be defined * within the same application context and can be ordered using the &#123;@link Ordered&#125; * interface or &#123;@link Order @Order&#125; annotation. * &lt;p&gt; * If you need access to &#123;@link ApplicationArguments&#125; instead of the raw String array * consider using &#123;@link ApplicationRunner&#125;. * * @author Dave Syer * @see ApplicationRunner */public interface CommandLineRunner &#123; /** * Callback used to run the bean. * @param args incoming main method arguments * @throws Exception on error */ void run(String... args) throws Exception;&#125; 如上所说：接口被用作加入Spring容器中时执行run(String… args)方法，通过命令行传递参数。SpringBoot在项目启动后会遍历所有实现CommandLineRunner的实体类并执行run方法，多个实现类可以并存并且根据order注解排序顺序执行。这边还有个ApplicationRunner接口，但是接收参数是使用的ApplicationArguments。这边不再赘述。 同样是启动时执行定时任务，使用这种方式我的写法如下：123456789101112131415161718192021222324252627282930@Component // 注意 这里必须有//@Order(2) 如果有多个类需要启动后执行 order注解中的值为启动的顺序public class StartAllJobInit implements CommandLineRunner &#123; protected Logger logger = LoggerFactory.getLogger(getClass().getName()); @Autowired JobInfoService jobInfoService; @Autowired JobTaskUtil jobTaskUtil; @Override public void run(String... args) &#123; List&lt;JobInfoBO&gt; list = jobInfoService.findList(); for (JobInfoBO jobinfo :list) &#123; try &#123; if(&quot;0&quot;.equals(jobinfo.getStartWithrun()))&#123; logger.info(&quot;任务&#123;&#125;未设置自动启动。&quot;, jobinfo.getJobName()); jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP); &#125;else&#123; logger.info(&quot;任务&#123;&#125;设置了自动启动。&quot;, jobinfo.getJobName()); jobTaskUtil.addOrUpdateJob(jobinfo); jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING); &#125; &#125; catch (SchedulerException e) &#123; logger.error(&quot;执行定时任务出错，任务名称 &#123;&#125; &quot;, jobinfo.getJobName()); &#125; &#125; &#125;&#125; 3、使用ContextRefreshedEvent事件(上下文件刷新事件) ContextRefreshedEvent 官方在接口上的doc说明Event raised when an {@code ApplicationContext} gets initialized or refreshed. ContextRefreshedEvent是Spring的ApplicationContextEvent一个实现，ContextRefreshedEvent 事件会在Spring容器初始化完成后以及刷新时触发。 在这里我需要在springboot程序启动之后加载配置信息和字典信息到Redis缓存中去，我可以这样写： 1234567891011121314151617181920212223@Component // 注意 这个也是必须有的注解 三种都需要 使spring扫描到这个类并交给它管理public class InitRedisCache implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; static final Logger logger = LoggerFactory .getLogger(InitRedisCache.class); @Autowired private SysConfigService sysConfigService; @Autowired private SysDictService sysDictService; @Override public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) &#123; logger.info(&quot;-------加载配置信息 start-------&quot;); sysConfigService.loadConfigIntoRedis(); logger.info(&quot;-------加载配置信息 end-------&quot;); logger.info(&quot;-------加载字典信息 start-------&quot;); sysDictService.loadDictIntoRedis(); logger.info(&quot;-------加载字典信息 end-------&quot;); &#125;&#125; 注意：这种方式在springmvc-spring的项目中使用的时候会出现执行两次的情况。这种是因为在加载spring和springmvc的时候会创建两个容器，都会触发这个事件的执行。这时候只需要在onApplicationEvent方法中判断是否有父容器即可。123456@Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; if(event.getApplicationContext().getParent() == null)&#123;//root application context 没有parent，他就是老大. //需要执行的逻辑代码，当spring容器初始化完成后就会执行该方法。 &#125; &#125; 总结以上，就是我在实际开发中常用的三种，在项目启动时执行代码的方式，开发者可以根据不同的使用情况选择合适的方法去执行自己的业务逻辑。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存分配与垃圾回收的复习整理]]></title>
    <url>%2Fblog%2F20190414%2FJava%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[摘要众所周知Java作为一个“一次编译，到处运行”的编译型语言，JVM虚拟机当之无愧的是Java语言世界的先锋将军。作为一个Java程序员，JVM虚拟机其相关知识是我们必须要了解以及深入掌握的重点。在本篇博客我将总结一下JVM虚拟机的内存结构、对象内存分配以及垃圾回收算法。这也是经常找工作求职必问的点。 Java内存分配与垃圾回收的复习整理Java内存区域划分Java虚拟机在执行Java程序的过程中会将它所管理的内存划分为若干个不同的区域。每个区域各司其职，其创建与销毁数据的规则也都各不相同。根据《Java虚拟机规范（Java SE 7版）》的规定，主要分为如下图几个区域。 程序计数器：当前线程执行字节码的行号指示器。[线程私有] 虚拟机栈：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。平常我们所说的Java虚拟机划分为堆和栈中的“栈”中的一部分就是虚拟机栈。其中局部变量表存放着编译期可知的所有基本数据类型、对象引用等。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法所需要的帧的大小是已经确定了的。[线程私有] 本地方法栈：与虚拟机栈发挥的作用相似，只不过这个区域执行的是native方法，即由c/c++或者其他语言编写的方法。[线程私有] Java堆：用来存放对象实例，即我们最熟悉的一块区域。Java堆是垃圾收集器管理的主要区域，所以有时也叫“GC堆”。[线程共享] 方法区：用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 [线程共享] 运行时常量池：这是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。[线程共享] 常用的垃圾回收算法 在Java代码中，我们程序员通常只关注广义上的“栈”和“堆”这两种区域。上述划分的Java内存区域告诉我们，栈是朝生夕死的一块区域，当线程进入的时候，栈空间被分配，线程结束之后，栈的内存空间即被回收用来去做其他的任务，栈中的栈帧随着线程的进入与退出有条不紊的执行着入栈和出栈的操作，每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的。而堆却不同，我们只有在程序运行期间才会知道创建那些对象，这部分内存分配和回收都是动态的。都由虚拟机的垃圾回收器进行“已死”对象的回收。 如何判断对象已死 引用计数法：给对象添加一个引用计数器，每当有引用指向它时计数器加1，引用失效后计数器减1。垃圾回收器回收对象计数器为0的对象昂即可。但是当出现对象之间循环引用，而对象却无实际作用的时候，这种方式就会出现内存泄漏。 可达性分析：通过一系列的称为“GC ROOTS”的对象作为起点，向下搜索，搜索走过的路径都称为引用链，当一个对象到“GC ROOTS”没有引用链的时候，证明这个对象不可达。此时会被判定为可回收对象。（此时并非一定死亡，在此之后还会进行两次标记处理，与finalize()方法有关，此处不再整理。注意一个知识点：任何对象的finalize()方法只会被系统调用一次，并且不建议使用） 知道哪些对象是“垃圾”，接下来就是回收操作了 标记-清除法 首先标记出所有需要回收的对象，然后统一回收。是最基础的回收算法。 不足之处：1、效率低下，标记和清除的效率都不高；2、产生大量内存碎片，使得之后程序要分配大对象却没有空间，不得不除法GC。 复制 首先将内存区域划分为两等分，每次只使用其中一块内存，当用完之后，将活着的对象复制到另一块内存，然后整个回收上一半。这种按顺序分配内存，实现简单，运行高效。 不足之处：直接将内存缩小了一半，产生大量的空间浪费。然而很多垃圾收集器都是用这种方式，但是有过改进。因为堆中的对象90%都是朝生夕死的，只有10%是会长期存活下来的对象，那么对于这90%的对象，完全可以使用这种高效的复制收集算法。首先将内存区域划分三份，10%的对象存在其中较大的一分中，另外的两份等份分配，处理这90%的“死的快”的对象。这就是Form,To,Eden区域。即Eden:From:To=8:1:1 标记-整理法 标记整理的方式实际上也是先将可回收对象标记起来，然后对于这些存活着的对象，并不直接回收，而是先向一端移动，最后直接回收端边界之外的对象。这种做法解决了处理存活率较高的大对象的回收，适合老年代堆对象回收。 分代收集 当前商业虚拟机基本上都会采取分代收集算法。即根据对象存活周期的不同将内存划分为不同区域，分别使用不同的垃圾回收算法进行垃圾回收。比如在新生代使用复制算法，因为新生代大量对象都是朝生夕死需要很高的回收效率，而对于老年代则使用标记清除或者标记整理。 Java虚拟机的对象内存分配Java对象内存分配实际上就指的是将对象分配在堆上的过程。不过实际上堆还被虚拟机划分成了不同的区域，并且每个区域的分配策略都不相同。上面我们说到虚拟机根据对象存活周期的不同将对内存分为几种不同的区域，即新生代Eden,From Survivor,To Survivor和老年代。那么这几种区域是如何进行内存分配的呢？ 对象优先再Eden区域分配：大多数情况下，对象会在Eden区域分配，在Eden区域空间不够的情况下，会先进行一次MinorGC（MinorGC是新生代垃圾回收，Full GC是老年代垃圾回收）。 大对象直接进入老年代：大对象即指的是需要大量连续空间的对象，例如很长的字符串以及数组。虚拟机提供参数-XX:PretenureSizeThreadhold参数设置大于多少算是大对象，避免在新生代几个区域中发生大量的内存复制。 长期存活的对象直接进入老年代：每经过一次MinorGC对象的年龄都会加1。当年龄加到-XX:MaxTenuringThreadhold（默认15）指定的值时，判断为长期存活，对象会被移动到老年代。 动态对象年龄判断：为了适应多变的内存情况，一般虚拟机都会使用动态对象年龄判定。如果Survivor中相同年龄的所有对象大小总和大于该空间的一半，该年龄以上的对象就会直接进入老年代，无需等到年龄大于-XX:MaxTenuringThreadhold（默认15）指定的值。 空间分配担保：在发生MinorGC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，是的话MinorGC可以被认定是安全的。如果不成立，虚拟机会先检查HandlerPromotionFailure参数是否允许担保失败，不允许的话会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于的话或者HandlerPromotionFailure设置不允许冒险，那么就会执行一次FullGC。 总结 内存回收与垃圾收集很多时候都是影响系统性能和并发能力的主要因素之一，虚拟机提供了多种垃圾收集器以及大量的调节参数，方便开发人员根据实际应用调整以便程序可以获得最高的性能。这些垃圾收集器和虚拟机参数没有固定的标准的组合，需要开发人员对于内存分配与垃圾回收相当了解，才得以根据实际情况实际配置。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>内存分配</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo服务降级]]></title>
    <url>%2Fblog%2F20190412%2Fdubbo%20%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[前言&nbsp;&nbsp;&nbsp;&nbsp;在分布式服务或者一些微服务当中，经常性的出现各个服务之间相互调用，业务处理流程耦合起来的情况。比如当用户在平台下单时，我们需要给用户生成订单之后发站内信或者短信通知用户订单生成成功。那么很多时候代码的编写就会是：&nbsp;&nbsp;&nbsp;&nbsp;调用订单模块生成订单-&gt;调用短信模块通知用户-&gt;调用其他模块处理更多业务逻辑&nbsp;&nbsp;&nbsp;&nbsp;可是当我们无足轻重的一个短信通知模块挂掉或者报错的时候，我们当然不希望整个业务逻辑就这样停止。那么这个时候，就需要引入服务降级的机制，为整个业务逻辑进行解耦合。 &nbsp;&nbsp;&nbsp;&nbsp;使用服务降级可以防止我们服务中间不影响整体流程的模块出错导致整个业务处理雪崩。将核心业务保证完整性，非核心业务弱化。本文使用 springboot+dubbo 进行服务降级的演示 dubbo自带的mock进行服务降级，也叫本地伪装dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。具体使用 dubbo mock的使用非常简单，即在我们平时进行开发时，编写impl实现类实现接口作为服务提供者的同时，编写mock实现类并覆盖所有接口中的方法。官方更详细的文档戳这里 比如有接口：123456public interface SysOperateFacade &#123; /** * 根据用户名查询操作员信息 */ SysOperateVO findByUserName(String username);&#125; 在实现类进行相应操作12345678910@Service //这里Service是dubbo的注解public class SysOperateFacadeImpl implements SysOperateFacade &#123; @Resource SysOperateService sysOperateService; @Override public SysOperateVO findByUserName(String username) &#123; return sysOperateService.findByUserName(username); &#125;&#125; 编写mock实现类覆盖findByUserName方法 注意 mock的类名必须是 接口名+Mock1234567public class SysOperateFacadeMock implements SysOperateFacade &#123; @Override public SysOperateVO findByUserName(String username) &#123; System.out.println(&quot;调用到dubbo mock 的findByUserName方法。。。。。。。&quot;); return new SysOperateVO(); &#125;&#125; 最后，在调用的地方加上注解@Reference(mock = &quot;true&quot;)进行使用即可12345678910111213@Controller@RequestMapping(&quot;/sys/sysOperate&quot;)public class SysOperateController extends BaseController &#123; @Reference(mock = &quot;true&quot;) private SysOperateFacade sysOperateFacade; @ResponseBody @RequestMapping(&quot;/test&quot;) public SysOperateVO test(String username)&#123; return sysOperateFacade.findByUserName(username); &#125;&#125; 使用 spring cloud Hystrix进行服务降级在服务调用方模块加入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt; 如果出现以下报错也许是由于Springboot与这个依赖版本不对应，修改下版本1java.lang.NoSuchMethodError: org.springframework.boot.builder.SpringApplicationBuilder.&lt;init&gt;([Ljava/lang/Class;)V at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:170) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:104) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:70) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:122) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:74) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:325) at org.springframework.boot.SpringApplication.run(SpringApplication.java:296) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) at com.gjj.p2p.BasicsApplication.main(BasicsApplication.java:18) 具体使用hystrix进行服务降级hystrix的使用也是非常简单，只需要在服务调用方即消费者方springboot启动类上加上注解 @EnableHystrix 然后使用如下方式，指定服务出错或者熔断后调用的方法12345678910@ResponseBody@RequestMapping(&quot;/test&quot;)@HystrixCommand(fallbackMethod = &quot;fallback&quot;)public String test(String message)&#123; return sysMenuFacade.test(message);&#125;public String fallback(String message)&#123; return &quot;sysMenuFacade挂了 调用到fallback &quot; + message;&#125; 这样当出现问题之后就会调用得到fallback方法还可以在这个controller上直接指定注解@DefaultProperties(defaultFallback = &quot;fallback&quot;)以免编写大量重复代码 总结服务降级与熔断机制在我们实际生产以及日常开发中都是是非常有必要使用的，例如我们在日常开发中，需要调用别人的模块，但是又不是非常依赖这个模块的数据，我们可以使用以上的方式构造“假的”调用结果。这样就不用为了调试某行代码去启动大量的服务了。 最后针对dubbo的mock机制以及hystrix，我觉得hystrix更像是try{}catch{}。]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>dubbo</tag>
        <tag>分布式服务降级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务传播机制和事务隔离级别]]></title>
    <url>%2Fblog%2F20190323%2F%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[事务的四个特性(ACID) 原子性 事务执行开始之后的一系列操作都堪称是一个原子操作，要么全部做完，要么全部失败，不能出现部分操作成功的情况。“原子”顾名思义，就是一个不可分割的最小单元。 一致性 事务开始执行之后，数据的正确性需要得到保证。如A向B转账，B却未收到钱。 隔离性 同一时间只能由一个事务对数据进行修改操作，对于其他事务来说这个修改操作时透明的。 持久性 事务对数据进行修改操作完成之后，数据发生的改变是持久不变的，不会自己恢复到改变之前的状态。 spring中的事务传播机制 以及事务隔离级别在接口TransactionDefinition中，定义了7种传播机制12345678910111213141516171819202122232425262728293031package org.springframework.transaction;public interface TransactionDefinition &#123; // 事务传播机制 int PROPAGATION_REQUIRED = 0; // 默认的 也是最常用的 ，如果当前有事务，就加入当前这个事务，如果没有事务，就新建一个事务 int PROPAGATION_SUPPORTS = 1; // 如果有事务，就加入当前这个事务，如果没有事务，也不新建 int PROPAGATION_MANDATORY = 2; // 如果有事务，就会使用当前这个事务，如果没有就会抛出异常 int PROPAGATION_REQUIRES_NEW = 3; // 总是会开启一个新的事务，如果当前已经有事务，就将当前事务挂起 int PROPAGATION_NOT_SUPPORTED = 4; // 代码总是会在非事务的环境执行，如果当前有事务，先将事务挂起，执行完成之后再恢复 int PROPAGATION_NEVER = 5; // 绝对不允许代码在有事务的环境执行，有事务就抛出异常停止执行 int PROPAGATION_NESTED = 6; // 嵌套事务级别：如果没有父事务，就使用默认机制，如果有，子事务执行完成之后父事务才会提交 // 事务隔离级别 int ISOLATION_DEFAULT = -1; // 默认级别 int ISOLATION_READ_UNCOMMITTED = 1; // 读未提交 即脏读，可以读取别的事务已修改未提交的数据，会导致脏读、幻读和不可重复度 int ISOLATION_READ_COMMITTED = 2; // 提交读 即不可重复读，一个事物能读取到另一个事务已经提交的数据，在多次读取同一数据时，该数据被另一事务修改，读取的数据不一致 int ISOLATION_REPEATABLE_READ = 4; // 可重复读 即一个事物只能读取到另一事务提交之前的数据，确保每次读取到的数据一致。但是数据又新增或者修改时不可预见 int ISOLATION_SERIALIZABLE = 8; // 序列化读 即事务串行读取数据，性能最差，安全性最高，保证数据准确性 int TIMEOUT_DEFAULT = -1; int getPropagationBehavior(); int getIsolationLevel(); int getTimeout(); boolean isReadOnly(); String getName();&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Springboot进行国际化时自定义读取数据库配置]]></title>
    <url>%2Fblog%2F20190320%2F%E4%BD%BF%E7%94%A8springboot%E8%BF%9B%E8%A1%8C%E5%9B%BD%E9%99%85%E5%8C%96%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言springboot默认就支持国际化的，而且不需要你过多的做什么配置，只需要在resources/下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。 具体的关于springboot的国际化配置我这边就不再过多介绍(包括Locale的设置以及如何根据区域设置语言等)，关于页面上得使用可以参考：springboot国际化。在这篇博客中，我要介绍的是一个很有用的功能并且绝大部分人也会用得到，就是不使用配置文件messages.properties储存国际化语言，而使用数据库进行动态配置，做到无需重启更改配置。 如何使用MessageSource介绍Spring提供了一个接口MessageSource用于获取国际化信息，ReloadableResourceBundleMessageSource和ResourceBundleMessageSource都是继承了该接口的一个抽象实现类AbstractMessageSource，在spring官网有一段这样介绍messageSource的话：图中红框画起来的意思就是，上下文加载的时候会查询messageSource的bean，如果没有就会创建一个名为messageSource放在上下文中… …等等。 在springboot中注入自定义messageSource通过上面的介绍，我们就可以自己定义自己的messageSource进行配置的读取了。 我这边是把这个放在了业务层，大家用的时候也可以直接放在控制层(一般都放在控制层，要用到)，使用@Compnent(“messageSource”)注解声明下bean名称即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// MyMessageSourceService是我自己的接口 你也可以不需要。使用@Compnent(&quot;messageSource&quot;)注解就行@Service(&quot;messageSource&quot;)public class MyMessageSource extends AbstractMessageSource implements ResourceLoaderAware, MyMessageSourceService &#123; ResourceLoader resourceLoader; // 这个是用来缓存数据库中获取到的配置的 数据库配置更改的时候可以调用reload方法重新加载 // 当然 实际使用者也可以不使用这种缓存的方式 private static final Map&lt;String, Map&lt;String, String&gt;&gt; LOCAL_CACHE = new ConcurrentHashMap&lt;&gt;(256); @Autowired SysI18nService sysI18nService; private final Logger logger = LoggerFactory.getLogger(MyMessageSource.class); /** * 初始化 */ @PostConstruct public void init() &#123; this.reload(); &#125; /** * 重新将数据库中的国际化配置加载 */ public void reload() &#123; LOCAL_CACHE.clear(); LOCAL_CACHE.putAll(loadAllMessageResourcesFromDB()); &#125; /** * 从数据库中获取所有国际化配置 这边可以根据自己数据库表结构进行相应的业务实现 * 对应的语言能够取出来对应的值就行了 无需一定要按照这个方法来 */ public Map&lt;String, Map&lt;String, String&gt;&gt; loadAllMessageResourcesFromDB() &#123; List&lt;SysI18nBO&gt; list = sysI18nService.findList(new SysI18nAO()); if (CollectionUtils.isNotEmpty(list)) &#123; final Map&lt;String, String&gt; zhCnMessageResources = new HashMap&lt;&gt;(list.size()); final Map&lt;String, String&gt; enUsMessageResources = new HashMap&lt;&gt;(list.size()); final Map&lt;String, String&gt; idIdMessageResources = new HashMap&lt;&gt;(list.size()); for (SysI18nBO bo : list) &#123; String name = bo.getModel() + &quot;.&quot; + bo.getName(); String zhText = bo.getZhCn(); String enText = bo.getEnUs(); String idText = bo.getInId(); zhCnMessageResources.put(name, zhText); enUsMessageResources.put(name, enText); idIdMessageResources.put(name, idText); &#125; LOCAL_CACHE.put(&quot;zh&quot;, zhCnMessageResources); LOCAL_CACHE.put(&quot;en&quot;, enUsMessageResources); LOCAL_CACHE.put(&quot;in&quot;, idIdMessageResources); &#125; return MapUtils.EMPTY_MAP; &#125; /** * 从缓存中取出国际化配置对应的数据 或者从父级获取 * * @param code * @param locale * @return */ public String getSourceFromCache(String code, Locale locale) &#123; String language = locale.getLanguage(); Map&lt;String, String&gt; props = LOCAL_CACHE.get(language); if (null != props &amp;&amp; props.containsKey(code)) &#123; return props.get(code); &#125; else &#123; try &#123; if (null != this.getParentMessageSource()) &#123; return this.getParentMessageSource().getMessage(code, null, locale); &#125; &#125; catch (Exception ex) &#123; logger.error(ex.getMessage(), ex); &#125; return code; &#125; &#125; // 下面三个重写的方法是比较重要的 @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = (resourceLoader == null ? new DefaultResourceLoader() : resourceLoader); &#125; @Override protected MessageFormat resolveCode(String code, Locale locale) &#123; String msg = getSourceFromCache(code, locale); MessageFormat messageFormat = new MessageFormat(msg, locale); return messageFormat; &#125; @Override protected String resolveCodeWithoutArguments(String code, Locale locale) &#123; return getSourceFromCache(code, locale); &#125;&#125; 最后 至此，自定义国际化配置读取数据库已经完成，只需要在更新数据库配置的时候调用一下reload重置一下缓存中的信息即可。 参考博客：spring xml配置自定义读取数据库的messageSource]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Layui结合freemarker+springboot进行前端数据表格字典转义]]></title>
    <url>%2Fblog%2F20190316%2Flayui%E5%BC%80%E5%8F%91%E4%B8%AD%E7%BB%93%E5%90%88freemarker%E5%B1%95%E7%A4%BA%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。那么在layui的数据表格中，我们要展示这样的数据，写法可以是：1234567templet: function (d) &#123; if(d.status === 1)&#123; return &quot;启用&quot;; &#125; else if(d.status === 0)&#123; return &quot;停用&quot;; &#125;&#125; 但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。最后我们的写法就会简化成：&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;，接下来看看如何在springboot中配置使用吧。 freemarker自定义标签介绍及使用TemplateDirectiveModel接口是freemarker自定标签或者自定义指令的核心处理接口。当模板页面遇到用户自定义的标签指令时，execute()方法会被执行。execute()方法如下。123public void execute( Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException; 我们在使用freemarker自定义标签的时候需要实现该接口并且重写execute方法。 execute()方法参数解释 Environment env：系统环境变量，通常用它来输出相关内容，如Writer out = env.getOut(); Map params：自定义标签传过来的对象，就是从页面上获取的参数，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等。在本例使用时，我们会将map转成我们自己的对象进行数据保存。 TemplateModel[] loopVars：循环替代变量 TemplateDirectiveBody body：标签中嵌套的内容，如&lt;@tag&gt;body&lt;/@tag&gt;，就是这个body 开始使用定义接收页面参数的对象1234567891011121314151617@Getter@Setterpublic class TableThTag &#123; /** * 对象属性名【需要进行对象属性获取】 */ private String objName; /** * 字典标识 */ private String nid; /** * 类型 */ private String type;&#125; 实现TemplateDirectiveModel接口并重写execute方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component@org.springframework.context.annotation.Configurationpublic class TableThDirective implements TemplateDirectiveModel &#123; Logger logger = LoggerFactory.getLogger(getClass().getName()); /** * FreeMarker自定义指令 */ @Override public void execute(Environment environment, Map map, TemplateModel[] templateModels, TemplateDirectiveBody templateDirectiveBody) throws TemplateException, IOException &#123; TableThTag tableThTag = new TableThTag(); //校验参数 try &#123; // 用来将一些 key-value 的值（例如 hashmap）映射到 bean 中的属性 BeanUtils.populate(tableThTag, map); if (StringUtils.isEmpty(tableThTag.getNid()) || StringUtils.isEmpty(tableThTag.getType())) &#123; throw new IllegalArgumentException(&quot;nid,type不能为空&quot;); &#125; &#125; catch (Exception e) &#123; logger.error(&quot;数据转化异常&quot;, e); &#125; StringBuilder html = new StringBuilder(); // 根据类型创建不同的HTML生成器 ThFormatterInterface thFormatterInterface = ThFormatterFactory.createThFormatter(tableThTag.getType()); if (thFormatterInterface != null) &#123; String dictHtml = thFormatterInterface.buildFormatterHtml(tableThTag.getNid(), tableThTag.getFieldName()); html.append(dictHtml); &#125; // 执行真正指令的执行部分: Writer out = environment.getOut(); out.write(html.toString()); if (templateDirectiveBody != null) &#123; templateDirectiveBody.render(environment.getOut()); &#125; &#125; public static BeansWrapper getBeansWrapper() &#123; BeansWrapper beansWrapper = new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build(); return beansWrapper; &#125;&#125; 大家可以看到，在这个方法中，我将页面上的参数转为TableThTag对象。然后再根据前端页面不同的type类型对应实现了ThFormatterInterface的工厂对象，创建不同的html生成器。（这里考虑到扩展性，可能以后不光创建数据表格会用的到，比如下拉框什么的，也可以使用这种方式创建，所以在这里使用抽象工厂依据类型动态创建。）下面就是创建html的具体工厂以及实现方法。 ThFormatterInterface抽象工厂创建html生成器接口12345678public interface ThFormatterInterface &#123; /** * 构造生成枚举html * @param nid * @return */ String buildFormatterHtml(String nid, String fieldName);&#125; 工厂1234567891011121314151617181920212223public class ThFormatterFactory &#123; private static Logger logger = LoggerFactory.getLogger(ThFormatterFactory.class); public static ThFormatterInterface createThFormatter(String type)&#123; if(StringUtils.isEmpty(type))&#123; return new ThFormatterTemplate(); &#125; // 文件名 如果type传template 就需要有一个名为ThFormatterTemplate的文件 // 并且实现了ThFormatterInterface以及重写生成html的方法 String fileName = &quot;ThFormatter&quot; + StringUtil.firstCharUpperCase(type); //类路径 通过反射去创建实现类 String className = &quot;com.module.freemarker.impl.&quot;+fileName; //生成表头格式实现类 ThFormatterInterface thFormatterInterface = null; try &#123; thFormatterInterface =(ThFormatterInterface) Class.forName(className).newInstance(); &#125; catch (Exception e) &#123; logger.error(e.getMessage(),e); &#125; return thFormatterInterface; &#125;&#125; 实现类1234567891011121314151617181920public class ThFormatterTemplate implements ThFormatterInterface &#123; @Override public String buildFormatterHtml(String nid, String fieldName) &#123; Assert.notEMPTY(nid, &quot;nid不能为空&quot;); Assert.notEMPTY(fieldName, &quot;objName不能为空&quot;); SysDictService sysDictService = SpringContextHolder.getBean(SysDictService.class); // 通过nid查询字典类 这里不需要进行照抄 每个人都会有自己的实现方法 List&lt;SysDictBO&gt; sysDictModelList = sysDictService.findByPartnerNid(nid); StringBuilder dictHtml = new StringBuilder(); // 反正目的就是根据字典类生成对应的html就行了 需要生成的格式对照template原本应该有的写法就行了 dictHtml.append(&quot;templet: function(d)&#123; &quot;); for (SysDictBO sysDict : sysDictModelList) &#123; dictHtml.append(&quot;if(d.&quot; + fieldName + &quot; == &apos;&quot; + sysDict.getValue() + &quot;&apos;)&#123; return &apos;&quot; + sysDict.getName() + &quot;&apos;;&#125;&quot;); &#125; dictHtml.append(&quot;&#125;&quot;); return dictHtml.toString(); &#125;&#125; 最后将自定义标签注入到freemarker标签中去123456789101112131415@org.springframework.context.annotation.Configurationpublic class FreemarkerConfig &#123; @Resource private Configuration configuration; @Resource private TableThDirective tableThDirective; @PostConstruct public void setSharedVariable()&#123; configuration.setSharedVariable(&quot;th&quot;,tableThDirective); configuration.setSharedVariable(&quot;shiro&quot;,new ShiroTags()); &#125;&#125; 这样就大功告成了。 在页面上进行使用吧：&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt; 以后进行扩展什么的也方便，比如生成下拉框：&lt;@th type=&quot;select&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;这样然后自动生成html的时候查出来所有的字典，根据类型生成多个出来就行了。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>springboot</tag>
        <tag>freemarker</tag>
        <tag>工厂模式</tag>
        <tag>layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot+shiro解决session污染的问题]]></title>
    <url>%2Fblog%2F20190309%2Fspringboot%2Bshiro%E8%A7%A3%E5%86%B3session%E6%B1%A1%E6%9F%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[同一个服务器启动多个web项目造成session污染昨天在敲代码的时候遇到了一个问题，同一个项目，我创建了两个分支，分别使用不同的端口。但是在测试环境启动的时候我发现，在同一个浏览器上，我只能登陆其中的一个后台。在登陆另一个后台之后，前面那个又需要再重新登陆了。 原因找了好久，最后F12控制台查看session发现，这两个web项目，使用的都是JSessionId作为cookie的key，在登陆另一个时，浏览器的这个cookie值就会被改变，所以前者就需要在重新登陆了。 解决方法在springboot中，对shiro配置进行更改session保存时的cookie的key名称，如下。1234567@Beanpublic DefaultWebSessionManager sessionManager() &#123; DefaultWebSessionManager sessionManager = new DefaultWebSessionManager(); Cookie cookie = sessionManager.getSessionIdCookie(); cookie.setName(&quot;MySessionId&quot;); return sessionManager;&#125; 然后在securityManager中将我们的sessionManager注入进去。12345678910/** * SecurityManager，权限管理，这个类组合了登陆，登出，权限，session的处理，是个比较重要的类。 */@Beanpublic DefaultWebSecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(myShiroRealm()); securityManager.setSessionManager(sessionManager()); return securityManager;&#125; 只需要这样修改好就可以了。然后重启项目，就会发现，两个web项目都可以同时登陆了。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>shiro</tag>
        <tag>session污染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode:Z字形变换]]></title>
    <url>%2Fblog%2F20181223%2Fleetcode-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题目如下将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： 123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1: 12输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2: 12输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot; 解释: 1234L D RE O E I IE C I H NT S G 解题思路拿到这个题目，第一时间就可以想到，根据题中图示构造二维数组，先将数据按照相应的样子存储进去，最后再从数组中按行取出，但是这样会有占用更多内存空间的风险。所以，我这边还思考了第二种解法：就是直接根据规律计算出下一个要输出的字符的下标，直接输出即可，无需再创建多余的二维数组。 第一种解法：构造二维数组 构造二位数组最主要的就是计算出这个二维数组有多少列，列数有了，按照Z型规律将原字符串塞进去就行了，计算列数代码如下 123456789private int getColNum(String s, int n) &#123; int x = s.length() / (2 * n - 2); int y = s.length() % (2 * n - 2); int l = x + 1 + x * (n - 2); if (y &gt;= n) &#123; l = l + 1 + y % n; &#125; return l; &#125; 第二种解法：计算下一个要输出的字符的下标直接看github代码吧：点这里]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中map新的骚操作]]></title>
    <url>%2Fblog%2F20181209%2FJava%E4%B8%ADmap%E6%96%B0%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下： 总结computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回nullcomputeIfAbsent 就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值compute 就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package test;import java.util.HashMap;public class MapTest &#123; public static void main(String[] args) &#123; HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1,&quot;zhang&quot;); // computeIfPresent 根据之前的key/value 如果oldValue 不为null 则根据提供的方法返回一个新的值 并进行新值对旧值的替换 System.out.println(&quot; 1 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123; return key + value;//原值不为null新值不为null 新值替换旧值 &#125;)); // 否则删除键值对 System.out.println(&quot; 2 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123; return null;//原值不为null新值为null 删除键值对 &#125;)); map.put(1,null); System.out.println(&quot; 3 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123; return &quot;jiaheng&quot;;//原值为null 不做更改 &#125;)); // computeIfAbsent 根据之前的key 如果旧值为空或者key不存在 就按照方法用新值替换旧值 新值为null不做替换 map.put(1,&quot;zhang&quot;); System.out.println(&quot; 4 ---&gt; &quot; + map.computeIfAbsent(1,k-&gt;&#123; return null;// 不会被替换旧值 返回原值 &#125;)); System.out.println(&quot; 5 ---&gt; &quot; + map.computeIfAbsent(2,k-&gt;&#123; k = k*k; return k.toString();// key=2不存在 直接新建并存入新值 &#125;)); // compute类似于computeIfAbsent和computeIfPresent的合体 map.put(1,null); System.out.println(&quot; 6 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123; return &quot;张&quot;;// 原值为null新值不为null 新值替换旧值 此处与computeIfPresent不同 &#125;)); System.out.println(&quot; 7 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123; v = (k*10) + v; return v;// 新值不为null 替换旧值 &#125;)); System.out.println(&quot; 8 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123; return null;// 新值为null 删除键值对 &#125;)); // 总结 // computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null // computeIfAbsent 就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值 // compute 就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。 &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodepad++不用插件去重的方法]]></title>
    <url>%2Fblog%2F20181112%2Fnodepad-%E4%B8%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在工作中，当我们需要对一个文本中的行进行去重统计的时候，会发现对于文本的去重并不是那么好处理。而nodepad++的去重插件一般人又懒得去安装，不巧在网上找到这样一个去重的小技巧，即使用正则表达式进行去重，简直方便快捷。在这里分享出来，希望大家能够用的上。1^(.*?)$\s+?^(?=.*^\1$) 点击全部替换，就可以将重复行全部去掉喽]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>工作技巧</tag>
        <tag>nodepad++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客文章置顶方式]]></title>
    <url>%2Fblog%2F20180904%2Fhexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[博文置顶目前已经有修改后支持置顶的仓库，可以直接用以下命令安装12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：123456---title: hexo博客置顶date: 2017-09-08 12:00:25categories: 博客搭建系列top: true--- 到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，紧接着下一行插入如下代码：12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 至此，博客置顶的方式就全部完成了]]></content>
      <categories>
        <category>hexo博客配置</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰国7天6晚自由行攻略]]></title>
    <url>%2Fblog%2F20180904%2F%E6%B3%B0%E5%9B%BD7%E5%A4%A96%E6%99%9A%E8%87%AA%E7%94%B1%E8%A1%8C%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[人生不可能是一场说走就走的旅行，但心怀远方的人，一定要时刻做着说走就走的准备！ 关于去泰国这件事情，可能发生的很突然，但是没关系，既然决定了，就把它安排在计划里。 一、出行前的准备1、护照&amp;签证我是在杭州工作，在杭州工作社保交满一年，就可以办护照了。拿着身份证在西湖区行政服务中心的出入境管理那儿就可以办理了。现在一楼自助打印下社保证明，然后去后面的楼，出入境办理区按照流程办理即可。大概一个多礼拜就能拿到护照，我也没想到有这么快。 签证是在淘宝上买的，260￥。七个工作日到手。 2、泰铢&amp;电话卡&amp;出入境&amp;去泰国的必备软件&amp;其他泰国新规定，过境签、落地签-10000泰铢或等值外币现金（每人），20000泰铢（家庭）；旅游签-20000泰铢或等值外币现金（每人），40000泰铢（家庭），抽查到概率很低，一般落地签会查的吧。但是网上说好像都不查的，或者很少查，但还是换两千的吧。 然后再淘宝买泰国7天happy卡，我买的是这家的，8天无限流量，4G。 入境时需要填写出入境卡，然后和护照一起交给海关查看盖章。下面是入境卡中文说明图： 一般情况下，在乘坐航班时常会有工作人员在抵达目的地钱给乘客发放出入境卡，以便乘客提前填好出入境卡，方便出关。护照也很重要，可以在国内出发前复印几份护照一定要放行李箱，不要随身携带。 END - 其他一些实用信息 大使馆/领事馆 中国驻泰国大使馆地址：NO.57, Racgadapisek Road, Bangkok电话：+66-02-2450088领事保护电话：+66-854833327（24小时值班手机），+66-02-2457010（工作日9：00-17：00） 中国驻清迈总领事馆地址：111 Changloh Road, Haiya District, Chiangmai电话：+66-53-280380，+66-53-276125，+66-53-276457 中国驻宋卡总领事馆（近普吉岛、苏梅岛、甲米）地址：9 Sadao Road, Songkhla电话：+66-74-322034领事保护电话：+66-817665560 中国驻宋卡总领馆驻普吉领事办公室电话：+66-76-304219领事保护电话：+66-945956168（中文、泰文），+66-945986859（中文） 中国驻孔敬总领馆地址：142/44 Moo 2，Rob-Bueng Rd.，Nai-Muang， Muang， Khon Kaen电话：+66-43-226873 紧急电话 警察:123/191火警:199救护:2460199领事:022-457010大使馆:022-457044旅游投诉:1155]]></content>
      <categories>
        <category>个人随笔</category>
      </categories>
      <tags>
        <tag>个人随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo获取注册中心的实例bean]]></title>
    <url>%2Fblog%2F20180719%2F%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-20180718%2F</url>
    <content type="text"><![CDATA[开发日记 20180718com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR Data length too large1com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR Data length too large: 11557050, max payload: 8388608 java.io.IOException: Data length too large: 11557050, max payload: 838860 在使用dubbo框架开发的时候，需要做一个导出csv文件的功能，查询大量的数据然后在提供者这边进行处理导出，其中数据达到过20万行以上，几十M的数据，抛出了这样一个异常。遇到服务提供者从数据库查询或者其他地方返回过大的对象，导致报错时，尽管有办法取消这个数据长度的限制，但是这并不符合程序开发的初衷。我们需要将对于数据的处理放在业务层，我在这里做了异步导出，给前端返回的仅仅是一个程序完成的状态，完美的解决了这个问题。 在dubbo消费者服务中写aop方法拦截工具类中的方法尽管服务的提供者和消费者都引入的工具类模块的依赖，但是拦截器的实际拦截的还是那个实际本身所在模块的方法。如果工具类是在消费者service层被使用的，那么在上层模块的拦截器是无法拦截到这个方法的。 在dubbo服务中手动获取注册的提供者的bean在这里犯的错：以为通过SpringContextHolder.getBean()可以获取，是我傻逼了，dubbo中的服务怎么能用spring上下文获取呢。这里我使用dubbo的方式完成了这个功能。1234567891011121314151617181920/** * 获取服务的代理对象 * * @return */public static &lt;T&gt; T getReferenceConfig(String appName,String address,Class&lt;?&gt; interfaceClass) &#123; String key = interfaceClass.getName(); ReferenceConfig&lt;T&gt; referenceConfig = (ReferenceConfig&lt;T&gt;)referenceCache.get(key); if(referenceConfig == null)&#123; referenceConfig = new ReferenceConfig&lt;T&gt;(); referenceConfig.setApplication(application); referenceConfig.setRegistry(getRegistryConfig(appName,address)); referenceConfig.setInterface(interfaceClass); referenceCache.put(key,referenceConfig); &#125; return referenceConfig.get();&#125;]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于IDEA再从git或者svn上导入项目时不能加载字模块的问题]]></title>
    <url>%2Fblog%2F20180708%2F%E5%85%B3%E4%BA%8EIDEA%E5%86%8D%E4%BB%8Egit%E6%88%96%E8%80%85svn%E4%B8%8A%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%8D%E8%83%BD%E5%8A%A0%E8%BD%BD%E5%AD%97%E6%A8%A1%E5%9D%97%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于IDEA再从git或者svn上导入项目时不能加载字模块的问题 最近入职新公司，很多东西也都算是要从头学起。在之前公司用的都是eclipse，这边要求用IDEA，其实很早就知道这是一个非常强大的编译器，但平时没有机会使用，现在有机会用这个还是挺开心的。 由于公司使用gitlab，在注册好账号导入代码的时候遇到一个情况，就是直接用IDEA的git工具导入的话会出现，maven项目的子模块无法被识别以及被管理的情况。事实上eclipse也有同样的问题。现在只说下使用IDEA遇到这个情况的解决办法。 有两种解决方式。1、手动将module添加到项目管理： 打开文件选项中的项目结构（快捷键ctrl+alt+shift+s） 选择 模块-加号-导入module，手动将自己需要的模块一一导入进去2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了 从eclipse转到IDEA前几天是最艰难的，因为很多习惯不是说改就能改掉的，工具的使用总得需要一个学习的时间，但是等这段时间过去，后面一定会体会到IDEA的强大。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>IDEA</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念即将结束的第一份工作]]></title>
    <url>%2Fblog%2F20180628%2F%E7%BA%AA%E5%BF%B5%E5%8D%B3%E5%B0%86%E7%BB%93%E6%9D%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[纪念即将 结束的第一份工作 我一直都不知道自己想要得到些什么东西 记得高中的时候，身边不管是家人还是老师，总会时刻不停在耳边说着：你需要如何如何学习，考上一个怎样的大学，进入一个怎么样的专业，以后找一个怎样的工作。可是当我听到这些话时总是会很反感。也许是叛逆，也许是这些对于我当时都是些虚无缥缈，很遥远的东西，我没有办法理解自己得到这些东西有什么用。但是虽然忠言不入耳，我还是得按照他们说的做。还好，大学上了一个普通的理工科一本。 当上了大学之后，没有了老师家长在耳边“絮叨”，更不知道自己要干什么了。记得当时参加各种社团，觉得在社团里面干的风风火火很牛逼，甚至课程都不上几节，最严重的时候好几周都不上课。浑浑噩噩的度过了大学的第一年之后，突然因为一个给学校编程培训班试听课凑人数的机会，让自动化专业的我接触到了软件开发这个方向。依然记得当时上课的老师，老范！当他用C语言在电脑上输出一串笑脸字符的时候，我当时的眼睛都亮了，我对和自己一块去凑人数的舍友说，这个人一定以后对我有很大的帮助，我一定要报名他的课程。后来真的觉得我是幸运的，老范是一个很有人格魅力的中年程序员 :) 。也是他让我知道了程序员是做什么的，也是他让我非常期待自己能够成为一个真正的软件开发者。 就这样我跟着老范从计算机基础，学到数据结构与算法，学计算机网络，MySQL，学习设计模式，学C++，后来又在另一个班学Java。计算机硬件方向专业的我，学完了软件专业学生要学的所有课程。终于大三，我找到了西安三星电子研究所的一份实习，写了两个月shell脚本，学习了Linux相关的知识以及自动化测试的东西，后来又在组内用PHP写了个网站，提供给大家进行会议的预定与提醒。现在想想这一切经验都是我的宝贵的财富. 实习结束后，工作却找的不是很顺利，也许是自己的实习经历没有太多做Java开发的东西，导致自己没有什么实际的项目经验。后来，我来了同※※。 或许离开这里是我最正确的选择 在拿到offer来到同※※之前，我觉得我来到了一个很好的大公司。事实上这里也没有很差，除了我所在的部门。同※※是国内最早做股票交易平台的软件公司，目前也有自己的大楼，装修的也很不错，很像一个一线的大型互联网公司。然而，只是很像而已。从一件很平常的事就看得出来：每天饭点，后勤部经理就站在食堂打饭窗口对打饭的员工喊，少打一点少打一点，他们吃不完！ … … 其实我刚来的时候觉得自己可以呆三年的，现在想想真的很抱歉，我得走了。并不是因为上面的“打饭”。我来到这里做的工作都是外包的，在B2B部门。我本来以为大公司的工作流程都很规范，没想到在这里刷新了我的三观哈哈。外包工作什么都得听客户的，乱改需求不说，自己公司的运维根本派不上用场，连tomcat的启动报错都不知道怎么解决，让我们作为开发的去同时做开发、测试、运维、项目经理、产品的活，想想就火大。项目经理把客户电话甩给你，自己沟通去，然后自己潇洒的下班。 唉ε=(′ο｀*)))，不想再说太多了，显得自己好像太小气，都要走了还要diss前公司。但是，我觉得我是真的得走了，而且我还算是忍得时间长的。我们组，比我来得晚，比我走的早的人，超过了10个。才一年啊。作为一个刚毕业一年的程序员，真的心好累。 接下来的路少交点儿朋友，否则离开时会难受 要走了要走了，却又感觉很难受。在这里，我接触过不少傻逼，但是也真的交到很多有趣的朋友。甚至有那种就算离职了，之后也不会断了联系的。在这个城市，原本独自一人的生活由他们，真的不会无聊。 天涯途上谁是客，散席时怎么分？ 也许有些人分开就不会再见，有些人想不见却总会出现在生活里。罢了，以后换到新的公司，不要再走心了。况且，真正值得走心的，也不会很多！ ✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。 ——《行歌》 · 陈鸿宇]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Git Pull 拉取不到最新记录]]></title>
    <url>%2Fblog%2F20180531%2F%E5%85%B3%E4%BA%8Egit-pull-%E6%8B%89%E5%8F%96%E4%B8%8D%E5%88%B0%E6%9C%80%E6%96%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[////1234567891011121314151617181920//~~~~~~~~~~~~~~~~~~~~~~o8888888o//~~~~~~~~~~~~~~~~~~~~~~88&quot;~.~&quot;88//~~~~~~~~~~~~~~~~~~~~~~(|~-_-~|)//~~~~~~~~~~~~~~~~~~~~~~0\~~=~~/0//~~~~~~~~~~~~~~~~~~~~___/`---&apos;\___//~~~~~~~~~~~~~~~~~~.&apos;~\\|~~~~~|//~&apos;.//~~~~~~~~~~~~~~~~~/~\\|||~~:~~|||//~\//~~~~~~~~~~~~~~~~/~_|||||~-:-~|||||-~\//~~~~~~~~~~~~~~~|~~~|~\\\~~-~~///~|~~~|//~~~~~~~~~~~~~~~|~\_|~~&apos;&apos;\---/&apos;&apos;~~|_/~|//~~~~~~~~~~~~~~~\~~.-\__~~&apos;-&apos;~~___/-.~///~~~~~~~~~~~~~___&apos;.~.&apos;~~/--.--\~~`.~.&apos;___//~~~~~~~~~~.&quot;&quot;~&apos;&lt;~~`.___\_&lt;|&gt;_/___.&apos;~&gt;&apos;~&quot;&quot;.//~~~~~~~~~|~|~:~~`-~\`.;`\~_~/`;.`/~-~`~:~|~|//~~~~~~~~~\~~\~`_.~~~\_~__\~/__~_/~~~.-`~/~~///~~~~~=====`-.____`.___~\_____/___.-`___.-&apos;=====//~~~~~~~~~~~~~~~~~~~~~~~`=---=&apos;//////~~~~~~~~~~~~~~~~~~~~~~~~~ ////~~~佛祖保佑~~~~~永无BUG////// 使用git pull 获取不到最新的记录，判断应该是某些时候未pull先commit导致的，使用命令：git pull origin master即可解决]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【陈年风楼】VLOG-000001 一个普通的程序员的普通的一天]]></title>
    <url>%2Fblog%2F20180421%2Fvlog-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Boot微服务搭建]]></title>
    <url>%2Fblog%2F20180327%2Fspring-boot%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本人的csdn传送门 前言 进行web开发的时候Java程序员们难免会碰到那种很小的服务，比如就提供一个生成订单号的接口，或者一个上传文件的服务。而这时我们再去使用SpringMVC这种体量稍大、配置繁琐的框架开发难免会加大工作量，而且是不必要的。这个时候我们就可以选择使用这个微服务框架——springboot进行开发。 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 springboot框架的搭建与简单的REST风格的MVC架构demo首先，建立一个新的maven工程，pom文件主要内容如下：123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 其中核心依赖是 spring-boot-starter-web1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 访问静态资源文件可以加入模板：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 编写Application.java文件，存放于src/main/java这个目录下这里是springboot的核心启动类12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan@EnableAutoConfigurationpublic class Application&#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 事实上，这个时候已经把框架搭建好了，运行以上main方法即可启动这个项目，但是我们现在看不到效果，接下来，就可以像SpringMVC一样加入MVC三层结构的代码了，目录结构如下图： 其中各层代码如下： controller12345678910111213141516171819202122232425262728package com.zhang.controller;import java.util.HashMap;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.servlet.ModelAndView;import com.zhang.entity.Photo;import com.zhang.service.mainService;@RestController@RequestMapping(&quot;/photo&quot;)public class mainController &#123; @Autowired private mainService mainservice; @RequestMapping(&quot;/&quot;) public ModelAndView index(ModelAndView mav)&#123; mav.addObject(&quot;hello&quot;, &quot;这是项目主页，访问根目录到达~~&quot;); mav.setViewName(&quot;index&quot;); return mav; &#125; @RequestMapping(&quot;/getPhoto&quot;) public Object doIt()&#123; Map&lt;String, Photo&gt; map = new HashMap&lt;String, Photo&gt;(); map.put(&quot;photo&quot;, mainservice.getPhotoById(123)); return map; &#125;&#125; service实现类12345678910111213141516171819package com.zhang.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.zhang.dao.mainDao;import com.zhang.entity.Photo;import com.zhang.service.mainService;@Service(&quot;mainservice&quot;)public class mainServiceImpl implements mainService &#123; @Autowired private mainDao maindao; @Override public Photo getPhotoById(int id) &#123; return maindao.getPhotoNameById(id); &#125;&#125; dao实现类12345678910111213141516171819package com.zhang.dao.impl;import org.springframework.stereotype.Repository;import com.zhang.dao.mainDao;import com.zhang.entity.Photo;@Repository(&quot;maindao&quot;)public class mainDaoImpl implements mainDao &#123; @Override public Photo getPhotoNameById(int id) &#123; Photo p = new Photo(); p.setId(123); p.setName(&quot;雪山行纪念照&quot;); return p; &#125;&#125; 实体类photo1234567891011121314151617package com.zhang.entity;public class Photo &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 启动项目 项目默认端口为8080，在浏览器中访问刚才的controller会看到： 如上，一个REST风格的MVC架构的demo项目就搭建完成了。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校招面试【京东、顺丰科技、招银网络科技、去哪儿网】]]></title>
    <url>%2Fblog%2F20160927%2F%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[2017校招过的太惨了，还一度把原因怪罪在实习上，认为自己实习了4个月非Java研发的东西导致自己对于Java没有进行更加深入的学习，其实呢，还是应该怪自己不努力，怪不得其他。*从三星离职之后就开始找一些公众号内推，我是来自非985、211院校的本科生，学的还是自动化专业，偏硬件，实习内容还不是Java开发之类的东西，不知道是由于这些公众号的原因（恶意吸引粉丝）还是自己的简历确实有问题，内推一直不顺利。烦得很。之后又从9月开始海投Java软件开发岗，各种在线笔试。博主的基础（计算机网络操作系统等）本身就不强，C/C++/Java/PHP等还有HTML/CSS/JS/jQuery这些乱七八糟都学，算法和数据结构也学得不是很精，应付不来笔试编程题，感觉面试过的公司好少，妈的工作要找到十月了。 首先说下招银电面： 9月23号晚上八点正在理发染发呢电话就来了，都不预约一下。1、在Java中进行数据库连接并操作数据的步骤？最后需要进行什么操作？2、项目中使用jquery，那么on、bind、live、delegate这几个函数有什么区别？3、一个http请求所包含的数据格式是什么？4、一次http请求的详细处理过程？5、一次struts处理请求从开始到看到页面数据之间都发生了什么，整个详细过程？6、项目中都用到了什么框架？（spring+struts+mybatis）7、在自己的项目中有没有用到并发？如果让你现在考虑给你的项目中考虑并发你会怎么做？你要控制（进行同步）的数据源是哪些？还有几个吧，想不起来了，应该比较简单就没有印象。电面后预约28号下午再面试。 招银现场面===该来的就这样来了9月28号下午，不知道哪里来的自信感觉自己能够在一个半小时之内从长安赶到永宁门，坐地铁还把安远门当成了永宁门，到了安远门叫个优步，打电话让司机快一点，妈的竟然给我取消了，害我最后坐公交去，迟到了半个小时。心态爆炸！！！╮(╯▽╰)╭1、去了在房间里等着，过会儿从酒店房间出来一个，叫我进去面试。先问我要了成绩单和一些证书，感觉招银对于成绩和证书很看重。面试官是三个人，3V1，很紧张有木有。中间坐着老大，然后一个问技术的，一个HR。2、自我介绍3、介绍一下自己的项目4、项目中是使用servlet编写的后台代码，为什么不用开源框架？5、如果要给项目中添加日志，该如何做？6、一个struts请求从输入URL到显示在页面上都经过了哪些过程？7、中间老大看我写着struts1，就问为什么使用struts1而不是struts2，有研究过两者的区别吗？8、给一个string，问如何不使用任何库函数也不转化为数组，如何逆序？就这么多问题，心态爆炸！怀疑人生！阿弥陀佛！ 京东一面： 9月24日一早6点就爬起来了，昨晚一晚上都没睡好。做梦都在想着一些多线程常考的东西，果然第二天就问了。1、了解哪些常用的集合（set、list、map）？说说他们各自的特点（ArrayList和LinkedList等）？2、HashMap、HashTable的区别？HashMap扩容为什么是2倍？如何实现的？3、说一说线程调度机制？对线程池有何理解？哪里会用到线程池？好处是？4、JVM中如果有一个线程挂起了，用什么工具去查找这个线程？5、Java在什么时候会内存溢出？持久代内存溢出是什么情况？6、动态代理的实现？（从动态代理答到了springAOP）7、装饰模式了解吗？它的特点是什么？8、I/O库中都用到了什么设计模式？9、struts的一次请求是如何处理的？10、网络编程？socket？11、数据库索引了解吗？一个表中什么情况适合建立索引？如何去建立数据库索引？12、快速排序的时间复杂度、原理？13、java多态的实现原理？动态绑定底层虚拟机是如何实现的？14、forward和redirect的区别？同样。。。有很多问题没想起来，一面半个多小时，后天二面。。 京东二面： 感觉一面回答的不好，全程面试官问什么我答什么，一点互动都没有，狠狠狠紧张！二面抱着无所谓的心态去的，倒还没有一面紧张。1、了解那些算法和设计模式，说说你都用他们在什么地方？（贪心、回溯、分治、动态规划 || 单例模式、工厂模式、动态代理、装饰模式、适配器模式等，说了说单例工厂动态代理等，再说到JDK动态代理和CGLIB代理的区别，一顿乱侃）2、你的项目中那些都用到了多服务器？分布式了解吗？还问到了跨域请求。在实习的时候开发的网站也是单机吗？（从这儿开始问分布式集群服务器，高并发，这方面没怎么深入学习哎）3、设计一个抢购商品的系统需要考虑到那些问题？4、对于线程池有什么理解？5、消息队列？6、知道红黑树吗？平衡树？有什么区别？算了不写了，想不起来了，估计二面跪了。。。 顺丰技术面： 9月24日下午5点，就是京东一面的下午。。。（除了技术面就是HR）1、简单的自我介绍一下。。。2、介绍自己认为最能体现自己能力的项目，跟着项目引出很多题目，问了个透彻。。。3、觉得自己还有那些方面的能力没有体现出来，可以说一说？（在这里傻逼了，我他喵说我暂时想不起来。因为可能自己的项目有点简单了，面试官还想要看看自己其他的能力，醉醉哒）顺丰科技面试就这样，问了40多分钟，结果问完就让我走了，伤心，怪自己傻逼了。另一个西电的技术面玩就直接HR面了，让我回来等通知，4天了都没有通过不通过的通知，也是厉害。挂了也不让我安心挂！ 去哪儿网 9月29号下午3点好像感觉自己真的是，干什么事情完全不做任何准备的，很多看过的问题，在面试的时候就只能说有印象，答不详细，想抽死自己！1、去哪儿在金沙国际酒店面试，一天内面完，对去哪儿抱了很大希望，因为听学长说这个面试不难，问的比较基础，妈的现在写这段话还是想扇自己。2、刚见到面试官，他拿到简历就说，你是本科生啊？我说哦。。。然后就是自我介绍。。。3、给我了一张纸，在纸上写出自己用过的所有的类名。。。然后他在一边电脑上敲着东西。突然让写自己用过的所有的类的类名，脑子有点儿蒙了。4、说说mysql的引擎吧，说了myisam和innodb以及其区别，这个看过。5、mysql的各种连接是怎么回事？6、说说B树和B+树的区别吧。7、哈希冲突的解决算法？8、说说HashMap的实现原理？9、有什么问题问我？10、还有一些忘记了。。。/(ㄒoㄒ)/~~。。。都是些很简单的问题，妈的就是答得不好不够详细。 总结 ： 菜鸟的求职之路总是艰辛的，校招时间还长，十月份还有几家面试（觉得自己的脸火辣辣的疼。。。），看到人都拿到了很好的Offer，不服啊！哎，语言总是苍白的，只有安心敲代码！！！！！！！！！国庆七天奋发图强，多看看Java并发编程实战那书上的东西吧，问得太多了。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>个人随笔</tag>
        <tag>面试经历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个菜鸟在三星实习的那点儿感受]]></title>
    <url>%2Fblog%2F20160911%2F%E4%B8%80%E4%B8%AA%E8%8F%9C%E9%B8%9F%E5%9C%A8%E4%B8%89%E6%98%9F%E5%AE%9E%E4%B9%A0%E7%9A%84%E6%84%9F%E5%8F%97%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;2016年暑假，在大学这片沃土上的第三个学期就这样结束了，回想大学这三年，为了自己的未来迷茫过，也为自己努力过，也为了不少事情烦恼过，不知道将来自己可以在什么地方过着怎样的生活。曾经以为自己将会平凡地与大部分人一样，每天上着不知老师所云的课程，浑浑噩噩地度过这大学四年的生活，然后找一个普普通通的工作，但是也算自己运气好吧，在大一第二学期遇到了一位让自己眼前一亮的老师，慢慢学习并了解程序员这个行业，最后决定走上学习Java开发的道路。 &nbsp;&nbsp;&nbsp;&nbsp;很早就听说，在大三暑假如果能够找到一个好的专业对口的暑期实习的话，那么在大学毕业以后找工作就方便许多。于是在2016年3月，我便一边努力学习着web开发的相关知识，一边在网上投简历找着实习，终于在一个学长的内推下，我进入了西安三星半导体有限公司，原西安三星电子研究所。 &nbsp;&nbsp;&nbsp;&nbsp;三星是一个气氛非常好的公司，直到现在我都觉得能够进入这个公司是我大学期间的很幸运的一件事。在这儿我遇到了对我很好的师傅们，和那些谦逊和善的同事们。 &nbsp;&nbsp;&nbsp;&nbsp;一开始进入公司，我被派的任务是进行artik芯片的测试执行，输出测试执行报告并且开发相应的shell脚本进行自动化测试。因为之前没有过Linux开发经验，所以对于这项工作还是有很多畏惧，怕自己不能完成相应的任务。后来进过一个礼拜的熟悉以后，对于自动化测试的脚本开发和测试执行更加得心应手起来。Artik芯片包含许多模块如MQTT、wifi、TLS、ZigBee、BT/BLE、Ethernet等，在进行这些模块的测试脚本的开发的时候，不仅要熟悉脚本开发的shell语言，还要对这些协议也有一定的学习。由于我之前没有接触过Linux，所以对于shell脚本的编写知识懂一丁点儿简单的命令，后来边工作边学习，对于一些常用的Linux命令也掌握的很熟悉了。 &nbsp;&nbsp;&nbsp;&nbsp;其实作自动化测试这个工作不是我期望的工作，但是来到公司里，对于公司的安排还是要服从的，毕竟也是能够学习到很多东西的。而且有很多有常年工作经验的师傅们的带领，不管是技术方面还是工作习惯与工作流程的熟悉上我也学习了不少。由于自己在学校是主要学习WEB开发的，所以一直希望自己能够在实习时得到一些这方面的工作经验，在接下来的两个月，我便被leader调到web组进行一个公司内部的项目管理系统的开发。 &nbsp;&nbsp;&nbsp;&nbsp;在做第二个项目之前，我不会想到这个项目的短短一个多月比我之前所有时间加起来都学到的多。因为这个项目几乎是由我独自完成前端与后台代码的编写，而且使用的是我之前没有任何经验的PHP语言进行开发。领导要求一个月内完成整个项目的开发，所以压力非常大。我一边在工作中学习，工作，一边再回到寝室后仍查资料学习希望能够把这个项目做到最好。前端方面我更加熟悉了jquery和bootstrap框架以及html/css，后端方面我又掌握了新的技能–PHP。从数据库的设计到前端页面的设计，再到后台业务代码的编写，投入了自己非常大的精力。不管最后结果如何，这个项目经历的确使我对于web开发的相关技术知识增长不少。在经历了一个多月的边学边做，最后总算（不是很完美的）完成了这项工作。 &nbsp;&nbsp;&nbsp;&nbsp;9月，由于学校开学以及准备毕业找工作（想找Java开发的岗位），便不能继续在公司继续实习，对于这里很不舍，因为这儿是一个工作气氛非常舒服愉快的地方。在这里我遇到了很多和我一起在这里实习的小伙伴，也结识了很多已经毕业很多年工作近十年的朋友，我相信这些人和事在未来的日子里都是我最宝贵的财富，而这次的实习经历也希望将会是我走上成功的路上的一块踏板。希望自己的努力能够对得起自己的理想！]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
        <tag>实习</tag>
        <tag>三星</tag>
        <tag>shell自动化测试</tag>
      </tags>
  </entry>
</search>
