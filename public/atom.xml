<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈年风楼 | 博客</title>
  
  <subtitle>当你看到了一座山，一定会想再看看山的后面是什么！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangjiaheng.cn/"/>
  <updated>2020-11-25T16:04:27.162Z</updated>
  <id>http://zhangjiaheng.cn/</id>
  
  <author>
    <name>陈年风楼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>让一切被中断的重新启动</title>
    <link href="http://zhangjiaheng.cn/blog/20200705/Make-everything-interrupted-reboot/"/>
    <id>http://zhangjiaheng.cn/blog/20200705/Make-everything-interrupted-reboot/</id>
    <published>2020-07-05T07:35:33.000Z</published>
    <updated>2020-11-25T16:04:27.162Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/blog/20200705/Make-everything-interrupted-reboot/flag.JPG" alt></p><a id="more"></a><p>2020年因为疫情原因导致自己浑浑噩噩地度过了半年时间，博客一直都没有更新，甚至都不知道自己每天在干什么。相比于 2019 年每天都拍一点视频记录一下自己干了些什么之外（其实每天也是一样枯燥无聊），2020 年这大半年好像是突然就消失掉了。</p><p>想要做的事情还有很多，所以今天打算整理一下思绪，三省一下吾身🧐。在 新公司工作 8 个月以来，好像失去了斗志，在这里每天做着一些简单的貌似无法提升自己的工作，其实有一些倦了。哎不过提升不提升都是看自己，也许是我现在太浮躁了。</p><p>从杭州回来之前想着每天工作轻松了可以做一些副业或者其他，比如视频剪辑，继续学习 <code>POPPIN</code> 之类的事情，但是现实是每天回到家就躺尸。西安的夏天每天8点才日落，真的感觉好浪费时间啊，大好的光阴都被自己挥霍掉了。20 年的后半年立一些F🚩L🇨🇳A🏳️‍🌈G吧，例如，多剪辑一些有趣的 VLOG（这个需要灵感），存一下钱（还好股票已经回本了），多去西安周边走一走（有驾照就方便了），谈个女朋友（这个对我来说其实是最难的，因为我发现自己其实是一个很闷的人，有时候就想一个人呆着不想和别人说话，和别人相处真的好累），还有健身（至少增重到 125 斤吧）先练出来一个好看的身体。</p><h3 id="剪辑"><a href="#剪辑" class="headerlink" title="剪辑"></a>剪辑</h3><p>2019 年每天都有拍一段小视频，20 年后半年不打算这样拍了，很耗费精力。也许在遇到一些好玩的东西的时候可以不用照片记录，而用一段简短的小视频记录下来（说到这里想起来 iPhone 的实况拍照功能，长按可以播放拍摄当时的视频片段，真的非常好用）。</p><p>也许可以花点时间学习一下稍微高级一点的剪辑技巧，emmm…看天分了吧，随缘学习。</p><h3 id="存钱"><a href="#存钱" class="headerlink" title="存钱"></a>存钱</h3><p>过年的时候数了数自己的存款发现也有十万呢，结果 20 年大半年过去了还是这个数目，不知道自己这大半年钱都去哪儿了。不科学啊，股票也回本了呢，在朋友那里放了 5 万，自己股票中留了 6 万，最近感觉牛市快来了呢，希望能够让我赚一些吧。有个在杭州的朋友最近遇到一些棘手的事情，需要打官司，可能还得赔十几万。哎，早就劝过他脚踏实地的赚钱，他从来没有听进去过我的一句话，其实我早就已经非常失望了。</p><p>以后我管好自己就行了，不去管别人好不好。</p><h3 id="户外"><a href="#户外" class="headerlink" title="户外"></a>户外</h3><p>回到西安以后好像就前段时间去了牛背梁。本来在五一的时候和成他们去太白山，因为一场婚礼没有去成，下一个目的地应该就是太白山了吧，和同事一起去。不过目前现阶段对我最重要的还是先尽快拿一下驾照。有了驾照会开车以后，秦岭我能每天下班去一趟哈哈。</p><p>哦对，我应该把去一些 livehouse，看糖蒜铺子脱口秀、看电影等等这种活动也算在户外这里，疫情原因有些一直都看不成，好气啊！</p><h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><p>前段时间称了下体重，<em>57.8KG</em>， 好气啊，可能我的饮食习惯也不太好。我们组有三个同事都是健身大神，猛的不行。也许我也需要办一个健身卡？跟着大佬们把我这核心力量，手臂背胸肌练一练哈哈。🌚 短期目标 125 斤！</p><p>2020 年下半年就暂时立这么写 FALG 吧，希望都能够完成！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;img src=&quot;/blog/20200705/Make-everything-interrupted-reboot/flag.JPG&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程的一些总结</title>
    <link href="http://zhangjiaheng.cn/blog/20200129/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://zhangjiaheng.cn/blog/20200129/Java-并发编程的一些总结/</id>
    <published>2020-01-29T14:06:28.000Z</published>
    <updated>2020-11-25T16:04:27.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3></blockquote><p>关于JAVA 并发编程的学习，我已零散的并不系统地积累了一些学习博客，如下：</p><p><a href="http://localhost:4000/blog/20190517/编写一个简易的可重入锁-一/" target="_blank" rel="noopener">并发编程学习(一)：编写一个简易的可重入锁</a></p><p><a href="http://localhost:4000/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/" target="_blank" rel="noopener">并发编程学习(二)：使用AQS编写可重入锁</a></p><p><a href="http://localhost:4000/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/" target="_blank" rel="noopener">并发编程学习(三)：CountDownLatch的实现原理及使用</a></p><p><a href="http://localhost:4000/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/" target="_blank" rel="noopener">并发编程学习(四)：理解ThreadPoolExecutor线程池</a></p><p><a href="http://localhost:4000/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/" target="_blank" rel="noopener">并发编程学习(五)：Semaphore源码学习及使用案例</a></p><p><a href="http://localhost:4000/blog/20190701/并发编程学习-六-：Exchanger的学习及使用场景/" target="_blank" rel="noopener">并发编程学习(六)：Exchanger的学习及使用场景</a></p><p><a href="http://localhost:4000/blog/20190814/并发编程学习-七-：Fork-Join框架原理及demo/" target="_blank" rel="noopener">并发编程学习(七)：Fork/Join框架原理及demo</a></p><p><a href="http://localhost:4000/blog/20190716/Synchronized使用时一个不起眼的注意点/" target="_blank" rel="noopener">Synchronized使用时一个不起眼的注意点</a></p><p>这篇博客，制作了一个 Slide，来针对 Java 并发编程做一些小小的总结：</p><p><a href="/ppt/java-concurrent-knowledge.html">&gt; 点击查看 Slide</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;关于JAVA 并发编程的学习，我已零散的并不系统地积累了一些学习博客，如下：&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>How to Use Junit5 to Test You Java Application Elegantly</title>
    <link href="http://zhangjiaheng.cn/blog/20200115/How-to-use-Junit5-to-test-you-java-application-elegantly/"/>
    <id>http://zhangjiaheng.cn/blog/20200115/How-to-use-Junit5-to-test-you-java-application-elegantly/</id>
    <published>2020-01-15T06:25:14.000Z</published>
    <updated>2020-11-25T16:04:27.191Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">Junit5 的一些实际开发中常用的功能【 TDD 向 】</h1><p><img src="/blog/20200115/How-to-use-Junit5-to-test-you-java-application-elegantly/junit5.png" alt="Junit"></p><a id="more"></a><blockquote><p>这篇博客本来应该写于鼠年过年之前，谁想到犯了个懒，现在怀着沉重的心情写下这篇博客~</p><p>因为中国现在正在受着新型冠状病毒疫情的危害，大过年的门都出不去，都躲在家里生怕被感染。无聊的我只能学习学习来打发一下枯燥的假期生活哈哈~</p></blockquote><h3 id="Junit5"><a href="#Junit5" class="headerlink" title="Junit5"></a>Junit5</h3><p>说到 JUNIT5 可能很多人都不陌生，就是一个测试框架而已。但是相信大部分的程序员都没有用过，感觉国内好多公司都没有写测试的习惯，也许是产品催需求催的太紧ε=(´ο｀*)))。我就不在这里介绍 Junit5 了，没有前置知识的话需要看一下：<a href="https://junit.org/junit5/" target="_blank" rel="noopener">Junit5</a>，我只在这篇博客介绍一下我在工作中是如何使用 Junit5 的。</p><h3 id="基本的测试代码"><a href="#基本的测试代码" class="headerlink" title="基本的测试代码"></a>基本的测试代码</h3><p>首先 gradle需要引入 Junit5 以及其他相关的依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">testImplementation <span class="string">'org.mockito:mockito-core:2.24.0'</span></span><br><span class="line">testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-api:5.2.0'</span></span><br><span class="line">testImplementation <span class="string">'org.junit.jupiter:junit-jupiter-params:5.2.0'</span></span><br><span class="line">testRuntimeOnly <span class="string">'org.junit.jupiter:junit-jupiter-engine:5.2.0'</span></span><br><span class="line">testImplementation <span class="string">"org.testcontainers:junit-jupiter:1.12.3"</span></span><br><span class="line">testImplementation <span class="string">"org.testcontainers:postgresql:1.12.3"</span></span><br><span class="line">testImplementation <span class="string">'org.mockito:mockito-junit-jupiter:3.1.0'</span></span><br><span class="line">testImplementation <span class="string">'org.hamcrest:hamcrest:2.2'</span></span><br></pre></td></tr></table></figure><p>然后编写一个简单的测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shouldReturnObjectsGivenValidIdWhenGetObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  when(objectService.findApplications(OBJECT_ID)).thenReturn(mockObjects);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> responseEntity = objectsController.getObjects(<span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">  assertThat(HttpStatus.OK).isEqualTo(responseEntity.getStatusCode());</span><br><span class="line">  assertThat(responseEntity.getBody()).isEqualTo(mockGetObjectsResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明一下，以上测试用例的编写需要注意以下几点：</p><ol><li>方法命名<br>一般的写测试的时候，方法的命名要求解释测试的功能，需要包含 should/given/when 条件。如以上方法的命名<code>shouldReturnObjectsGivenValidIdWhenGetObjects</code>是指当调用getObjects()的时候，给定一个合法的 ID，能够返回一组 Objects。</li><li>方法的条件、执行、以及对于结果的验证的代码换行隔开</li><li>使用 assertThat()验证结果：<br><code>assertThat</code>方法是包<code>import static org.assertj.core.api.Assertions.assertThat;</code>中的方法。它接收一个实际的值，然后再使用<code>isEqualTo</code>等方法判断上一个执行结果是否正确。</li></ol><h3 id="在类中的测试执行之前执行一次代码"><a href="#在类中的测试执行之前执行一次代码" class="headerlink" title="在类中的测试执行之前执行一次代码"></a>在类中的测试执行之前执行一次代码</h3><p>以下代码使用<code>@BeforeAll</code>注解在方法 setupMDC 上面，并且这个方法必须是 static 静态方法。是指在所有类中的测试方法执行之前只执行一次该方法。一般用于设置无状态的全局变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@BeforeAll</span><br><span class="line">static void setupMDC() &#123;</span><br><span class="line">    MDC.put(TRANSACTION_ID, UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在每个测试方法之前都执行一些代码"><a href="#在每个测试方法之前都执行一些代码" class="headerlink" title="在每个测试方法之前都执行一些代码"></a>在每个测试方法之前都执行一些代码</h3><p>以下代码使用<code>@BeforeEach</code>注解，可以在每一个方法执行之前都执行该方法，用于每个方法执行前的初始化或者做一些共同的 mock 操作，相当于 AOP 的 Before。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  when(service.save(any(String<span class="class">.<span class="keyword">class</span>), <span class="title">any</span>(<span class="title">UUID</span>.<span class="title">class</span>), <span class="title">any</span>(<span class="title">UUID</span>.<span class="title">class</span>))).<span class="title">thenReturn</span>(<span class="title">null</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他的比如<code>@AfterAll</code> <code>@AfterEach</code>等等功能依次类推。</p><h3 id="测试分层"><a href="#测试分层" class="headerlink" title="测试分层"></a>测试分层</h3><p>在使用 Junit5 测试过程中，最让我觉得方便的是对于测试类的结构划分方式：内部类。通过内部类，我们可以将我们要测试的东西使用类结构的形式去进行描述（使用注解<code>@Nested</code>修饰），然后再在类中编写相应的测试方法进行具体的测试。</p><p>比如一个 Controller 需要测试 create/update/get 等方法，就可以将这几个方法依次编写内部类分开描述，然后再在类中对于不同的分支编写测试方法进行单元测试，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(MockitoExtension<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ObjectsControllerTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CreateObjects</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Test</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">someTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// some code</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UpdateObjects</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Test</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">someTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// some code</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GetObjects</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Test</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">someTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// some code</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是我在编写 unit 测试的时候的一些小小的总结，以后会继续加深对于测试代码编写的学习，实际上测试才是写代码过程中最重要的一环，可以保障系统的功能的正确性，还能保护重构。Junit5 为 JAVA 程序员提供了更强大、方便的测试框架，值得深入研究使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 align=&quot;center&quot;&gt;Junit5 的一些实际开发中常用的功能【 TDD 向 】&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/blog/20200115/How-to-use-Junit5-to-test-you-java-application-elegantly/junit5.png&quot; alt=&quot;Junit&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Junit5" scheme="http://zhangjiaheng.cn/categories/Junit5/"/>
    
      <category term="Unit Test" scheme="http://zhangjiaheng.cn/categories/Junit5/Unit-Test/"/>
    
    
      <category term="Junit5" scheme="http://zhangjiaheng.cn/tags/Junit5/"/>
    
      <category term="Java 基础" scheme="http://zhangjiaheng.cn/tags/Java-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="单元测试" scheme="http://zhangjiaheng.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="unit test" scheme="http://zhangjiaheng.cn/tags/unit-test/"/>
    
  </entry>
  
  <entry>
    <title> 解决@ResuestBody中的 JSON 自动转化非 Boolean 为 Boolean 值</title>
    <link href="http://zhangjiaheng.cn/blog/20191217/%E8%A7%A3%E5%86%B3-ResuestBody%E4%B8%AD%E7%9A%84-JSON-%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%8C%96%E9%9D%9E-boolean-%E4%B8%BA-boolean-%E5%80%BC/"/>
    <id>http://zhangjiaheng.cn/blog/20191217/解决-ResuestBody中的-JSON-自动转化非-boolean-为-boolean-值/</id>
    <published>2019-12-17T03:39:58.000Z</published>
    <updated>2019-12-17T06:44:08.492Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20191217/解决-ResuestBody中的-JSON-自动转化非-boolean-为-boolean-值/code.jpg" alt="封面"></p><a id="more"></a><h2 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h2><p>当我们在 SpringBoot 中写 API 的时候，通常我们会使用<code>@RequestBody</code>注解一个参数将这个对象标记之后，然后我们在请求头使用<code>application/json</code>调用这个 API，传入 JSON 的 body 体，就可以自动的将我们的 JSON 转化成 JAVA 对象。但是，当我使用的 JAVA 对象中有个 Boolean 的字段的时候，我的 JSON 的 body 对这个对象传数值、”True”等等其他值得时候，往往会被默认转成相应的 true 或者 false。例如传入{“able”:0}的时候，我的对象中的 able 字段就是 false。但是我不想要这个功能，我希望接口调用者传的类型都是 Boolean 类型。</p><h2 id="Debug-源码"><a href="#Debug-源码" class="headerlink" title="Debug 源码"></a>Debug 源码</h2><p>首先你要知道，在 SpringBoot 或者 SpringMVC 中对于request 和 response 的处理是使用的消息转换器处理的。所以我在 debug 源码的时候发现，SpringBoot 使用<code>MappingJackson2HttpMessageConverter</code>处理 JSON 转化成对象，然后实际的转化方法<code>MappingJackson2HttpMessageConverter</code>没有重写，而是交给父类<code>AbstractJackson2HttpMessageConverter</code>的方法，在该类的第239 行会发现实际上是使用的 <code>this.objectMapper.readValue(inputMessage.getBody(), javaType);</code> 将一个 JSON 字符串转化成 JAVA 对象。再进去看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(InputStream src, JavaType valueType)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException, JsonParseException, JsonMappingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>_readMapAndClose</code>方法是这样的(重点看下 4013 行)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">_readMapAndClose</span><span class="params">(JsonParser p0, JavaType valueType)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> (JsonParser p = p0) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    JsonToken t = _initForReading(p, valueType);</span><br><span class="line">    <span class="keyword">final</span> DeserializationConfig cfg = getDeserializationConfig();</span><br><span class="line">    <span class="keyword">final</span> DeserializationContext ctxt = createDeserializationContext(p, cfg);</span><br><span class="line">    <span class="keyword">if</span> (t == JsonToken.VALUE_NULL) &#123;</span><br><span class="line">      <span class="comment">// Ask JsonDeserializer what 'null value' to use:</span></span><br><span class="line">      result = _findRootDeserializer(ctxt, valueType).getNullValue(ctxt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) &#123;</span><br><span class="line">      result = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      JsonDeserializer&lt;Object&gt; deser = _findRootDeserializer(ctxt, valueType);</span><br><span class="line">      <span class="keyword">if</span> (cfg.useRootWrapping()) &#123;</span><br><span class="line">        result = _unwrapAndDeserialize(p, ctxt, cfg, valueType, deser);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = deser.deserialize(p, ctxt);</span><br><span class="line">      &#125;</span><br><span class="line">      ctxt.checkUnresolvedObjectId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cfg.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)) &#123;</span><br><span class="line">      _verifyNoTrailingTokens(p, ctxt, valueType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这行代码<code>result = deser.deserialize(p, ctxt);</code>使用一个反序列化对象进行 JSON 的反序列化，这里如果传入的是数字转化成 Boolean的话就是用的是<code>NumberDeserializers</code>中的<code>BooleanDeserializer</code>，而它的<code>deserialize</code>方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">deserialize</span><span class="params">(JsonParser p, DeserializationContext ctxt)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  JsonToken t = p.getCurrentToken();</span><br><span class="line">  <span class="keyword">if</span> (t == JsonToken.VALUE_TRUE) &#123;</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (t == JsonToken.VALUE_FALSE) &#123;</span><br><span class="line">    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _parseBoolean(p, ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后<code>_parseBoolean</code>中将其他的数值转化成 Boolean。</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>以上就是整个 debug 的全过程了，总结一下就是<code>AbstractJackson2HttpMessageConverter</code>中会默认地将非 Boolean 的数值转化成 Boolean。那么如何解决这个问题呢？</p><p>首先使用搜索引擎解决😹然后搜索不到。。。然后我在 StackOverFlow 上提了一个<a href="https://stackoverflow.com/questions/59353379/springboot-atomically-convert-integer-to-boolean-with-requestbody-annotation-h/59355180#59355180" target="_blank" rel="noopener">问题 &lt;click</a>。简单来说就是以下这种方式：</p><ul><li><p>自定义自己的反序列化工具，然后让 Spring 去管理这个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleModule <span class="title">addDeserializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleModule().addDeserializer(Boolean<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">MyDeserializer</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">deserialize</span><span class="params">(JsonParser p, DeserializationContext ctxt)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            JsonToken t = p.getCurrentToken();</span><br><span class="line">            <span class="keyword">if</span> (t == JsonToken.VALUE_TRUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t == JsonToken.VALUE_FALSE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t == JsonToken.VALUE_STRING) &#123;</span><br><span class="line">                String value = p.getValueAsString();</span><br><span class="line">                <span class="keyword">return</span> value.equals(<span class="string">"true"</span>) ? <span class="keyword">true</span> : value.equals(<span class="string">"false"</span>) ? <span class="keyword">false</span> : <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样就将所有 API 中，存在 Boolean 的情况都处理掉了。只能接受 Boolean 值或者字符串的”true”或者”false”。</p><p>但是作为一个优秀(pa ma fan)的👩‍💻coder😷，我们应该保证自己修改的代码不会影响到其他人或者其他模块，随便的修改全局的配置不太好。所以我寻找到了一个更加୧(๑•̀◡•́๑)૭的方式 —— 编写一个该属性的 set 方法即可。</p><p>因为Deserializer会将读取到的 JSON 的值通过 set 方法填入对象中，所以这种方式也是完全可行的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAble</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">    able = (Boolean) value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"true"</span>.equals(value)) &#123;</span><br><span class="line">    able = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，大功告成。但是实际上整个过程 debug 的时候是最有意思的，可以了解到它在转换的过程中实际上都做了些什么事情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20191217/解决-ResuestBody中的-JSON-自动转化非-boolean-为-boolean-值/code.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://zhangjiaheng.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://zhangjiaheng.cn/tags/SpringBoot/"/>
    
      <category term="Spring" scheme="http://zhangjiaheng.cn/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://zhangjiaheng.cn/tags/SpringMVC/"/>
    
      <category term="JSON" scheme="http://zhangjiaheng.cn/tags/JSON/"/>
    
      <category term="converter" scheme="http://zhangjiaheng.cn/tags/converter/"/>
    
      <category term="RequestBody" scheme="http://zhangjiaheng.cn/tags/RequestBody/"/>
    
  </entry>
  
  <entry>
    <title>如何在 SpringCloud 微服务项目中一键部署 Docker 启动</title>
    <link href="http://zhangjiaheng.cn/blog/20191211/%E5%A6%82%E4%BD%95%E5%9C%A8-SpringCloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2-docker-%E5%90%AF%E5%8A%A8/"/>
    <id>http://zhangjiaheng.cn/blog/20191211/如何在-SpringCloud-微服务项目中一键部署-docker-启动/</id>
    <published>2019-12-11T09:26:46.000Z</published>
    <updated>2019-12-11T10:13:18.063Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20191211/如何在-SpringCloud-微服务项目中一键部署-docker-启动/docker.jpg" alt></p><a id="more"></a><h2 id="如何用-docker-一键启动-SpringCloud-微服务？"><a href="#如何用-docker-一键启动-SpringCloud-微服务？" class="headerlink" title="如何用 docker 一键启动 SpringCloud 微服务？"></a>如何用 docker 一键启动 SpringCloud 微服务？</h2><h3 id="为什么要使用-docker-启动我们的微服务？"><a href="#为什么要使用-docker-启动我们的微服务？" class="headerlink" title="为什么要使用 docker 启动我们的微服务？"></a>为什么要使用 docker 启动我们的微服务？</h3><p>原始传统的部署方式为我们带来了太多问题，比如当你的服务在测试环境正运行的正常，但是部署到生产环境就会出现一大堆未知问题，你查了好久，debug 代码之后发现，仅仅是一个环境变量没有设置正确，导致产生了目前这么一大串问题，浪费了你的时间，拖延了项目上线的时间，甚至产生了严重的生产事故。这个时候，我们就需要一个机制来保证我们的代码在部署到本地、测试以及生产的时候，我们的代码不会受到环境不一致的影响而导致我们部署失败！</p><p>还有就是我们可以使用 docker 打包镜像然后使用 docker-compose 编排容器一键启动，让运维自动化，极大的节省我们的工作时间。</p><h3 id="在-Spring-Cloud-微服务项目中如何使用-DOCKER？"><a href="#在-Spring-Cloud-微服务项目中如何使用-DOCKER？" class="headerlink" title="在 Spring-Cloud 微服务项目中如何使用 DOCKER？"></a>在 Spring-Cloud 微服务项目中如何使用 DOCKER？</h3><h4 id="首先我们需要将我们的每一个服务打包成镜像"><a href="#首先我们需要将我们的每一个服务打包成镜像" class="headerlink" title="首先我们需要将我们的每一个服务打包成镜像"></a>首先我们需要将我们的每一个服务打包成镜像</h4><p>例如我的<a href="https://github.com/Fatezhang/scaffold-cloud/blob/a6dd55772f59eecd99b099e013ce2ef4470cec91/scaffold-eureka/pom.xml#L43" target="_blank" rel="noopener"> Scaffold-Cloud 项目中的 eureka 服务的 pom 文件</a>(点击链接跳转到 github 以下代码行)如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>scaffold-cloud/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">forceTags</span>&gt;</span>true<span class="tag">&lt;/<span class="name">forceTags</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">baseImage</span>&gt;</span>java<span class="tag">&lt;/<span class="name">baseImage</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后其他模块也一样，在 pom 文件中加入以上 maven 插件，完整项目代码如下(觉得好用 star✨一下哦)：</p><p><a href="https://github.com/Fatezhang/scaffold-cloud" target="_blank" rel="noopener">https://github.com/Fatezhang/scaffold-cloud/</a></p><h4 id="使用脚本一键创建-docker-镜像"><a href="#使用脚本一键创建-docker-镜像" class="headerlink" title="使用脚本一键创建 docker 镜像"></a>使用脚本一键创建 docker 镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">echo "============start to package with maven and recreate docker image=============="</span><br><span class="line"></span><br><span class="line">SERVICE_FOLDERS=(</span><br><span class="line">  scaffold-eureka</span><br><span class="line">  scaffold-zuul</span><br><span class="line">  scaffold-tx-manager</span><br><span class="line">  scaffold-business/scaffold-business-sys-service</span><br><span class="line">  scaffold-business/scaffold-business-job-service</span><br><span class="line">  scaffold-business/scaffold-business-thirdparty-service</span><br><span class="line">  scaffold-route/scaffold-route-app</span><br><span class="line">  scaffold-route/scaffold-route-openapi</span><br><span class="line">  scaffold-route/scaffold-route-operate</span><br><span class="line">)</span><br><span class="line">path=</span><br><span class="line">for (( i = 0; i &lt; $&#123;#SERVICE_FOLDERS[@]&#125;; i++ )); do</span><br><span class="line">    path=$&#123;SERVICE_FOLDERS[$&#123;i&#125;]&#125;</span><br><span class="line">    echo "进入目录 &gt;&gt;&gt;&gt; cd $&#123;path&#125;"</span><br><span class="line">    cd "$&#123;path&#125;" || exit</span><br><span class="line">    pwd</span><br><span class="line">    mvn clean package docker:build -Pdocker</span><br><span class="line">    cd - || exit</span><br><span class="line">done</span><br><span class="line">echo "============                      create end                     =============="</span><br></pre></td></tr></table></figure><h4 id="编排-docker-compose-启动所有微服务"><a href="#编排-docker-compose-启动所有微服务" class="headerlink" title="编排 docker-compose 启动所有微服务"></a>编排 docker-compose 启动所有微服务</h4><p>然后只需要将所有镜像编排在 docker-compose.yml 文件中即可，其中所有的容器都在同一个网络中以访问到对方服务，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br></pre></td></tr></table></figure><p>完整的 docker-compose.yml 文件如下（注意有一个<code>wait-for-it.sh</code>）：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.7"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">micro-sys:</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">./wait-for-it.sh</span> <span class="string">tx_manager:7970</span> <span class="string">'java -jar scaffold-business-sys-service-1.0-SNAPSHOT.jar'</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">scaffold-cloud/scaffold-business-sys-service:1.0-SNAPSHOT</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp:/tmp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./.scripts/wait-for-it.sh:/wait-for-it.sh</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8750</span><span class="string">:8750</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eureka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rmqbroker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rmqnamesrv</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tx_manager</span></span><br><span class="line">  <span class="attr">route-operate:</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">./wait-for-it.sh</span> <span class="string">micro-sys:8750</span> <span class="string">'java -jar scaffold-route-operate-1.0-SNAPSHOT.jar'</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">scaffold-cloud/scaffold-route-operate:1.0-SNAPSHOT</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp:/tmp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./.scripts/wait-for-it.sh:/wait-for-it.sh</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8850</span><span class="string">:8850</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">micro-sys</span></span><br><span class="line">  <span class="attr">eureka:</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">java</span> <span class="string">-jar</span> <span class="string">scaffold-eureka-1.0-SNAPSHOT.jar</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">scaffold-cloud/scaffold-eureka:1.0-SNAPSHOT</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp:/tmp</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8761</span><span class="string">:8761</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br><span class="line">  <span class="attr">zuul:</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">./wait-for-it.sh</span> <span class="string">eureka:8761</span> <span class="string">'java -jar scaffold-zuul-1.0-SNAPSHOT.jar'</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">scaffold-cloud/scaffold-zuul:1.0-SNAPSHOT</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp:/tmp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./.scripts/wait-for-it.sh:/wait-for-it.sh</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8861</span><span class="string">:8861</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eureka</span></span><br><span class="line">  <span class="attr">tx_manager:</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">./wait-for-it.sh</span> <span class="string">mysql:3306,redis:6379</span> <span class="string">'java -jar scaffold-txmanager-1.0-SNAPSHOT.jar'</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">scaffold-cloud/scaffold-txmanager:1.0-SNAPSHOT</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp:/tmp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./.scripts/wait-for-it.sh:/wait-for-it.sh</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8890</span><span class="string">:8890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7970</span><span class="string">:7970</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eureka</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql/mysql-server:5.7</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/config/my.cnf:/etc/my.cnf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/init:/docker-entrypoint-initdb.d/</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--requirepass</span> <span class="string">pwd8ok8</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br><span class="line">  <span class="attr">rmqnamesrv:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">foxiswho/rocketmq:server-4.5.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqnamesrv</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./rmq/logs:/opt/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./rmq/store:/opt/store</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPT_EXT:</span> <span class="string">"-Duser.home=/opt -Xms128m -Xmx128m -Xmn128m"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br><span class="line">  <span class="attr">rmqbroker:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">foxiswho/rocketmq:broker-4.5.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqbroker</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10909</span><span class="string">:10909</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10911</span><span class="string">:10911</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./rmq/logs:/opt/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./rmq/store:/opt/store</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./rmq/brokerconf/broker.conf:/etc/rocketmq/broker.conf</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPT_EXT:</span> <span class="string">"-Duser.home=/opt -server -Xms128m -Xmx128m -Xmn128m"</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["/bin/bash","mqbroker","-c","/etc/rocketmq/broker.conf","-n","rmqnamesrv:9876","autoCreateTopicEnable=true"]</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rmqnamesrv</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">rmqconsole:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">styletang/rocketmq-console-ng</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqconsole</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8180</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPTS:</span> <span class="string">"-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false"</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rmqnamesrv</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">scaffold-cloud</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">scaffold-cloud:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">scaffold-cloud</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure></p><h4 id="如何在启动所有微服务的时候按顺序启动呢？"><a href="#如何在启动所有微服务的时候按顺序启动呢？" class="headerlink" title="如何在启动所有微服务的时候按顺序启动呢？"></a>如何在启动所有微服务的时候按顺序启动呢？</h4><p>我们知道，SpringCloud 微服务中各个服务之间可能存在依赖关系，比如 tx-manager 服务需要等待 MySQL 和 Redis 都启动完成之后才能够顺利启动，但是 docker-compose.yml 文件中的 <code>depends_on</code>只能等待 docker 容器启动成功，而不能等待 docker 容器中的服务启动完成！</p><p>docker 官方给出的方案是使用wait-for-it.sh脚本，在容器启动之前执行脚本，判断依赖的服务和端口是否启动成功，然后再执行自己服务的启动命令。</p><p>所以我们也是这样去写一个脚本：<code>wait-for-it.sh</code>如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> shellcheck disable=SC2223</span><br><span class="line">: $&#123;SLEEP_SECOND:=2&#125;</span><br><span class="line"></span><br><span class="line">wait_for() &#123;</span><br><span class="line">  echo Waiting for $1 on port $2... ...</span><br><span class="line"><span class="meta">  #</span> shellcheck disable=SC2086</span><br><span class="line"><span class="meta">  #</span> shellcheck disable=SC2188</span><br><span class="line">  while ! &lt;/dev/tcp/$1/$2; do</span><br><span class="line">    echo Waiting for $1 on port $2... ...</span><br><span class="line">    sleep $SLEEP_SECOND</span><br><span class="line">  done</span><br><span class="line">  echo Server:"$1" on port:"$2" is running... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SER_STRS=$1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> shellcheck disable=SC2207</span><br><span class="line"><span class="meta">#</span> shellcheck disable=SC2006</span><br><span class="line">SERVICES_PORTS=($(echo "$SER_STRS" | tr ',' ' '))</span><br><span class="line"></span><br><span class="line">THEN_COMMAND=$2</span><br><span class="line"></span><br><span class="line">for ((i = 0; i &lt; $&#123;#SERVICES_PORTS[@]&#125;; i++)); do</span><br><span class="line">  SERVICE_PORT=$&#123;SERVICES_PORTS[$&#123;i&#125;]&#125;</span><br><span class="line"><span class="meta">  #</span> shellcheck disable=SC2207</span><br><span class="line"><span class="meta">  #</span> shellcheck disable=SC2006</span><br><span class="line">  array=($(echo "$SERVICE_PORT" | tr ':' ' '))</span><br><span class="line">  servername=$&#123;array[0]&#125;</span><br><span class="line">  serverport=$&#123;array[1]&#125;</span><br><span class="line">  wait_for "$servername" "$&#123;serverport&#125;"</span><br><span class="line">done</span><br><span class="line">echo "start to run command: $THEN_COMMAND"</span><br><span class="line"><span class="meta">#</span> shellcheck disable=SC2004</span><br><span class="line">if [ "$THEN_COMMAND" ]; then</span><br><span class="line">  eval "$THEN_COMMAND"</span><br><span class="line">else</span><br><span class="line"><span class="meta">  #</span> shellcheck disable=SC2102</span><br><span class="line">  echo command: [$THEN_COMMAND] is invalid... ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>上述脚本的作用就是等待启动的服务以及端口启动成功，没有成功的话就继续 wait 等待，默认等待 2 秒，启动成功的话就执行自己的启动命令。</p><p>使用方式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tx_manager:</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">./wait-for-it.sh</span> <span class="string">mysql:3306,redis:6379</span> <span class="string">'java -jar scaffold-txmanager-1.0-SNAPSHOT.jar'</span></span><br></pre></td></tr></table></figure><p>所以，以上就是使用 docker 启动 SpringCloud 微服务的全部内容，如果你觉得有用，希望能够给我的项目<a href="https://github.com/Fatezhang/scaffold-cloud/点个star" target="_blank" rel="noopener">https://github.com/Fatezhang/scaffold-cloud/点个star</a> 哦~</p><p>而且你也可以给我提 issue，提 PR，欢迎一起交流学习，一起开发~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20191211/如何在-SpringCloud-微服务项目中一键部署-docker-启动/docker.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://zhangjiaheng.cn/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://zhangjiaheng.cn/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="http://zhangjiaheng.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="spring" scheme="http://zhangjiaheng.cn/tags/spring/"/>
    
      <category term="docker" scheme="http://zhangjiaheng.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Scaffold-Cloud —— SpringCloud微服务架构实践</title>
    <link href="http://zhangjiaheng.cn/blog/20191025/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://zhangjiaheng.cn/blog/20191025/SpringCloud微服务架构实践/</id>
    <published>2019-10-25T05:42:24.000Z</published>
    <updated>2020-11-25T15:48:42.828Z</updated>
    
    <content type="html"><![CDATA[<p><center><u style="font-size=16px;"><a href="/">Scaffold-Cloud: SpringCloud微服务脚手架</a></u></center> <a href="https://mubu.com/doc/6NZlNw3DIw" target="_blank" rel="noopener">幕布</a><br>Scaffold-Cloud 是一个适用于开发者学习的 Spring-Cloud 微服务项目脚手架。项目期望集成大部分目前互联网公司使用的主流的Spring-Cloud微服务相关工具和服务。并结合一些实际的业务增加一些其他功能，如：分布式事务、定时任务、消息队列、日志分析等等，然后加入 CI/CD 并引入 docker 部署。</p><p>Scaffold-Cloud 基于 SpringCloud Netflix 全家桶进行微服务项目的构建，所以在这之前，使用 Scaffold-Cloud 需要先了解下 SpringCloud 以及 Netflix 工具全家桶。</p><p><img src="/blog/20191025/SpringCloud微服务架构实践/netflix.png" alt></p><p><center><u style="font-size=6px; color:gray">Sorry, NetFlix is not available in your country yet.</u></center><br><a id="more"></a></p><h2 id="Spring-Cloud-介绍"><a href="#Spring-Cloud-介绍" class="headerlink" title="Spring Cloud 介绍"></a>Spring Cloud 介绍</h2><h4 id="从单体应用到微服务"><a href="#从单体应用到微服务" class="headerlink" title="从单体应用到微服务"></a>从单体应用到微服务</h4><p>在早期的企业中，项目基本上都是单体应用，将一个网站部署在一台单独的服务器上对用户提供服务。但是这样的服务最大的缺点就是，当服务器断电或者服务进程挂掉，用户直接就无法访问。后来演进出集群服务，将同样的服务在多台服务器分别部署，使用负载均衡等手段让服务对于用户来说看到的都是同一个，这样当一台服务器夯机至少还有其他的服务器提供相同的应用。</p><p>但是，当企业级服务变得越来越复杂的时候，项目变得越来越庞大，有时甚至影响到了服务的部署，这个时候就应该将庞大的服务拆分成多个子系统，部署在不同的服务器上，这样的服务当遭遇高并发访问的时候也能够将请求压力分摊到多个服务器上，这就是分布式。</p><p>而当企业需要开启一个新的项目时，为了避免重复造轮子，往往一些可复用的模块会被拆分出来作为一个微小的系统，它可以独立的开发、设计、运行和运维，只需要使用 ESB企业服务总线将所有服务整合并提供统一的访问入口，就能够复用，这就是 SOA。</p><p>而微服务是对以上服务架构的最终演进结构：将服务切分成多个微小的应用，提供统一的服务访问协议HTTP(SpringCloud)/TCP(Dubbo)，强调运行时的分散解耦，在业务上也有着高度的抽离。</p><blockquote><p><code>微服务架构风格</code><strong>是一种将<code>一个单一应用程序</code>开发为<code>一组小型服务</code>的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制</strong>(通常使用HTTP资源API)。这些<strong>服务围绕<code>业务能力</code>构建</strong>，并且可通过<strong>全自动部署机制独立部署</strong>。这些服务共用一个<strong>最小型的集中式的管理</strong>，服务可用不同的语言开发，使用不同的<strong>数据存储技术</strong>。<br><img src="/blog/20191025/SpringCloud微服务架构实践/microservice.webp" alt><br>—— Martin Fowler</p></blockquote><p><strong>但是拆分成这么微小的微服务一定会碰到各种各样的问题——如何拆分？服务之间如何发现？如何授权？如何做负载均衡？如何管理多服务配置？如何跟踪调用链路？如何实时查看服务状态等等… … SpringCloud 就是以上一系列问题的 Solver。它提供了一整套的解决方案！</strong></p><h4 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h4><p>首先，SpringCloud 并不是一个框架，而是一个微服务的规范，或者说是一个微服务工具集合。</p><h5 id="SpringCloud特点："><a href="#SpringCloud特点：" class="headerlink" title="SpringCloud特点："></a>SpringCloud特点：</h5><ul><li>约定大于配置，基于 SpringBoot</li><li>开发部署于各种环境，AWS，阿里云，PC 等</li><li>隐藏组件复杂性，声明式配置，无 xml</li><li>开箱即用，快速启动</li><li>丰富的轻量级组件</li><li>灵活选型，如注册发现可用 eureka，zookeeper 或者 Redis</li></ul><h5 id="SpringCloud-各版本组件及版本兼容性"><a href="#SpringCloud-各版本组件及版本兼容性" class="headerlink" title="SpringCloud 各版本组件及版本兼容性"></a>SpringCloud 各版本组件及<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">版本兼容性</a></h5><table><thead><tr><th>Component</th><th>Edgware.SR6</th><th>Greenwich.SR2</th><th>Greenwich.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws</td><td>1.2.4.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-bus</td><td>1.3.4.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cli</td><td>1.4.1.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-commons</td><td>1.3.6.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-contract</td><td>1.2.7.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-config</td><td>1.4.7.RELEASE</td><td>2.1.3.RELEASE</td><td>2.1.4.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.7.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-security</td><td>1.2.4.RELEASE</td><td>2.1.3.RELEASE</td><td>2.1.4.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cloudfoundry</td><td>1.1.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-consul</td><td>1.3.6.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.6.RELEASE</td><td>2.1.1.RELEASE</td><td>2.1.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR5</td><td>Fishtown.SR3</td><td>Fishtown.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-boot</td><td>1.5.21.RELEASE</td><td>2.1.5.RELEASE</td><td>2.1.8.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-task</td><td>1.2.4.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-vault</td><td>1.1.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.3.RELEASE</td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-openfeign</td><td></td><td>2.1.2.RELEASE</td><td>2.1.3.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-function</td><td>1.0.2.RELEASE</td><td>2.0.2.RELEASE</td><td>2.0.3.BUILD-SNAPSHOT</td></tr></tbody></table><h3 id="SpringCloud-全家桶"><a href="#SpringCloud-全家桶" class="headerlink" title="SpringCloud 全家桶"></a><a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">SpringCloud 全家桶</a></h3><h4 id="spring-cloud-netflix"><a href="#spring-cloud-netflix" class="headerlink" title="spring-cloud-netflix"></a>spring-cloud-netflix</h4><h5 id="eureka-原理："><a href="#eureka-原理：" class="headerlink" title="eureka 原理："></a>eureka 原理：</h5><ul><li>服务启动时，调用 eureka 接口进行注册，Eureka Server 会存储这些信息，IP、端口、微服务名称等</li><li>微服务启动之后，会周期性的发送心跳进行“续租”，默认 30 秒</li><li>如果一定时间没有“续租”，默认 90 秒，就销毁微服务实例</li><li>默认情况下，Eureka Server 也是一个 Eureka Client，集群下会互相复制服务注册表中的信息进行同步</li><li>Eureka Client 会缓存注册表的信息，减少Eureka Server 的请求压力，以及容灾</li></ul><h4 id="spring-cloud-openfeign"><a href="#spring-cloud-openfeign" class="headerlink" title="spring-cloud-openfeign"></a>spring-cloud-openfeign</h4><h4 id="spring-cloud-zuul-微服务网关"><a href="#spring-cloud-zuul-微服务网关" class="headerlink" title="spring-cloud-zuul 微服务网关"></a>spring-cloud-zuul 微服务网关</h4><h4 id="spring-cloud-config-配置中心"><a href="#spring-cloud-config-配置中心" class="headerlink" title="spring-cloud-config 配置中心"></a>spring-cloud-config 配置中心</h4><h2 id="项目创建的目的？"><a href="#项目创建的目的？" class="headerlink" title="项目创建的目的？"></a>项目创建的目的？</h2><p>第一个目的是为了本人能够熟悉和学习 Spring-Cloud 相关知识，不过在做了一段时间之后还是希望能够分享出来让更多的同学一起学习和讨论。</p><h2 id="项目结构如何？"><a href="#项目结构如何？" class="headerlink" title="项目结构如何？"></a>项目结构如何？</h2><ul><li>scaffold-business <a href="#">业务服务提供者</a> 端口从8850 - 8860<ul><li>scaffold-business-sys-service <a href="#">系统业务微服务-业务模块</a> 端口 8850</li><li>scaffold-business-job-service <a href="#">定时任务微服务-业务模块</a> 端口 8851</li><li>scaffold-business-thirdparty-service <a href="#">第三方业务微服务-业务模块</a> 端口 8852</li></ul></li><li>scaffold-business-api <a href="#">业务API包 用于接口与实现分离</a><ul><li>scaffold-business-sys-api <a href="#">系统资源、菜单、权限等API封装</a></li><li>scaffold-business-job-api <a href="#">定时任务API封装</a></li><li>scaffold-business-thirdparty-api <a href="#">第三方服务API封装</a></li></ul></li><li>scaffold-core <a href="#">工具类以及各种公共代码</a><ul><li>scaffold-core-code <a href="#">每个模块都会用到的公共代码，Bean，config等</a></li><li>scaffold-core-common <a href="#">工具类模块，公共代码</a></li><li>scaffold-core-plugin <a href="#">自动代码生成插件模块</a></li></ul></li><li>scaffold-eureka <a href="#">注册中心Eureka</a> 端口 8761 - 8771</li><li>scaffold-zuul <a href="#">网关服务</a> 端口 8861 - 8870</li><li>scaffold-config-server <a href="#">配置服务端服务</a> 端口 8871 - 8881</li><li>scaffold-config-client <a href="#">配置客户端服务</a> 端口 8880 - 8891</li><li>scaffold-tx-manager <a href="#">分布式事务协调服务</a> 端口7970 </li><li>scaffold-feign <a href="#">Feign模块</a><ul><li>scaffold-feign-sys <a href="#">feign-sys模块</a></li><li>scaffold-feign-job <a href="#">feign-job模块</a></li><li>scaffold-feign-thirdparty <a href="#">feign-thirdparty模块</a></li></ul></li><li>scaffold-route <a href="#">主业务消费者</a> 端口从8750 - 8760<ul><li>scaffold-route-operate <a href="#">后台管理接口及页面</a> 端口 8750</li><li>scaffold-route-app <a href="#">APP客户端接口</a> 端口 8751</li></ul></li></ul><h2 id="如何快速开始？"><a href="#如何快速开始？" class="headerlink" title="如何快速开始？"></a>如何快速开始？</h2><h3 id="1-本地直接启动"><a href="#1-本地直接启动" class="headerlink" title="1. 本地直接启动"></a>1. 本地直接启动</h3><ul><li><p>下载/克隆项目到本地 </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/Fatezhang/scaffold-cloud</span></span><br></pre></td></tr></table></figure></li><li><p>安装MySql数据库并启动</p></li><li>创建数据库scaffold_cloud_base 和 tx_manager</li><li>修改 scaffold-cloud 中微服务的数据库链接配置，本地运行只需要修改application-local.yml</li><li>安装redis服务并启动，修改scaffold-core-code配置文件中的配置，同样只需要修改local中的</li><li>安装Rocket MQ服务，同样修改配置</li><li>如果有需要，注册阿里OSS，并修改配置中的配置</li><li>启动EurekaApplication注册中心</li><li>启动TxlcnApplication分布式事务协调服务</li><li>启动SysServiceApplication，加载数据库字典等配置到缓存、提供后台管理微服务（权限、操作员、角色、国际化配置等）</li><li>启动RouteOperateApplication服务，默认端口为8750</li><li>访问<a href="http://localhost:8750/ßß" target="_blank" rel="noopener">http://localhost:8750/ßß</a></li><li>默认账号密码为admin/admin123</li></ul><h3 id="2-使用-docker-部署"><a href="#2-使用-docker-部署" class="headerlink" title="2. 使用 docker 部署"></a>2. 使用 docker 部署</h3><h4 id="docker-启动-Linux-或者-Mac-下使用如下脚本-Windows-环境自行按照脚本中的示例执行"><a href="#docker-启动-Linux-或者-Mac-下使用如下脚本-Windows-环境自行按照脚本中的示例执行" class="headerlink" title="docker 启动 : Linux 或者 Mac 下使用如下脚本, Windows 环境自行按照脚本中的示例执行"></a>docker 启动 : Linux 或者 Mac 下使用如下脚本, Windows 环境自行按照脚本中的示例执行</h4><h4 id="mvn-clean-package-docker-build-Pdocker"><a href="#mvn-clean-package-docker-build-Pdocker" class="headerlink" title="mvn clean package docker:build -Pdocker"></a><code>mvn clean package docker:build -Pdocker</code></h4><pre><code>1. 进入项目所在目录2. 执行 `./.scripts/recreate-docker-image.sh` 创建 docker 镜像3. 执行 `./.scripts/start-docker-service.sh` 即使用 docker-compose 启动</code></pre><h2 id="项目未来还需要做什么？"><a href="#项目未来还需要做什么？" class="headerlink" title="项目未来还需要做什么？"></a>项目未来还需要做什么？</h2><ul><li>更改项目注册发现中心，也许用 nacos 或者 zookeeper</li><li>加入更多 spring-cloud 周边服务，包括各种监控平台等</li><li>CI/CD 使用 Jenkins 或者 BuildKite</li><li>使用 docker 容器化部署</li><li>ElasticSearch 日志收集</li><li><a href="https://github.com/xuxueli/xxl-job" target="_blank" rel="noopener">xxl-job</a> 分布式定时任务 <a href="https://www.xuxueli.com/xxl-job/" target="_blank" rel="noopener">https://www.xuxueli.com/xxl-job/</a></li><li>整合<a href="https://github.com/justauth/JustAuth" target="_blank" rel="noopener">第三方开源库</a>用以登录、支付等</li><li>最后，实际开发一些业务功能</li></ul><hr><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><blockquote><p><a href="https://juejin.im/post/5c28f2fe51882565a15776fb" target="_blank" rel="noopener">https://juejin.im/post/5c28f2fe51882565a15776fb</a></p><p><a href="https://juejin.im/post/5de740566fb9a0165721b744" target="_blank" rel="noopener">https://juejin.im/post/5de740566fb9a0165721b744</a></p><p><a href="https://juejin.im/post/5dc220126fb9a04aa660dcfb" target="_blank" rel="noopener">https://juejin.im/post/5dc220126fb9a04aa660dcfb</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;u style=&quot;font-size=16px;&quot;&gt;&lt;a href=&quot;/&quot;&gt;Scaffold-Cloud: SpringCloud微服务脚手架&lt;/a&gt;&lt;/u&gt;&lt;/center&gt; &lt;a href=&quot;https://mubu.com/doc/6NZlNw3DIw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;幕布&lt;/a&gt;&lt;br&gt;Scaffold-Cloud 是一个适用于开发者学习的 Spring-Cloud 微服务项目脚手架。项目期望集成大部分目前互联网公司使用的主流的Spring-Cloud微服务相关工具和服务。并结合一些实际的业务增加一些其他功能，如：分布式事务、定时任务、消息队列、日志分析等等，然后加入 CI/CD 并引入 docker 部署。&lt;/p&gt;
&lt;p&gt;Scaffold-Cloud 基于 SpringCloud Netflix 全家桶进行微服务项目的构建，所以在这之前，使用 Scaffold-Cloud 需要先了解下 SpringCloud 以及 Netflix 工具全家桶。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/20191025/SpringCloud微服务架构实践/netflix.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;u style=&quot;font-size=6px; color:gray&quot;&gt;Sorry, NetFlix is not available in your country yet.&lt;/u&gt;&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://zhangjiaheng.cn/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://zhangjiaheng.cn/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="http://zhangjiaheng.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="分布式" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="http://zhangjiaheng.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>我项目中使用的分布式事务：LCN</title>
    <link href="http://zhangjiaheng.cn/blog/20191020/%E6%88%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9ALCN/"/>
    <id>http://zhangjiaheng.cn/blog/20191020/我项目中使用的分布式事务：LCN/</id>
    <published>2019-10-20T03:14:44.000Z</published>
    <updated>2019-12-05T15:41:57.697Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20191020/我项目中使用的分布式事务：LCN/tx.png" alt="官网首页"></p><center><a href="#more2">其他关于分布式事务的总结整理</a></center><a id="more"></a><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>由于公司项目是使用dubbo进行开发的分布式服务，所以项目中有很多涉及到分布式事务问题的场景。比如有两个模块：用户模块和账户资金模块。有一个场景是用户被邀请成为系统的新用户，需要先初始化用户信息，然后再去账户资金模块初始化用户账户信息。两个不同的模块为两个不同的RPC服务，分别被调用然后插入数据，这时候如果账户资金插入失败，不加入分布式事务的话用户直接初始化成功。我们希望这种情况下用户插入的信息被回滚，所以需要引入分布式事务来进行业务处理。</p><h4 id="使用的框架"><a href="#使用的框架" class="headerlink" title="使用的框架"></a>使用的框架</h4><p>经过调研，我们发现TX-LCN框架比较适合我们的业务场景，我们打算引入并使用LCN事务模式来进行服务中的分布式事务的业务处理。关于LCN、TCC、TXC几种事务模式的区别在<a href="#more2">下面</a>整理。</p><p>在<a href="https://www.txlcn.org/zh-cn/index.html" target="_blank" rel="noopener">官网</a>下载对应的服务，并引入项目或者单独启动：</p><p><img src="/blog/20191020/我项目中使用的分布式事务：LCN/tx.png" alt="官网首页"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transaction-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lcn.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tx-plugins-db<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lcn.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用：</p><p>在服务的发起方使用注解<code>@TxTransaction(isStart = true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@TxTransaction</span>(isStart = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ExperienceLogVO <span class="title">doUseExperience</span><span class="params">(Long userId, Long experienceRecordId, ExperienceLogCreateModel createModel)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ... do something  ...</span></span><br><span class="line">    userFacade.insert();</span><br><span class="line"> <span class="comment">// ... do something  ...</span></span><br><span class="line">    accountFacede.insert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务的参与方使用注解<code>@TxTransaction</code>标识即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TxTransaction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// ... do something  ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再启动项目之前，先启动tx-manager服务，作为协调者的角色存在，然后启动项目，调用接口的时候就可以使用分布式事务了。</p><p><a id="more2" class="active"></a></p><h4 id="其他关于分布式事务的总结整理"><a href="#其他关于分布式事务的总结整理" class="headerlink" title="其他关于分布式事务的总结整理"></a>其他关于分布式事务的总结整理</h4><h5 id="关于Tx-LCN-官网文档"><a href="#关于Tx-LCN-官网文档" class="headerlink" title="关于Tx-LCN - 官网文档"></a>关于Tx-LCN - <a href="https://www.txlcn.org/zh-cn/docs/preface.html" target="_blank" rel="noopener">官网文档</a></h5><p>Tx-LCN早期是为了设计出LCN分布式事务而命名的，不过在5.0之后可以支持LCN、TXC、TCC三种分布式事务模式。LCN框架定位为<code>不生产事务，只做事务的搬运工</code>。即TX-LCN是一款事务协调框架，本身并不操作事务，只是基于对事务的协调从而达到事务一致性的效果。</p><p>最新版本的TX-LCN同时支持多种事务模式。并支持多种不同的数据源同时使用分布式事务，完全达到拔插效果。以下是三种事务模式的介绍、区别及优缺点。</p><h6 id="LCN事务模式"><a href="#LCN事务模式" class="headerlink" title="LCN事务模式"></a>LCN事务模式</h6><ul><li>仅仅作为事务的协调者，本身不生产事务。原理是在事务发起方创建事务分组，并通过Http/Tcp协议调用的时候将事务分组传递到事务参与方。事务参与方的本地事务执行成功之后，根据事务分组ID通知事务的发起方提交所有事务。在全部事务成功通知之前，其各个本地事务均为假关闭，等待TxManager协调完成事务之后再关闭连接。</li><li>LCN事务对于代码几乎没有嵌入性，只需要添加注解即可实现分布式事务。</li><li>LCN的事务提交与回滚都有本地事务保障，更安全的确保数据一致性。</li><li>但是LCN仅限于存在本地事务并且可以通过连接对象控制事务模块的系统。</li><li>LCN模式依赖于连接代理服务，事务的发起方与参与方要一起连接与释放，较耗性能。</li><li><img src="/blog/20191020/我项目中使用的分布式事务：LCN/LCN1.png" alt="情况1"></li><li><img src="/blog/20191020/我项目中使用的分布式事务：LCN/LCN2.png" alt="情况1"></li><li><img src="/blog/20191020/我项目中使用的分布式事务：LCN/LCN3.png" alt="情况1"><h6 id="TCC事务模式"><a href="#TCC事务模式" class="headerlink" title="TCC事务模式"></a>TCC事务模式</h6></li><li>TCC事务模式不依赖于资源管理器对于XA的支持，而是通过业务系统提供的业务逻辑的调度来实现分布式事务。即编写三步操作：Try：尝试执行业务（先插入一条数据，状态为Try）、Confrim：确认执行业务（成功后状态改为Confrim）、Cancel：取消执行业务（需要回滚的话根据前两个步骤的id继续更改状态或者删除数据）。</li><li>TCC模式对于代码的侵入性很高，基本上一个接口需要拆分成3个，对于程序员的编码要求很高，业务的正确性、数据一致性都由开发者来保证</li><li>优点是TCC模式对于有无本地事务的场景都适用，甚至可以跨数据源，针对MySQL、redis、Mongo等整合成一个大的事务<h6 id="TXC事务模式"><a href="#TXC事务模式" class="headerlink" title="TXC事务模式"></a>TXC事务模式</h6></li><li>其来源于阿里巴巴的一个分布式事务中间件，可以通过极少量的代码侵入，实现分布式事务。原理是在执行SQL之前，先查询SQL的影响数据，然后保存执行的SQL快照信息并创建锁。当需要回滚的时候就采用这些记录回滚数据库。目前实现锁使用的是redis分布式锁控制。</li><li>TXC事务模式同样对代码的侵入性低</li><li>该模式仅限于对支持SQL方式的模块支持</li><li>该模式由于每次执行SQL之前需要先查询影响数据，因此相比LCN模式更消耗性能</li><li>TXC事务模式不会占用数据库资源</li><li>关于TXC事务的详细介绍可以查看<a href="https://blog.csdn.net/m0_38110132/article/details/77043580" target="_blank" rel="noopener">这篇博客</a></li></ul><h5 id="CAP理论和BASE理论"><a href="#CAP理论和BASE理论" class="headerlink" title="CAP理论和BASE理论"></a>CAP理论和BASE理论</h5><h6 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h6><p>CAP理论即数据一致性、服务可用性和分区容错性的简称。</p><ul><li>Consistency 数据一致性：一次完整的更新操作，所有节点在同一时刻访问到的数据是一致的</li><li>Availability 服务可用性：服务一直可用，并且是正常响应时间</li><li>Partition tolerance 分区容错性：分布式多节点在某几个节点挂掉后仍然可以对外提供正常的服务</li></ul><p>事实上，CAP这三种并无法保证完全满足，一般只能满足其二。对于分布式系统来说，分区容错性是最基本需要满足的条件，否则不能称为分布式系统，只满足CA 其实是传统的单机服务。那么在满足P（分区容错）的时候，就需要在C和A之间权衡。事实上，分布式系统下一般会保证A（服务可用）P，放弃数据的强一致性，只保证数据的最终一致性。这样就衍生出了BASE理论。</p><h6 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h6><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。BASE理论的核心思想是：<strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</strong>。</p><ul><li>基本可用：在分布式系统中，允许在出现不可预知故障的情况下损失部分可用性（并不是允许系统不可用），允许响应时间上的确实和部分系统功能的错误（并发场景下拒绝服务产生报错等）</li><li>软状态：即允许数据存在中间状态，允许不同节点的数据之间存在时间上的数据差异</li><li>最终一致性：强调所有数据副本能够最终一致，不需要保证数据实时强一致。</li></ul><p>传统事务的ACID机制追求强一致性，而BASE理论为分布式系统而生，主张牺牲强一致性，使得服务达到高可用。不过在分布式系统中，不同场景下对于数据的一致性又是不同的，所以才会有分布式事务来保证数据的一致，即ACID与BASE理论结合使用。</p><h5 id="2PC和3PC"><a href="#2PC和3PC" class="headerlink" title="2PC和3PC"></a>2PC和3PC</h5><h6 id="2PC-二段式提交"><a href="#2PC-二段式提交" class="headerlink" title="2PC - 二段式提交"></a>2PC - 二段式提交</h6><p>2PC，是Two-Phase Commit的缩写。过程如下：</p><ul><li><p>阶段一：提交事务请求</p><ul><li>协调者询问参与方是否可以执行提交操作并等待响应</li><li>参与者执行询问为止的所有事务操作</li><li>参与者响应协调者，返回事务执行成功与否</li></ul></li><li><p>阶段二：执行事务提交</p><ul><li><p>协调者收到所有第一阶段响应之后发起正式提交请求</p></li><li><p>参与者正式完成操作并释放整个事务期间占用的资源</p></li><li><p>反馈事务提交结果</p></li><li><p>协调者收到所有完成的消息后，完成事务。</p></li><li><p>如果任意参与者在第一阶段返回执行失败或者超时的消息，中断事务</p></li><li><p>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p></li><li><p>参与者节点向协调者节点发送”回滚完成”消息。</p></li><li><p>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p></li><li><p>不管最后结果如何，第二阶段都会结束当前事务</p></li></ul></li></ul><p>  <strong>2PC的缺点：</strong> 执行过程中所有节点都是同步阻塞的；如果协调者是单点并且发生故障，参与者将一直阻塞；如果在第二阶段协调者正式向所有参与者发送正式提交事务的请求，其中部分因为网络问题没有收到，另一部分却已经提交无法回滚，出现数据不一致的情况；协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><p>  由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p><h6 id="3PC-三段式提交"><a href="#3PC-三段式提交" class="headerlink" title="3PC - 三段式提交"></a>3PC - 三段式提交</h6><p>3PC将2PC的准备阶段又划分为两次准备，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。。并且在协调者与参与者中都引入超时机制。</p><ul><li><p>CanCommit阶段</p><ul><li>同2PC的准备阶段，协调者向参与者发送事务提交请求，询问并等待响应</li><li>得到响应之后进入预备提交阶段</li></ul></li><li><p>PreCommit阶段</p><ul><li>所有参与者第一阶段都返回成功状态，那么就会开始事务的预执行</li><li>进入PreCommit并执行事务操作，全部成功就返回给提交者</li><li>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。发送中断请求协调者向所有参与者发送abort请求;中断事务参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li></ul></li><li><p>doCommit阶段</p><ul><li><p>发送提交请求协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p></li><li><p>事务提交参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p></li><li><p>响应反馈事务提交完之后，向协调者发送Ack响应。</p></li><li><p>完成事务协调者接收到所有参与者的ack响应之后，完成事务。</p></li></ul></li></ul><p>  中断事务协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><ul><li><p>发送中断请求协调者向所有参与者发送abort请求</p></li><li><p>事务回滚参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p></li><li><p>反馈结果参与者完成事务回滚之后，向协调者发送ACK消息</p></li><li><p>中断事务协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p></li></ul><p>  相比于2PC，3PC最关键要解决的就是协调者和参与者同时挂掉的问题，所以3PC把2PC的准备阶段再次一分为二。在第一阶段只是询问所有参与者是否都可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行commit或者rollback。</p><p>  <strong>3PC存在的问题：</strong> 在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。这样与其他执行回滚的参与者就会出现数据不一致的情况。</p><hr><blockquote><p>参考：</p><ul><li><p><a href="https://www.hollischuang.com/archives/1580" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1580</a></p></li><li><p><a href="http://anruence.com/2018/03/05/tcc-2pc-3pc/" target="_blank" rel="noopener">http://anruence.com/2018/03/05/tcc-2pc-3pc/</a></p></li><li><p><a href="http://blog.jobbole.com/95632/" target="_blank" rel="noopener">http://blog.jobbole.com/95632/</a></p></li><li><a href="http://blog.csdn.net/zhangjq520/article/details/78433686" target="_blank" rel="noopener">http://blog.csdn.net/zhangjq520/article/details/78433686</a></li><li><a href="https://www.zhihu.com/question/48627764/answer/111983553" target="_blank" rel="noopener">https://www.zhihu.com/question/48627764/answer/111983553</a></li><li><a href="https://www.jianshu.com/p/d3eda795188a" target="_blank" rel="noopener">https://www.jianshu.com/p/d3eda795188a</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20191020/我项目中使用的分布式事务：LCN/tx.png&quot; alt=&quot;官网首页&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;a href=&quot;#more2&quot;&gt;其他关于分布式事务的总结整理&lt;/a&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://zhangjiaheng.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式事务" scheme="http://zhangjiaheng.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://zhangjiaheng.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="分布式" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据库" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式事务" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>其实我不太想离开这里</title>
    <link href="http://zhangjiaheng.cn/blog/20190909/%E5%85%B6%E5%AE%9E%E6%88%91%E4%B8%8D%E6%83%B3%E7%A6%BB%E5%BC%80%E8%BF%99%E9%87%8C/"/>
    <id>http://zhangjiaheng.cn/blog/20190909/其实我不想离开这里/</id>
    <published>2019-09-09T14:01:04.000Z</published>
    <updated>2020-11-25T16:04:27.198Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190909/其实我不想离开这里/fm.png" alt="杭州西湖"></p><a id="more"></a><blockquote><p>写于 2018-09-09 22:01:04</p></blockquote><h4 id="序"><a href="#序" class="headerlink" title="序"></a>序</h4><p>我要离开了。离开杭州，离开这个生活了快三年的地儿。放弃要去一线大公司的欲望，放弃年薪百万的梦想，放弃温柔可爱的南方姑娘，放弃我毕业之前一直向往的自由和远方… … 最让我难受的，在杭州两年认识的几个朋友，也许以后再难见上一面。还有，回到了家乡，我是否就此过上一个安逸的生活，还能否保持目前的这份斗志。杭州被程序员论坛称为“奋斗逼之都”，源于马老师的福报，我虽不喜欢这种996的工作节奏，但是离开这里，真的要放弃很多。</p><h4 id="辞职"><a href="#辞职" class="headerlink" title="辞职"></a>辞职</h4><p>2019年8月21日，在被称为互联网寒冬的这年，我辞职了。因为这一年以来，公司的经营状况出了很大的问题，8月，线上服务器关闭了，这意味着理财业务此时已经完全停止，公司金融部门用仅剩的海外贷款业务维持着最后一线生机。这种时刻，但凡是觉得自己在离开之后能够找到合适工作的人，都不会想要再继续再公司呆下去。我就是其中之一，所以我向老大说，我想走了！</p><p>后来，我们一起去吃了散伙饭，又是火锅，每次都是。为什么说“每次”呢？因为在我之前，还有5个人。我想我也不会是最后一个吧。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>事实上半年以来我都在使用空闲时间学习、刷算法题、写博客、点亮GitHub绿点以期望自己在之后找工作能够靠着博客和GitHub的活跃程度吸引到某公司的面试官（后来事实证明，这个做法还挺管用，当然我的确有在丰富自己的知识而不只是点“绿点”）。这半年以来，在公司所做的工作几乎可以用杂活来形容！不过这些杂活，为我营造了充足的学习时间的同时，却也让我后来的简历上难以写上一些有含金量的项目。</p><p>今年以来，我写了大概30多篇博客，有段时间几乎是一周两篇，就在公司用上班时间写！博客主要学习和整理一些Java基础、多线程并发编程系列的知识，以及整理一些我在实际项目中的一些需求的解决方案。除了博客，我还在GitHub整理了自己在公司使用的一些基础框架，然后自己搭建了一个spring cloud版本的脚手架：<a href="https://github.com/Fatezhang/scaffold-cloud" target="_blank" rel="noopener">Scaffold-Cloud</a>。还在幕布上整理了大篇幅的<a href="https://mubu.com/doc/hpBd1e5h6z" target="_blank" rel="noopener">Java学习大纲</a>和一些面试题目、Java知识点、阿里Java开发手册，不过到目前还没有整理完成，因为实在是太多了，Java基础、设计模式、数据结构与算法、分布式、数据库、计算机网络等等，一点点敲下来也是非常费时间的。</p><h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><p>说了这么多，你可能以为离职之后我找到了一个好工作。然而，在离职后的一周，我在某直聘APP上投递了几十家简历，在八月的最后一周，我面试了五家公司，包括一家仅有电话面试的公司。事实上在面试之前，我对自己还是很有自信的，毕竟学了半年，怎么着小公司的offer还是可以拿到手的，拿到小公司offer在开始投大公司，开启offer收割机模式。然而我的脸被现实狠狠的打肿了。我面试了鲸灵、大华、兑吧、涂鸦！现实告诉我：你就是个彩笔！还他么想拿大厂的offer？做梦去吧！</p><p>事实上，我在面试的时候基本上都能够回答的出来面试官的问题，尤其是多线程和一些分布式相关的问题，Java基础、JVM更是一直在我的复习范围。然而，当面试官问到一些实际项目遇到的问题以及自己是如何解决的，我就歇菜了。例如实际生产中是如何做性能调优的，实际项目中遇到了哪些问题，是如何解决的？我知道面试官是想考察我解决问题的思路，然而当我将自己工作中所做的全盘托出，换来的却是面试官的鄙视！因为实在是太没有技术含量了，而我自己也确实没有在实际生产中遇到一些比较棘手的问题。这一周的面试将我的信心打压到谷底。</p><h4 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h4><p>幸运的是，我在正式办好离职手续的最后一个礼拜，一个大学的时候进了西安一个比较好的外企的同学告诉我，他们公司招人，问我要不要试一下。在从同花顺离职的时候，也就是一年之前，我有尝试面试过这家公司，可惜在homework阶段由于代码没有写的很好被淘汰了。这次，我要求自己要做好充足的准备。</p><p>他们公司面试不像杭州这边的互联网公司，面试总爱问一些高并发、分布式等等只会出现在面试中而不会出现在实际工作中的问题（当然这种说法也很片面）。这个外企的面试流程是给出一道程序设计题，3天时间提交代码，审核代码的质量以及是否优雅的完成题目要求，然后二面针对所做的题目增加需求，考察应试者实际动手能力以及程序设计能力。三面针对项目经验、工作经验再进行一轮面试。</p><p>9月6日周五下午4:19，我收到了这家公司的offer，丰厚的报酬和福利，还有离家近的条件让我无法拒绝这样一个offer。再加上在杭州这边面试的不顺利，我决定回去了。在我最后一个面试——杭州涂鸦的时候，我清楚地记得涂鸦HR很明确的告诉我，公司加班严重，大小周。我想，这样的公司是我想要去为之奋斗的吗？不，对于公司来说，员工都只是公司的一颗颗的螺丝钉，都是可被替代的零件，为何要为这种血汗工厂去牺牲自己的生活，杭州的996相必在最近五年之内都会是这个城市程序员的梦魇，最让人无奈的是，有些人竟然真的认为自己是在为自己“奋斗”，殊不知他们是被压迫的社会底层的劳动者，忘记了曾经的“8小时工作制”是由一些多么向往自由的人反抗争取来的，真正宣传996“福报”的资本家已经赚足了钱退休了（写于2019年9月10日）。</p><h4 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h4><p>我在写这篇博客的时候，脑中不断地回忆起17年2月底来到杭州直到现在发生的种种事情。确实由那句话所说，很多年后回想起来，你什么时候准备考研、出国留学、工作、恋爱、结婚生子、跳槽，都有可能会是人生中的一个大的转折点，而自己当时还只是认为这些事只是人生中很小的一件事情。</p><p>从同花顺跳槽去杭州的第二家公司工作，是我这两年最后悔的事情。如果我当时不从同花顺走，或者说在同花顺能有一些好的工作体验，也许目前就是另一种状态了吧。原本我跳槽后的计划是，在新的公司将自己沉淀两三年，将技术提升上去，三年后跳槽去一线大公司，但是无奈公司连支持我待够两年都做不到。2019年，其实是我最抑郁，世界最黑暗的一年。这年来，在新的公司工作，公司发展不顺利，志同道合的朋友也渐少，以前几个老朋友从每周几次在一起吃饭、玩的状态突然就变成一个月都见不了一面。也许是他们也都有了自己的女朋友，有了自己的生活，顾不上我了吧。而我每周末都想出去玩，却找不到同行的伙伴。</p><p>在杭州的两年时间，我去了周边的很多地方，刚毕业那会也许想的是，我终于获得了自己想要的自由生活，工资也足以让我到处去旅游。我曾经想，自己家要是江浙沪这一带的该有多好，西安那边真的很落后，虽然城市中不太看得出差距，但是城市周边的市、县、村，却是西北那边怎么也追赶不上来的。而且我在这边能够接触到更新的东西，一些新兴的互联网产品都会在这一带优先投放，例如共享单车、共享充电宝、智慧城市服务等等。我想杭州应该会是最优先开始智能化、互联网化的城市之一吧。</p><p>可惜了，即将离开这里，放弃两年来在这边拥有的一切。我的朋友，还有我的生活。虽然很不想说再见，但是谁又能主导自己的命运呢。</p><p>杭州，有缘再见吧！</p><p><img src="/blog/20190909/其实我不想离开这里/mu.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190909/其实我不想离开这里/fm.png&quot; alt=&quot;杭州西湖&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(七)：Fork/Join框架原理及demo</title>
    <link href="http://zhangjiaheng.cn/blog/20190814/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%83-%EF%BC%9AFork-Join%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%8F%8Ademo/"/>
    <id>http://zhangjiaheng.cn/blog/20190814/并发编程学习-七-：Fork-Join框架原理及demo/</id>
    <published>2019-08-14T08:48:56.000Z</published>
    <updated>2019-11-01T01:40:48.237Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190814/并发编程学习-七-：Fork-Join框架原理及demo/fm.jpg" alt="fm.jpg"></p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Fork/Join框架是jdk1.7引入的一个基于“分治”思想的多线程框架。它的功能是将一个大任务切分(<strong>fork</strong>)成多个相同逻辑的小任务，分而治之，当子任务全都执行完成之后，将结果合并(<strong>join</strong>)起来，最终成为整体任务的执行结果。原理可以抽象成下图表示：</p><p><img src="/blog/20190814/并发编程学习-七-：Fork-Join框架原理及demo/fj.png" alt="Fork/Join"></p><h3 id="Fork-Join相关代码原理及思想"><a href="#Fork-Join相关代码原理及思想" class="headerlink" title="Fork/Join相关代码原理及思想"></a>Fork/Join相关代码原理及思想</h3><h6 id="Fork-Join执行步骤"><a href="#Fork-Join执行步骤" class="headerlink" title="Fork/Join执行步骤"></a>Fork/Join执行步骤</h6><ol><li><p>进行任务分割：将任务分割成小任务，然后这个小任务有可能还需要继续分割，直到足够小。</p></li><li><p>执行并合并结果：分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p></li></ol><p>Fork/Join使用两个类完成以上步骤：</p><ul><li><strong>ForkJoinTask</strong>：<ul><li>Fork/Join提供了两个子类：RecursiveAction：用于没有返回结果的任务；RecursiveTask ：用于有返回结果的任务</li></ul></li><li><strong>ForkJoinPool</strong> ：<code>public class ForkJoinPool extends AbstractExecutorService{ ... }</code>ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。这种算法成为<strong>工作窃取算法(work-stealing)</strong></li></ul><h6 id="工作窃取算法-work-stealing"><a href="#工作窃取算法-work-stealing" class="headerlink" title="工作窃取算法(work-stealing)"></a>工作窃取算法(work-stealing)</h6><ul><li><p>Fork/Join框架内部实现了一个类似于LinkedBlockingDeque的双端队列用作工作线程的任务队列<strong>WorkQueue</strong>。使用<code>ForkJoinWorkerThread</code>保存工作线程，<code>ForkJoinPool.WorkQueue</code>就在其内部。</p></li><li><p>Fork/Join每个工作线程在运行中产生了新的任务(通常是调用fork方法)的时候，将任务加入WorkQueue尾部，并且工作线程每次取出任务执行也是从队尾取出执行，即LIFO</p></li><li><p>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</p></li><li><p>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</p></li><li><p>在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</p></li></ul><h3 id="Fork-Join-demo演示"><a href="#Fork-Join-demo演示" class="headerlink" title="Fork/Join demo演示"></a>Fork/Join demo演示</h3><blockquote><p>使用Fork/Join完成大量有序数字的加和</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalculateTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADSHOLD = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyCalculateTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start = start;</span><br><span class="line">    <span class="keyword">this</span>.end = end;</span><br><span class="line">    <span class="keyword">this</span>.list = list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (end - start &lt; THREADSHOLD) &#123;</span><br><span class="line">      <span class="comment">// 当两数字之间差值小于指定值 就不再查分成小任务 </span></span><br><span class="line">      String so = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        so += list.get(i) + <span class="string">","</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"处理 "</span> + so + <span class="string">" 的数据"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 一分为二 拆分任务</span></span><br><span class="line">      <span class="keyword">final</span> MyCalculateTask left = <span class="keyword">new</span> MyCalculateTask(start, mid, list);</span><br><span class="line">      <span class="keyword">final</span> MyCalculateTask right = <span class="keyword">new</span> MyCalculateTask(mid, end, list);</span><br><span class="line">      left.fork();</span><br><span class="line">      right.fork();</span><br><span class="line">      sum += left.join();</span><br><span class="line">      sum += right.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">400</span>;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      list.add(<span class="string">"i-"</span> + i);</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    MyCalculateTask task = <span class="keyword">new</span> MyCalculateTask(<span class="number">0</span>, count, list);</span><br><span class="line">    <span class="keyword">final</span> ForkJoinTask&lt;Integer&gt; submit = pool.submit(task);</span><br><span class="line">    System.out.println(<span class="string">"sum = "</span> + sum + <span class="string">" --- submit.get() = "</span> + submit.get());</span><br><span class="line">    pool.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    pool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Fork/Join框架可以帮助我们完成很多这种大任务可以拆分成小任务执行的场景，不过上面的方法并不是最佳执行调用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left.fork();  </span><br><span class="line">right.fork();</span><br><span class="line">替换为</span><br><span class="line">invokeAll(left, right);</span><br></pre></td></tr></table></figure><p>因为对于Fork/Join模式，假如Pool里面线程数量是固定的，那么调用子任务的fork方法相当于A先分工给B，然后A当监工不干活，B去完成A交代的任务。所以上面的模式相当于浪费了一个线程。那么如果使用invokeAll相当于A分工给B后，A和B都去完成工作。这样可以更好的利用线程池，缩短执行的时间。</p><blockquote><p>参考：<a href="http://ifeve.com/talk-concurrency-forkjoin/" target="_blank" rel="noopener">http://ifeve.com/talk-concurrency-forkjoin/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190814/并发编程学习-七-：Fork-Join框架原理及demo/fm.jpg&quot; alt=&quot;fm.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Fork/Join框架" scheme="http://zhangjiaheng.cn/tags/Fork-Join%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ForkJoinPool" scheme="http://zhangjiaheng.cn/tags/ForkJoinPool/"/>
    
      <category term="线程池" scheme="http://zhangjiaheng.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】设计模式基本思想以及23种模式总结整理</title>
    <link href="http://zhangjiaheng.cn/blog/20190812/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8A23%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86/"/>
    <id>http://zhangjiaheng.cn/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/</id>
    <published>2019-08-12T03:47:54.000Z</published>
    <updated>2019-11-01T01:40:48.200Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/bz.png" alt="封面"></p><a id="more"></a><h3 id="设计模式主要思想"><a href="#设计模式主要思想" class="headerlink" title="设计模式主要思想"></a>设计模式主要思想</h3><p>设计模式是在长期应用开发过程中，众多开发者总结归纳出来的程序架构与设计思想。是经过实践证明的，可在实际背景下使用的一系列程序设计方案。设计模式产生的根本目的就是为了解决开发过程中重复的代码编写，以及让程序更易扩展复用。</p><h4 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h4><ul><li>单一职责：每个类都应该实现单一的功能，否则应该将类进行拆分</li><li>里氏替换：即继承复用/合成复用。尽量使用合成/聚合的方式而不是继承。任何父类出现的地方，子类都可以出现。派生类可以在基类的基础上扩展自己的功能实现。是对“开闭原则”的一个补充。在里氏替换原则中，尽量不要对父类进行重载或者重写，因为父类代表一个定义好的结构，通过规范好的接口与外界进行交互，子类不应该随意破坏它，而是对其进行扩展。</li><li>依赖倒置：“开闭原则”的基础。即面向接口编程。依赖于抽象而不是依赖于具体的实现，编程时遇到具体的类时，不与具体的类交互，而与抽象接口进行交互。便于增加新的具体类的时候代码可以复用。</li><li>接口隔离：每个接口不应该存在子类用不到却必须实现的方法，否则就应该将接口拆分，将职责单一化。</li><li>最少知道：即迪米特法则。一个类对于自己依赖的类知道的越少越好，无论被依赖的类多么复杂，都应该将逻辑封装在方法内部，通过一个共有的方法提供给依赖类使用，这样当被依赖类发生改变的时候，才会尽可能少的影响依赖类。</li></ul><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><blockquote><p>点击对应链接跳转到该设计模式的详细整理与代码示例</p></blockquote><table><thead><tr><th>范围</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>对象创建</td><td><a href="http://zhangjiaheng.cn/blog/20190607/%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B/">Singleton（单例模式）</a><br>Prototype(原型模式)<br>Factory Method（工厂方法模式）<br>Abstract Factory（抽象工厂模式）<br>Builder（建造者模式）</td><td></td><td></td></tr><tr><td>接口适配</td><td></td><td>Adapter（适配器模式）<br>Bridge（桥接模式）<br>Facade（外观模式）</td><td></td></tr><tr><td>对象解耦</td><td></td><td></td><td>Mediator（中介者模式）<br>Observer（观察者模式）</td></tr><tr><td>抽象集合</td><td></td><td>Composite（组合模式）</td><td>Iterator（迭代器模式）</td></tr><tr><td>行为扩展</td><td></td><td>Decorator（装饰模式）</td><td>Visitor（访问者模式）<br>Chain of Responsibility（职责链）</td></tr><tr><td>算法封装</td><td></td><td></td><td><a href="http://zhangjiaheng.cn/blog/20190707/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">Template（模板方法模式）</a><br>Strategy（策略模式）</td></tr><tr><td>性能与对象访问</td><td></td><td>Flyweight（享元模式）<br>Proxy（代理模式）</td><td></td></tr><tr><td>对象状态</td><td></td><td></td><td>Memento（备忘录模式）<br>State（状态模式）</td></tr><tr><td>其他</td><td></td><td></td><td>Interpreter（解释器模式）</td></tr></tbody></table><h4 id="总结下设计模式的归类"><a href="#总结下设计模式的归类" class="headerlink" title="总结下设计模式的归类"></a>总结下设计模式的归类</h4><p><img src="/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/sjmo.png" alt="设计模式分类 - 幕布"></p><h4 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h4><p>创建型设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，使调用者无需new对象，在程序中针对给定业务场景去调用特定的对象创建方法，使程序更加灵活。</p><h4 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h4><p>行为型设计模式主要关注对象之间的通信。</p><h4 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h4><p>结构型设计模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/bz.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式基本思想" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode - 52. N皇后 II 回溯算法求解</title>
    <link href="http://zhangjiaheng.cn/blog/20190809/Leetcode-52-N%E7%9A%87%E5%90%8E-II-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3/"/>
    <id>http://zhangjiaheng.cn/blog/20190809/Leetcode-52-N皇后-II-回溯算法求解/</id>
    <published>2019-08-09T10:19:50.000Z</published>
    <updated>2019-11-01T01:40:48.191Z</updated>
    
    <content type="html"><![CDATA[<h4 id="N皇后问题-leetcode"><a href="#N皇后问题-leetcode" class="headerlink" title="N皇后问题 - leetcode"></a>N皇后问题 - <a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">leetcode</a></h4><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<img src="/blog/20190809/Leetcode-52-N皇后-II-回溯算法求解/8-queens.png" alt="8皇后示例"><br>上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><p>输入: 4<br>输出: 2<br>解释: 4 皇后问题存在如下两个不同的解法。<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[".Q..",  // 解法 1</span><br><span class="line">"...Q",</span><br><span class="line">"Q...",</span><br><span class="line">"..Q."],</span><br><span class="line">["..Q.",  // 解法 2</span><br><span class="line">"Q...",</span><br><span class="line">"...Q",</span><br><span class="line">".Q.."]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>使用回溯算法，深度优先搜索，进行遍历查询深度优先搜索的条件是有能够判断棋盘是否能落子的依据。</p><p>我这边使用一个长度为N的数组存储第J列是否有棋子，使用两个N*2-1长度的数组分别存储左对角线和右对角线是否有棋子。</p><p>对于左右对角线来说，左对角线的每一个位置i与j的和都相同，右对角线的每一个位置的i与j的差都相同，所以可以用来判断某个位置的斜线上是否存在棋子，对应对角线的数组标志为有或者没有。</p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 总记录数 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/** N皇后 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">  <span class="comment">/** 判断当前位置的左对角线是否存放了棋子 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>];</span><br><span class="line">  <span class="comment">/** 判断当前位置的右对角线是否存放了棋子 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>];</span><br><span class="line">  <span class="comment">/** 判断当前位置的列是否存放了棋子 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] curn;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.N = n;</span><br><span class="line">    curn = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    left = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    right = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    calResult(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calResult</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 棋盘第i行 遍历判断第j列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">      <span class="comment">// 开始判断第i行第j列</span></span><br><span class="line">      <span class="comment">// 判断第j列是否已经有棋子；判断(i,j)的左对角线是否有棋子；判断右对角线是否有棋子</span></span><br><span class="line">      <span class="keyword">if</span> (curn[j] == <span class="number">0</span> &amp;&amp; left[i + j] == <span class="number">0</span> &amp;&amp; right[N - <span class="number">1</span> + i - j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有棋子 就可以在(i,j)放置棋子</span></span><br><span class="line">        curn[j] = left[i + j] = right[N - <span class="number">1</span> + i - j] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果N行都放置了棋子 total就加1 否则继续放置下一行</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; N - <span class="number">1</span>) &#123;</span><br><span class="line">          calResult(i + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放置完成之后 (i,j)位置棋子去掉，然后重新走下一步 进行深度优先搜索</span></span><br><span class="line">        curn[j] = left[i + j] = right[N - <span class="number">1</span> + i - j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    solution.totalNQueens(<span class="number">8</span>);</span><br><span class="line">    System.out.println(<span class="string">"total = "</span> + solution.total);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;N皇后问题-leetcode&quot;&gt;&lt;a href=&quot;#N皇后问题-leetcode&quot; class=&quot;headerlink&quot; title=&quot;N皇后问题 - leetcode&quot;&gt;&lt;/a&gt;N皇后问题 - &lt;a href=&quot;https://leetcode-cn.com/problems/n-queens-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;img src=&quot;/blog/20190809/Leetcode-52-N皇后-II-回溯算法求解/8-queens.png&quot; alt=&quot;8皇后示例&quot;&gt;&lt;br&gt;上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。&lt;/p&gt;
&lt;h4 id=&quot;示例：&quot;&gt;&lt;a href=&quot;#示例：&quot; class=&quot;headerlink&quot; title=&quot;示例：&quot;&gt;&lt;/a&gt;示例：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;输入: 4&lt;br&gt;输出: 2&lt;br&gt;解释: 4 皇后问题存在如下两个不同的解法。&lt;br&gt;&lt;figure class=&quot;highlight md&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&quot;.Q..&quot;,  // 解法 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;...Q&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;Q...&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;..Q.&quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&quot;..Q.&quot;,  // 解法 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;Q...&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;...Q&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;.Q..&quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode上的几个多线程编程题解</title>
    <link href="http://zhangjiaheng.cn/blog/20190724/LeetCode%E4%B8%8A%E7%9A%84%E5%87%A0%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    <id>http://zhangjiaheng.cn/blog/20190724/LeetCode上的几个多线程编程题解/</id>
    <published>2019-07-24T07:16:20.000Z</published>
    <updated>2019-11-01T01:40:48.187Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190724/LeetCode上的几个多线程编程题解/fm.png" alt></p><a id="more"></a><h3 id="以下所有题目的题解-github"><a href="#以下所有题目的题解-github" class="headerlink" title="以下所有题目的题解 - github"></a><a href="https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/src/main/java/Alogrithm/Alogrithm" target="_blank" rel="noopener">以下所有题目的题解 - github</a></h3><h4 id="1、按序打印"><a href="#1、按序打印" class="headerlink" title="1、按序打印"></a>1、<a href="https://leetcode-cn.com/problems/print-in-order" target="_blank" rel="noopener">按序打印</a></h4><ul><li>方法一：使用volatile变量控制顺序</li><li>思路：利用volatile语义，实现变量的内存可见性，使得别的线程在修改完state状态变量的时候结果对于另一个线程立即可见。这样每个线程在打印的时候就可以通过状态判断是不是该轮到自己执行了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (state != <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst.run();</span><br><span class="line">        state = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (state != <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond.run();</span><br><span class="line">        state = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (state != <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird.run();</span><br><span class="line">        state = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：使用CountDownLatch控制顺序（只适用于执行一次。。。可以使用循环栅栏改一下~）</li><li>CountDownLatch俗称“闭锁”。使用闭锁来控制线程是否该执行，在没有达到条件时，闭锁阻塞线程。这样在第一个线程执行完成之后打开第二个线程的闭锁，第二个执行完成之后打开第三个线程的闭锁，实现按照顺序打印。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch3 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst.run();</span><br><span class="line">        countDownLatch2.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond.run();</span><br><span class="line">        countDownLatch3.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、交替打印FooBar"><a href="#2、交替打印FooBar" class="headerlink" title="2、交替打印FooBar"></a>2、<a href="https://leetcode-cn.com/problems/print-foobar-alternately" target="_blank" rel="noopener">交替打印FooBar</a></h4><ul><li>思路：使用显示可重入锁加上Condition条件阻塞机制，再加上volatile修饰的状态变量控制打印顺序。线程打印时加锁，如果状态是使当前线程打印，就打印并且转换状态，然后唤醒另一个线程。下一次再判断当前状态不适合打印，就使用第一个条件锁阻塞当前线程。以此类推。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> 交替打印FooBar */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printFoo.run() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">            printFoo.run();</span><br><span class="line">            flag = !flag;</span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printBar.run() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">            printBar.run();</span><br><span class="line">            flag = !flag;</span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、打印0与奇偶数"><a href="#3、打印0与奇偶数" class="headerlink" title="3、打印0与奇偶数"></a>3、<a href="https://leetcode-cn.com/problems/print-zero-even-odd" target="_blank" rel="noopener">打印0与奇偶数</a></h4><ul><li>思路：也是使用显示可重入锁加上条件阻塞机制，加上volatile修饰的状态变量控制奇偶数的打印。不符合当前执行的状态就使用condition阻塞，符合就执行并且转换状态，然后唤醒其他线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> https://leetcode-cn.com/problems/print-zero-even-odd</span></span><br><span class="line"><span class="comment"> * 3个线程交替打印奇偶数和0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 0-打印0 1-打印奇数 2-打印偶数 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">          c1.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">          flag = <span class="number">1</span>;</span><br><span class="line">          c3.signal();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          flag = <span class="number">2</span>;</span><br><span class="line">          c2.signal();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">          c2.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        c1.signal();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">          c3.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        c1.signal();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ZeroEvenOdd zeroEvenOdd = <span class="keyword">new</span> ZeroEvenOdd(<span class="number">5</span>);</span><br><span class="line">    ThreadPoolExecutor pools =</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), r -&gt; <span class="keyword">new</span> Thread(r, <span class="string">"某线程"</span>));</span><br><span class="line">    pools.execute(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.zero(System.out::print);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    pools.execute(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.even(System.out::print);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    pools.execute(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.odd(System.out::print);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、H2O生成"><a href="#4、H2O生成" class="headerlink" title="4、H2O生成"></a>4、<a href="https://leetcode-cn.com/problems/building-h2o" target="_blank" rel="noopener">H2O生成</a></h4><ul><li>方法一：使用显示锁和condition</li><li>思路：老生常谈的思路了，同上面一样的原理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> 水分子生成 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition H = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition O = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">while</span> (hCount == <span class="number">2</span>) &#123;</span><br><span class="line">        H.await();</span><br><span class="line">      &#125;</span><br><span class="line">      hCount++;</span><br><span class="line">      releaseHydrogen.run();</span><br><span class="line">      <span class="keyword">if</span> (hCount == <span class="number">2</span>) &#123;</span><br><span class="line">        O.signal();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        H.signal();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">while</span> (hCount != <span class="number">2</span>) &#123;</span><br><span class="line">        O.await();</span><br><span class="line">      &#125;</span><br><span class="line">      hCount = <span class="number">0</span>;</span><br><span class="line">      releaseOxygen.run();</span><br><span class="line">      H.signal();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"HHOOOHHHH"</span>;</span><br><span class="line">    <span class="keyword">final</span> H2O o = <span class="keyword">new</span> H2O();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">'H'</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    o.hydrogen(() -&gt; System.out.print(<span class="string">"H"</span>));</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            .start();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    o.oxygen(() -&gt; System.out.print(<span class="string">"O"</span>));</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            .start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：使用信号量控制通知线程</li><li>思路：使用信号量控制线程间的通信。分别分为执行信号和唤醒信号，氢原子的执行信号首先为2，氧原子的执行信号首先为1。氢氧线程执行时消耗执行信号量，当一个氢原子执行后，氢原子的释放信号开始释放（只有一个氧线程等待其释放），然后等待氧原子释放信号释放（即一个氧原子已经产生），之后产生一个氢原子在释放请求信号。氧线程执行时，开始请求释放一个氧原子，成功之后氧线程释放信号开始释放（因为2个氢线程等待所以释放两个信号），然后等待氢线程释放两个信号（说明已经有两个氢原子生成）。然后再生成氧原子，成功之后在释放氧线程的请求信号。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> 使用信号量控制水分子生成 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2O_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Semaphore hAcquire, oAcquire, hRelease, oRelease;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">H2O_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// H 原子线程 请求信号</span></span><br><span class="line">    hAcquire = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// O 原子线程 请求信号</span></span><br><span class="line">    oAcquire = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// H 原子线程 释放信号</span></span><br><span class="line">    hRelease = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// O 原子线程 释放信号</span></span><br><span class="line">    oRelease = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    hAcquire.acquire(); <span class="comment">// H线程开始请求</span></span><br><span class="line">    hRelease.release(); <span class="comment">// 通知一个H线程即将释放 因为一个H线程释放最多只有一个O线程等待其释放</span></span><br><span class="line">    oRelease.acquire(); <span class="comment">// 等待O线程释放 一个O线程释放就可以通过</span></span><br><span class="line">    releaseHydrogen.run();</span><br><span class="line">    hAcquire.release(); <span class="comment">// 唤醒H线程请求</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    oAcquire.acquire(); <span class="comment">// O线程开始请求</span></span><br><span class="line">    oRelease.release(<span class="number">2</span>); <span class="comment">// 通知一个O线程即将释放 因为一个O线程释放 会有两个H线程等待其释放</span></span><br><span class="line">    hRelease.acquire(<span class="number">2</span>); <span class="comment">// 等待H线程释放 要等待两次释放 才可以通过</span></span><br><span class="line">    releaseOxygen.run();</span><br><span class="line">    oAcquire.release(); <span class="comment">// 唤醒O线程请求</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHOOHHOOOOOHOOOHHHOHHHHOOOHHHOOOHOHOHOHHOHOOHHHOOHOOOHHOOOOHOHHHHOOOOOHHHOOOHOHOHOOOHHOHOOHHOHHHHHHHHHHHHHHHHHHHHHHHHHHH"</span>;</span><br><span class="line">    <span class="keyword">final</span> H2O_2 o = <span class="keyword">new</span> H2O_2();</span><br><span class="line">    ThreadPoolExecutor pool =</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">300</span>,</span><br><span class="line">            <span class="number">300</span>,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>),</span><br><span class="line">                (ThreadFactory) Thread::<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">'H'</span>) &#123;</span><br><span class="line">        pool.execute(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                o.hydrogen(() -&gt; System.out.print(<span class="string">"H"</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pool.execute(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                o.oxygen(() -&gt; System.out.print(<span class="string">"O"</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190724/LeetCode上的几个多线程编程题解/fm.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized使用时一个不起眼的注意点</title>
    <link href="http://zhangjiaheng.cn/blog/20190716/Synchronized%E4%BD%BF%E7%94%A8%E6%97%B6%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%B5%B7%E7%9C%BC%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://zhangjiaheng.cn/blog/20190716/Synchronized使用时一个不起眼的注意点/</id>
    <published>2019-07-16T09:12:47.000Z</published>
    <updated>2019-11-01T01:40:48.191Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Synchronized-前情提要"><a href="#Synchronized-前情提要" class="headerlink" title="Synchronized 前情提要"></a>Synchronized 前情提要</h4><p>Synchronized是Java中用来进行方法或者代码同步的一个内置锁机制。这种内置锁机制可以保证代码执行的原子性、可见性，但是并不能屏蔽代码的重排序。Synchronized可以修饰方法、对象以及代码块，并可以保证被修饰的方法或者代码块，在同一个时刻只能有一个线程能够访问得到。</p><ul><li>修饰静态方法：锁的是当前类的class对象，修饰方法时Synchronized没有表现在字节码指令中，而是在class文件的方法表中将该方法的access_flags值置为1。表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象。</li><li>修饰普通方法：锁的是当前实例对象，修饰方法时同上。</li><li>修饰代码块：锁的是Synchronized()中的对象，编译后的字节码会在代码块前后插入monitorenter 和monitorexit。JVM需要每一个monitorenter都有一个monitorexit与之对应，任何对象都有一个monitor与之相对应，当一个monitor被持有，即线程执行到monitorenter时，对象将处于锁定状态。</li></ul><p>Synchronized是Java内置的重量级锁，在jdk1.6之后引入了自旋锁、轻量级锁、适应性自旋、锁粗化、锁消除、偏向锁等技术来减少Synchronized的性能开销。</p><a id="more"></a><h4 id="切入正题"><a href="#切入正题" class="headerlink" title="切入正题"></a>切入正题</h4><p>以上知识点想必刚开始学习并发编程的程序员都会先学习以上知识，但是很多程序员在使用Synchronized的时候有可能会发现，我明明加锁了，但是方法却并没有同步执行，这到底是什么原因？先看下如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer cn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (cn) &#123;</span><br><span class="line">                        cn++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码启动了20个线程，对Integer变量cn进行自增。很多人在写Synchronized的时候都有可能出现这种问题。这样的写法是错误的！</p><p>因为<code>cn++</code>这句代码的原理是将cn指向一个cn+1的新的Integer对象！</p><p>修改成如下，然后看看输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer cn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cd = <span class="keyword">new</span> CountDownLatch(size);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalJ = j;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cd.countDown();</span><br><span class="line">                    cd.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (cn) &#123;</span><br><span class="line">                        cn++;</span><br><span class="line">                        System.out.println(</span><br><span class="line">                            <span class="string">"cn"</span> + finalJ + <span class="string">" = "</span> + cn + <span class="string">"\t\t\t"</span> + System.identityHashCode(cn));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上代码输出如下 &gt;&gt;</strong></p><p><img src="/blog/20190716/Synchronized使用时一个不起眼的注意点/cons.png" alt="输出"></p><p>每次输出的Integer对象的HashCode值并不相同。所以，每次锁的并不是同一个对象！既然不是同一个对象，那么这个方法在多线程访问的时候肯定就不是线程安全的！对于如上这种例子我们当然可以使用原子变量<code>AtomicInteger</code>来实现更高级的同步机制去解决这个问题，但是其他场景下呢？</p><p>不仅仅是Integer对象哦！所有的对象都有可能会有这些问题存在！当你在锁这个对象的时候，一定要保证加锁的对象在线程中不被修改成另一个对象！否则就是一个<strong>假的</strong>同步代码块！</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Synchronized-前情提要&quot;&gt;&lt;a href=&quot;#Synchronized-前情提要&quot; class=&quot;headerlink&quot; title=&quot;Synchronized 前情提要&quot;&gt;&lt;/a&gt;Synchronized 前情提要&lt;/h4&gt;&lt;p&gt;Synchronized是Java中用来进行方法或者代码同步的一个内置锁机制。这种内置锁机制可以保证代码执行的原子性、可见性，但是并不能屏蔽代码的重排序。Synchronized可以修饰方法、对象以及代码块，并可以保证被修饰的方法或者代码块，在同一个时刻只能有一个线程能够访问得到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修饰静态方法：锁的是当前类的class对象，修饰方法时Synchronized没有表现在字节码指令中，而是在class文件的方法表中将该方法的access_flags值置为1。表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象。&lt;/li&gt;
&lt;li&gt;修饰普通方法：锁的是当前实例对象，修饰方法时同上。&lt;/li&gt;
&lt;li&gt;修饰代码块：锁的是Synchronized()中的对象，编译后的字节码会在代码块前后插入monitorenter 和monitorexit。JVM需要每一个monitorenter都有一个monitorexit与之对应，任何对象都有一个monitor与之相对应，当一个monitor被持有，即线程执行到monitorenter时，对象将处于锁定状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Synchronized是Java内置的重量级锁，在jdk1.6之后引入了自旋锁、轻量级锁、适应性自旋、锁粗化、锁消除、偏向锁等技术来减少Synchronized的性能开销。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Synchronized" scheme="http://zhangjiaheng.cn/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>一个[合格]的程序员必须具备的工具和插件</title>
    <link href="http://zhangjiaheng.cn/blog/20190714/%E4%B8%80%E4%B8%AA-%E5%90%88%E6%A0%BC-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E5%85%B7%E5%A4%87%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6/"/>
    <id>http://zhangjiaheng.cn/blog/20190714/一个-合格-的程序员必须具备的工具和插件/</id>
    <published>2019-07-14T13:38:04.000Z</published>
    <updated>2019-11-01T01:40:48.205Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/gtx.jpg" alt="封面"><br><a id="more"></a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><strong>如题… 是我标题党了，应该这样讲：“合格的程序员”不一定需要会使用哪些工具，但是会使用那些能够有效减少自己工作量的很酷的工具和插件的程序员一定会进步成一个“合格的程序员”。因为他们善于思考，并能够将繁杂的重复性工作交给工具去完成，将精力集中在核心的编码任务上。</strong></p><h4 id="逐个介绍那些我自己常用的工具、插件或者网站"><a href="#逐个介绍那些我自己常用的工具、插件或者网站" class="headerlink" title="逐个介绍那些我自己常用的工具、插件或者网站"></a>逐个介绍那些我自己常用的工具、插件或者网站</h4><h5 id="Ghelper"><a href="#Ghelper" class="headerlink" title="Ghelper"></a><a href="http://googlehelper.net/" target="_blank" rel="noopener">Ghelper</a></h5><p>说到工具，不会翻墙用啥子工具。Ghelper是一个谷歌浏览器插件，直接下载安装到chrome扩展即可轻松访问谷歌等服务！注意，访问谷歌的相关服务是免费的哦！如果你有需求访问其他的例如YouTuBe、Twitter之类的，可以购买会员服务！这里还有一个谷歌访问助手破解版，我没有试过，有兴趣可以装一下看看：<a href="https://github.com/haotian-wang/google-access-helper" target="_blank" rel="noopener">GHelper破解版</a><br>这个工具可以说是以下大部分工具的基础。</p><h5 id="FeHelper"><a href="#FeHelper" class="headerlink" title="FeHelper"></a><a href="https://www.baidufe.com/fehelper/feedback.html" target="_blank" rel="noopener">FeHelper</a></h5><p>FeHelper是一个在谷歌浏览器上我最常用的一个插件。功能如下，字符串编解码、JSON格式化、时间戳转换等等工具，在做web开发的时候查看某个JSON数据格式是否正确直接黏贴到这个框里就OK，简单暴力~</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/feh.png" alt="FeHelper"></p><h5 id="油猴儿"><a href="#油猴儿" class="headerlink" title="油猴儿"></a><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">油猴儿</a></h5><p>大名鼎鼎的油猴儿想必很多程序员都了解以及用过吧(没用过别告诉我你是个程序员，死敲代码的)。</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/yh.png" alt="油猴儿"></p><p>如上图就是我的一些油猴儿插件的已安装的一部分脚本的截图。例如看各大视频网站，不想要买VIP去看，那么直接安装一个VIP视频破解脚本；或者百度网盘，拒绝启动客户端下载文件，安装个油猴脚本直接直链下载！</p><p>油猴儿在我看来就是一个浏览器脚本的容器，网上极客众多，你可以找得到任何自己感兴趣的想要安装的插件去完成自己要做的事情。</p><p>油猴儿的安装：<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">谷歌应用商店 - 油猴儿</a>，安装完成之后你就可以找到任何你想要的脚本装在油猴儿里面啦！</p><p>这边，我只告诉大家一个终极脚本：<a href="https://greasyfork.org/zh-CN/scripts/24508-userscript-show-site-all-userjs" target="_blank" rel="noopener">UserScript+</a>。为啥叫它终极脚本。。。因为安装上它之后，当你打开任何网站，他都会提示你这个网站可以安装的脚本有哪些，这样你就不用在茫茫大海中去寻找自己需要的那些脚本了。</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/jb.png" alt="掘金油猴儿脚本"></p><p>可以想象，有了这个之后，面向百度编程的程序员是不是不用再被眼花缭乱的广告所骚扰！喜欢使用掘金的程序员也可以设置自己喜欢的页面排版~ 经常水V2EX的程序员也可以在评论区盖楼了！！哈哈想想就刺激呢！</p><h5 id="云盘精灵"><a href="#云盘精灵" class="headerlink" title="云盘精灵"></a><a href="https://www.yunpanjingling.com/" target="_blank" rel="noopener">云盘精灵</a></h5><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/ypjl.png" alt="云盘精灵"></p><p>云盘精灵是一个下载百度网盘资源的神奇的网站，在这里你几乎可以找到任何您想要的资源去下载。然鹅，需要注册然后使用豆子购买。不过这也是理所应当的，毕竟知识付费的天下。但是需要付的并不多，而且你还可以将你自己的资源分享到云盘精灵，有人下载你也会赚取到相应的豆子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190714/一个-合格-的程序员必须具备的工具和插件/gtx.jpg&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>将阿里Java编码规范敲成思维导图</title>
    <link href="http://zhangjiaheng.cn/blog/20190714/%E5%B0%86%E9%98%BF%E9%87%8CJava%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B2%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://zhangjiaheng.cn/blog/20190714/将阿里Java编码规范敲成思维导图/</id>
    <published>2019-07-14T03:12:01.000Z</published>
    <updated>2019-11-01T01:40:48.223Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/fm.png" alt="阿里Java编码规范"></p><p><center>阿里Java编码规范</center><br><a id="more"></a></p><p><center></center></p><p><center><a href="https://mubu.com/doc/CuUSIfxtSz" target="_blank" rel="noopener">可以点击这里查看分享的笔记</a></center></p><p><center></center></p><p><center></center></p><p><center>或者扫描如下二维码获取我分享的《阿里Java开发手册-幕布版》</center><br><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/qrcode.png" alt></p><p><center></center></p><p><center></center></p><h2 id><a href="#" class="headerlink" title></a><center></center></h2><p><center>最后，思维导图效果如下，密集恐惧症慎入~~</center></p><p><center>查看清晰完整的效果请去幕布笔记，点击查看思维导图即可</center><br><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/阿里Java编码规范.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190714/将阿里Java编码规范敲成思维导图/fm.png&quot; alt=&quot;阿里Java编码规范&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;阿里Java编码规范&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】模板方法模式</title>
    <link href="http://zhangjiaheng.cn/blog/20190707/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhangjiaheng.cn/blog/20190707/【设计模式】模板方法模式/</id>
    <published>2019-07-07T02:32:44.000Z</published>
    <updated>2019-11-01T01:40:48.196Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190707/【设计模式】模板方法模式/fm.png" alt="封面"><br><a id="more"></a></p><h4 id="什么是模板方法模式"><a href="#什么是模板方法模式" class="headerlink" title="什么是模板方法模式"></a>什么是模板方法模式</h4><p>在计算机程序中，为了将一些具有不同实现但有相同执行步骤的类统一起来，通常我们将这些类抽象成一个模板类。模板类定义了一个算法的框架，使得子类可以不改变算法的结构而去对一些细节实现进行重新定义。</p><h4 id="模板方法模式的核心要素"><a href="#模板方法模式的核心要素" class="headerlink" title="模板方法模式的核心要素"></a>模板方法模式的核心要素</h4><h5 id="抽象模板"><a href="#抽象模板" class="headerlink" title="抽象模板"></a>抽象模板</h5><p>抽象模板中定义了两种方法：需要子类去实现的基本方法，以及固定的不需要子类去实现的具体算法步骤的模板方法。基本方法在模板方法中被调用，模板方法一般会是一个具体的算法框架，调度基本方法完成所有功能。</p><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>子类具体实现抽象模板中的基本方法，完成对框架中的算法细节进行重新定义。</p><h4 id="我在实际项目中使用的案例"><a href="#我在实际项目中使用的案例" class="headerlink" title="我在实际项目中使用的案例"></a>我在实际项目中使用的案例</h4><p>在做某个按需查询不同类别的用户，并将其上传到OSS上，每日发邮件告诉运营人员结果的一个需求的时候，我就用到了模板方法模式。<br>首先定义一个抽象模板，分别有查询用户(每天都不同的SQL)，上传到OSS，发邮件等几个步骤，即基本方法。在模板方法中将这几个步骤封装起来。定义7个子类分别对每天不同的查询、上传、邮件做具体的实现。最后根据策略模式，不同的星期调用不同的对象的模板方法完成核心功能。</p><h4 id="模板方法模式代码示例"><a href="#模板方法模式代码示例" class="headerlink" title="模板方法模式代码示例"></a>模板方法模式代码示例</h4><p>如图，有个做饭的抽象模板：定义了[洗菜-炒菜-完成]三个步骤为基本方法，一个<code>ComplateCook</code>方法完成步骤的组装</p><p><img src="/blog/20190707/【设计模式】模板方法模式/bb.png" alt="抽象模板"></p><p>一个西红柿炒蛋的实现类</p><p><img src="/blog/20190707/【设计模式】模板方法模式/z1.png" alt="子类1"></p><p>一个鱼香肉丝的实现类</p><p><img src="/blog/20190707/【设计模式】模板方法模式/z2.png" alt="子类2"></p><p><strong>具体代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CookTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义步骤为抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ComplateCook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始做菜～"</span>);</span><br><span class="line">        wash();</span><br><span class="line">        cook();</span><br><span class="line">        finish();</span><br><span class="line">        System.out.println(<span class="string">"完成做菜步骤～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XihongshiChaoEgg</span> <span class="keyword">extends</span> <span class="title">CookTemplate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"切西红柿，准备鸡蛋～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"炒鸡蛋，然后再炒西红柿～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"西红柿炒蛋做好了，出锅～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YuXiangRose</span> <span class="keyword">extends</span> <span class="title">CookTemplate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"洗胡萝卜～"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切肉丝～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始做鱼香肉丝～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鱼香肉丝做好了 出锅～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CookTemplate cook = <span class="keyword">new</span> XihongshiChaoEgg();</span><br><span class="line">        cook.ComplateCook();</span><br><span class="line">        cook = <span class="keyword">new</span> YuXiangRose();</span><br><span class="line">        cook.ComplateCook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h4><ul><li><p>优点</p><ul><li>封装了不可变的部分，扩展可变部分</li><li>提供公共代码，便于维护</li><li>具体行为父类控制，子类只管自己的细节实现，符合开闭原则</li></ul></li><li><p>缺点</p><ul><li>一个不同的实现都要增加一个子类，会导致代码量很庞大</li><li>父类的执行结果会受到子类的影响，在复杂代码的阅读中会给开发人员带来很多麻烦</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>模板方法模式适用于：有一个固定的算法步骤，但是细节实现存在多种可能的场景，即整体稳定但是个别易变的时候讲会变化的那一部分抽象出来。<br>模板方法模式强调抽象类与子类之间的协作，它将调用权交给父类，是一种控制反转的设计理念。子类不再去完成核心的功能，只需要关注属于自己的那一部分的实现。</p><hr><ul><li>JDK中经典的模板方法模式实现：<strong>AQS</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190707/【设计模式】模板方法模式/fm.png&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="模板方法模式模式" scheme="http://zhangjiaheng.cn/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(六)：Exchanger的学习及使用场景</title>
    <link href="http://zhangjiaheng.cn/blog/20190701/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%85%AD-%EF%BC%9AExchanger%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://zhangjiaheng.cn/blog/20190701/并发编程学习-六-：Exchanger的学习及使用场景/</id>
    <published>2019-07-01T13:28:39.000Z</published>
    <updated>2019-11-01T01:40:48.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在JUC包中，除了一些常用的或者说常见的并发工具类(ReentrantLock，CountDownLatch，CyclicBarrier，Semaphore)等，还有一个不常用的线程同步器类 —— Exchanger。<br></p><p>Exchanger是适用在两个线程之间数据交换的并发工具类，它的作用是找到一个同步点，当两个线程都执行到了同步点(<strong>exchange方法</strong>)之后(<em>有一个没有执行到就一直等待，也可以设置等待超时时间</em>)，就将自身线程的数据与对方交换。</p><a id="more"></a><p><div style="text-align: center" center><a href="javascript:" target="_blank" rel="noopener">Exchanger工具类UML</a></div><br><img src="/blog/20190701/并发编程学习-六-：Exchanger的学习及使用场景/exc.png" alt="UML"></p><h4 id="Exchanger类结构"><a href="#Exchanger类结构" class="headerlink" title="Exchanger类结构"></a>Exchanger类结构</h4><p>如上图UNML，Exchanger类中有两个内部类，一个Node，一个Participant。</p><p>Participant继承了ThreadLocal并且重写了其initialValue方法，返回一个Node对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The corresponding thread local class */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node类封装了两个线程存储的数据对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes hold partially exchanged data, plus other per-thread</span></span><br><span class="line"><span class="comment"> * bookkeeping. Padded via <span class="doctag">@sun</span>.misc.Contended to reduce memory</span></span><br><span class="line"><span class="comment"> * contention.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">//  node 在 arena 数组下标</span></span><br><span class="line">    <span class="keyword">int</span> bound;              <span class="comment">//  交换器的最后记录值 </span></span><br><span class="line">    <span class="keyword">int</span> collides;           <span class="comment">//  记录的 CAS 失败数</span></span><br><span class="line">    <span class="keyword">int</span> hash;               <span class="comment">//  伪随机的自旋数</span></span><br><span class="line">    Object item;            <span class="comment">//  这个线程的数据项</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match;  <span class="comment">//  另一个线程的数据项</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked; <span class="comment">//  当阻塞时，设置此线程，不阻塞的话会自旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exchanger源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x; <span class="comment">// translate null args</span></span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> || <span class="comment">// 是null就执行后面的方法</span></span><br><span class="line">         (v = slotExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        <span class="comment">// 如果执行slotExchange有结果就执行后面的，否则返回</span></span><br><span class="line">        ((Thread.interrupted() || <span class="comment">// 非中断则执行后面的方法</span></span><br><span class="line">          (v = arenaExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exchange</code>方法的步骤：</p><ul><li>如果执行slotExchange有结果就执行后面的arenaExchange</li><li>如果solt被占用，就执行arenaExchange</li><li>返回的数据v是对方线程的数据项</li><li>总结即：如果A线程先调用，那么A的数据项存储的item中</li><li>则B线程的数据项存储在match中</li><li>当没有多线程并发操作 Exchange 的时候，使用 slotExchange 就足够了。 slot 是一个 node 对象。</li><li>当出现并发了，一个 slot 就不够了，就需要使用一个 node 数组 arena 操作了。</li></ul><p>​    </p><h4 id="Exchanger的使用"><a href="#Exchanger的使用" class="headerlink" title="Exchanger的使用"></a>Exchanger的使用</h4><p>下面的例子模拟一个队列中数据的交换使用的场景：</p><ul><li>线程A往队列中存入数据</li><li>线程B从队列中消耗数据</li><li>当线程A存满的时候</li><li>才交换给线程B</li><li>当线程B消耗完成之后才交换给线程A。</li><li>线程A、B的生产和消耗的速率有可能不同</li><li>对方线程调用exchange之前，另一个线程执行到exchange会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在对方线程调用exchange之前，另一个线程执行到exchange会阻塞 直到双方都调用exchange */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerStudy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;String&gt; initialFillQueue </span><br><span class="line">      = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;String&gt; initialEmptyQueue </span><br><span class="line">      = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Exchanger&lt;ArrayBlockingQueue&lt;String&gt;&gt; exchanger </span><br><span class="line">      = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 填充缓存队列的线程 */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ArrayBlockingQueue&lt;String&gt; current = initialEmptyQueue;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String str = StrUtil.uuid();</span><br><span class="line">          System.out.println(<span class="string">"生产了一个序列："</span> + str + <span class="string">"&gt;&gt;&gt;&gt;&gt;加入到交换区"</span>);</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            current.add(str);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已满，换一个空的"</span>);</span><br><span class="line">            current = exchanger.exchange(current);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 填充缓存队列的线程 */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ArrayBlockingQueue&lt;String&gt; current = initialFillQueue;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!current.isEmpty()) &#123;</span><br><span class="line">            String str = current.poll();</span><br><span class="line">            System.out.println(<span class="string">"消耗一个数列："</span> + str);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列空了，换个满的"</span>);</span><br><span class="line">            current = exchanger.exchange(current);</span><br><span class="line">            System.out.println(<span class="string">"换满的成功~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> FillingRunnable()).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> EmptyingRunnable()).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><a href="https://juejin.im/post/5ae7554ff265da0b86360880" target="_blank" rel="noopener">&gt;&gt;&gt;&gt;&gt; 更详细的源码解析 - 掘金</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/16317a536c642f7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="结尾"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在JUC包中，除了一些常用的或者说常见的并发工具类(ReentrantLock，CountDownLatch，CyclicBarrier，Semaphore)等，还有一个不常用的线程同步器类 —— Exchanger。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Exchanger是适用在两个线程之间数据交换的并发工具类，它的作用是找到一个同步点，当两个线程都执行到了同步点(&lt;strong&gt;exchange方法&lt;/strong&gt;)之后(&lt;em&gt;有一个没有执行到就一直等待，也可以设置等待超时时间&lt;/em&gt;)，就将自身线程的数据与对方交换。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Exchanger" scheme="http://zhangjiaheng.cn/tags/Exchanger/"/>
    
      <category term="线程交换器" scheme="http://zhangjiaheng.cn/tags/%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%8D%A2%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(五)：Semaphore源码学习及使用案例</title>
    <link href="http://zhangjiaheng.cn/blog/20190623/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%94-%EF%BC%9ASemaphore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>http://zhangjiaheng.cn/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/</id>
    <published>2019-06-23T12:27:19.000Z</published>
    <updated>2019-11-01T01:40:48.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/fm.png" alt></p><a id="more"></a><h3 id="Semaphore同步工具类之信号量介绍"><a href="#Semaphore同步工具类之信号量介绍" class="headerlink" title="Semaphore同步工具类之信号量介绍"></a>Semaphore同步工具类之信号量介绍</h3><h4 id="什么是Semaphore"><a href="#什么是Semaphore" class="headerlink" title="什么是Semaphore"></a>什么是Semaphore</h4><ul><li>Semaphore是JUC包中的一个很简单的工具类，用来实现多线程下对于资源的同一时刻的访问线程数限制</li><li>Semaphore中存在一个【许可】的概念，即访问资源之前，先要获得许可，如果当前许可数量为0，那么线程阻塞，直到获得许可</li><li>Semaphore内部使用AQS实现，由抽象内部类Sync继承了AQS。因为Semaphore天生就是共享的场景，所以其内部实际上类似于共享锁的实现。</li><li>Semaphore机制是提供给线程抢占式获取许可，所以他可以实现公平或者非公平，类似于ReentrantLock。</li><li>Semaphore提供两个构造方法，用来传入许可数量以及公平或者非公平：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Semaphore的使用场景"><a href="#Semaphore的使用场景" class="headerlink" title="Semaphore的使用场景"></a>Semaphore的使用场景</h4><ul><li>限流：并发环境(例如有1000个线程)下只允许100个线程访问数据库某资源</li><li>亦例如实际的，停车场只有10个车位，目前有15个汽车要来停车，多出的5个需要等其他车辆离开之后才能进行停车</li></ul><h3 id="Semaphore源码解读"><a href="#Semaphore源码解读" class="headerlink" title="Semaphore源码解读"></a>Semaphore源码解读</h3><p>分为公平与非公平</p><h4 id="获取许可的非公平的实现"><a href="#获取许可的非公平的实现" class="headerlink" title="获取许可的非公平的实现"></a>获取许可的非公平的实现</h4><p>在抽象类Sync中实现了非公平的消耗“许可”的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">        compareAndSetState(available, remaining))</span><br><span class="line">        <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>首先获取当前许可数量</p></li><li><p>判断消耗许可之后的剩余数量是否&gt;=0</p></li><li><p>是的话执行<code>compareAndSetState(available, remaining)</code>设置许可之后返回</p></li><li><p>否则返回的负数会使得其在<code>doAcquireSharedInterruptibly</code>中等待许可并挂起，直到被唤醒(这步骤在AQS中实现，如下)</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//如果线程被中断了，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//获取许可失败，将线程加入到等待队列中</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取许可的公平实现"><a href="#获取许可的公平实现" class="headerlink" title="获取许可的公平实现"></a>获取许可的公平实现</h4><p>首先会在获取许可之前，判断<code>hasQueuedPredecessors()</code>，是否有线程在等待队列中等待许可，有的话直接返回-1，这个底层实现在AQS中已经实现好了。接下来剩下的操作就和非公平的基本一致了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 判断头节点不等于尾节点并且（头节点的下一节点为空或者其为当前线程）</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="许可的释放"><a href="#许可的释放" class="headerlink" title="许可的释放"></a>许可的释放</h4><p>许可的释放对于公平和非公平的实现都是一致的，定义在Sync类中。因为是共享式的，释放的时候没有像ReentrantLock一样去判断是否是当前线程来释放许可。释放许可也是采用原子操作将需要释放的许可加回去就完成了。</p><p>一旦线程调用<code>releaseShared</code>释放许可成功，就会同时调用<code>doReleaseShared</code>方法，其中会对阻塞的线程进行环型，下面是<code>tryReleaseShared</code>的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 拿到当前的许可数量</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">// 加上还回来的许可</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 原子操作 归还许可</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="减少许可数量以及将剩余许可数量都取走"><a href="#减少许可数量以及将剩余许可数量都取走" class="headerlink" title="减少许可数量以及将剩余许可数量都取走"></a>减少许可数量以及将剩余许可数量都取走</h4><p>Semaphore还提供了几个额外的操作许可的方法</p><ul><li><p>减少许可数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">        <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取走剩余全部许可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实际使用信号量的代码实例"><a href="#实际使用信号量的代码实例" class="headerlink" title="实际使用信号量的代码实例"></a>实际使用信号量的代码实例</h3><p>如下：使用信号量做了一个限流的功能。</p><p>在1000个线程并发访问的情况下，每次限制只有100个线程能够获取到资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreStudy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 许可的数量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 线程数量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1000</span>;</span><br><span class="line">  <span class="comment">// 获取许可失败的次数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger F = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 获取许可成功的次数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger S = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 声明许可</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Semaphore store = <span class="keyword">new</span> Semaphore(N);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 使用栅栏模拟1000并发</span></span><br><span class="line">    CyclicBarrier BARRIER = <span class="keyword">new</span> CyclicBarrier(M + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用线程池创建线程</span></span><br><span class="line">    ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">      pool.execute(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              BARRIER.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            getData();</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"等待2秒执行并发1000线程"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 等待两秒后打开栅栏 并发获取数据开始执行</span></span><br><span class="line">    BARRIER.await();</span><br><span class="line">    pool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 模拟获取数据或者业务处理 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!store.tryAcquire()) &#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">5000</span> + <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(<span class="string">"没有可用资源，等待一小会儿: "</span> + a + <span class="string">"，目前："</span> + F.incrementAndGet());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(a);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"成功拿到资源"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    store.release();</span><br><span class="line">    System.out.println(<span class="string">"释放资源，现在："</span> + S.incrementAndGet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/fm.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Semaphore" scheme="http://zhangjiaheng.cn/tags/Semaphore/"/>
    
      <category term="信号量" scheme="http://zhangjiaheng.cn/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(四)：理解ThreadPoolExecutor线程池</title>
    <link href="http://zhangjiaheng.cn/blog/20190617/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%EF%BC%9A%E7%90%86%E8%A7%A3ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://zhangjiaheng.cn/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/</id>
    <published>2019-06-17T06:19:07.000Z</published>
    <updated>2019-11-01T01:40:48.245Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png" alt="线程池"></p><a id="more"></a><h3 id="前言：关于ThreadPoolExecutor"><a href="#前言：关于ThreadPoolExecutor" class="headerlink" title="前言：关于ThreadPoolExecutor"></a>前言：关于ThreadPoolExecutor</h3><p><strong>ThreadPoolExecutor</strong>即我们常说的线程池。《阿里巴巴Java手册》中对于线程池的使用规定如下：</p><blockquote><p><strong>3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong><br><br><strong>说明：使用线程池的好处是减少线程在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量的同类线程而导致消耗完内存或者“过度切换”的问题​</strong></p></blockquote><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><h4 id="使用线程池创建线程可以"><a href="#使用线程池创建线程可以" class="headerlink" title="使用线程池创建线程可以"></a>使用线程池创建线程可以</h4><ul><li>避免在应用中频繁的创建和销毁线程</li><li>使用线程池创建线程可以复用CPU资源</li><li>提高线程的可管理性</li></ul><h3 id="使用线程池的风险"><a href="#使用线程池的风险" class="headerlink" title="使用线程池的风险"></a>使用线程池的风险</h3><h4 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h4><p>线程池为“死锁”这一概念带来了一种新的可能：线程饥饿死锁。在线程池中，如果一个任务将另一个任务提交到同一个Executor，那么通常会引发死锁。第二个线程停留在工作队列中等待第一个提交的任务执行完成，但是第一个任务又无法执行完成，因为它在等待第二个任务执行完成。如下代码所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadPoolDeadLock &#123;</span><br><span class="line">    static ExecutorService singlePool = Executors.newSingleThreadExecutor();</span><br><span class="line">    static class MyTask implements Callable&lt;String&gt; &#123;</span><br><span class="line">        String name;</span><br><span class="line">        public MyTask(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            Future&lt;String&gt; inner = singlePool.submit(new MyTask(&quot;inner&quot;));</span><br><span class="line">            return inner.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        Future&lt;String&gt; result = singlePool.submit(new MyTask(&quot;outer&quot;));</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在更大的线程池中，如果所有线程都由于等待其他仍处于工作队列的任务而阻塞，那么会发生同样的问题，这种情况被称为线程饥饿死锁。</p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>除了Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。如果线程池的大小设置的不合理就会有可能导致内存溢出的风险。还有就是Java预置线程池FixedThreadPool 和 SingleThreadPool中的阻塞队列使用的无界队列，最多可以保存2147483647个任务，如果代码编写不严谨就会堆积大量请求导致内存溢出。</p><h4 id="线程泄漏"><a href="#线程泄漏" class="headerlink" title="线程泄漏"></a>线程泄漏</h4><p>各种线程池都会导致一种问题就是线程泄漏。当从线程池取出一个线程去执行任务时，如果任务抛出RuntimeException 或一个Error而未捕获异常时，那么线程只会退出而线程池的大小将永远减少一个，当这种情况发生多次时，线程池最终就会为空并且因为没有可用的线程来处理任务。</p><h3 id="如果要自己实现线程池需要关注哪些点"><a href="#如果要自己实现线程池需要关注哪些点" class="headerlink" title="如果要自己实现线程池需要关注哪些点"></a>如果要自己实现线程池需要关注哪些点</h3><ul><li>首先要有一个存放线程的容器并设置容量</li><li>还需要一个存放用户提交的任务的容器，阻塞队列，有界还是无界</li><li>线程池创建的时候需要将指定数量的线程启动</li><li>用户提交任务的时候如果线程池没有空闲的线程如何创建线程并放入线程池</li><li>线程数量远大于用户提交的任务数量需要有一个回收线程的机制</li><li>线程全部在执行任务的时候存放的任务需要等待还是怎样或者再新加入任务时要提供一个饱和策略</li></ul><h3 id="ThreadPoolExecutor构造函数参数意义"><a href="#ThreadPoolExecutor构造函数参数意义" class="headerlink" title="ThreadPoolExecutor构造函数参数意义"></a>ThreadPoolExecutor构造函数参数意义</h3><p><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/gzhs.png" alt="构造函数"><br>ThreadPoolExecutor提供了四种构造函数，总共有如下几种参数，意义为：</p><ul><li><code>int corePoolSize</code>: 核心线程数的大小，在线程池创建的时候就会创建这么多线程待命，用户提交任务之后立即开始执行任务</li><li><code>int maximumPoolSize</code>: 最大线程数的大小，即最多会创建这么多线程，当超过这个数目的时候可能会在执行完任务之后回收多于核心线程数的线程</li><li><code>long keepAliveTime</code>: 线程最大存活时间，是相对于核心线程数来讲的。没有超过核心线程数的会一直存活的。超过的才有存活时间的限制</li><li><code>TimeUnit unit</code>: 时间单位</li><li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 阻塞队列，用于存放用户提交的任务。系统预置的线程池的阻塞队列一般都是无界的LinkBlockingQueue，但是建议使用有界队列，对于非常大或者无界的线程池，可以使用同步移交队列控制避免排队，直接将任务从生产者移交到工作者线程。</li><li><code>ThreadFactory threadFactory</code>: 线程工厂接口。只有一个newThread方法。便于用户根据业务需要实现自己的线程创建机制。</li><li><code>RejectedExecutionHandler handler</code>: 饱和策略。默认四种，在下面讲解。</li></ul><h3 id="几种默认的饱和策略"><a href="#几种默认的饱和策略" class="headerlink" title="几种默认的饱和策略"></a>几种默认的饱和策略</h3><p>当有界队列被填满后，用户创建的任务无法再添加到线程池中保存，饱和策略开始发挥作用。如果某个任务被提交到已关闭的Executors时，饱和策略也会被执行。饱和策略的实现需要实现接口<code>RejectedExecutionHandler</code>。<br><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/bhcl.png" alt="四种默认的饱和策略"><br>如上，在ThreadPoolExecutor类中有四个内部类实现了<code>RejectedExecutionHandler</code>接口。分别是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class DiscardPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br></pre></td></tr></table></figure></p><h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><p>“中止”策略是默认的饱和策略，该策略将会抛出一个异常<code>RejectedExecutionException</code>，调用者可以捕获这个异常然后编写自己的业务代码。</p><h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><p>“抛弃”策略会在新提交的任务无法保存在队列中等待执行时将其抛弃掉。</p><h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><p>同“抛弃”策略，这种策略会将即将执行的那个任务抛弃掉，即抛弃最老的任务然后尝试提交新的任务。如果工作队列使用的是优先队列，那么会导致优先级最高的任务被抛弃，<strong>慎用</strong>！</p><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><p>“调用者执行”策略即在队列满的时候由调用者去执行该任务。不会在线程池的某个线程中执行新的任务。</p><blockquote><p>《阿里巴巴Java开发手册》中强调使用线程池的时候尽量使用ThreadPoolExecutor，目的在于让程序员更加明确线程池的工作机制，实际业务中不可能在任务满时将任务抛弃掉，所以实现自己的饱和策略是有必要的。</p></blockquote><h3 id="Java预置线程池及其使用场景"><a href="#Java预置线程池及其使用场景" class="headerlink" title="Java预置线程池及其使用场景"></a>Java预置线程池及其使用场景</h3><p>如图是Executors类中的所有方法<br><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcgz.png" alt="预置线程池构造"></p><h4 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                              <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                              <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限容量的线程池(最大为2147483647)，调用ThreadPoolExecutor构造传入的核心线程数为0。适合场景为创建执行时间短效快速的线程任务，线程在执行完成之后直接被回收。阻塞队列使用SynchronousQueue，这是一个不保存数据的队列，因为该线程池有任务提交就会创建线程去执行，所以不需要保存</p><h4 id="Executors-newFixedThreadPool-nThreads"><a href="#Executors-newFixedThreadPool-nThreads" class="headerlink" title="Executors.newFixedThreadPool(nThreads)"></a>Executors.newFixedThreadPool(nThreads)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建固定数量的线程池。调用ThreadPoolExecutor的构造函数传入的核心线程数等于最大线程数。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。</p><h4 id="Executors-newSingleThreadExecutor-："><a href="#Executors-newSingleThreadExecutor-：" class="headerlink" title="Executors.newSingleThreadExecutor()："></a>Executors.newSingleThreadExecutor()：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都只有一个线程去执行任务，用户提交的任务都会排队阻塞在阻塞队列中等待上一个任务执行完之后执行下一个。适用场景为后面任务依赖前面任务的情况。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。使用这个线程池需要小心<a href="#线程饥饿死锁">线程饥饿死锁</a></p><h4 id="Executors-newWorkStealingPool"><a href="#Executors-newWorkStealingPool" class="headerlink" title="Executors.newWorkStealingPool()"></a>Executors.newWorkStealingPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前可用的线程数量进行创建作为并行级别，通过源码可以看出底层调用的是ForkJoinPool线程池，newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中。</p><h4 id="Executors-newScheduledThreadPool"><a href="#Executors-newScheduledThreadPool" class="headerlink" title="Executors.newScheduledThreadPool()"></a>Executors.newScheduledThreadPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">↑↑↑</span><br><span class="line">↓↓↓</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设定延迟时间，定期执行。通过源码可以看出底层调用的是一个ScheduledThreadPoolExecutor，然后传入线程数量。同newWorkStealingPool一样也不是直接使用ThreadPoolExecutor进行扩展。可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</p><h3 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>设置线程池状态为关闭，但是只会关闭已经执行完成的线程，对于还未执行完成的线程，会等待执行完成再关闭。</p><p>当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。</p><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><p>立马关闭线程池，线程池里的任务不再执行。</p><p>如果我们调用shutdownNow方法时，线程处于从队列里读取任务而阻塞中，则会导致抛出InterruptedException异常</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png&quot; alt=&quot;线程池&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://zhangjiaheng.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://zhangjiaheng.cn/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的几种非递归遍历</title>
    <link href="http://zhangjiaheng.cn/blog/20190613/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <id>http://zhangjiaheng.cn/blog/20190613/二叉树的几种非递归遍历/</id>
    <published>2019-06-13T09:36:48.000Z</published>
    <updated>2019-11-01T01:40:48.210Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190613/二叉树的几种非递归遍历/fm.jpg" alt="封面"></p><a id="more"></a><h2 id="二叉树的几种非递归遍历解法"><a href="#二叉树的几种非递归遍历解法" class="headerlink" title="二叉树的几种非递归遍历解法"></a>二叉树的几种非递归遍历解法</h2><p>二叉树的递归遍历想必了解递归以及二叉树的同学都能够轻松写出正确答案，然而二叉树的非递归遍历确是很多人难以理解学会的，所以我在这里进行一下归纳总结，主要是复习巩固一下这方面的知识。</p><h3 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将根节点入栈</li><li>然后循环判断栈不为空</li><li>则弹出栈顶元素</li><li>如果弹出元素的右子树不为空则入栈</li><li>如果弹出元素的左子树不为空则入栈</li><li>继续循环</li></ul><p>解析：由于先序遍历为[根-左-右]，所以根节点应该先入栈，然后出栈的同时依次入栈右-左子树即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">frontPrintByLoop</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将根节点入栈</li><li>循环判断根节点是否有左子树，有则入栈继续循环，否则循环结束</li><li>然后循环判断栈不为空</li><li>则弹出栈顶元素</li><li>如果栈顶元素右子树不为空</li><li>则循环入栈右子树及其右子树的左子树</li><li>继续循环</li></ul><p>解析：因为中序遍历为[左-根-又]，所以树的左子树应该先入栈，循环入栈左子树之后循环出栈，出栈的同时判断出栈元素是否有右子树，如果右子树不为空则对右子树执行相同的操作，即入栈右子树的左子树。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midPrintByLoop</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            TreeNode n = node.right;</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(n);</span><br><span class="line">                n = n.left;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h4><ul><li>逆向思考先序遍历，因为后序遍历为[根-左-右]，我们可以以类似先序遍历的方式先将[右-左-根]的顺序找出来存入另一个栈，然后再依次出栈该栈元素即可</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastPrintByOtherStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;TreeNode&gt; stackReverse = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stackReverse.push(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackReverse.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stackReverse.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h4><ul><li>只使用一个栈</li><li>先将根节点入栈</li><li>设置一个标识引用 h首先指向root</li><li>循环判断栈非空</li><li>在循环中判断栈顶元素node</li><li>如果node左子树不为空并且左右子树都不为h指向的元素</li><li>入栈左子树</li><li>否则再判断右子树是否为空以及右子树是否为h节点</li><li>入栈右子树</li><li>否则，弹出栈顶元素，并且将h指向该弹出的栈顶元素</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码 2"></a>代码 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastPrintByOneStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        TreeNode h = root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.left != h &amp;&amp; node.right != h) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != node.right &amp;&amp; node.right != h) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">                h = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：使用一个栈进行后序遍历的时候需要使用一个h引用来标识上一个节点是否被遍历过，是的话就往上判断之后的树节点即可。</p><h3 id="按层遍历二叉树"><a href="#按层遍历二叉树" class="headerlink" title="按层遍历二叉树"></a>按层遍历二叉树</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>以上前中后序遍历二叉树都是用到了栈这种数据结构，而按层遍历二叉树就非常简单了，只需要引入先入先出的队列，然后依次在出队的时候将出队元素的左右子树入队即可。</p><ul><li>根节点入队</li><li>队列不为空则开始循环</li><li>如果队首元素左子树不为空，就入队</li><li>右子树不为空，也入队</li><li>队首元素出队输出</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelPrintOutTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        TreeNode i = root;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(i.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(i.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i.val + <span class="string">" | "</span>);</span><br><span class="line">            queue.poll();</span><br><span class="line">            i = queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190613/二叉树的几种非递归遍历/fm.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
