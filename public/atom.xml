<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈年风楼 | 博客</title>
  
  <subtitle>当你看到了一座山，一定会想再看看山的后面是什么！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangjiaheng.cn/"/>
  <updated>2019-08-13T03:52:05.492Z</updated>
  <id>http://zhangjiaheng.cn/</id>
  
  <author>
    <name>陈年风楼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【设计模式】设计模式基本思想以及23种模式总结整理</title>
    <link href="http://zhangjiaheng.cn/blog/20190812/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8A23%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86/"/>
    <id>http://zhangjiaheng.cn/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/</id>
    <published>2019-08-12T03:47:54.000Z</published>
    <updated>2019-08-13T03:52:05.492Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/bz.png" alt="封面"></p><a id="more"></a><h3 id="设计模式主要思想"><a href="#设计模式主要思想" class="headerlink" title="设计模式主要思想"></a>设计模式主要思想</h3><p>设计模式是在长期应用开发过程中，众多开发者总结归纳出来的程序架构与设计思想。是经过实践证明的，可在实际背景下使用的一系列程序设计方案。设计模式产生的根本目的就是为了解决开发过程中重复的代码编写，以及让程序更易扩展复用。</p><h4 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h4><ul><li>单一职责：每个类都应该实现单一的功能，否则应该将类进行拆分</li><li>里氏替换：即继承复用/合成复用。尽量使用合成/聚合的方式而不是继承。任何父类出现的地方，子类都可以出现。派生类可以在基类的基础上扩展自己的功能实现。是对“开闭原则”的一个补充。在里氏替换原则中，尽量不要对父类进行重载或者重写，因为父类代表一个定义好的结构，通过规范好的接口与外界进行交互，子类不应该随意破坏它，而是对其进行扩展。</li><li>依赖倒置：“开闭原则”的基础。即面向接口编程。依赖于抽象而不是依赖于具体的实现，编程时遇到具体的类时，不与具体的类交互，而与抽象接口进行交互。便于增加新的具体类的时候代码可以复用。</li><li>接口隔离：每个接口不应该存在子类用不到却必须实现的方法，否则就应该将接口拆分，将职责单一化。</li><li>最少知道：即迪米特法则。一个类对于自己依赖的类知道的越少越好，无论被依赖的类多么复杂，都应该将逻辑封装在方法内部，通过一个共有的方法提供给依赖类使用，这样当被依赖类发生改变的时候，才会尽可能少的影响依赖类。</li></ul><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><blockquote><p>点击对应链接跳转到该设计模式的详细整理与代码示例</p></blockquote><table><thead><tr><th>范围</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>对象创建</td><td><a href="http://zhangjiaheng.cn/blog/20190607/%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B/">Singleton（单例模式）</a><br>Prototype(原型模式)<br>Factory Method（工厂方法模式）<br>Abstract Factory（抽象工厂模式）<br>Builder（建造者模式）</td><td></td><td></td></tr><tr><td>接口适配</td><td></td><td>Adapter（适配器模式）<br>Bridge（桥接模式）<br>Facade（外观模式）</td><td></td></tr><tr><td>对象解耦</td><td></td><td></td><td>Mediator（中介者模式）<br>Observer（观察者模式）</td></tr><tr><td>抽象集合</td><td></td><td>Composite（组合模式）</td><td>Iterator（迭代器模式）</td></tr><tr><td>行为扩展</td><td></td><td>Decorator（装饰模式）</td><td>Visitor（访问者模式）<br>Chain of Responsibility（职责链）</td></tr><tr><td>算法封装</td><td></td><td></td><td><a href="http://zhangjiaheng.cn/blog/20190707/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">Template（模板方法模式）</a><br>Strategy（策略模式）</td></tr><tr><td>性能与对象访问</td><td></td><td>Flyweight（享元模式）<br>Proxy（代理模式）</td><td></td></tr><tr><td>对象状态</td><td></td><td></td><td>Memento（备忘录模式）<br>State（状态模式）</td></tr><tr><td>其他</td><td></td><td></td><td>Interpreter（解释器模式）</td></tr></tbody></table><h4 id="总结下设计模式的归类"><a href="#总结下设计模式的归类" class="headerlink" title="总结下设计模式的归类"></a>总结下设计模式的归类</h4><p><img src="/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/sjmo.png" alt="设计模式分类 - 幕布"></p><h4 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h4><p>创建型设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，使调用者无需new对象，在程序中针对给定业务场景去调用特定的对象创建方法，使程序更加灵活。</p><h4 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h4><p>行为型设计模式主要关注对象之间的通信。</p><h4 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h4><p>结构型设计模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/bz.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式基本思想" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode - 52. N皇后 II 回溯算法求解</title>
    <link href="http://zhangjiaheng.cn/blog/20190809/Leetcode-52-N%E7%9A%87%E5%90%8E-II-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3/"/>
    <id>http://zhangjiaheng.cn/blog/20190809/Leetcode-52-N皇后-II-回溯算法求解/</id>
    <published>2019-08-09T10:19:50.000Z</published>
    <updated>2019-08-09T10:26:44.297Z</updated>
    
    <content type="html"><![CDATA[<h4 id="N皇后问题-leetcode"><a href="#N皇后问题-leetcode" class="headerlink" title="N皇后问题 - leetcode"></a>N皇后问题 - <a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">leetcode</a></h4><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<img src="/blog/20190809/Leetcode-52-N皇后-II-回溯算法求解/8-queens.png" alt="8皇后示例"><br>上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><p>输入: 4<br>输出: 2<br>解释: 4 皇后问题存在如下两个不同的解法。<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[".Q..",  // 解法 1</span><br><span class="line">"...Q",</span><br><span class="line">"Q...",</span><br><span class="line">"..Q."],</span><br><span class="line">["..Q.",  // 解法 2</span><br><span class="line">"Q...",</span><br><span class="line">"...Q",</span><br><span class="line">".Q.."]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>使用回溯算法，深度优先搜索，进行遍历查询深度优先搜索的条件是有能够判断棋盘是否能落子的依据。</p><p>我这边使用一个长度为N的数组存储第J列是否有棋子，使用两个N*2-1长度的数组分别存储左对角线和右对角线是否有棋子。</p><p>对于左右对角线来说，左对角线的每一个位置i与j的和都相同，右对角线的每一个位置的i与j的差都相同，所以可以用来判断某个位置的斜线上是否存在棋子，对应对角线的数组标志为有或者没有。</p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 总记录数 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/** N皇后 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">  <span class="comment">/** 判断当前位置的左对角线是否存放了棋子 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>];</span><br><span class="line">  <span class="comment">/** 判断当前位置的右对角线是否存放了棋子 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>];</span><br><span class="line">  <span class="comment">/** 判断当前位置的列是否存放了棋子 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] curn;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.N = n;</span><br><span class="line">    curn = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    left = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    right = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    calResult(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calResult</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 棋盘第i行 遍历判断第j列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">      <span class="comment">// 开始判断第i行第j列</span></span><br><span class="line">      <span class="comment">// 判断第j列是否已经有棋子；判断(i,j)的左对角线是否有棋子；判断右对角线是否有棋子</span></span><br><span class="line">      <span class="keyword">if</span> (curn[j] == <span class="number">0</span> &amp;&amp; left[i + j] == <span class="number">0</span> &amp;&amp; right[N - <span class="number">1</span> + i - j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有棋子 就可以在(i,j)放置棋子</span></span><br><span class="line">        curn[j] = left[i + j] = right[N - <span class="number">1</span> + i - j] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果N行都放置了棋子 total就加1 否则继续放置下一行</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; N - <span class="number">1</span>) &#123;</span><br><span class="line">          calResult(i + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放置完成之后 (i,j)位置棋子去掉，然后重新走下一步 进行深度优先搜索</span></span><br><span class="line">        curn[j] = left[i + j] = right[N - <span class="number">1</span> + i - j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    solution.totalNQueens(<span class="number">8</span>);</span><br><span class="line">    System.out.println(<span class="string">"total = "</span> + solution.total);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;N皇后问题-leetcode&quot;&gt;&lt;a href=&quot;#N皇后问题-leetcode&quot; class=&quot;headerlink&quot; title=&quot;N皇后问题 - leetcode&quot;&gt;&lt;/a&gt;N皇后问题 - &lt;a href=&quot;https://leetcode-cn.com/problems/n-queens-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;img src=&quot;/blog/20190809/Leetcode-52-N皇后-II-回溯算法求解/8-queens.png&quot; alt=&quot;8皇后示例&quot;&gt;&lt;br&gt;上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。&lt;/p&gt;
&lt;h4 id=&quot;示例：&quot;&gt;&lt;a href=&quot;#示例：&quot; class=&quot;headerlink&quot; title=&quot;示例：&quot;&gt;&lt;/a&gt;示例：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;输入: 4&lt;br&gt;输出: 2&lt;br&gt;解释: 4 皇后问题存在如下两个不同的解法。&lt;br&gt;&lt;figure class=&quot;highlight md&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&quot;.Q..&quot;,  // 解法 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;...Q&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;Q...&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;..Q.&quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&quot;..Q.&quot;,  // 解法 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;Q...&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;...Q&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;.Q..&quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>我项目中使用的分布式事务：LCN</title>
    <link href="http://zhangjiaheng.cn/blog/20190806/%E6%88%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9ALCN/"/>
    <id>http://zhangjiaheng.cn/blog/20190806/我项目中使用的分布式事务：LCN/</id>
    <published>2019-08-06T03:14:44.000Z</published>
    <updated>2019-08-13T12:34:36.014Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190806/我项目中使用的分布式事务：LCN/tx.png" alt="官网首页"></p><center><a href="#more2">其他关于分布式事务的总结整理</a></center><a id="more"></a><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>由于公司项目是使用dubbo进行开发的分布式服务，所以项目中有很多涉及到分布式事务问题的场景。比如有两个模块：用户模块和账户资金模块。有一个场景是用户被邀请成为系统的新用户，需要先初始化用户信息，然后再去账户资金模块初始化用户账户信息。两个不同的模块为两个不同的RPC服务，分别被调用然后插入数据，这时候如果账户资金插入失败，不加入分布式事务的话用户直接初始化成功。我们希望这种情况下用户插入的信息被回滚，所以需要引入分布式事务来进行业务处理。</p><h4 id="使用的框架"><a href="#使用的框架" class="headerlink" title="使用的框架"></a>使用的框架</h4><p>经过调研，我们发现TX-LCN框架比较适合我们的业务场景，我们打算引入并使用LCN事务模式来进行服务中的分布式事务的业务处理。关于LCN、TCC、TXC几种事务模式的区别在<a href="#more2">下面</a>整理。</p><p>在<a href="https://www.txlcn.org/zh-cn/index.html" target="_blank" rel="noopener">官网</a>下载对应的服务，并引入项目或者单独启动：</p><p><img src="/blog/20190806/我项目中使用的分布式事务：LCN/tx.png" alt="官网首页"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transaction-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lcn.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tx-plugins-db<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lcn.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用：</p><p>在服务的发起方使用注解<code>@TxTransaction(isStart = true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@TxTransaction</span>(isStart = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ExperienceLogVO <span class="title">doUseExperience</span><span class="params">(Long userId, Long experienceRecordId, ExperienceLogCreateModel createModel)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ... do something  ...</span></span><br><span class="line">    userFacade.insert();</span><br><span class="line"> <span class="comment">// ... do something  ...</span></span><br><span class="line">    accountFacede.insert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务的参与方使用注解<code>@TxTransaction</code>标识即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TxTransaction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// ... do something  ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再启动项目之前，先启动tx-manager服务，作为协调者的角色存在，然后启动项目，调用接口的时候就可以使用分布式事务了。</p><p><a id="more2" class="active"></a></p><h4 id="其他关于分布式事务的总结整理"><a href="#其他关于分布式事务的总结整理" class="headerlink" title="其他关于分布式事务的总结整理"></a>其他关于分布式事务的总结整理</h4><h5 id="关于Tx-LCN-官网文档"><a href="#关于Tx-LCN-官网文档" class="headerlink" title="关于Tx-LCN - 官网文档"></a>关于Tx-LCN - <a href="https://www.txlcn.org/zh-cn/docs/preface.html" target="_blank" rel="noopener">官网文档</a></h5><p>Tx-LCN早期是为了设计出LCN分布式事务而命名的，不过在5.0之后可以支持LCN、TXC、TCC三种分布式事务模式。LCN框架定位为<code>不生产事务，只做事务的搬运工</code>。即TX-LCN是一款事务协调框架，本身并不操作事务，只是基于对事务的协调从而达到事务一致性的效果。</p><p>最新版本的TX-LCN同时支持多种事务模式。并支持多种不同的数据源同时使用分布式事务，完全达到拔插效果。以下是三种事务模式的介绍、区别及优缺点。</p><h6 id="LCN事务模式"><a href="#LCN事务模式" class="headerlink" title="LCN事务模式"></a>LCN事务模式</h6><ul><li>仅仅作为事务的协调者，本身不生产事务。原理是在事务发起方创建事务分组，并通过Http/Tcp协议调用的时候将事务分组传递到事务参与方。事务参与方的本地事务执行成功之后，根据事务分组ID通知事务的发起方提交所有事务。在全部事务成功通知之前，其各个本地事务均为假关闭，等待TxManager协调完成事务之后再关闭连接。</li><li>LCN事务对于代码几乎没有嵌入性，只需要添加注解即可实现分布式事务。</li><li>LCN的事务提交与回滚都有本地事务保障，更安全的确保数据一致性。</li><li>但是LCN仅限于存在本地事务并且可以通过连接对象控制事务模块的系统。</li><li>LCN模式依赖于连接代理服务，事务的发起方与参与方要一起连接与释放，较耗性能。</li><li><img src="/blog/20190806/我项目中使用的分布式事务：LCN/LCN1.png" alt="情况1"></li><li><img src="/blog/20190806/我项目中使用的分布式事务：LCN/LCN2.png" alt="情况1"></li><li><img src="/blog/20190806/我项目中使用的分布式事务：LCN/LCN3.png" alt="情况1"><h6 id="TCC事务模式"><a href="#TCC事务模式" class="headerlink" title="TCC事务模式"></a>TCC事务模式</h6></li><li>TCC事务模式不依赖于资源管理器对于XA的支持，而是通过业务系统提供的业务逻辑的调度来实现分布式事务。即编写三步操作：Try：尝试执行业务（先插入一条数据，状态为Try）、Confrim：确认执行业务（成功后状态改为Confrim）、Cancel：取消执行业务（需要回滚的话根据前两个步骤的id继续更改状态或者删除数据）。</li><li>TCC模式对于代码的侵入性很高，基本上一个接口需要拆分成3个，对于程序员的编码要求很高，业务的正确性、数据一致性都由开发者来保证</li><li>优点是TCC模式对于有无本地事务的场景都适用，甚至可以跨数据源，针对MySQL、redis、Mongo等整合成一个大的事务<h6 id="TXC事务模式"><a href="#TXC事务模式" class="headerlink" title="TXC事务模式"></a>TXC事务模式</h6></li><li>其来源于阿里巴巴的一个分布式事务中间件，可以通过极少量的代码侵入，实现分布式事务。原理是在执行SQL之前，先查询SQL的影响数据，然后保存执行的SQL快照信息并创建锁。当需要回滚的时候就采用这些记录回滚数据库。目前实现锁使用的是redis分布式锁控制。</li><li>TXC事务模式同样对代码的侵入性低</li><li>该模式仅限于对支持SQL方式的模块支持</li><li>该模式由于每次执行SQL之前需要先查询影响数据，因此相比LCN模式更消耗性能</li><li>TXC事务模式不会占用数据库资源</li><li>关于TXC事务的详细介绍可以查看<a href="https://blog.csdn.net/m0_38110132/article/details/77043580" target="_blank" rel="noopener">这篇博客</a></li></ul><h5 id="CAP理论和BASE理论"><a href="#CAP理论和BASE理论" class="headerlink" title="CAP理论和BASE理论"></a>CAP理论和BASE理论</h5><h6 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h6><p>CAP理论即数据一致性、服务可用性和分区容错性的简称。</p><ul><li>Consistency 数据一致性：一次完整的更新操作，所有节点在同一时刻访问到的数据是一致的</li><li>Availability 服务可用性：服务一直可用，并且是正常响应时间</li><li>Partition tolerance 分区容错性：分布式多节点在某几个节点挂掉后仍然可以对外提供正常的服务</li></ul><p>事实上，CAP这三种并无法保证完全满足，一般只能满足其二。对于分布式系统来说，分区容错性是最基本需要满足的条件，否则不能称为分布式系统，只满足CA 其实是传统的单机服务。那么在满足P（分区容错）的时候，就需要在C和A之间权衡。事实上，分布式系统下一般会保证A（服务可用）P，放弃数据的强一致性，只保证数据的最终一致性。这样就衍生出了BASE理论。</p><h6 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h6><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。BASE理论的核心思想是：<strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</strong>。</p><ul><li>基本可用：在分布式系统中，允许在出现不可预知故障的情况下损失部分可用性（并不是允许系统不可用），允许响应时间上的确实和部分系统功能的错误（并发场景下拒绝服务产生报错等）</li><li>软状态：即允许数据存在中间状态，允许不同节点的数据之间存在时间上的数据差异</li><li>最终一致性：强调所有数据副本能够最终一致，不需要保证数据实时强一致。</li></ul><p>传统事务的ACID机制追求强一致性，而BASE理论为分布式系统而生，主张牺牲强一致性，使得服务达到高可用。不过在分布式系统中，不同场景下对于数据的一致性又是不同的，所以才会有分布式事务来保证数据的一致，即ACID与BASE理论结合使用。</p><h5 id="2PC和3PC"><a href="#2PC和3PC" class="headerlink" title="2PC和3PC"></a>2PC和3PC</h5><h6 id="2PC-二段式提交"><a href="#2PC-二段式提交" class="headerlink" title="2PC - 二段式提交"></a>2PC - 二段式提交</h6><p>2PC，是Two-Phase Commit的缩写。过程如下：</p><ul><li><p>阶段一：提交事务请求</p><ul><li>协调者询问参与方是否可以执行提交操作并等待响应</li><li>参与者执行询问为止的所有事务操作</li><li>参与者响应协调者，返回事务执行成功与否</li></ul></li><li><p>阶段二：执行事务提交</p><ul><li><p>协调者收到所有第一阶段响应之后发起正式提交请求</p></li><li><p>参与者正式完成操作并释放整个事务期间占用的资源</p></li><li><p>反馈事务提交结果</p></li><li><p>协调者收到所有完成的消息后，完成事务。</p></li><li><p>如果任意参与者在第一阶段返回执行失败或者超时的消息，中断事务</p></li><li><p>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p></li><li><p>参与者节点向协调者节点发送”回滚完成”消息。</p></li><li><p>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p></li><li><p>不管最后结果如何，第二阶段都会结束当前事务</p></li></ul></li></ul><p>  <strong>2PC的缺点：</strong> 执行过程中所有节点都是同步阻塞的；如果协调者是单点并且发生故障，参与者将一直阻塞；如果在第二阶段协调者正式向所有参与者发送正式提交事务的请求，其中部分因为网络问题没有收到，另一部分却已经提交无法回滚，出现数据不一致的情况；协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><p>  由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p><h6 id="3PC-三段式提交"><a href="#3PC-三段式提交" class="headerlink" title="3PC - 三段式提交"></a>3PC - 三段式提交</h6><p>3PC将2PC的准备阶段又划分为两次准备，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。。并且在协调者与参与者中都引入超时机制。</p><ul><li><p>CanCommit阶段</p><ul><li>同2PC的准备阶段，协调者向参与者发送事务提交请求，询问并等待响应</li><li>得到响应之后进入预备提交阶段</li></ul></li><li><p>PreCommit阶段</p><ul><li>所有参与者第一阶段都返回成功状态，那么就会开始事务的预执行</li><li>进入PreCommit并执行事务操作，全部成功就返回给提交者</li><li>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。发送中断请求协调者向所有参与者发送abort请求;中断事务参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li></ul></li><li><p>doCommit阶段</p><ul><li><p>发送提交请求协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p></li><li><p>事务提交参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p></li><li><p>响应反馈事务提交完之后，向协调者发送Ack响应。</p></li><li><p>完成事务协调者接收到所有参与者的ack响应之后，完成事务。</p></li></ul></li></ul><p>  中断事务协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><ul><li><p>发送中断请求协调者向所有参与者发送abort请求</p></li><li><p>事务回滚参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p></li><li><p>反馈结果参与者完成事务回滚之后，向协调者发送ACK消息</p></li><li><p>中断事务协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p></li></ul><p>  相比于2PC，3PC最关键要解决的就是协调者和参与者同时挂掉的问题，所以3PC把2PC的准备阶段再次一分为二。在第一阶段只是询问所有参与者是否都可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行commit或者rollback。</p><p>  <strong>3PC存在的问题：</strong> 在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。这样与其他执行回滚的参与者就会出现数据不一致的情况。</p><hr><blockquote><p>参考：</p><ul><li><p><a href="https://www.hollischuang.com/archives/1580" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1580</a></p></li><li><p><a href="http://anruence.com/2018/03/05/tcc-2pc-3pc/" target="_blank" rel="noopener">http://anruence.com/2018/03/05/tcc-2pc-3pc/</a></p></li><li><p><a href="http://blog.jobbole.com/95632/" target="_blank" rel="noopener">http://blog.jobbole.com/95632/</a></p></li><li><a href="http://blog.csdn.net/zhangjq520/article/details/78433686" target="_blank" rel="noopener">http://blog.csdn.net/zhangjq520/article/details/78433686</a></li><li><a href="https://www.zhihu.com/question/48627764/answer/111983553" target="_blank" rel="noopener">https://www.zhihu.com/question/48627764/answer/111983553</a></li><li><a href="https://www.jianshu.com/p/d3eda795188a" target="_blank" rel="noopener">https://www.jianshu.com/p/d3eda795188a</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190806/我项目中使用的分布式事务：LCN/tx.png&quot; alt=&quot;官网首页&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;a href=&quot;#more2&quot;&gt;其他关于分布式事务的总结整理&lt;/a&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://zhangjiaheng.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式事务" scheme="http://zhangjiaheng.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="数据库" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式事务" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="微服务" scheme="http://zhangjiaheng.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode上的几个多线程编程题解</title>
    <link href="http://zhangjiaheng.cn/blog/20190724/LeetCode%E4%B8%8A%E7%9A%84%E5%87%A0%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    <id>http://zhangjiaheng.cn/blog/20190724/LeetCode上的几个多线程编程题解/</id>
    <published>2019-07-24T07:16:20.000Z</published>
    <updated>2019-08-06T02:59:38.484Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190724/LeetCode上的几个多线程编程题解/fm.png" alt=""></p><a id="more"></a><h3 id="以下所有题目的题解-github"><a href="#以下所有题目的题解-github" class="headerlink" title="以下所有题目的题解 - github"></a><a href="https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/src/main/java/Alogrithm/Alogrithm" target="_blank" rel="noopener">以下所有题目的题解 - github</a></h3><h4 id="1、按序打印"><a href="#1、按序打印" class="headerlink" title="1、按序打印"></a>1、<a href="https://leetcode-cn.com/problems/print-in-order" target="_blank" rel="noopener">按序打印</a></h4><ul><li>方法一：使用volatile变量控制顺序</li><li>思路：利用volatile语义，实现变量的内存可见性，使得别的线程在修改完state状态变量的时候结果对于另一个线程立即可见。这样每个线程在打印的时候就可以通过状态判断是不是该轮到自己执行了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (state != <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst.run();</span><br><span class="line">        state = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (state != <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond.run();</span><br><span class="line">        state = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (state != <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird.run();</span><br><span class="line">        state = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：使用CountDownLatch控制顺序（只适用于执行一次。。。可以使用循环栅栏改一下~）</li><li>CountDownLatch俗称“闭锁”。使用闭锁来控制线程是否该执行，在没有达到条件时，闭锁阻塞线程。这样在第一个线程执行完成之后打开第二个线程的闭锁，第二个执行完成之后打开第三个线程的闭锁，实现按照顺序打印。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch3 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst.run();</span><br><span class="line">        countDownLatch2.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond.run();</span><br><span class="line">        countDownLatch3.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、交替打印FooBar"><a href="#2、交替打印FooBar" class="headerlink" title="2、交替打印FooBar"></a>2、<a href="https://leetcode-cn.com/problems/print-foobar-alternately" target="_blank" rel="noopener">交替打印FooBar</a></h4><ul><li>思路：使用显示可重入锁加上Condition条件阻塞机制，再加上volatile修饰的状态变量控制打印顺序。线程打印时加锁，如果状态是使当前线程打印，就打印并且转换状态，然后唤醒另一个线程。下一次再判断当前状态不适合打印，就使用第一个条件锁阻塞当前线程。以此类推。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> 交替打印FooBar */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printFoo.run() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">            printFoo.run();</span><br><span class="line">            flag = !flag;</span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printBar.run() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">            printBar.run();</span><br><span class="line">            flag = !flag;</span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、打印0与奇偶数"><a href="#3、打印0与奇偶数" class="headerlink" title="3、打印0与奇偶数"></a>3、<a href="https://leetcode-cn.com/problems/print-zero-even-odd" target="_blank" rel="noopener">打印0与奇偶数</a></h4><ul><li>思路：也是使用显示可重入锁加上条件阻塞机制，加上volatile修饰的状态变量控制奇偶数的打印。不符合当前执行的状态就使用condition阻塞，符合就执行并且转换状态，然后唤醒其他线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> https://leetcode-cn.com/problems/print-zero-even-odd</span></span><br><span class="line"><span class="comment"> * 3个线程交替打印奇偶数和0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 0-打印0 1-打印奇数 2-打印偶数 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">          c1.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">          flag = <span class="number">1</span>;</span><br><span class="line">          c3.signal();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          flag = <span class="number">2</span>;</span><br><span class="line">          c2.signal();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">          c2.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        c1.signal();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">          c3.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        c1.signal();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ZeroEvenOdd zeroEvenOdd = <span class="keyword">new</span> ZeroEvenOdd(<span class="number">5</span>);</span><br><span class="line">    ThreadPoolExecutor pools =</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), r -&gt; <span class="keyword">new</span> Thread(r, <span class="string">"某线程"</span>));</span><br><span class="line">    pools.execute(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.zero(System.out::print);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    pools.execute(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.even(System.out::print);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    pools.execute(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.odd(System.out::print);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、H2O生成"><a href="#4、H2O生成" class="headerlink" title="4、H2O生成"></a>4、<a href="https://leetcode-cn.com/problems/building-h2o" target="_blank" rel="noopener">H2O生成</a></h4><ul><li>方法一：使用显示锁和condition</li><li>思路：老生常谈的思路了，同上面一样的原理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> 水分子生成 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition H = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition O = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">while</span> (hCount == <span class="number">2</span>) &#123;</span><br><span class="line">        H.await();</span><br><span class="line">      &#125;</span><br><span class="line">      hCount++;</span><br><span class="line">      releaseHydrogen.run();</span><br><span class="line">      <span class="keyword">if</span> (hCount == <span class="number">2</span>) &#123;</span><br><span class="line">        O.signal();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        H.signal();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">while</span> (hCount != <span class="number">2</span>) &#123;</span><br><span class="line">        O.await();</span><br><span class="line">      &#125;</span><br><span class="line">      hCount = <span class="number">0</span>;</span><br><span class="line">      releaseOxygen.run();</span><br><span class="line">      H.signal();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"HHOOOHHHH"</span>;</span><br><span class="line">    <span class="keyword">final</span> H2O o = <span class="keyword">new</span> H2O();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">'H'</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    o.hydrogen(() -&gt; System.out.print(<span class="string">"H"</span>));</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            .start();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    o.oxygen(() -&gt; System.out.print(<span class="string">"O"</span>));</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            .start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：使用信号量控制通知线程</li><li>思路：使用信号量控制线程间的通信。分别分为执行信号和唤醒信号，氢原子的执行信号首先为2，氧原子的执行信号首先为1。氢氧线程执行时消耗执行信号量，当一个氢原子执行后，氢原子的释放信号开始释放（只有一个氧线程等待其释放），然后等待氧原子释放信号释放（即一个氧原子已经产生），之后产生一个氢原子在释放请求信号。氧线程执行时，开始请求释放一个氧原子，成功之后氧线程释放信号开始释放（因为2个氢线程等待所以释放两个信号），然后等待氢线程释放两个信号（说明已经有两个氢原子生成）。然后再生成氧原子，成功之后在释放氧线程的请求信号。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> 使用信号量控制水分子生成 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2O_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Semaphore hAcquire, oAcquire, hRelease, oRelease;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">H2O_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// H 原子线程 请求信号</span></span><br><span class="line">    hAcquire = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// O 原子线程 请求信号</span></span><br><span class="line">    oAcquire = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// H 原子线程 释放信号</span></span><br><span class="line">    hRelease = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// O 原子线程 释放信号</span></span><br><span class="line">    oRelease = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    hAcquire.acquire(); <span class="comment">// H线程开始请求</span></span><br><span class="line">    hRelease.release(); <span class="comment">// 通知一个H线程即将释放 因为一个H线程释放最多只有一个O线程等待其释放</span></span><br><span class="line">    oRelease.acquire(); <span class="comment">// 等待O线程释放 一个O线程释放就可以通过</span></span><br><span class="line">    releaseHydrogen.run();</span><br><span class="line">    hAcquire.release(); <span class="comment">// 唤醒H线程请求</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    oAcquire.acquire(); <span class="comment">// O线程开始请求</span></span><br><span class="line">    oRelease.release(<span class="number">2</span>); <span class="comment">// 通知一个O线程即将释放 因为一个O线程释放 会有两个H线程等待其释放</span></span><br><span class="line">    hRelease.acquire(<span class="number">2</span>); <span class="comment">// 等待H线程释放 要等待两次释放 才可以通过</span></span><br><span class="line">    releaseOxygen.run();</span><br><span class="line">    oAcquire.release(); <span class="comment">// 唤醒O线程请求</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHOOHHOOOOOHOOOHHHOHHHHOOOHHHOOOHOHOHOHHOHOOHHHOOHOOOHHOOOOHOHHHHOOOOOHHHOOOHOHOHOOOHHOHOOHHOHHHHHHHHHHHHHHHHHHHHHHHHHHH"</span>;</span><br><span class="line">    <span class="keyword">final</span> H2O_2 o = <span class="keyword">new</span> H2O_2();</span><br><span class="line">    ThreadPoolExecutor pool =</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">300</span>,</span><br><span class="line">            <span class="number">300</span>,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>),</span><br><span class="line">                (ThreadFactory) Thread::<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">'H'</span>) &#123;</span><br><span class="line">        pool.execute(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                o.hydrogen(() -&gt; System.out.print(<span class="string">"H"</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pool.execute(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                o.oxygen(() -&gt; System.out.print(<span class="string">"O"</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190724/LeetCode上的几个多线程编程题解/fm.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized使用时一个不起眼的注意点</title>
    <link href="http://zhangjiaheng.cn/blog/20190716/Synchronized%E4%BD%BF%E7%94%A8%E6%97%B6%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%B5%B7%E7%9C%BC%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://zhangjiaheng.cn/blog/20190716/Synchronized使用时一个不起眼的注意点/</id>
    <published>2019-07-16T09:12:47.000Z</published>
    <updated>2019-07-16T09:56:23.703Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Synchronized-前情提要"><a href="#Synchronized-前情提要" class="headerlink" title="Synchronized 前情提要"></a>Synchronized 前情提要</h4><p>Synchronized是Java中用来进行方法或者代码同步的一个内置锁机制。这种内置锁机制可以保证代码执行的原子性、可见性，但是并不能屏蔽代码的重排序。Synchronized可以修饰方法、对象以及代码块，并可以保证被修饰的方法或者代码块，在同一个时刻只能有一个线程能够访问得到。</p><ul><li>修饰静态方法：锁的是当前类的class对象，修饰方法时Synchronized没有表现在字节码指令中，而是在class文件的方法表中将该方法的access_flags值置为1。表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象。</li><li>修饰普通方法：锁的是当前实例对象，修饰方法时同上。</li><li>修饰代码块：锁的是Synchronized()中的对象，编译后的字节码会在代码块前后插入monitorenter 和monitorexit。JVM需要每一个monitorenter都有一个monitorexit与之对应，任何对象都有一个monitor与之相对应，当一个monitor被持有，即线程执行到monitorenter时，对象将处于锁定状态。</li></ul><p>Synchronized是Java内置的重量级锁，在jdk1.6之后引入了自旋锁、轻量级锁、适应性自旋、锁粗化、锁消除、偏向锁等技术来减少Synchronized的性能开销。</p><a id="more"></a><h4 id="切入正题"><a href="#切入正题" class="headerlink" title="切入正题"></a>切入正题</h4><p>以上知识点想必刚开始学习并发编程的程序员都会先学习以上知识，但是很多程序员在使用Synchronized的时候有可能会发现，我明明加锁了，但是方法却并没有同步执行，这到底是什么原因？先看下如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer cn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (cn) &#123;</span><br><span class="line">                        cn++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码启动了20个线程，对Integer变量cn进行自增。很多人在写Synchronized的时候都有可能出现这种问题。这样的写法是错误的！</p><p>因为<code>cn++</code>这句代码的原理是将cn指向一个cn+1的新的Integer对象！</p><p>修改成如下，然后看看输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer cn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cd = <span class="keyword">new</span> CountDownLatch(size);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalJ = j;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cd.countDown();</span><br><span class="line">                    cd.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (cn) &#123;</span><br><span class="line">                        cn++;</span><br><span class="line">                        System.out.println(</span><br><span class="line">                            <span class="string">"cn"</span> + finalJ + <span class="string">" = "</span> + cn + <span class="string">"\t\t\t"</span> + System.identityHashCode(cn));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上代码输出如下 &gt;&gt;</strong></p><p><img src="/blog/20190716/Synchronized使用时一个不起眼的注意点/cons.png" alt="输出"></p><p>每次输出的Integer对象的HashCode值并不相同。所以，每次锁的并不是同一个对象！既然不是同一个对象，那么这个方法在多线程访问的时候肯定就不是线程安全的！对于如上这种例子我们当然可以使用原子变量<code>AtomicInteger</code>来实现更高级的同步机制去解决这个问题，但是其他场景下呢？</p><p>不仅仅是Integer对象哦！所有的对象都有可能会有这些问题存在！当你在锁这个对象的时候，一定要保证加锁的对象在线程中不被修改成另一个对象！否则就是一个<strong>假的</strong>同步代码块！</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Synchronized-前情提要&quot;&gt;&lt;a href=&quot;#Synchronized-前情提要&quot; class=&quot;headerlink&quot; title=&quot;Synchronized 前情提要&quot;&gt;&lt;/a&gt;Synchronized 前情提要&lt;/h4&gt;&lt;p&gt;Synchronized是Java中用来进行方法或者代码同步的一个内置锁机制。这种内置锁机制可以保证代码执行的原子性、可见性，但是并不能屏蔽代码的重排序。Synchronized可以修饰方法、对象以及代码块，并可以保证被修饰的方法或者代码块，在同一个时刻只能有一个线程能够访问得到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修饰静态方法：锁的是当前类的class对象，修饰方法时Synchronized没有表现在字节码指令中，而是在class文件的方法表中将该方法的access_flags值置为1。表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象。&lt;/li&gt;
&lt;li&gt;修饰普通方法：锁的是当前实例对象，修饰方法时同上。&lt;/li&gt;
&lt;li&gt;修饰代码块：锁的是Synchronized()中的对象，编译后的字节码会在代码块前后插入monitorenter 和monitorexit。JVM需要每一个monitorenter都有一个monitorexit与之对应，任何对象都有一个monitor与之相对应，当一个monitor被持有，即线程执行到monitorenter时，对象将处于锁定状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Synchronized是Java内置的重量级锁，在jdk1.6之后引入了自旋锁、轻量级锁、适应性自旋、锁粗化、锁消除、偏向锁等技术来减少Synchronized的性能开销。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Synchronized" scheme="http://zhangjiaheng.cn/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>一个[合格]的程序员必须具备的工具和插件</title>
    <link href="http://zhangjiaheng.cn/blog/20190714/%E4%B8%80%E4%B8%AA-%E5%90%88%E6%A0%BC-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E5%85%B7%E5%A4%87%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6/"/>
    <id>http://zhangjiaheng.cn/blog/20190714/一个-合格-的程序员必须具备的工具和插件/</id>
    <published>2019-07-14T13:38:04.000Z</published>
    <updated>2019-07-16T09:12:23.152Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/gtx.jpg" alt="封面"><br><a id="more"></a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><strong>如题… 是我标题党了，应该这样讲：“合格的程序员”不一定需要会使用哪些工具，但是会使用那些能够有效减少自己工作量的很酷的工具和插件的程序员一定会进步成一个“合格的程序员”。因为他们善于思考，并能够将繁杂的重复性工作交给工具去完成，将精力集中在核心的编码任务上。</strong></p><h4 id="逐个介绍那些我自己常用的工具、插件或者网站"><a href="#逐个介绍那些我自己常用的工具、插件或者网站" class="headerlink" title="逐个介绍那些我自己常用的工具、插件或者网站"></a>逐个介绍那些我自己常用的工具、插件或者网站</h4><h5 id="Ghelper"><a href="#Ghelper" class="headerlink" title="Ghelper"></a><a href="http://googlehelper.net/" target="_blank" rel="noopener">Ghelper</a></h5><p>说到工具，不会翻墙用啥子工具。Ghelper是一个谷歌浏览器插件，直接下载安装到chrome扩展即可轻松访问谷歌等服务！注意，访问谷歌的相关服务是免费的哦！如果你有需求访问其他的例如YouTuBe、Twitter之类的，可以购买会员服务！这里还有一个谷歌访问助手破解版，我没有试过，有兴趣可以装一下看看：<a href="https://github.com/haotian-wang/google-access-helper" target="_blank" rel="noopener">GHelper破解版</a><br>这个工具可以说是以下大部分工具的基础。</p><h5 id="FeHelper"><a href="#FeHelper" class="headerlink" title="FeHelper"></a><a href="https://www.baidufe.com/fehelper/feedback.html" target="_blank" rel="noopener">FeHelper</a></h5><p>FeHelper是一个在谷歌浏览器上我最常用的一个插件。功能如下，字符串编解码、JSON格式化、时间戳转换等等工具，在做web开发的时候查看某个JSON数据格式是否正确直接黏贴到这个框里就OK，简单暴力~</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/feh.png" alt="FeHelper"></p><h5 id="油猴儿"><a href="#油猴儿" class="headerlink" title="油猴儿"></a><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">油猴儿</a></h5><p>大名鼎鼎的油猴儿想必很多程序员都了解以及用过吧(没用过别告诉我你是个程序员，死敲代码的)。</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/yh.png" alt="油猴儿"></p><p>如上图就是我的一些油猴儿插件的已安装的一部分脚本的截图。例如看各大视频网站，不想要买VIP去看，那么直接安装一个VIP视频破解脚本；或者百度网盘，拒绝启动客户端下载文件，安装个油猴脚本直接直链下载！</p><p>油猴儿在我看来就是一个浏览器脚本的容器，网上极客众多，你可以找得到任何自己感兴趣的想要安装的插件去完成自己要做的事情。</p><p>油猴儿的安装：<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">谷歌应用商店 - 油猴儿</a>，安装完成之后你就可以找到任何你想要的脚本装在油猴儿里面啦！</p><p>这边，我只告诉大家一个终极脚本：<a href="https://greasyfork.org/zh-CN/scripts/24508-userscript-show-site-all-userjs" target="_blank" rel="noopener">UserScript+</a>。为啥叫它终极脚本。。。因为安装上它之后，当你打开任何网站，他都会提示你这个网站可以安装的脚本有哪些，这样你就不用在茫茫大海中去寻找自己需要的那些脚本了。</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/jb.png" alt="掘金油猴儿脚本"></p><p>可以想象，有了这个之后，面向百度编程的程序员是不是不用再被眼花缭乱的广告所骚扰！喜欢使用掘金的程序员也可以设置自己喜欢的页面排版~ 经常水V2EX的程序员也可以在评论区盖楼了！！哈哈想想就刺激呢！</p><h5 id="云盘精灵"><a href="#云盘精灵" class="headerlink" title="云盘精灵"></a><a href="https://www.yunpanjingling.com/" target="_blank" rel="noopener">云盘精灵</a></h5><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/ypjl.png" alt="云盘精灵"></p><p>云盘精灵是一个下载百度网盘资源的神奇的网站，在这里你几乎可以找到任何您想要的资源去下载。然鹅，需要注册然后使用豆子购买。不过这也是理所应当的，毕竟知识付费的天下。但是需要付的并不多，而且你还可以将你自己的资源分享到云盘精灵，有人下载你也会赚取到相应的豆子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190714/一个-合格-的程序员必须具备的工具和插件/gtx.jpg&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>将阿里Java编码规范敲成思维导图</title>
    <link href="http://zhangjiaheng.cn/blog/20190714/%E5%B0%86%E9%98%BF%E9%87%8CJava%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B2%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://zhangjiaheng.cn/blog/20190714/将阿里Java编码规范敲成思维导图/</id>
    <published>2019-07-14T03:12:01.000Z</published>
    <updated>2019-07-24T03:25:02.238Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/fm.png" alt="阿里Java编码规范"></p><p><center>阿里Java编码规范</center><br><a id="more"></a></p><p><center></center></p><p><center><a href="https://mubu.com/doc/CuUSIfxtSz" target="_blank" rel="noopener">可以点击这里查看分享的笔记</a></center></p><p><center></center></p><p><center></center></p><p><center>或者扫描如下二维码获取我分享的《阿里Java开发手册-幕布版》</center><br><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/qrcode.png" alt=""></p><p><center></center></p><p><center></center></p><h2 id=""><a href="#" class="headerlink" title=""></a><center></center></h2><p><center>最后，思维导图效果如下，密集恐惧症慎入~~</center></p><p><center>查看清晰完整的效果请去幕布笔记，点击查看思维导图即可</center><br><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/阿里Java编码规范.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190714/将阿里Java编码规范敲成思维导图/fm.png&quot; alt=&quot;阿里Java编码规范&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;阿里Java编码规范&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】模板方法模式</title>
    <link href="http://zhangjiaheng.cn/blog/20190707/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhangjiaheng.cn/blog/20190707/【设计模式】模板方法模式/</id>
    <published>2019-07-07T02:32:44.000Z</published>
    <updated>2019-08-13T03:17:55.034Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190707/【设计模式】模板方法模式/fm.png" alt="封面"><br><a id="more"></a></p><h4 id="什么是模板方法模式"><a href="#什么是模板方法模式" class="headerlink" title="什么是模板方法模式"></a>什么是模板方法模式</h4><p>在计算机程序中，为了将一些具有不同实现但有相同执行步骤的类统一起来，通常我们将这些类抽象成一个模板类。模板类定义了一个算法的框架，使得子类可以不改变算法的结构而去对一些细节实现进行重新定义。</p><h4 id="模板方法模式的核心要素"><a href="#模板方法模式的核心要素" class="headerlink" title="模板方法模式的核心要素"></a>模板方法模式的核心要素</h4><h5 id="抽象模板"><a href="#抽象模板" class="headerlink" title="抽象模板"></a>抽象模板</h5><p>抽象模板中定义了两种方法：需要子类去实现的基本方法，以及固定的不需要子类去实现的具体算法步骤的模板方法。基本方法在模板方法中被调用，模板方法一般会是一个具体的算法框架，调度基本方法完成所有功能。</p><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>子类具体实现抽象模板中的基本方法，完成对框架中的算法细节进行重新定义。</p><h4 id="我在实际项目中使用的案例"><a href="#我在实际项目中使用的案例" class="headerlink" title="我在实际项目中使用的案例"></a>我在实际项目中使用的案例</h4><p>在做某个按需查询不同类别的用户，并将其上传到OSS上，每日发邮件告诉运营人员结果的一个需求的时候，我就用到了模板方法模式。<br>首先定义一个抽象模板，分别有查询用户(每天都不同的SQL)，上传到OSS，发邮件等几个步骤，即基本方法。在模板方法中将这几个步骤封装起来。定义7个子类分别对每天不同的查询、上传、邮件做具体的实现。最后根据策略模式，不同的星期调用不同的对象的模板方法完成核心功能。</p><h4 id="模板方法模式代码示例"><a href="#模板方法模式代码示例" class="headerlink" title="模板方法模式代码示例"></a>模板方法模式代码示例</h4><p>如图，有个做饭的抽象模板：定义了[洗菜-炒菜-完成]三个步骤为基本方法，一个<code>ComplateCook</code>方法完成步骤的组装</p><p><img src="/blog/20190707/【设计模式】模板方法模式/bb.png" alt="抽象模板"></p><p>一个西红柿炒蛋的实现类</p><p><img src="/blog/20190707/【设计模式】模板方法模式/z1.png" alt="子类1"></p><p>一个鱼香肉丝的实现类</p><p><img src="/blog/20190707/【设计模式】模板方法模式/z2.png" alt="子类2"></p><p><strong>具体代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CookTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义步骤为抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ComplateCook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始做菜～"</span>);</span><br><span class="line">        wash();</span><br><span class="line">        cook();</span><br><span class="line">        finish();</span><br><span class="line">        System.out.println(<span class="string">"完成做菜步骤～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XihongshiChaoEgg</span> <span class="keyword">extends</span> <span class="title">CookTemplate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"切西红柿，准备鸡蛋～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"炒鸡蛋，然后再炒西红柿～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"西红柿炒蛋做好了，出锅～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YuXiangRose</span> <span class="keyword">extends</span> <span class="title">CookTemplate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"洗胡萝卜～"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切肉丝～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始做鱼香肉丝～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鱼香肉丝做好了 出锅～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CookTemplate cook = <span class="keyword">new</span> XihongshiChaoEgg();</span><br><span class="line">        cook.ComplateCook();</span><br><span class="line">        cook = <span class="keyword">new</span> YuXiangRose();</span><br><span class="line">        cook.ComplateCook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h4><ul><li><p>优点</p><ul><li>封装了不可变的部分，扩展可变部分</li><li>提供公共代码，便于维护</li><li>具体行为父类控制，子类只管自己的细节实现，符合开闭原则</li></ul></li><li><p>缺点</p><ul><li>一个不同的实现都要增加一个子类，会导致代码量很庞大</li><li>父类的执行结果会受到子类的影响，在复杂代码的阅读中会给开发人员带来很多麻烦</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>模板方法模式适用于：有一个固定的算法步骤，但是细节实现存在多种可能的场景，即整体稳定但是个别易变的时候讲会变化的那一部分抽象出来。<br>模板方法模式强调抽象类与子类之间的协作，它将调用权交给父类，是一种控制反转的设计理念。子类不再去完成核心的功能，只需要关注属于自己的那一部分的实现。</p><hr><ul><li>JDK中经典的模板方法模式实现：<strong>AQS</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190707/【设计模式】模板方法模式/fm.png&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="模板方法模式模式" scheme="http://zhangjiaheng.cn/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(六)：Exchanger的学习及使用场景</title>
    <link href="http://zhangjiaheng.cn/blog/20190701/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%85%AD-%EF%BC%9AExchanger%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://zhangjiaheng.cn/blog/20190701/并发编程学习-六-：Exchanger的学习及使用场景/</id>
    <published>2019-07-01T13:28:39.000Z</published>
    <updated>2019-07-02T02:33:09.625Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在JUC包中，除了一些常用的或者说常见的并发工具类(ReentrantLock，CountDownLatch，CyclicBarrier，Semaphore)等，还有一个不常用的线程同步器类 —— Exchanger。<br></p><p>Exchanger是适用在两个线程之间数据交换的并发工具类，它的作用是找到一个同步点，当两个线程都执行到了同步点(<strong>exchange方法</strong>)之后(<em>有一个没有执行到就一直等待，也可以设置等待超时时间</em>)，就将自身线程的数据与对方交换。</p><a id="more"></a><p><div style="text-align: center" center=""><a href="javascript:" target="_blank" rel="noopener">Exchanger工具类UML</a></div><br><img src="/blog/20190701/并发编程学习-六-：Exchanger的学习及使用场景/exc.png" alt="UML"></p><h4 id="Exchanger类结构"><a href="#Exchanger类结构" class="headerlink" title="Exchanger类结构"></a>Exchanger类结构</h4><p>如上图UNML，Exchanger类中有两个内部类，一个Node，一个Participant。</p><p>Participant继承了ThreadLocal并且重写了其initialValue方法，返回一个Node对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The corresponding thread local class */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node类封装了两个线程存储的数据对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes hold partially exchanged data, plus other per-thread</span></span><br><span class="line"><span class="comment"> * bookkeeping. Padded via <span class="doctag">@sun</span>.misc.Contended to reduce memory</span></span><br><span class="line"><span class="comment"> * contention.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">//  node 在 arena 数组下标</span></span><br><span class="line">    <span class="keyword">int</span> bound;              <span class="comment">//  交换器的最后记录值 </span></span><br><span class="line">    <span class="keyword">int</span> collides;           <span class="comment">//  记录的 CAS 失败数</span></span><br><span class="line">    <span class="keyword">int</span> hash;               <span class="comment">//  伪随机的自旋数</span></span><br><span class="line">    Object item;            <span class="comment">//  这个线程的数据项</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match;  <span class="comment">//  另一个线程的数据项</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked; <span class="comment">//  当阻塞时，设置此线程，不阻塞的话会自旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exchanger源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x; <span class="comment">// translate null args</span></span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> || <span class="comment">// 是null就执行后面的方法</span></span><br><span class="line">         (v = slotExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        <span class="comment">// 如果执行slotExchange有结果就执行后面的，否则返回</span></span><br><span class="line">        ((Thread.interrupted() || <span class="comment">// 非中断则执行后面的方法</span></span><br><span class="line">          (v = arenaExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exchange</code>方法的步骤：</p><ul><li>如果执行slotExchange有结果就执行后面的arenaExchange</li><li>如果solt被占用，就执行arenaExchange</li><li>返回的数据v是对方线程的数据项</li><li>总结即：如果A线程先调用，那么A的数据项存储的item中</li><li>则B线程的数据项存储在match中</li><li>当没有多线程并发操作 Exchange 的时候，使用 slotExchange 就足够了。 slot 是一个 node 对象。</li><li>当出现并发了，一个 slot 就不够了，就需要使用一个 node 数组 arena 操作了。</li></ul><p>​    </p><h4 id="Exchanger的使用"><a href="#Exchanger的使用" class="headerlink" title="Exchanger的使用"></a>Exchanger的使用</h4><p>下面的例子模拟一个队列中数据的交换使用的场景：</p><ul><li>线程A往队列中存入数据</li><li>线程B从队列中消耗数据</li><li>当线程A存满的时候</li><li>才交换给线程B</li><li>当线程B消耗完成之后才交换给线程A。</li><li>线程A、B的生产和消耗的速率有可能不同</li><li>对方线程调用exchange之前，另一个线程执行到exchange会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在对方线程调用exchange之前，另一个线程执行到exchange会阻塞 直到双方都调用exchange */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerStudy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;String&gt; initialFillQueue </span><br><span class="line">      = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;String&gt; initialEmptyQueue </span><br><span class="line">      = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Exchanger&lt;ArrayBlockingQueue&lt;String&gt;&gt; exchanger </span><br><span class="line">      = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 填充缓存队列的线程 */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ArrayBlockingQueue&lt;String&gt; current = initialEmptyQueue;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String str = StrUtil.uuid();</span><br><span class="line">          System.out.println(<span class="string">"生产了一个序列："</span> + str + <span class="string">"&gt;&gt;&gt;&gt;&gt;加入到交换区"</span>);</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            current.add(str);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已满，换一个空的"</span>);</span><br><span class="line">            current = exchanger.exchange(current);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 填充缓存队列的线程 */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ArrayBlockingQueue&lt;String&gt; current = initialFillQueue;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!current.isEmpty()) &#123;</span><br><span class="line">            String str = current.poll();</span><br><span class="line">            System.out.println(<span class="string">"消耗一个数列："</span> + str);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列空了，换个满的"</span>);</span><br><span class="line">            current = exchanger.exchange(current);</span><br><span class="line">            System.out.println(<span class="string">"换满的成功~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> FillingRunnable()).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> EmptyingRunnable()).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><a href="https://juejin.im/post/5ae7554ff265da0b86360880" target="_blank" rel="noopener">&gt;&gt;&gt;&gt;&gt; 更详细的源码解析 - 掘金</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/16317a536c642f7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="结尾"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在JUC包中，除了一些常用的或者说常见的并发工具类(ReentrantLock，CountDownLatch，CyclicBarrier，Semaphore)等，还有一个不常用的线程同步器类 —— Exchanger。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Exchanger是适用在两个线程之间数据交换的并发工具类，它的作用是找到一个同步点，当两个线程都执行到了同步点(&lt;strong&gt;exchange方法&lt;/strong&gt;)之后(&lt;em&gt;有一个没有执行到就一直等待，也可以设置等待超时时间&lt;/em&gt;)，就将自身线程的数据与对方交换。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Exchanger" scheme="http://zhangjiaheng.cn/tags/Exchanger/"/>
    
      <category term="线程交换器" scheme="http://zhangjiaheng.cn/tags/%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%8D%A2%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(五)：Semaphore源码学习及使用案例</title>
    <link href="http://zhangjiaheng.cn/blog/20190623/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%94-%EF%BC%9ASemaphore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>http://zhangjiaheng.cn/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/</id>
    <published>2019-06-23T12:27:19.000Z</published>
    <updated>2019-06-28T02:16:29.494Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/fm.png" alt=""></p><a id="more"></a><h3 id="Semaphore同步工具类之信号量介绍"><a href="#Semaphore同步工具类之信号量介绍" class="headerlink" title="Semaphore同步工具类之信号量介绍"></a>Semaphore同步工具类之信号量介绍</h3><h4 id="什么是Semaphore"><a href="#什么是Semaphore" class="headerlink" title="什么是Semaphore"></a>什么是Semaphore</h4><ul><li>Semaphore是JUC包中的一个很简单的工具类，用来实现多线程下对于资源的同一时刻的访问线程数限制</li><li>Semaphore中存在一个【许可】的概念，即访问资源之前，先要获得许可，如果当前许可数量为0，那么线程阻塞，直到获得许可</li><li>Semaphore内部使用AQS实现，由抽象内部类Sync继承了AQS。因为Semaphore天生就是共享的场景，所以其内部实际上类似于共享锁的实现。</li><li>Semaphore机制是提供给线程抢占式获取许可，所以他可以实现公平或者非公平，类似于ReentrantLock。</li><li>Semaphore提供两个构造方法，用来传入许可数量以及公平或者非公平：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Semaphore的使用场景"><a href="#Semaphore的使用场景" class="headerlink" title="Semaphore的使用场景"></a>Semaphore的使用场景</h4><ul><li>限流：并发环境(例如有1000个线程)下只允许100个线程访问数据库某资源</li><li>亦例如实际的，停车场只有10个车位，目前有15个汽车要来停车，多出的5个需要等其他车辆离开之后才能进行停车</li></ul><h3 id="Semaphore源码解读"><a href="#Semaphore源码解读" class="headerlink" title="Semaphore源码解读"></a>Semaphore源码解读</h3><p>分为公平与非公平</p><h4 id="获取许可的非公平的实现"><a href="#获取许可的非公平的实现" class="headerlink" title="获取许可的非公平的实现"></a>获取许可的非公平的实现</h4><p>在抽象类Sync中实现了非公平的消耗“许可”的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">        compareAndSetState(available, remaining))</span><br><span class="line">        <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>首先获取当前许可数量</p></li><li><p>判断消耗许可之后的剩余数量是否&gt;=0</p></li><li><p>是的话执行<code>compareAndSetState(available, remaining)</code>设置许可之后返回</p></li><li><p>否则返回的负数会使得其在<code>doAcquireSharedInterruptibly</code>中等待许可并挂起，直到被唤醒(这步骤在AQS中实现，如下)</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//如果线程被中断了，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//获取许可失败，将线程加入到等待队列中</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取许可的公平实现"><a href="#获取许可的公平实现" class="headerlink" title="获取许可的公平实现"></a>获取许可的公平实现</h4><p>首先会在获取许可之前，判断<code>hasQueuedPredecessors()</code>，是否有线程在等待队列中等待许可，有的话直接返回-1，这个底层实现在AQS中已经实现好了。接下来剩下的操作就和非公平的基本一致了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 判断头节点不等于尾节点并且（头节点的下一节点为空或者其为当前线程）</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="许可的释放"><a href="#许可的释放" class="headerlink" title="许可的释放"></a>许可的释放</h4><p>许可的释放对于公平和非公平的实现都是一致的，定义在Sync类中。因为是共享式的，释放的时候没有像ReentrantLock一样去判断是否是当前线程来释放许可。释放许可也是采用原子操作将需要释放的许可加回去就完成了。</p><p>一旦线程调用<code>releaseShared</code>释放许可成功，就会同时调用<code>doReleaseShared</code>方法，其中会对阻塞的线程进行环型，下面是<code>tryReleaseShared</code>的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 拿到当前的许可数量</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">// 加上还回来的许可</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 原子操作 归还许可</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="减少许可数量以及将剩余许可数量都取走"><a href="#减少许可数量以及将剩余许可数量都取走" class="headerlink" title="减少许可数量以及将剩余许可数量都取走"></a>减少许可数量以及将剩余许可数量都取走</h4><p>Semaphore还提供了几个额外的操作许可的方法</p><ul><li><p>减少许可数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">        <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取走剩余全部许可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实际使用信号量的代码实例"><a href="#实际使用信号量的代码实例" class="headerlink" title="实际使用信号量的代码实例"></a>实际使用信号量的代码实例</h3><p>如下：使用信号量做了一个限流的功能。</p><p>在1000个线程并发访问的情况下，每次限制只有100个线程能够获取到资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreStudy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 许可的数量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 线程数量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1000</span>;</span><br><span class="line">  <span class="comment">// 获取许可失败的次数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger F = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 获取许可成功的次数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger S = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 声明许可</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Semaphore store = <span class="keyword">new</span> Semaphore(N);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 使用栅栏模拟1000并发</span></span><br><span class="line">    CyclicBarrier BARRIER = <span class="keyword">new</span> CyclicBarrier(M + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用线程池创建线程</span></span><br><span class="line">    ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">      pool.execute(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              BARRIER.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            getData();</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"等待2秒执行并发1000线程"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 等待两秒后打开栅栏 并发获取数据开始执行</span></span><br><span class="line">    BARRIER.await();</span><br><span class="line">    pool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 模拟获取数据或者业务处理 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!store.tryAcquire()) &#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">5000</span> + <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(<span class="string">"没有可用资源，等待一小会儿: "</span> + a + <span class="string">"，目前："</span> + F.incrementAndGet());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(a);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"成功拿到资源"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    store.release();</span><br><span class="line">    System.out.println(<span class="string">"释放资源，现在："</span> + S.incrementAndGet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/fm.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Semaphore" scheme="http://zhangjiaheng.cn/tags/Semaphore/"/>
    
      <category term="信号量" scheme="http://zhangjiaheng.cn/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(四)：理解ThreadPoolExecutor线程池</title>
    <link href="http://zhangjiaheng.cn/blog/20190617/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%EF%BC%9A%E7%90%86%E8%A7%A3ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://zhangjiaheng.cn/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/</id>
    <published>2019-06-17T06:19:07.000Z</published>
    <updated>2019-06-24T08:14:12.684Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png" alt="线程池"></p><a id="more"></a><h3 id="前言：关于ThreadPoolExecutor"><a href="#前言：关于ThreadPoolExecutor" class="headerlink" title="前言：关于ThreadPoolExecutor"></a>前言：关于ThreadPoolExecutor</h3><p><strong>ThreadPoolExecutor</strong>即我们常说的线程池。《阿里巴巴Java手册》中对于线程池的使用规定如下：</p><blockquote><p><strong>3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong><br><br><strong>说明：使用线程池的好处是减少线程在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量的同类线程而导致消耗完内存或者“过度切换”的问题​</strong></p></blockquote><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><h4 id="使用线程池创建线程可以"><a href="#使用线程池创建线程可以" class="headerlink" title="使用线程池创建线程可以"></a>使用线程池创建线程可以</h4><ul><li>避免在应用中频繁的创建和销毁线程</li><li>使用线程池创建线程可以复用CPU资源</li><li>提高线程的可管理性</li></ul><h3 id="使用线程池的风险"><a href="#使用线程池的风险" class="headerlink" title="使用线程池的风险"></a>使用线程池的风险</h3><h4 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h4><p>线程池为“死锁”这一概念带来了一种新的可能：线程饥饿死锁。在线程池中，如果一个任务将另一个任务提交到同一个Executor，那么通常会引发死锁。第二个线程停留在工作队列中等待第一个提交的任务执行完成，但是第一个任务又无法执行完成，因为它在等待第二个任务执行完成。如下代码所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadPoolDeadLock &#123;</span><br><span class="line">    static ExecutorService singlePool = Executors.newSingleThreadExecutor();</span><br><span class="line">    static class MyTask implements Callable&lt;String&gt; &#123;</span><br><span class="line">        String name;</span><br><span class="line">        public MyTask(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            Future&lt;String&gt; inner = singlePool.submit(new MyTask(&quot;inner&quot;));</span><br><span class="line">            return inner.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        Future&lt;String&gt; result = singlePool.submit(new MyTask(&quot;outer&quot;));</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在更大的线程池中，如果所有线程都由于等待其他仍处于工作队列的任务而阻塞，那么会发生同样的问题，这种情况被称为线程饥饿死锁。</p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>除了Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。如果线程池的大小设置的不合理就会有可能导致内存溢出的风险。还有就是Java预置线程池FixedThreadPool 和 SingleThreadPool中的阻塞队列使用的无界队列，最多可以保存2147483647个任务，如果代码编写不严谨就会堆积大量请求导致内存溢出。</p><h4 id="线程泄漏"><a href="#线程泄漏" class="headerlink" title="线程泄漏"></a>线程泄漏</h4><p>各种线程池都会导致一种问题就是线程泄漏。当从线程池取出一个线程去执行任务时，如果任务抛出RuntimeException 或一个Error而未捕获异常时，那么线程只会退出而线程池的大小将永远减少一个，当这种情况发生多次时，线程池最终就会为空并且因为没有可用的线程来处理任务。</p><h3 id="如果要自己实现线程池需要关注哪些点"><a href="#如果要自己实现线程池需要关注哪些点" class="headerlink" title="如果要自己实现线程池需要关注哪些点"></a>如果要自己实现线程池需要关注哪些点</h3><ul><li>首先要有一个存放线程的容器并设置容量</li><li>还需要一个存放用户提交的任务的容器，阻塞队列，有界还是无界</li><li>线程池创建的时候需要将指定数量的线程启动</li><li>用户提交任务的时候如果线程池没有空闲的线程如何创建线程并放入线程池</li><li>线程数量远大于用户提交的任务数量需要有一个回收线程的机制</li><li>线程全部在执行任务的时候存放的任务需要等待还是怎样或者再新加入任务时要提供一个饱和策略</li></ul><h3 id="ThreadPoolExecutor构造函数参数意义"><a href="#ThreadPoolExecutor构造函数参数意义" class="headerlink" title="ThreadPoolExecutor构造函数参数意义"></a>ThreadPoolExecutor构造函数参数意义</h3><p><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/gzhs.png" alt="构造函数"><br>ThreadPoolExecutor提供了四种构造函数，总共有如下几种参数，意义为：</p><ul><li><code>int corePoolSize</code>: 核心线程数的大小，在线程池创建的时候就会创建这么多线程待命，用户提交任务之后立即开始执行任务</li><li><code>int maximumPoolSize</code>: 最大线程数的大小，即最多会创建这么多线程，当超过这个数目的时候可能会在执行完任务之后回收多于核心线程数的线程</li><li><code>long keepAliveTime</code>: 线程最大存活时间，是相对于核心线程数来讲的。没有超过核心线程数的会一直存活的。超过的才有存活时间的限制</li><li><code>TimeUnit unit</code>: 时间单位</li><li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 阻塞队列，用于存放用户提交的任务。系统预置的线程池的阻塞队列一般都是无界的LinkBlockingQueue，但是建议使用有界队列，对于非常大或者无界的线程池，可以使用同步移交队列控制避免排队，直接将任务从生产者移交到工作者线程。</li><li><code>ThreadFactory threadFactory</code>: 线程工厂接口。只有一个newThread方法。便于用户根据业务需要实现自己的线程创建机制。</li><li><code>RejectedExecutionHandler handler</code>: 饱和策略。默认四种，在下面讲解。</li></ul><h3 id="几种默认的饱和策略"><a href="#几种默认的饱和策略" class="headerlink" title="几种默认的饱和策略"></a>几种默认的饱和策略</h3><p>当有界队列被填满后，用户创建的任务无法再添加到线程池中保存，饱和策略开始发挥作用。如果某个任务被提交到已关闭的Executors时，饱和策略也会被执行。饱和策略的实现需要实现接口<code>RejectedExecutionHandler</code>。<br><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/bhcl.png" alt="四种默认的饱和策略"><br>如上，在ThreadPoolExecutor类中有四个内部类实现了<code>RejectedExecutionHandler</code>接口。分别是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class DiscardPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br></pre></td></tr></table></figure></p><h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><p>“中止”策略是默认的饱和策略，该策略将会抛出一个异常<code>RejectedExecutionException</code>，调用者可以捕获这个异常然后编写自己的业务代码。</p><h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><p>“抛弃”策略会在新提交的任务无法保存在队列中等待执行时将其抛弃掉。</p><h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><p>同“抛弃”策略，这种策略会将即将执行的那个任务抛弃掉，即抛弃最老的任务然后尝试提交新的任务。如果工作队列使用的是优先队列，那么会导致优先级最高的任务被抛弃，<strong>慎用</strong>！</p><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><p>“调用者执行”策略即在队列满的时候由调用者去执行该任务。不会在线程池的某个线程中执行新的任务。</p><blockquote><p>《阿里巴巴Java开发手册》中强调使用线程池的时候尽量使用ThreadPoolExecutor，目的在于让程序员更加明确线程池的工作机制，实际业务中不可能在任务满时将任务抛弃掉，所以实现自己的饱和策略是有必要的。</p></blockquote><h3 id="Java预置线程池及其使用场景"><a href="#Java预置线程池及其使用场景" class="headerlink" title="Java预置线程池及其使用场景"></a>Java预置线程池及其使用场景</h3><p>如图是Executors类中的所有方法<br><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcgz.png" alt="预置线程池构造"></p><h4 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                              <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                              <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限容量的线程池(最大为2147483647)，调用ThreadPoolExecutor构造传入的核心线程数为0。适合场景为创建执行时间短效快速的线程任务，线程在执行完成之后直接被回收。阻塞队列使用SynchronousQueue，这是一个不保存数据的队列，因为该线程池有任务提交就会创建线程去执行，所以不需要保存</p><h4 id="Executors-newFixedThreadPool-nThreads"><a href="#Executors-newFixedThreadPool-nThreads" class="headerlink" title="Executors.newFixedThreadPool(nThreads)"></a>Executors.newFixedThreadPool(nThreads)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建固定数量的线程池。调用ThreadPoolExecutor的构造函数传入的核心线程数等于最大线程数。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。</p><h4 id="Executors-newSingleThreadExecutor-："><a href="#Executors-newSingleThreadExecutor-：" class="headerlink" title="Executors.newSingleThreadExecutor()："></a>Executors.newSingleThreadExecutor()：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都只有一个线程去执行任务，用户提交的任务都会排队阻塞在阻塞队列中等待上一个任务执行完之后执行下一个。适用场景为后面任务依赖前面任务的情况。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。使用这个线程池需要小心<a href="#线程饥饿死锁">线程饥饿死锁</a></p><h4 id="Executors-newWorkStealingPool"><a href="#Executors-newWorkStealingPool" class="headerlink" title="Executors.newWorkStealingPool()"></a>Executors.newWorkStealingPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前可用的线程数量进行创建作为并行级别，通过源码可以看出底层调用的是ForkJoinPool线程池，newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中。</p><h4 id="Executors-newScheduledThreadPool"><a href="#Executors-newScheduledThreadPool" class="headerlink" title="Executors.newScheduledThreadPool()"></a>Executors.newScheduledThreadPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">↑↑↑</span><br><span class="line">↓↓↓</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设定延迟时间，定期执行。通过源码可以看出底层调用的是一个ScheduledThreadPoolExecutor，然后传入线程数量。同newWorkStealingPool一样也不是直接使用ThreadPoolExecutor进行扩展。可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</p><h3 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>设置线程池状态为关闭，但是只会关闭已经执行完成的线程，对于还未执行完成的线程，会等待执行完成再关闭。</p><p>当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。</p><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><p>立马关闭线程池，线程池里的任务不再执行。</p><p>如果我们调用shutdownNow方法时，线程处于从队列里读取任务而阻塞中，则会导致抛出InterruptedException异常</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png&quot; alt=&quot;线程池&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://zhangjiaheng.cn/tags/ThreadPoolExecutor/"/>
    
      <category term="线程池" scheme="http://zhangjiaheng.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的几种非递归遍历</title>
    <link href="http://zhangjiaheng.cn/blog/20190613/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <id>http://zhangjiaheng.cn/blog/20190613/二叉树的几种非递归遍历/</id>
    <published>2019-06-13T09:36:48.000Z</published>
    <updated>2019-06-24T08:14:52.771Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190613/二叉树的几种非递归遍历/fm.jpg" alt="封面"></p><a id="more"></a><h2 id="二叉树的几种非递归遍历解法"><a href="#二叉树的几种非递归遍历解法" class="headerlink" title="二叉树的几种非递归遍历解法"></a>二叉树的几种非递归遍历解法</h2><p>二叉树的递归遍历想必了解递归以及二叉树的同学都能够轻松写出正确答案，然而二叉树的非递归遍历确是很多人难以理解学会的，所以我在这里进行一下归纳总结，主要是复习巩固一下这方面的知识。</p><h3 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将根节点入栈</li><li>然后循环判断栈不为空</li><li>则弹出栈顶元素</li><li>如果弹出元素的右子树不为空则入栈</li><li>如果弹出元素的左子树不为空则入栈</li><li>继续循环</li></ul><p>解析：由于先序遍历为[根-左-右]，所以根节点应该先入栈，然后出栈的同时依次入栈右-左子树即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">frontPrintByLoop</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将根节点入栈</li><li>循环判断根节点是否有左子树，有则入栈继续循环，否则循环结束</li><li>然后循环判断栈不为空</li><li>则弹出栈顶元素</li><li>如果栈顶元素右子树不为空</li><li>则循环入栈右子树及其右子树的左子树</li><li>继续循环</li></ul><p>解析：因为中序遍历为[左-根-又]，所以树的左子树应该先入栈，循环入栈左子树之后循环出栈，出栈的同时判断出栈元素是否有右子树，如果右子树不为空则对右子树执行相同的操作，即入栈右子树的左子树。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midPrintByLoop</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            TreeNode n = node.right;</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(n);</span><br><span class="line">                n = n.left;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h4><ul><li>逆向思考先序遍历，因为后序遍历为[根-左-右]，我们可以以类似先序遍历的方式先将[右-左-根]的顺序找出来存入另一个栈，然后再依次出栈该栈元素即可</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastPrintByOtherStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;TreeNode&gt; stackReverse = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stackReverse.push(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackReverse.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stackReverse.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h4><ul><li>只使用一个栈</li><li>先将根节点入栈</li><li>设置一个标识引用 h首先指向root</li><li>循环判断栈非空</li><li>在循环中判断栈顶元素node</li><li>如果node左子树不为空并且左右子树都不为h指向的元素</li><li>入栈左子树</li><li>否则再判断右子树是否为空以及右子树是否为h节点</li><li>入栈右子树</li><li>否则，弹出栈顶元素，并且将h指向该弹出的栈顶元素</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码 2"></a>代码 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastPrintByOneStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        TreeNode h = root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.left != h &amp;&amp; node.right != h) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != node.right &amp;&amp; node.right != h) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">                h = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：使用一个栈进行后序遍历的时候需要使用一个h引用来标识上一个节点是否被遍历过，是的话就往上判断之后的树节点即可。</p><h3 id="按层遍历二叉树"><a href="#按层遍历二叉树" class="headerlink" title="按层遍历二叉树"></a>按层遍历二叉树</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>以上前中后序遍历二叉树都是用到了栈这种数据结构，而按层遍历二叉树就非常简单了，只需要引入先入先出的队列，然后依次在出队的时候将出队元素的左右子树入队即可。</p><ul><li>根节点入队</li><li>队列不为空则开始循环</li><li>如果队首元素左子树不为空，就入队</li><li>右子树不为空，也入队</li><li>队首元素出队输出</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelPrintOutTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        TreeNode i = root;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(i.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(i.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i.val + <span class="string">" | "</span>);</span><br><span class="line">            queue.poll();</span><br><span class="line">            i = queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190613/二叉树的几种非递归遍历/fm.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>深度分析如何写出一个线程安全的单例</title>
    <link href="http://zhangjiaheng.cn/blog/20190607/%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B/"/>
    <id>http://zhangjiaheng.cn/blog/20190607/深度分析如何写出一个线程安全的单例/</id>
    <published>2019-06-07T12:51:33.000Z</published>
    <updated>2019-08-13T03:17:55.049Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190607/深度分析如何写出一个线程安全的单例/fm.png" alt="封面"></p><a id="more"></a><h3 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h3><p>单例模式是在Java编程中除了工厂模式之外最常用的创建型设计模式之一。单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。</p><p><strong>单例模式在创建时的注意事项：</strong></p><ul><li>因为每个类只能创建一个实例，所以需要将其构造方法封闭起来不能被外部调用，即私有化；</li><li>需要提供一个获取类实例的公有方法，所有使用该类实例的人都通过这个方法拿到单例对象；</li><li>在多线程环境下需要注意线程安全问题，避免多个线程同时创建出多个不同的实例，违背了单例的原则。</li></ul><h3 id="创建单例模式的方法及其优缺点"><a href="#创建单例模式的方法及其优缺点" class="headerlink" title="创建单例模式的方法及其优缺点"></a>创建单例模式的方法及其优缺点</h3><h4 id="饿汉型"><a href="#饿汉型" class="headerlink" title="饿汉型"></a>饿汉型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton INSTANCE = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取类在加载的时候就创建好的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：饿汉型单例是最简单的单例创建方法，在类中维护一个该类私有不可变的实例，然后提供一个获取该实例的静态方法即可。</li><li>优点：代码编写简单，线程安全（使用类加载机制保证线程安全，classloader在加载类的时候使用synchronized同步）</li><li>缺点：无法实现懒加载，在使用较少的时候浪费资源，无法防止反射破坏以及反序列化破坏单例唯一性</li></ul><h4 id="普通懒汉型"><a href="#普通懒汉型" class="headerlink" title="普通懒汉型"></a>普通懒汉型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton INSTANCE ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == INSTANCE)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：这种懒汉型单例也是一种比较简单的单例实现方式，与第一种不同在于这种实例是在调用获取实例的静态方法的时候才创建</li><li>优点：代码简单，可以实现懒加载</li><li>缺点：多线程环境下会有线程安全问题，多个线程同时走到第8行代码，判断实例未创建，则会创建出多个实例;无法防止反射破坏以及反序列化破坏</li></ul><p><em>那么为了实现线程安全我们可以在方法上加上同步关键字，但是这种方式的缺点就是多线程环境调用该方法都会阻塞，导致性能存在不必要的浪费</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == INSTANCE)&#123;</span><br><span class="line">INSTANCE = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="双重检测锁实现懒加载单例"><a href="#双重检测锁实现懒加载单例" class="headerlink" title="双重检测锁实现懒加载单例"></a>双重检测锁实现懒加载单例</h4><p>上述懒汉型同步机制可以改进如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleLockSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DoubleLockSingleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleLockSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 进入方法后先判断一次 大幅减少多线程环境同步阻塞问题 </span></span><br><span class="line"><span class="comment">// 但是这种方式在多线程第一次调用创建实例的时候会出现线程安全问题</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleLockSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line"><span class="comment">// 问题的根源所在</span></span><br><span class="line"><span class="comment">// 此处可能会出现指令重排序 </span></span><br><span class="line"><span class="comment">// new对象并不是原子操作</span></span><br><span class="line">INSTANCE = <span class="keyword">new</span> DoubleLockSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：双重检测锁机制在进入<code>getInstance()</code>方法的时候会判断实例是否被创建，如果被创建，那么直接返回，如果没有，进入同步代码块，创建实例。这个方法貌似没有问题，而且还大大减少线程进入同步代码块阻塞的情况（因为只有第一次判断对象还没有创建的时候才会有线程进入同步代码块）。但是这种方法仍然存在线程安全性问题。<font color="#db1414">问题出在第17行：<code>INSTANCE = new DoubleLockSingleton();</code>由于JVM虚拟机内部会对代码进行优化，在使用new创建对象的时候并不是一个原子操作且会被虚拟机进行指令重排序。这个步骤会被分成三步：<strong>1、在堆上为对象分配空间；2、对象进行初始化；3、将引用指向该堆上的地址。 </strong>由于在虚拟机中，指令重排序优化导致第2步和第3步的执行顺序可以被打乱，那么在代码执行到第11行的时候发现，INSTANCE不为null，直接返回一个未初始化完成的对象，导致程序崩溃。</font><strong>注意：synchronzed关键字没有屏蔽指令重排序的功能</strong>，那么如何优化呢？答案是使用<code>volatile</code>关键字修饰实例变量引用，即<code>private volatile static TripleLockSingleton INSTANCE;</code>。<code>volatile</code>关键字才有屏蔽指令重排序的语义。</li><li>优点：多线程环境下大部分时间线程安全</li><li>缺点：有可能会出现线程安全问题；不能避免反射和反序列化破坏</li><li>优化：<code>private volatile static TripleLockSingleton INSTANCE;</code></li></ul><h4 id="静态内部类单例"><a href="#静态内部类单例" class="headerlink" title="静态内部类单例"></a>静态内部类单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton INSTANCE = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：静态内部类实现单例也是借助了类加载的线程安全机制，并同时基于内部类的使用时再创建的懒加载机制实现线程安全的懒加载模式的单例</li><li>优点：线程安全，可以实现懒加载</li><li>缺点：无法防止被反射以及反序列化破坏单例的唯一性</li></ul><h4 id="枚举类单例"><a href="#枚举类单例" class="headerlink" title="枚举类单例"></a>枚举类单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：<strong>Joshua Bloch</strong>大神说过：“单元素的枚举类型已经成为实现Singleton的最佳方法”。足以见证枚举类在创建单例中的优势。</li><li>优点：代码简单，线程安全，可以防止反射和反序列化破坏</li><li>缺点：暂无</li></ul><h4 id="CAS创建单例"><a href="#CAS创建单例" class="headerlink" title="CAS创建单例"></a>CAS创建单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;CASSingleton&gt; INSTANCE = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CASSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用原子操作 实现获取唯一实例</span></span><br><span class="line"><span class="comment">     * 理论上在大量竞争的环境中 原子操作自旋等待消耗大量性能 但是实际上当一个线程创建好实例之后其余线程不会出现死循环</span></span><br><span class="line"><span class="comment">     * 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CASSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            CASSingleton instance = INSTANCE.get();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != instance) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> CASSingleton();</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE.compareAndSet(<span class="keyword">null</span>, instance)) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：使用原子操作<code>AtomicReference</code>进行单例的创建，事实上目前相对于双重检查锁性能上差的也不是也别大</li><li>优点：线程安全，懒加载，相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</li><li>缺点：代码编写相对复杂，不能防止被反射和反序列化破坏</li></ul><h3 id="防止反射和反序列化破坏单例的方式"><a href="#防止反射和反序列化破坏单例的方式" class="headerlink" title="防止反射和反序列化破坏单例的方式"></a>防止反射和反序列化破坏单例的方式</h3><p>上述几个创建单例的方式中，除了使用枚举类创建单例，都会产生被反射和反序列化破坏的情况，避免该问题的方式如下，大家需要深究的话可以打开搜索引擎… 这里不再展开了~</p><h4 id="枚举类防止反射和反序列化破坏"><a href="#枚举类防止反射和反序列化破坏" class="headerlink" title="枚举类防止反射和反序列化破坏"></a>枚举类防止反射和反序列化破坏</h4><blockquote><p><strong> 参考文章：<a href="https://www.cnblogs.com/chiclee/p/9097772.html" target="_blank" rel="noopener">https://www.cnblogs.com/chiclee/p/9097772.html</a> </strong></p></blockquote><h4 id="防止反射破坏"><a href="#防止反射破坏" class="headerlink" title="防止反射破坏"></a>防止反射破坏</h4><p>因为反射是通过class对象来调用类的构造方法创建对象的，我们只需要在构造方法中进行判断，如果实例已经存在，就抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(INSTANCE != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="防止反序列化破坏"><a href="#防止反序列化破坏" class="headerlink" title="防止反序列化破坏"></a>防止反序列化破坏</h4><p>在反序列化的时候<code>ObjectInputStream.readObject()</code>中会去判断是否存在<code>readResolve()</code>方法，如果存在的话会调用该方法返回一个实例，所以在单例类中编写<code>readResolve()</code>方法返回<code>INSTANCE</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在反序列化时，直接调用这个方法，返回指定的对象，无需再新建一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190607/深度分析如何写出一个线程安全的单例/fm.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://zhangjiaheng.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(三)：CountDownLatch的实现原理及使用</title>
    <link href="http://zhangjiaheng.cn/blog/20190602/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%89-%EF%BC%9ACountDownLatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://zhangjiaheng.cn/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/</id>
    <published>2019-06-02T13:36:53.000Z</published>
    <updated>2019-06-24T08:14:12.663Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png" alt="什么是CountDownLatch？"></p><a id="more"></a><h3 id="什么是CountDownLatch？"><a href="#什么是CountDownLatch？" class="headerlink" title="什么是CountDownLatch？"></a>什么是<code>CountDownLatch</code>？</h3><p>  在本篇博客的封面，我放了一个截图，上面对于<code>CountDownLatch</code>的翻译是这样的：<em>闭锁，倒计时门闩</em>。其实顾名思义，<code>CountDownLatch</code>实际上就是一个计数器：<strong>计数-计数完成后做一些事</strong>。其实这个东西可以类比为一个水坝：当水还没有装满水库的时候水坝是关闭的，当水装满之后开闸放水，水库中的水”一起”涌出水库。</p><p>  拥有同样功能的还有<code>CyclicBarrier</code>这个类，但是这个类相对较复杂，并且相对于<code>CountDownLatch</code>还可以重复使用，实际上前者一般被叫做线程计数器，后者被叫做循环屏障，还是有很大区别的。这个 <strong>在后面再进行源码学习</strong>。</p><h3 id="CountDownLatch是如何实现的？"><a href="#CountDownLatch是如何实现的？" class="headerlink" title="CountDownLatch是如何实现的？"></a><code>CountDownLatch</code>是如何实现的？</h3><p>  同<code>ReentrantLock</code>类似，内部也是有一个实现了<code>AbstractQueueSynchronizer</code>的内部类。内部类做了父类的共享式的显示锁的方法实现，维护一个初始为N的状态<code>state</code>，每次有线程调用之后阻塞，然后<code>state</code>减1，直到减为0之后所有阻塞的线程重新开始执行。</p><h4 id="首先是内部类Sync的实现"><a href="#首先是内部类Sync的实现" class="headerlink" title="首先是内部类Sync的实现"></a>首先是内部类Sync的实现</h4><p>  构造器接收一个int参数初始化state的值。<code>tryAcquireShared()</code>方法不会对state做改变，当state不为0的时候返回-1即失败，当state等于0其返回1，表示计数器已经计数完成，<code>await()</code>方法不再阻塞。<code>tryReleaseShared()</code>方法会使用原子操作当<code>countDown()</code>被调用的时候释放一个state的占用，即state-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">      Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">          setState(count);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> getState();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">int</span> c = getState();</span><br><span class="line">              <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                  <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch的countDown方法"><a href="#CountDownLatch的countDown方法" class="headerlink" title="CountDownLatch的countDown方法"></a>CountDownLatch的countDown方法</h4><p>  countDown方法主要作用就是使state-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AQS中的<code>releaseShared()</code>方法的实现，如果释放成功执行<code>doReleaseShared();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch的await方法"><a href="#CountDownLatch的await方法" class="headerlink" title="CountDownLatch的await方法"></a>CountDownLatch的await方法</h4><p>  await方法会等待当前state值是否是0，如果不是的话就一直阻塞。直到state为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AQS中的<code>acquireSharedInterruptibly()</code>方法实现如下，在AQS的实现中，判断当前线程是否中断，是的话抛出中断异常，否则判断当前线程是否继续需要阻塞，即调用<code>tryAcquireShared()</code>。是的话进入<code>doAcquireSharedInterruptibly()</code>方法，不断的判断<code>int r = tryAcquireShared(arg);</code>，state如果一直不等于0，r就一直是负数，就会继续进入循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实以上代码的整体流程非常简单，即初始化<code>CountDownLatch</code>的state=N，每次调用countDown时state-1，减到0的时候停止阻塞，继续向下执行。</p><h3 id="我可以用CountDownLatch来做什么事情？"><a href="#我可以用CountDownLatch来做什么事情？" class="headerlink" title="我可以用CountDownLatch来做什么事情？"></a>我可以用<code>CountDownLatch</code>来做什么事情？</h3><h4 id="使用CountDownLatch模拟并发场景"><a href="#使用CountDownLatch模拟并发场景" class="headerlink" title="使用CountDownLatch模拟并发场景"></a>使用<code>CountDownLatch</code>模拟并发场景</h4><ul><li>可以使用<code>CountDownLatch</code>，创建多个线程并等待线程全部就绪之后唤醒所有线程。可以用这种方式测试代码的可用性，或者测试单例类等；</li></ul><p>我在自己学习过程中也有写过类似的测试类 - <a href="https://github.com/Fatezhang/Concurrent/tree/master/src/main/java/com/mime/concurrent/CountDownLatchStudy" target="_blank" rel="noopener">github</a></p><h4 id="使用CountDownLatch等待依赖线程执行"><a href="#使用CountDownLatch等待依赖线程执行" class="headerlink" title="使用CountDownLatch等待依赖线程执行"></a>使用<code>CountDownLatch</code>等待依赖线程执行</h4><ul><li><code>CountDownLatch</code>用来等待其他依赖服务都启动好之后在进行自身线程的任务处理</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  <code>CountDownLatch</code>是面试的时候多线程这块很容易被问到的点，实际上会考察这几个方面：</p><ul><li>1、内部实现原理 <strong>——</strong> 使用内部类继承AQS实现；</li><li>2、需要注意的方面 <strong>——</strong> 计数器为0时，await后面的方法才会执行，否则一直阻塞，countDown方法尽量写在finally代码块中，避免出现异常导致死锁；</li><li>3、使用场景 <strong>——</strong> 监控一些依赖服务启动完成之后执行代码，或者造“水坝”，即模拟大量并发场景等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png&quot; alt=&quot;什么是CountDownLatch？&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AQS" scheme="http://zhangjiaheng.cn/tags/AQS/"/>
    
      <category term="CountDownLatch" scheme="http://zhangjiaheng.cn/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>编写自己的SpringMVC框架</title>
    <link href="http://zhangjiaheng.cn/blog/20190531/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84SpringMVC%E6%A1%86%E6%9E%B6/"/>
    <id>http://zhangjiaheng.cn/blog/20190531/编写自己的SpringMVC框架/</id>
    <published>2019-05-31T07:25:00.000Z</published>
    <updated>2019-06-24T08:20:06.216Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190531/编写自己的SpringMVC框架/aaa.jpeg" alt="封面"><br><a id="more"></a></p><h2 id="Summer项目"><a href="#Summer项目" class="headerlink" title="Summer项目"></a>Summer项目</h2><p><strong><a href="https://github.com/Fatezhang/Summer" target="_blank" rel="noopener">项目github地址</a></strong></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>Summer项目是本人在学习Spring源码的时候按照SpringMVC的流程编写的一个简易的SpringMVC框架，主要完成以下功能：<ul><li>读取配置文件进行包的扫描</li><li>对所有加入注解的bean进行装配</li><li>对加了注解的字段进行依赖自动注入</li><li>URL与相应方法的映射</li><li>请求的分发处理</li></ul></li></ul><p>项目通过实现以上流程完成SpringMVC框架工作的整体过程演示</p><h3 id="以下是框架流程的详细步骤说明"><a href="#以下是框架流程的详细步骤说明" class="headerlink" title="以下是框架流程的详细步骤说明"></a>以下是框架流程的详细步骤说明</h3><h4 id="项目的结构"><a href="#项目的结构" class="headerlink" title="项目的结构"></a>项目的结构</h4><p>Summer项目仅仅是一个单独的Servlet项目，没有引入Spring相关的任何依赖，仅仅使用了一些外部的工具类，我的pom.xml文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.3.12.v20160915<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>项目使用jetty启动，所以我还配置了jetty插件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- jetty插件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jetty-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>0<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/Summer<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">connectors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">connector</span> <span class="attr">implementation</span>=<span class="string">"org.mortbay.jetty.nio.SelectChannelConnector"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">port</span>&gt;</span>4000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">connectors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="整体框架结构"><a href="#整体框架结构" class="headerlink" title="整体框架结构"></a>整体框架结构</h4><p><img src="/blog/20190531/编写自己的SpringMVC框架/zj.png" alt="注解"><br>除了自定义的这几个注解之外其他的就和平常编写Controller以及Service的流程一样，我的核心代码主要在MyServlet中</p><h4 id="MyServlet主要做了什么"><a href="#MyServlet主要做了什么" class="headerlink" title="MyServlet主要做了什么"></a>MyServlet主要做了什么</h4><h5 id="加载配置文件，首先读取web-xml中配置的配置文件"><a href="#加载配置文件，首先读取web-xml中配置的配置文件" class="headerlink" title="加载配置文件，首先读取web.xml中配置的配置文件"></a>加载配置文件，首先读取web.xml中配置的配置文件</h5><p>把扫描到的所有类全链路径名保存在list中</p><blockquote><p>以下是servlet的配置</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明Servlet对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面一句指定Servlet对象的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.zhang.summer.servlet.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面一句指定Servlet对象的完整位置，包含包名和类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下面一句是在启动时加载servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射Servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;servlet-name&gt;与上面&lt;Servlet&gt;标签的&lt;servlet-name&gt;元素相对应，不可以随便起名  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面一句话用于映射访问URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="遍历所有类，使用反射创建对象class-forName"><a href="#遍历所有类，使用反射创建对象class-forName" class="headerlink" title="遍历所有类，使用反射创建对象class.forName"></a>遍历所有类，使用反射创建对象<code>class.forName</code></h5><p>创建对象，将所有我们声明了自己注解的类加入到一个Map中，即IOC-Map</p><h5 id="遍历IOC-Map中的所有对象，进行依赖注入"><a href="#遍历IOC-Map中的所有对象，进行依赖注入" class="headerlink" title="遍历IOC-Map中的所有对象，进行依赖注入"></a>遍历IOC-Map中的所有对象，进行依赖注入</h5><p>在这里我只判断是<code>@MyController</code>注解的类才进行依赖注入</p><h5 id="处理URL和方法之间的映射"><a href="#处理URL和方法之间的映射" class="headerlink" title="处理URL和方法之间的映射"></a>处理URL和方法之间的映射</h5><p>将注解了<code>@MyRequestMapping</code>的类和方法路径拼接起来，对方法和拼接起来的url路径进行映射，并且对方法参数做特殊处理</p><h5 id="请求分发"><a href="#请求分发" class="headerlink" title="请求分发"></a>请求分发</h5><p>在doGet或者doPost请求中通过映射好的url-method找到方法进行请求的分发处理</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190531/编写自己的SpringMVC框架/aaa.jpeg&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringMVC框架" scheme="http://zhangjiaheng.cn/categories/SpringMVC%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Spring" scheme="http://zhangjiaheng.cn/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://zhangjiaheng.cn/tags/SpringMVC/"/>
    
      <category term="Servlet" scheme="http://zhangjiaheng.cn/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(二)：使用AQS编写可重入锁</title>
    <link href="http://zhangjiaheng.cn/blog/20190525/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%EF%BC%9A%E4%BD%BF%E7%94%A8AQS%E7%BC%96%E5%86%99%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <id>http://zhangjiaheng.cn/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/</id>
    <published>2019-05-25T06:07:35.000Z</published>
    <updated>2019-06-24T08:14:12.658Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/aqs.png" alt="AQS中文文档介绍"></p><div style="width:100%;text-align: center;"><a href="http://www.matools.com/api/java8" target="_blank" rel="noopener">AQS中文文档介绍</a></div><a id="more"></a><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong> <a href="/blog/20190517/编写一个简易的可重入锁-一/">上一章</a> </strong> 我使用实现<code>Lock</code>接口的方式并结合<code>Synchronized</code>关键字实现了自己的可重入锁，学习并了解了可重入锁的原理机制。这一章我在学习了AQS之后结合AQS实现自己的显示可重入锁。</p><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>如上所述，Java8中文文档中描述的，AQS即<code>AbstractQueuedSynchronizer</code>。它提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状态。 子类必须定义改变此状态的受保护方法，以及根据该对象被获取或释放来定义该状态的含义。 给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。<strong>子类应定义为非公共内部助手类，用于实现其封闭类的同步属性。 AbstractQueuedSynchronizer类不实现任何同步接口。 相反，它定义了一些方法，如acquireInterruptibly(int) ，可以通过具体的锁和相关同步器来调用适当履行其公共方法。</strong></p><p>其实AQS类是一个使用了模板方法模式的抽象框架类。它将核心实现封装在模板方法中，提供给程序员去实现具体的加锁和释放的机制，以便于实现一些特殊功能的锁，比如JDK提供的可重入锁和可重入读写锁等等。</p><h3 id="如何使用AQS"><a href="#如何使用AQS" class="headerlink" title="如何使用AQS"></a>如何使用AQS</h3><p><strong>AQS在使用的时候主要需要重写以下方法</strong></p><ul><li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><h3 id="使用AQS实现自己的可重入独占非公平锁的伪代码如下"><a href="#使用AQS实现自己的可重入独占非公平锁的伪代码如下" class="headerlink" title="使用AQS实现自己的可重入独占非公平锁的伪代码如下"></a>使用AQS实现自己的可重入独占非公平锁的伪代码如下</h3><h4 id="加锁步骤伪代码"><a href="#加锁步骤伪代码" class="headerlink" title="加锁步骤伪代码"></a>加锁步骤伪代码</h4><p>线程调用<code>lock</code>方法加锁，直接调用<code>sync.acquire(1);</code>，具体实现在<code>tryAcquire</code></p><ul><li>首先线程进入想要获取锁</li><li>拿到当前线程的引用</li><li>判断加锁状态，如果是未加锁状态<ul><li>使用<code>compareAndSetState</code>自旋原子操作加锁</li><li>设置当前线程</li><li>返回true加锁成功</li></ul></li><li>如果是加锁状态<ul><li>判断是否是当前线程重入</li><li>如果是当前线程重入，state加1，并返回true加锁成功</li></ul></li><li>最后如果都不是就返回false加锁失败</li></ul><h4 id="释放锁步骤伪代码"><a href="#释放锁步骤伪代码" class="headerlink" title="释放锁步骤伪代码"></a>释放锁步骤伪代码</h4><p>线程调用<code>unLock</code>方法加锁，直接调用<code>sync.release(1);</code>，具体实现在<code>tryRelease</code></p><ul><li>首先线程进入方法想要释放锁</li><li>判断如果不是当前线程，就抛出异常</li><li>如果是当前线程，state就减1（arg一般为1），表示释放一次</li><li>当state释放到0时，设置拥有锁的线程为null，然后返回true</li></ul><p><strong>具体的代码实现如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> zhangjiaheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 使用AQS重写一个可重入锁</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReentrantLockByAQS</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类Sync ReentrantLock使用的内部抽象类 并派生两个子类实现两种(公平/非公平)锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            Thread t = Thread.currentThread();</span><br><span class="line">            <span class="comment">// 如果第一个线程进来 可以拿到锁 则返回true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果第二个线程进来 如果不等于当前线程 返回false 否则更新当前线程值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> state = getState();</span><br><span class="line">            <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(t);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">// 当前线程再进来</span></span><br><span class="line">                setState(getState() + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 锁的获取和释放时一一对应的</span></span><br><span class="line">            <span class="comment">// 调用此方法的线程肯定是当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - arg;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newCondition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/aqs.png&quot; alt=&quot;AQS中文文档介绍&quot;&gt;&lt;/p&gt;
&lt;div style=&quot;width:100%;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.matools.com/api/java8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AQS中文文档介绍&lt;/a&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AQS" scheme="http://zhangjiaheng.cn/tags/AQS/"/>
    
      <category term="可重入锁" scheme="http://zhangjiaheng.cn/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(一)：编写一个简易的可重入锁</title>
    <link href="http://zhangjiaheng.cn/blog/20190517/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E4%B8%80/"/>
    <id>http://zhangjiaheng.cn/blog/20190517/编写一个简易的可重入锁-一/</id>
    <published>2019-05-17T12:22:23.000Z</published>
    <updated>2019-06-24T08:20:06.178Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190517/编写一个简易的可重入锁-一/nullIsMistake.jpg" alt="封面"></p><a id="more"></a><h4 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h4><p>在Java多线程编程中，锁是用来控制代码操作的原子性的重要机制，即对某线程共享的数据进行操作的时候，保证该操作同一时间段只有一个线程操作，整个过程是原子操作，其他线程再操作的时候只能等待锁的释放(排他锁)。一般我们的锁都是声明在方法上或者代码块中，那么在实际编程中我们经常会出现一个类的实例方法调用另一个实例方法的情况，我们不希望这个时候同一个线程进入另一实例方法时还要再去等待锁的释放，可重入锁就是为了解决这个问题，即 <strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>。</p><h4 id="如何实现一个简单的可重入锁"><a href="#如何实现一个简单的可重入锁" class="headerlink" title="如何实现一个简单的可重入锁"></a>如何实现一个简单的可重入锁</h4><ul><li>首先加锁的时候需要记录当前是哪一个线程加锁，加锁之后加锁标志位标记锁已被占用</li><li>维护一个加锁计数器，线程每次加锁计数器都要加1，每释放一次计数器减1</li><li>当非占用锁的线程进来之后自旋等待锁的释放，如果锁还在被占用，就wait();</li><li>所释放的时候只有当前获取锁的线程调用才有用，锁释放加锁计数器减1，当减到0的时候，加锁标志位置为false，然后唤醒其他等待的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;<span class="comment">// 当前锁是否已经被线程使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lockCount;<span class="comment">// 保存当前线程加锁的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread thread;<span class="comment">// 保存当前线程是哪一个</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">            <span class="comment">// 可重入：如果获取锁的不是当前线程并且当前已经有线程加锁，则等待</span></span><br><span class="line">            <span class="keyword">while</span> (locked &amp;&amp; Thread.currentThread() != <span class="keyword">this</span>.thread) &#123;</span><br><span class="line">                System.out.println(<span class="string">"我等会儿。。。"</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有线程使用锁或者获取锁的是当前线程 加锁计数器+1 然后thread指向获取锁的线程</span></span><br><span class="line">            <span class="keyword">this</span>.thread = Thread.currentThread();</span><br><span class="line">            lockCount++;</span><br><span class="line">            locked = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是当前线程 不需要做任何操作</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.thread == Thread.currentThread())&#123;</span><br><span class="line">                <span class="comment">// 锁计数器减1 如果当前线程获取锁个数释放完成</span></span><br><span class="line">                lockCount--;</span><br><span class="line">                <span class="keyword">if</span>(lockCount == <span class="number">0</span> )&#123;</span><br><span class="line">                    <span class="comment">// 释放完成 加锁标志置为false 再唤醒等待锁的线程</span></span><br><span class="line">                    locked = <span class="keyword">false</span>;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在Java中常用的可重入锁"><a href="#在Java中常用的可重入锁" class="headerlink" title="在Java中常用的可重入锁"></a>在Java中常用的可重入锁</h4><ul><li>synchronized 关键字加锁</li><li>java.util.concurrent.locks.ReentrantLock</li><li>java.util.concurrent.locks.ReentrantReadWriteLock<blockquote><p>上述ReentrantLock内部实际上还是使用AQS，关于AQS，后面还要进行学习与整理</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190517/编写一个简易的可重入锁-一/nullIsMistake.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="可重入锁" scheme="http://zhangjiaheng.cn/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://zhangjiaheng.cn/blog/20190512/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://zhangjiaheng.cn/blog/20190512/无重复字符的最长子串/</id>
    <published>2019-05-12T06:36:15.000Z</published>
    <updated>2019-07-24T11:44:03.138Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190512/无重复字符的最长子串/bb.png" alt="封面"></p><h4 id="算法题解：无重复字符的最长子串"><a href="#算法题解：无重复字符的最长子串" class="headerlink" title="算法题解：无重复字符的最长子串"></a>算法题解：无重复字符的最长子串</h4><p>leetcode地址： <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">leetcode</a></p><blockquote><p><strong>题目：</strong> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="解法1：暴力求解"><a href="#解法1：暴力求解" class="headerlink" title="解法1：暴力求解"></a>解法1：暴力求解</h4><ul><li><p>思路：遍历字符串，以每一个字符作为子串的起始字符，向后查找直到遇到和该字符相同的字符，记录长度，依次执行直到找到最长长度。</p></li><li><p>题解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIndexStrLength</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; s.length(); index++) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> i = index + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= s.length()) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           String ts = s.substring(index, i);</span><br><span class="line">           <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (ts.contains(c + <span class="string">""</span>)) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           length++;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       maxLength = maxLength &gt; length ? maxLength : length;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="解法2：滑动窗口法"><a href="#解法2：滑动窗口法" class="headerlink" title="解法2：滑动窗口法"></a>解法2：滑动窗口法</h4><ul><li>思路：在使用暴力解法时我们会发现实际上对于无重复子串来讲，我们产生了一些冗余的判断操作。例如对于串<code>sdabcabcbb</code>，判断了子串<code>sdabc</code>之后，当后面再出现字符<code>a</code>，那么重复字符之前的串直接舍弃就好。即直接从<code>bca</code>…开始判断即可。这样可以减少大量的不必要的判断与计算操作。</li><li>题解如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIndexStrLength</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">      <span class="comment">//如果当前元素与滑动窗口中的元素重复：</span></span><br><span class="line">      <span class="keyword">if</span> (map.containsKey(c) &amp;&amp; map.get(c) &gt;= start) &#123;</span><br><span class="line">          max = Math.max(max, i - start);</span><br><span class="line">          start = map.get(c) + <span class="number">1</span>;</span><br><span class="line">          <span class="comment">//如果当前元素与滑动窗口中的元素不重复，但已经遍历到了最后一个字符：</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">          max = Math.max(max, i - start + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      map.put(c, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>滑动窗口法的思路可以用来解决很多字符串相关的问题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190512/无重复字符的最长子串/bb.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;算法题解：无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#算法题解：无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;算法题解：无重复字符的最长子串&quot;&gt;&lt;/a&gt;算法题解：无重复字符的最长子串&lt;/h4&gt;&lt;p&gt;leetcode地址： &lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt; 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;span class=&quot;string&quot;&gt;&quot;abcabcbb&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;，所以其长度为 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化和transient关键字的理解与学习</title>
    <link href="http://zhangjiaheng.cn/blog/20190511/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8Ctransient%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zhangjiaheng.cn/blog/20190511/Java序列化和transient关键字的理解与学习/</id>
    <published>2019-05-11T12:44:31.000Z</published>
    <updated>2019-06-24T08:20:06.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h4><p><img src="/blog/20190511/Java序列化和transient关键字的理解与学习/xuliehua.png" alt="Java序列化过程"></p><blockquote><p>在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。</p></blockquote><a id="more"></a><h5 id="Java中如何进行序列化与反序列化"><a href="#Java中如何进行序列化与反序列化" class="headerlink" title="Java中如何进行序列化与反序列化"></a>Java中如何进行序列化与反序列化</h5><ul><li><p>在Java中，对象一般是无法进行序列化与反序列化的。而使得对象能够被序列化的方式也很简单，即实现接口 <code>Serializable</code> 。如下代码即将对象序列化以及反序列化的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerializable</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    TestSerializable() &#123;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        name = <span class="string">"aachuanpu"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        TestSerializable test = <span class="keyword">new</span> TestSerializable();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"e:/test.txt"</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class="line">        System.out.println(newTest.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h5><ul><li>serialVersionUID作为实现序列化接口的一个非必须非必须声明的静态常量经常不被开发者所重视，忘记声明。其实serialVersionUID的作用是为了保证序列化之前和之后的对象是同一对象。我们知道JVM判断对象是否相同是根据对象的类路径全限定名确定的，而虚拟机决定一个对象是否允许序列化和反序列化成这个类还取决于其serialVersionUID是否一致。不一致的话会导致<code>java.io.InvalidClassException的异常</code>，也可以不指定serialVersionUID，如果不指定的话java会根据class计算serialVersionUID。</li><li>对于两个相同的类及拥有相同的serialVersionUID，如果两个类字段不一致也会序列化和反序列化成功。这时Java会在反序列化的时候忽略掉不一致的字段。</li></ul><h5 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h5><ul><li><p>在序列化的时候，静态变量能够被序列化成功吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerializable</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    TestSerializable() &#123;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        name = <span class="string">"aachuanpu"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        TestSerializable test = <span class="keyword">new</span> TestSerializable();</span><br><span class="line">        TestSerializable.staticName = <span class="string">"name11111"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"e:/test.txt"</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        TestSerializable.staticName = <span class="string">"name222"</span>;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class="line">        System.out.println(newTest.name);</span><br><span class="line">        System.out.println(TestSerializable.staticName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上代码会输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aachuanpu</span><br><span class="line">name222</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li><li><p>如上所见：将对象序列化之后，修改静态变量的值，再将对象反序列化，输出的静态变量的值是修改之后的。即序列化保存的是对象的状态，静态变量属于类，因此序列化并不保存静态变量。</p></li></ul><h5 id="transient关键字与自定义序列化"><a href="#transient关键字与自定义序列化" class="headerlink" title="transient关键字与自定义序列化"></a>transient关键字与自定义序列化</h5><ul><li><p>对象的序列化是将对象中的数据写入本地文件或者用于网络传输的过程，但是很多时候会有一些数据无需进行序列化保存起来或者传输出去。我们可以使用<code>transient</code>关键字修饰成员变量。那么在Java序列化的时候就<strong>不会使用Java本身的序列化方式对其进行序列化</strong>。但是我们依然可以自定义自己的序列化行为对其进行序列化！</p><p><strong>自定义序列化：</strong> 定义自己的<code>writeObject</code>和<code>readObject</code>方法</p></li><li><p>对于使用transient修饰的成员变量，可以编写<code>writeObject</code>和<code>readObject</code>方法实现对于该成员变量(不仅仅只是针对该成员变量)的自定义序列化。在编写<code>writeObject</code>和<code>readObject</code>方法的时候需要注意的地方在于：这俩方法没有在Object中定义，也没有在<code>Serializable</code>接口中声明，JVM是如何调用到这俩方法的呢？答案是通过反射，去根据方法名和参数寻找到相应的方法，找到之后会被ObjectOutputStream调用，没有这俩方法就调用默认的序列化呗。还有就是因为ObjectOutputStream使用getPrivateMethod，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。</p></li><li><p>通过这种方法，我们实现自己的序列化与反序列化可以实现很多场景下的需求。比如网络传输的时候对于特殊字段进行加密等等。</p></li><li><p>如下，你会发现我在这俩方法中调用了defaultWriteObject()和defaultReadObject()用于处理未被transient修饰的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerializable</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    TestSerializable() &#123;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        name = <span class="string">"aachuanpu"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        TestSerializable test = <span class="keyword">new</span> TestSerializable();</span><br><span class="line">        TestSerializable.staticName = <span class="string">"name11111"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"e:/test.txt"</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        TestSerializable.staticName = <span class="string">"name222"</span>;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class="line">        System.out.println(newTest.name);</span><br><span class="line">        System.out.println(TestSerializable.staticName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream oos)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        oos.defaultWriteObject();</span><br><span class="line">        name = <span class="string">"自定义名称"</span>;</span><br><span class="line">        oos.writeObject(name);</span><br><span class="line">        System.out.println(<span class="string">"调用writeObject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ois.defaultReadObject();</span><br><span class="line">        String name = (String) ois.readObject();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">"读出的name="</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"调用readObject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">调用writeObject</span><br><span class="line">读出的name=自定义名称</span><br><span class="line">调用readObject</span><br><span class="line">自定义名称</span><br><span class="line">name222</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li></ul><h5 id="父类的序列化"><a href="#父类的序列化" class="headerlink" title="父类的序列化"></a>父类的序列化</h5><ul><li>一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取 父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都 是默认声明的值。</li></ul><h5 id="常问：ArrayList中数组使用transient修饰为何还能被序列化"><a href="#常问：ArrayList中数组使用transient修饰为何还能被序列化" class="headerlink" title="常问：ArrayList中数组使用transient修饰为何还能被序列化"></a>常问：ArrayList中数组使用transient修饰为何还能被序列化</h5><p>  <strong>ArrayList源码：</strong><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure></p><p>  transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。但是ArrayList又是可序行化的类，elementData是ArrayList具体存放元素的成员，用transient来修饰elementData，需要实现自己的序列化方式去处理。即对于数组中多余的空间不去进行序列化。如下：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment"> * is, serialize it).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment"> *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span></span><br><span class="line"><span class="comment"> * deserialize it).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  <strong>elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。</strong></p><h5 id="其余补充"><a href="#其余补充" class="headerlink" title="其余补充"></a>其余补充</h5><p><a href="https://bluepopopo.iteye.com/blog/486548" target="_blank" rel="noopener">来自文章</a> ← 点击链接查看参考博客</p><blockquote><p>1.Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值;</p></blockquote><blockquote><p>2.Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。Serializable是内建支持的也就是直接implement即可，但Externalizable的实现类必须提供readExternal和writeExternal实现。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。</p></blockquote><blockquote><p>3.正如Effectvie Java中提到的，序列化就如同另外一个构造函数，只不过是有由stream进行创建的。如果字段有一些条件限制的，特别是非可变的类定义了可变的字段会反序列化可能会有问题。可以在readObject方法中添加条件限制，也可以在readResolve中做。参考56条“保护性的编写readObject”和“提供一个readResolve方法”。</p></blockquote><blockquote><p>4.当有非常复杂的对象需要提供deep clone时，可以考虑将其声明为可序列化，不过缺点也显而易见，性能开销。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Java序列化&quot;&gt;&lt;a href=&quot;#Java序列化&quot; class=&quot;headerlink&quot; title=&quot;Java序列化&quot;&gt;&lt;/a&gt;Java序列化&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/blog/20190511/Java序列化和transient关键字的理解与学习/xuliehua.png&quot; alt=&quot;Java序列化过程&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="序列化" scheme="http://zhangjiaheng.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="transient关键字" scheme="http://zhangjiaheng.cn/tags/transient%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>你的内心比拳头更强大</title>
    <link href="http://zhangjiaheng.cn/blog/20190509/%E4%BD%A0%E7%9A%84%E5%86%85%E5%BF%83%E6%AF%94%E6%8B%B3%E5%A4%B4%E6%9B%B4%E5%BC%BA%E5%A4%A7/"/>
    <id>http://zhangjiaheng.cn/blog/20190509/你的内心比拳头更强大/</id>
    <published>2019-05-09T15:37:36.000Z</published>
    <updated>2019-05-13T06:27:50.123Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">加密博客请输入密码访问</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      最近真的很不开心，将烦躁的感受记录下来吧~
    
    </summary>
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
