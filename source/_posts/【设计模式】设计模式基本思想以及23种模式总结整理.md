---
title: 【设计模式】设计模式基本思想以及23种模式总结整理
date: 2019-08-12 11:47:54
categories: [Java基础,设计模式]
tags: [Java基础,设计模式基本思想,设计模式]
---



![封面](bz.png)

<!--more-->

### 设计模式主要思想

设计模式是在长期应用开发过程中，众多开发者总结归纳出来的程序架构与设计思想。是经过实践证明的，可在实际背景下使用的一系列程序设计方案。设计模式产生的根本目的就是为了解决开发过程中重复的代码编写，以及让程序更易扩展复用。

#### 设计模式的原则

- 单一职责：每个类都应该实现单一的功能，否则应该将类进行拆分
- 里氏替换：即继承复用/合成复用。尽量使用合成/聚合的方式而不是继承。任何父类出现的地方，子类都可以出现。派生类可以在基类的基础上扩展自己的功能实现。是对“开闭原则”的一个补充。在里氏替换原则中，尽量不要对父类进行重载或者重写，因为父类代表一个定义好的结构，通过规范好的接口与外界进行交互，子类不应该随意破坏它，而是对其进行扩展。
- 依赖倒置：“开闭原则”的基础。即面向接口编程。依赖于抽象而不是依赖于具体的实现，编程时遇到具体的类时，不与具体的类交互，而与抽象接口进行交互。便于增加新的具体类的时候代码可以复用。
- 接口隔离：每个接口不应该存在子类用不到却必须实现的方法，否则就应该将接口拆分，将职责单一化。
- 最少知道：即迪米特法则。一个类对于自己依赖的类知道的越少越好，无论被依赖的类多么复杂，都应该将逻辑封装在方法内部，通过一个共有的方法提供给依赖类使用，这样当被依赖类发生改变的时候，才会尽可能少的影响依赖类。

### 设计模式的分类

> 点击对应链接跳转到该设计模式的详细整理与代码示例



| 范围           | 创建型模式                                                   | 结构型模式                                                   | 行为型模式                                                   |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 对象创建       | [Singleton（单例模式）](http://zhangjiaheng.cn/blog/20190607/%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B/)<br/>Prototype(原型模式)<br/>Factory Method（工厂方法模式）<br/>Abstract Factory（抽象工厂模式）<br/>Builder（建造者模式） |                                                              |                                                              |
| 接口适配       |                                                              | Adapter（适配器模式）<br/>Bridge（桥接模式）<br/>Facade（外观模式） |                                                              |
| 对象解耦       |                                                              |                                                              | Mediator（中介者模式）<br/>Observer（观察者模式）            |
| 抽象集合       |                                                              | Composite（组合模式）                                        | Iterator（迭代器模式）                                       |
| 行为扩展       |                                                              | Decorator（装饰模式）                                        | Visitor（访问者模式）<br/>Chain of Responsibility（职责链）  |
| 算法封装       |                                                              |                                                              | [Template（模板方法模式）](http://zhangjiaheng.cn/blog/20190707/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/)<br/>Strategy（策略模式） |
| 性能与对象访问 |                                                              | Flyweight（享元模式）<br/>Proxy（代理模式）                  |                                                              |
| 对象状态       |                                                              |                                                              | Memento（备忘录模式）<br/>State（状态模式）                  |
| 其他           |                                                              |                                                              | Interpreter（解释器模式）                                    |

#### 总结下设计模式的归类

![设计模式分类 - 幕布](sjmo.png)

#### 创建型设计模式

创建型设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，使调用者无需new对象，在程序中针对给定业务场景去调用特定的对象创建方法，使程序更加灵活。

#### 行为型设计模式

行为型设计模式主要关注对象之间的通信。

#### 结构型设计模式

结构型设计模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。
