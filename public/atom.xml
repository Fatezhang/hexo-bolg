<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈年风楼 | 博客</title>
  
  <subtitle>当你看到了一座山，一定会想再看看山的后面是什么！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangjiaheng.cn/"/>
  <updated>2019-07-16T09:56:23.703Z</updated>
  <id>http://zhangjiaheng.cn/</id>
  
  <author>
    <name>陈年风楼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Synchronized使用时一个不起眼的注意点</title>
    <link href="http://zhangjiaheng.cn/blog/20190716/Synchronized%E4%BD%BF%E7%94%A8%E6%97%B6%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%B5%B7%E7%9C%BC%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://zhangjiaheng.cn/blog/20190716/Synchronized使用时一个不起眼的注意点/</id>
    <published>2019-07-16T09:12:47.000Z</published>
    <updated>2019-07-16T09:56:23.703Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Synchronized-前情提要"><a href="#Synchronized-前情提要" class="headerlink" title="Synchronized 前情提要"></a>Synchronized 前情提要</h4><p>Synchronized是Java中用来进行方法或者代码同步的一个内置锁机制。这种内置锁机制可以保证代码执行的原子性、可见性，但是并不能屏蔽代码的重排序。Synchronized可以修饰方法、对象以及代码块，并可以保证被修饰的方法或者代码块，在同一个时刻只能有一个线程能够访问得到。</p><ul><li>修饰静态方法：锁的是当前类的class对象，修饰方法时Synchronized没有表现在字节码指令中，而是在class文件的方法表中将该方法的access_flags值置为1。表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象。</li><li>修饰普通方法：锁的是当前实例对象，修饰方法时同上。</li><li>修饰代码块：锁的是Synchronized()中的对象，编译后的字节码会在代码块前后插入monitorenter 和monitorexit。JVM需要每一个monitorenter都有一个monitorexit与之对应，任何对象都有一个monitor与之相对应，当一个monitor被持有，即线程执行到monitorenter时，对象将处于锁定状态。</li></ul><p>Synchronized是Java内置的重量级锁，在jdk1.6之后引入了自旋锁、轻量级锁、适应性自旋、锁粗化、锁消除、偏向锁等技术来减少Synchronized的性能开销。</p><a id="more"></a><h4 id="切入正题"><a href="#切入正题" class="headerlink" title="切入正题"></a>切入正题</h4><p>以上知识点想必刚开始学习并发编程的程序员都会先学习以上知识，但是很多程序员在使用Synchronized的时候有可能会发现，我明明加锁了，但是方法却并没有同步执行，这到底是什么原因？先看下如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer cn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (cn) &#123;</span><br><span class="line">                        cn++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码启动了20个线程，对Integer变量cn进行自增。很多人在写Synchronized的时候都有可能出现这种问题。这样的写法是错误的！</p><p>因为<code>cn++</code>这句代码的原理是将cn指向一个cn+1的新的Integer对象！</p><p>修改成如下，然后看看输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer cn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cd = <span class="keyword">new</span> CountDownLatch(size);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalJ = j;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cd.countDown();</span><br><span class="line">                    cd.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (cn) &#123;</span><br><span class="line">                        cn++;</span><br><span class="line">                        System.out.println(</span><br><span class="line">                            <span class="string">"cn"</span> + finalJ + <span class="string">" = "</span> + cn + <span class="string">"\t\t\t"</span> + System.identityHashCode(cn));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上代码输出如下 &gt;&gt;</strong></p><p><img src="/blog/20190716/Synchronized使用时一个不起眼的注意点/cons.png" alt="输出"></p><p>每次输出的Integer对象的HashCode值并不相同。所以，每次锁的并不是同一个对象！既然不是同一个对象，那么这个方法在多线程访问的时候肯定就不是线程安全的！对于如上这种例子我们当然可以使用原子变量<code>AtomicInteger</code>来实现更高级的同步机制去解决这个问题，但是其他场景下呢？</p><p>不仅仅是Integer对象哦！所有的对象都有可能会有这些问题存在！当你在锁这个对象的时候，一定要保证加锁的对象在线程中不被修改成另一个对象！否则就是一个<strong>假的</strong>同步代码块！</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Synchronized-前情提要&quot;&gt;&lt;a href=&quot;#Synchronized-前情提要&quot; class=&quot;headerlink&quot; title=&quot;Synchronized 前情提要&quot;&gt;&lt;/a&gt;Synchronized 前情提要&lt;/h4&gt;&lt;p&gt;Synchronized是Java中用来进行方法或者代码同步的一个内置锁机制。这种内置锁机制可以保证代码执行的原子性、可见性，但是并不能屏蔽代码的重排序。Synchronized可以修饰方法、对象以及代码块，并可以保证被修饰的方法或者代码块，在同一个时刻只能有一个线程能够访问得到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修饰静态方法：锁的是当前类的class对象，修饰方法时Synchronized没有表现在字节码指令中，而是在class文件的方法表中将该方法的access_flags值置为1。表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象。&lt;/li&gt;
&lt;li&gt;修饰普通方法：锁的是当前实例对象，修饰方法时同上。&lt;/li&gt;
&lt;li&gt;修饰代码块：锁的是Synchronized()中的对象，编译后的字节码会在代码块前后插入monitorenter 和monitorexit。JVM需要每一个monitorenter都有一个monitorexit与之对应，任何对象都有一个monitor与之相对应，当一个monitor被持有，即线程执行到monitorenter时，对象将处于锁定状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Synchronized是Java内置的重量级锁，在jdk1.6之后引入了自旋锁、轻量级锁、适应性自旋、锁粗化、锁消除、偏向锁等技术来减少Synchronized的性能开销。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Synchronized" scheme="http://zhangjiaheng.cn/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>一个[合格]的程序员必须具备的工具和插件</title>
    <link href="http://zhangjiaheng.cn/blog/20190714/%E4%B8%80%E4%B8%AA-%E5%90%88%E6%A0%BC-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E5%85%B7%E5%A4%87%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6/"/>
    <id>http://zhangjiaheng.cn/blog/20190714/一个-合格-的程序员必须具备的工具和插件/</id>
    <published>2019-07-14T13:38:04.000Z</published>
    <updated>2019-07-16T09:12:23.152Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/gtx.jpg" alt="封面"><br><a id="more"></a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><strong>如题… 是我标题党了，应该这样讲：“合格的程序员”不一定需要会使用哪些工具，但是会使用那些能够有效减少自己工作量的很酷的工具和插件的程序员一定会进步成一个“合格的程序员”。因为他们善于思考，并能够将繁杂的重复性工作交给工具去完成，将精力集中在核心的编码任务上。</strong></p><h4 id="逐个介绍那些我自己常用的工具、插件或者网站"><a href="#逐个介绍那些我自己常用的工具、插件或者网站" class="headerlink" title="逐个介绍那些我自己常用的工具、插件或者网站"></a>逐个介绍那些我自己常用的工具、插件或者网站</h4><h5 id="Ghelper"><a href="#Ghelper" class="headerlink" title="Ghelper"></a><a href="http://googlehelper.net/" target="_blank" rel="noopener">Ghelper</a></h5><p>说到工具，不会翻墙用啥子工具。Ghelper是一个谷歌浏览器插件，直接下载安装到chrome扩展即可轻松访问谷歌等服务！注意，访问谷歌的相关服务是免费的哦！如果你有需求访问其他的例如YouTuBe、Twitter之类的，可以购买会员服务！这里还有一个谷歌访问助手破解版，我没有试过，有兴趣可以装一下看看：<a href="https://github.com/haotian-wang/google-access-helper" target="_blank" rel="noopener">GHelper破解版</a><br>这个工具可以说是以下大部分工具的基础。</p><h5 id="FeHelper"><a href="#FeHelper" class="headerlink" title="FeHelper"></a><a href="https://www.baidufe.com/fehelper/feedback.html" target="_blank" rel="noopener">FeHelper</a></h5><p>FeHelper是一个在谷歌浏览器上我最常用的一个插件。功能如下，字符串编解码、JSON格式化、时间戳转换等等工具，在做web开发的时候查看某个JSON数据格式是否正确直接黏贴到这个框里就OK，简单暴力~</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/feh.png" alt="FeHelper"></p><h5 id="油猴儿"><a href="#油猴儿" class="headerlink" title="油猴儿"></a><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">油猴儿</a></h5><p>大名鼎鼎的油猴儿想必很多程序员都了解以及用过吧(没用过别告诉我你是个程序员，死敲代码的)。</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/yh.png" alt="油猴儿"></p><p>如上图就是我的一些油猴儿插件的已安装的一部分脚本的截图。例如看各大视频网站，不想要买VIP去看，那么直接安装一个VIP视频破解脚本；或者百度网盘，拒绝启动客户端下载文件，安装个油猴脚本直接直链下载！</p><p>油猴儿在我看来就是一个浏览器脚本的容器，网上极客众多，你可以找得到任何自己感兴趣的想要安装的插件去完成自己要做的事情。</p><p>油猴儿的安装：<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">谷歌应用商店 - 油猴儿</a>，安装完成之后你就可以找到任何你想要的脚本装在油猴儿里面啦！</p><p>这边，我只告诉大家一个终极脚本：<a href="https://greasyfork.org/zh-CN/scripts/24508-userscript-show-site-all-userjs" target="_blank" rel="noopener">UserScript+</a>。为啥叫它终极脚本。。。因为安装上它之后，当你打开任何网站，他都会提示你这个网站可以安装的脚本有哪些，这样你就不用在茫茫大海中去寻找自己需要的那些脚本了。</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/jb.png" alt="掘金油猴儿脚本"></p><p>可以想象，有了这个之后，面向百度编程的程序员是不是不用再被眼花缭乱的广告所骚扰！喜欢使用掘金的程序员也可以设置自己喜欢的页面排版~ 经常水V2EX的程序员也可以在评论区盖楼了！！哈哈想想就刺激呢！</p><h5 id="云盘精灵"><a href="#云盘精灵" class="headerlink" title="云盘精灵"></a><a href="https://www.yunpanjingling.com/" target="_blank" rel="noopener">云盘精灵</a></h5><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/ypjl.png" alt="云盘精灵"></p><p>云盘精灵是一个下载百度网盘资源的神奇的网站，在这里你几乎可以找到任何您想要的资源去下载。然鹅，需要注册然后使用豆子购买。不过这也是理所应当的，毕竟知识付费的天下。但是需要付的并不多，而且你还可以将你自己的资源分享到云盘精灵，有人下载你也会赚取到相应的豆子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190714/一个-合格-的程序员必须具备的工具和插件/gtx.jpg&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>将阿里Java编码规范敲成思维导图</title>
    <link href="http://zhangjiaheng.cn/blog/20190714/%E5%B0%86%E9%98%BF%E9%87%8CJava%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B2%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://zhangjiaheng.cn/blog/20190714/将阿里Java编码规范敲成思维导图/</id>
    <published>2019-07-14T03:12:01.000Z</published>
    <updated>2019-07-24T03:25:02.238Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/fm.png" alt="阿里Java编码规范"></p><p><center>阿里Java编码规范</center><br><a id="more"></a></p><p><center></center></p><p><center><a href="https://mubu.com/doc/CuUSIfxtSz" target="_blank" rel="noopener">可以点击这里查看分享的笔记</a></center></p><p><center></center></p><p><center></center></p><p><center>或者扫描如下二维码获取我分享的《阿里Java开发手册-幕布版》</center><br><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/qrcode.png" alt=""></p><p><center></center></p><p><center></center></p><h2 id=""><a href="#" class="headerlink" title=""></a><center></center></h2><p><center>最后，思维导图效果如下，密集恐惧症慎入~~</center></p><p><center>查看清晰完整的效果请去幕布笔记，点击查看思维导图即可</center><br><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/阿里Java编码规范.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190714/将阿里Java编码规范敲成思维导图/fm.png&quot; alt=&quot;阿里Java编码规范&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;阿里Java编码规范&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】模板方法模式</title>
    <link href="http://zhangjiaheng.cn/blog/20190707/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhangjiaheng.cn/blog/20190707/【设计模式】模板方法模式/</id>
    <published>2019-07-07T02:32:44.000Z</published>
    <updated>2019-07-10T03:17:55.487Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190707/【设计模式】模板方法模式/fm.png" alt="封面"><br><a id="more"></a></p><h4 id="什么是模板方法模式"><a href="#什么是模板方法模式" class="headerlink" title="什么是模板方法模式"></a>什么是模板方法模式</h4><p>在计算机程序中，为了将一些具有不同实现但有相同执行步骤的类统一起来，通常我们将这些类抽象成一个模板类。模板类定义了一个算法的框架，使得子类可以不改变算法的结构而去对一些细节实现进行重新定义。</p><h4 id="模板方法模式的核心要素"><a href="#模板方法模式的核心要素" class="headerlink" title="模板方法模式的核心要素"></a>模板方法模式的核心要素</h4><h5 id="抽象模板"><a href="#抽象模板" class="headerlink" title="抽象模板"></a>抽象模板</h5><p>抽象模板中定义了两种方法：需要子类去实现的基本方法，以及固定的不需要子类去实现的具体算法步骤的模板方法。基本方法在模板方法中被调用，模板方法一般会是一个具体的算法框架，调度基本方法完成所有功能。</p><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>子类具体实现抽象模板中的基本方法，完成对框架中的算法细节进行重新定义。</p><h4 id="我在实际项目中使用的案例"><a href="#我在实际项目中使用的案例" class="headerlink" title="我在实际项目中使用的案例"></a>我在实际项目中使用的案例</h4><p>在做某个按需查询不同类别的用户，并将其上传到OSS上，每日发邮件告诉运营人员结果的一个需求的时候，我就用到了模板方法模式。<br>首先定义一个抽象模板，分别有查询用户(每天都不同的SQL)，上传到OSS，发邮件等几个步骤，即基本方法。在模板方法中将这几个步骤封装起来。定义7个子类分别对每天不同的查询、上传、邮件做具体的实现。最后根据策略模式，不同的星期调用不同的对象的模板方法完成核心功能。</p><h4 id="模板方法模式代码示例"><a href="#模板方法模式代码示例" class="headerlink" title="模板方法模式代码示例"></a>模板方法模式代码示例</h4><p>如图，有个做饭的抽象模板：定义了[洗菜-炒菜-完成]三个步骤为基本方法，一个<code>ComplateCook</code>方法完成步骤的组装</p><p><img src="/blog/20190707/【设计模式】模板方法模式/bb.png" alt="抽象模板"></p><p>一个西红柿炒蛋的实现类</p><p><img src="/blog/20190707/【设计模式】模板方法模式/z1.png" alt="子类1"></p><p>一个鱼香肉丝的实现类</p><p><img src="/blog/20190707/【设计模式】模板方法模式/z2.png" alt="子类2"></p><p><strong>具体代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CookTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义步骤为抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ComplateCook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始做菜～"</span>);</span><br><span class="line">        wash();</span><br><span class="line">        cook();</span><br><span class="line">        finish();</span><br><span class="line">        System.out.println(<span class="string">"完成做菜步骤～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XihongshiChaoEgg</span> <span class="keyword">extends</span> <span class="title">CookTemplate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"切西红柿，准备鸡蛋～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"炒鸡蛋，然后再炒西红柿～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"西红柿炒蛋做好了，出锅～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YuXiangRose</span> <span class="keyword">extends</span> <span class="title">CookTemplate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"洗胡萝卜～"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切肉丝～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始做鱼香肉丝～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鱼香肉丝做好了 出锅～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CookTemplate cook = <span class="keyword">new</span> XihongshiChaoEgg();</span><br><span class="line">        cook.ComplateCook();</span><br><span class="line">        cook = <span class="keyword">new</span> YuXiangRose();</span><br><span class="line">        cook.ComplateCook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h4><ul><li><p>优点</p><ul><li>封装了不可变的部分，扩展可变部分</li><li>提供公共代码，便于维护</li><li>具体行为父类控制，子类只管自己的细节实现，符合开闭原则</li></ul></li><li><p>缺点</p><ul><li>一个不同的实现都要增加一个子类，会导致代码量很庞大</li><li>父类的执行结果会受到子类的影响，在复杂代码的阅读中会给开发人员带来很多麻烦</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>模板方法模式适用于：有一个固定的算法步骤，但是细节实现存在多种可能的场景，即整体稳定但是个别易变的时候讲会变化的那一部分抽象出来。<br>模板方法模式强调抽象类与子类之间的协作，它将调用权交给父类，是一种控制反转的设计理念。子类不再去完成核心的功能，只需要关注属于自己的那一部分的实现。</p><hr><ul><li>JDK中经典的模板方法模式实现：<strong>AQS</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190707/【设计模式】模板方法模式/fm.png&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="模板方法模式模式" scheme="http://zhangjiaheng.cn/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(六)：Exchanger的学习及使用场景</title>
    <link href="http://zhangjiaheng.cn/blog/20190701/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%85%AD-%EF%BC%9AExchanger%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://zhangjiaheng.cn/blog/20190701/并发编程学习-六-：Exchanger的学习及使用场景/</id>
    <published>2019-07-01T13:28:39.000Z</published>
    <updated>2019-07-02T02:33:09.625Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在JUC包中，除了一些常用的或者说常见的并发工具类(ReentrantLock，CountDownLatch，CyclicBarrier，Semaphore)等，还有一个不常用的线程同步器类 —— Exchanger。<br></p><p>Exchanger是适用在两个线程之间数据交换的并发工具类，它的作用是找到一个同步点，当两个线程都执行到了同步点(<strong>exchange方法</strong>)之后(<em>有一个没有执行到就一直等待，也可以设置等待超时时间</em>)，就将自身线程的数据与对方交换。</p><a id="more"></a><p><div style="text-align: center" center=""><a href="javascript:" target="_blank" rel="noopener">Exchanger工具类UML</a></div><br><img src="/blog/20190701/并发编程学习-六-：Exchanger的学习及使用场景/exc.png" alt="UML"></p><h4 id="Exchanger类结构"><a href="#Exchanger类结构" class="headerlink" title="Exchanger类结构"></a>Exchanger类结构</h4><p>如上图UNML，Exchanger类中有两个内部类，一个Node，一个Participant。</p><p>Participant继承了ThreadLocal并且重写了其initialValue方法，返回一个Node对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The corresponding thread local class */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node类封装了两个线程存储的数据对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes hold partially exchanged data, plus other per-thread</span></span><br><span class="line"><span class="comment"> * bookkeeping. Padded via <span class="doctag">@sun</span>.misc.Contended to reduce memory</span></span><br><span class="line"><span class="comment"> * contention.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">//  node 在 arena 数组下标</span></span><br><span class="line">    <span class="keyword">int</span> bound;              <span class="comment">//  交换器的最后记录值 </span></span><br><span class="line">    <span class="keyword">int</span> collides;           <span class="comment">//  记录的 CAS 失败数</span></span><br><span class="line">    <span class="keyword">int</span> hash;               <span class="comment">//  伪随机的自旋数</span></span><br><span class="line">    Object item;            <span class="comment">//  这个线程的数据项</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match;  <span class="comment">//  另一个线程的数据项</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked; <span class="comment">//  当阻塞时，设置此线程，不阻塞的话会自旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exchanger源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x; <span class="comment">// translate null args</span></span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> || <span class="comment">// 是null就执行后面的方法</span></span><br><span class="line">         (v = slotExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        <span class="comment">// 如果执行slotExchange有结果就执行后面的，否则返回</span></span><br><span class="line">        ((Thread.interrupted() || <span class="comment">// 非中断则执行后面的方法</span></span><br><span class="line">          (v = arenaExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exchange</code>方法的步骤：</p><ul><li>如果执行slotExchange有结果就执行后面的arenaExchange</li><li>如果solt被占用，就执行arenaExchange</li><li>返回的数据v是对方线程的数据项</li><li>总结即：如果A线程先调用，那么A的数据项存储的item中</li><li>则B线程的数据项存储在match中</li><li>当没有多线程并发操作 Exchange 的时候，使用 slotExchange 就足够了。 slot 是一个 node 对象。</li><li>当出现并发了，一个 slot 就不够了，就需要使用一个 node 数组 arena 操作了。</li></ul><p>​    </p><h4 id="Exchanger的使用"><a href="#Exchanger的使用" class="headerlink" title="Exchanger的使用"></a>Exchanger的使用</h4><p>下面的例子模拟一个队列中数据的交换使用的场景：</p><ul><li>线程A往队列中存入数据</li><li>线程B从队列中消耗数据</li><li>当线程A存满的时候</li><li>才交换给线程B</li><li>当线程B消耗完成之后才交换给线程A。</li><li>线程A、B的生产和消耗的速率有可能不同</li><li>对方线程调用exchange之前，另一个线程执行到exchange会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在对方线程调用exchange之前，另一个线程执行到exchange会阻塞 直到双方都调用exchange */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerStudy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;String&gt; initialFillQueue </span><br><span class="line">      = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;String&gt; initialEmptyQueue </span><br><span class="line">      = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Exchanger&lt;ArrayBlockingQueue&lt;String&gt;&gt; exchanger </span><br><span class="line">      = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 填充缓存队列的线程 */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ArrayBlockingQueue&lt;String&gt; current = initialEmptyQueue;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String str = StrUtil.uuid();</span><br><span class="line">          System.out.println(<span class="string">"生产了一个序列："</span> + str + <span class="string">"&gt;&gt;&gt;&gt;&gt;加入到交换区"</span>);</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            current.add(str);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已满，换一个空的"</span>);</span><br><span class="line">            current = exchanger.exchange(current);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 填充缓存队列的线程 */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ArrayBlockingQueue&lt;String&gt; current = initialFillQueue;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!current.isEmpty()) &#123;</span><br><span class="line">            String str = current.poll();</span><br><span class="line">            System.out.println(<span class="string">"消耗一个数列："</span> + str);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列空了，换个满的"</span>);</span><br><span class="line">            current = exchanger.exchange(current);</span><br><span class="line">            System.out.println(<span class="string">"换满的成功~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> FillingRunnable()).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> EmptyingRunnable()).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><a href="https://juejin.im/post/5ae7554ff265da0b86360880" target="_blank" rel="noopener">&gt;&gt;&gt;&gt;&gt; 更详细的源码解析 - 掘金</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/16317a536c642f7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="结尾"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在JUC包中，除了一些常用的或者说常见的并发工具类(ReentrantLock，CountDownLatch，CyclicBarrier，Semaphore)等，还有一个不常用的线程同步器类 —— Exchanger。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Exchanger是适用在两个线程之间数据交换的并发工具类，它的作用是找到一个同步点，当两个线程都执行到了同步点(&lt;strong&gt;exchange方法&lt;/strong&gt;)之后(&lt;em&gt;有一个没有执行到就一直等待，也可以设置等待超时时间&lt;/em&gt;)，就将自身线程的数据与对方交换。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Exchanger" scheme="http://zhangjiaheng.cn/tags/Exchanger/"/>
    
      <category term="线程交换器" scheme="http://zhangjiaheng.cn/tags/%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%8D%A2%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(五)：Semaphore源码学习及使用案例</title>
    <link href="http://zhangjiaheng.cn/blog/20190623/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%94-%EF%BC%9ASemaphore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>http://zhangjiaheng.cn/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/</id>
    <published>2019-06-23T12:27:19.000Z</published>
    <updated>2019-06-28T02:16:29.494Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/fm.png" alt=""></p><a id="more"></a><h3 id="Semaphore同步工具类之信号量介绍"><a href="#Semaphore同步工具类之信号量介绍" class="headerlink" title="Semaphore同步工具类之信号量介绍"></a>Semaphore同步工具类之信号量介绍</h3><h4 id="什么是Semaphore"><a href="#什么是Semaphore" class="headerlink" title="什么是Semaphore"></a>什么是Semaphore</h4><ul><li>Semaphore是JUC包中的一个很简单的工具类，用来实现多线程下对于资源的同一时刻的访问线程数限制</li><li>Semaphore中存在一个【许可】的概念，即访问资源之前，先要获得许可，如果当前许可数量为0，那么线程阻塞，直到获得许可</li><li>Semaphore内部使用AQS实现，由抽象内部类Sync继承了AQS。因为Semaphore天生就是共享的场景，所以其内部实际上类似于共享锁的实现。</li><li>Semaphore机制是提供给线程抢占式获取许可，所以他可以实现公平或者非公平，类似于ReentrantLock。</li><li>Semaphore提供两个构造方法，用来传入许可数量以及公平或者非公平：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Semaphore的使用场景"><a href="#Semaphore的使用场景" class="headerlink" title="Semaphore的使用场景"></a>Semaphore的使用场景</h4><ul><li>限流：并发环境(例如有1000个线程)下只允许100个线程访问数据库某资源</li><li>亦例如实际的，停车场只有10个车位，目前有15个汽车要来停车，多出的5个需要等其他车辆离开之后才能进行停车</li></ul><h3 id="Semaphore源码解读"><a href="#Semaphore源码解读" class="headerlink" title="Semaphore源码解读"></a>Semaphore源码解读</h3><p>分为公平与非公平</p><h4 id="获取许可的非公平的实现"><a href="#获取许可的非公平的实现" class="headerlink" title="获取许可的非公平的实现"></a>获取许可的非公平的实现</h4><p>在抽象类Sync中实现了非公平的消耗“许可”的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">        compareAndSetState(available, remaining))</span><br><span class="line">        <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>首先获取当前许可数量</p></li><li><p>判断消耗许可之后的剩余数量是否&gt;=0</p></li><li><p>是的话执行<code>compareAndSetState(available, remaining)</code>设置许可之后返回</p></li><li><p>否则返回的负数会使得其在<code>doAcquireSharedInterruptibly</code>中等待许可并挂起，直到被唤醒(这步骤在AQS中实现，如下)</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//如果线程被中断了，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//获取许可失败，将线程加入到等待队列中</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取许可的公平实现"><a href="#获取许可的公平实现" class="headerlink" title="获取许可的公平实现"></a>获取许可的公平实现</h4><p>首先会在获取许可之前，判断<code>hasQueuedPredecessors()</code>，是否有线程在等待队列中等待许可，有的话直接返回-1，这个底层实现在AQS中已经实现好了。接下来剩下的操作就和非公平的基本一致了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 判断头节点不等于尾节点并且（头节点的下一节点为空或者其为当前线程）</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="许可的释放"><a href="#许可的释放" class="headerlink" title="许可的释放"></a>许可的释放</h4><p>许可的释放对于公平和非公平的实现都是一致的，定义在Sync类中。因为是共享式的，释放的时候没有像ReentrantLock一样去判断是否是当前线程来释放许可。释放许可也是采用原子操作将需要释放的许可加回去就完成了。</p><p>一旦线程调用<code>releaseShared</code>释放许可成功，就会同时调用<code>doReleaseShared</code>方法，其中会对阻塞的线程进行环型，下面是<code>tryReleaseShared</code>的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 拿到当前的许可数量</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">// 加上还回来的许可</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 原子操作 归还许可</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="减少许可数量以及将剩余许可数量都取走"><a href="#减少许可数量以及将剩余许可数量都取走" class="headerlink" title="减少许可数量以及将剩余许可数量都取走"></a>减少许可数量以及将剩余许可数量都取走</h4><p>Semaphore还提供了几个额外的操作许可的方法</p><ul><li><p>减少许可数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">        <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取走剩余全部许可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实际使用信号量的代码实例"><a href="#实际使用信号量的代码实例" class="headerlink" title="实际使用信号量的代码实例"></a>实际使用信号量的代码实例</h3><p>如下：使用信号量做了一个限流的功能。</p><p>在1000个线程并发访问的情况下，每次限制只有100个线程能够获取到资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreStudy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 许可的数量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 线程数量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1000</span>;</span><br><span class="line">  <span class="comment">// 获取许可失败的次数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger F = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 获取许可成功的次数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger S = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 声明许可</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Semaphore store = <span class="keyword">new</span> Semaphore(N);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 使用栅栏模拟1000并发</span></span><br><span class="line">    CyclicBarrier BARRIER = <span class="keyword">new</span> CyclicBarrier(M + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用线程池创建线程</span></span><br><span class="line">    ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">      pool.execute(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              BARRIER.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            getData();</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"等待2秒执行并发1000线程"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 等待两秒后打开栅栏 并发获取数据开始执行</span></span><br><span class="line">    BARRIER.await();</span><br><span class="line">    pool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 模拟获取数据或者业务处理 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!store.tryAcquire()) &#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">5000</span> + <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(<span class="string">"没有可用资源，等待一小会儿: "</span> + a + <span class="string">"，目前："</span> + F.incrementAndGet());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(a);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"成功拿到资源"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    store.release();</span><br><span class="line">    System.out.println(<span class="string">"释放资源，现在："</span> + S.incrementAndGet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/fm.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Semaphore" scheme="http://zhangjiaheng.cn/tags/Semaphore/"/>
    
      <category term="信号量" scheme="http://zhangjiaheng.cn/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(四)：理解ThreadPoolExecutor线程池</title>
    <link href="http://zhangjiaheng.cn/blog/20190617/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%EF%BC%9A%E7%90%86%E8%A7%A3ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://zhangjiaheng.cn/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/</id>
    <published>2019-06-17T06:19:07.000Z</published>
    <updated>2019-06-24T08:14:12.684Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png" alt="线程池"></p><a id="more"></a><h3 id="前言：关于ThreadPoolExecutor"><a href="#前言：关于ThreadPoolExecutor" class="headerlink" title="前言：关于ThreadPoolExecutor"></a>前言：关于ThreadPoolExecutor</h3><p><strong>ThreadPoolExecutor</strong>即我们常说的线程池。《阿里巴巴Java手册》中对于线程池的使用规定如下：</p><blockquote><p><strong>3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong><br><br><strong>说明：使用线程池的好处是减少线程在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量的同类线程而导致消耗完内存或者“过度切换”的问题​</strong></p></blockquote><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><h4 id="使用线程池创建线程可以"><a href="#使用线程池创建线程可以" class="headerlink" title="使用线程池创建线程可以"></a>使用线程池创建线程可以</h4><ul><li>避免在应用中频繁的创建和销毁线程</li><li>使用线程池创建线程可以复用CPU资源</li><li>提高线程的可管理性</li></ul><h3 id="使用线程池的风险"><a href="#使用线程池的风险" class="headerlink" title="使用线程池的风险"></a>使用线程池的风险</h3><h4 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h4><p>线程池为“死锁”这一概念带来了一种新的可能：线程饥饿死锁。在线程池中，如果一个任务将另一个任务提交到同一个Executor，那么通常会引发死锁。第二个线程停留在工作队列中等待第一个提交的任务执行完成，但是第一个任务又无法执行完成，因为它在等待第二个任务执行完成。如下代码所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadPoolDeadLock &#123;</span><br><span class="line">    static ExecutorService singlePool = Executors.newSingleThreadExecutor();</span><br><span class="line">    static class MyTask implements Callable&lt;String&gt; &#123;</span><br><span class="line">        String name;</span><br><span class="line">        public MyTask(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            Future&lt;String&gt; inner = singlePool.submit(new MyTask(&quot;inner&quot;));</span><br><span class="line">            return inner.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        Future&lt;String&gt; result = singlePool.submit(new MyTask(&quot;outer&quot;));</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在更大的线程池中，如果所有线程都由于等待其他仍处于工作队列的任务而阻塞，那么会发生同样的问题，这种情况被称为线程饥饿死锁。</p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>除了Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。如果线程池的大小设置的不合理就会有可能导致内存溢出的风险。还有就是Java预置线程池FixedThreadPool 和 SingleThreadPool中的阻塞队列使用的无界队列，最多可以保存2147483647个任务，如果代码编写不严谨就会堆积大量请求导致内存溢出。</p><h4 id="线程泄漏"><a href="#线程泄漏" class="headerlink" title="线程泄漏"></a>线程泄漏</h4><p>各种线程池都会导致一种问题就是线程泄漏。当从线程池取出一个线程去执行任务时，如果任务抛出RuntimeException 或一个Error而未捕获异常时，那么线程只会退出而线程池的大小将永远减少一个，当这种情况发生多次时，线程池最终就会为空并且因为没有可用的线程来处理任务。</p><h3 id="如果要自己实现线程池需要关注哪些点"><a href="#如果要自己实现线程池需要关注哪些点" class="headerlink" title="如果要自己实现线程池需要关注哪些点"></a>如果要自己实现线程池需要关注哪些点</h3><ul><li>首先要有一个存放线程的容器并设置容量</li><li>还需要一个存放用户提交的任务的容器，阻塞队列，有界还是无界</li><li>线程池创建的时候需要将指定数量的线程启动</li><li>用户提交任务的时候如果线程池没有空闲的线程如何创建线程并放入线程池</li><li>线程数量远大于用户提交的任务数量需要有一个回收线程的机制</li><li>线程全部在执行任务的时候存放的任务需要等待还是怎样或者再新加入任务时要提供一个饱和策略</li></ul><h3 id="ThreadPoolExecutor构造函数参数意义"><a href="#ThreadPoolExecutor构造函数参数意义" class="headerlink" title="ThreadPoolExecutor构造函数参数意义"></a>ThreadPoolExecutor构造函数参数意义</h3><p><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/gzhs.png" alt="构造函数"><br>ThreadPoolExecutor提供了四种构造函数，总共有如下几种参数，意义为：</p><ul><li><code>int corePoolSize</code>: 核心线程数的大小，在线程池创建的时候就会创建这么多线程待命，用户提交任务之后立即开始执行任务</li><li><code>int maximumPoolSize</code>: 最大线程数的大小，即最多会创建这么多线程，当超过这个数目的时候可能会在执行完任务之后回收多于核心线程数的线程</li><li><code>long keepAliveTime</code>: 线程最大存活时间，是相对于核心线程数来讲的。没有超过核心线程数的会一直存活的。超过的才有存活时间的限制</li><li><code>TimeUnit unit</code>: 时间单位</li><li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 阻塞队列，用于存放用户提交的任务。系统预置的线程池的阻塞队列一般都是无界的LinkBlockingQueue，但是建议使用有界队列，对于非常大或者无界的线程池，可以使用同步移交队列控制避免排队，直接将任务从生产者移交到工作者线程。</li><li><code>ThreadFactory threadFactory</code>: 线程工厂接口。只有一个newThread方法。便于用户根据业务需要实现自己的线程创建机制。</li><li><code>RejectedExecutionHandler handler</code>: 饱和策略。默认四种，在下面讲解。</li></ul><h3 id="几种默认的饱和策略"><a href="#几种默认的饱和策略" class="headerlink" title="几种默认的饱和策略"></a>几种默认的饱和策略</h3><p>当有界队列被填满后，用户创建的任务无法再添加到线程池中保存，饱和策略开始发挥作用。如果某个任务被提交到已关闭的Executors时，饱和策略也会被执行。饱和策略的实现需要实现接口<code>RejectedExecutionHandler</code>。<br><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/bhcl.png" alt="四种默认的饱和策略"><br>如上，在ThreadPoolExecutor类中有四个内部类实现了<code>RejectedExecutionHandler</code>接口。分别是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class DiscardPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br></pre></td></tr></table></figure></p><h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><p>“中止”策略是默认的饱和策略，该策略将会抛出一个异常<code>RejectedExecutionException</code>，调用者可以捕获这个异常然后编写自己的业务代码。</p><h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><p>“抛弃”策略会在新提交的任务无法保存在队列中等待执行时将其抛弃掉。</p><h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><p>同“抛弃”策略，这种策略会将即将执行的那个任务抛弃掉，即抛弃最老的任务然后尝试提交新的任务。如果工作队列使用的是优先队列，那么会导致优先级最高的任务被抛弃，<strong>慎用</strong>！</p><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><p>“调用者执行”策略即在队列满的时候由调用者去执行该任务。不会在线程池的某个线程中执行新的任务。</p><blockquote><p>《阿里巴巴Java开发手册》中强调使用线程池的时候尽量使用ThreadPoolExecutor，目的在于让程序员更加明确线程池的工作机制，实际业务中不可能在任务满时将任务抛弃掉，所以实现自己的饱和策略是有必要的。</p></blockquote><h3 id="Java预置线程池及其使用场景"><a href="#Java预置线程池及其使用场景" class="headerlink" title="Java预置线程池及其使用场景"></a>Java预置线程池及其使用场景</h3><p>如图是Executors类中的所有方法<br><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcgz.png" alt="预置线程池构造"></p><h4 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                              <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                              <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限容量的线程池(最大为2147483647)，调用ThreadPoolExecutor构造传入的核心线程数为0。适合场景为创建执行时间短效快速的线程任务，线程在执行完成之后直接被回收。阻塞队列使用SynchronousQueue，这是一个不保存数据的队列，因为该线程池有任务提交就会创建线程去执行，所以不需要保存</p><h4 id="Executors-newFixedThreadPool-nThreads"><a href="#Executors-newFixedThreadPool-nThreads" class="headerlink" title="Executors.newFixedThreadPool(nThreads)"></a>Executors.newFixedThreadPool(nThreads)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建固定数量的线程池。调用ThreadPoolExecutor的构造函数传入的核心线程数等于最大线程数。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。</p><h4 id="Executors-newSingleThreadExecutor-："><a href="#Executors-newSingleThreadExecutor-：" class="headerlink" title="Executors.newSingleThreadExecutor()："></a>Executors.newSingleThreadExecutor()：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都只有一个线程去执行任务，用户提交的任务都会排队阻塞在阻塞队列中等待上一个任务执行完之后执行下一个。适用场景为后面任务依赖前面任务的情况。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。使用这个线程池需要小心<a href="#线程饥饿死锁">线程饥饿死锁</a></p><h4 id="Executors-newWorkStealingPool"><a href="#Executors-newWorkStealingPool" class="headerlink" title="Executors.newWorkStealingPool()"></a>Executors.newWorkStealingPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前可用的线程数量进行创建作为并行级别，通过源码可以看出底层调用的是ForkJoinPool线程池，newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中。</p><h4 id="Executors-newScheduledThreadPool"><a href="#Executors-newScheduledThreadPool" class="headerlink" title="Executors.newScheduledThreadPool()"></a>Executors.newScheduledThreadPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">↑↑↑</span><br><span class="line">↓↓↓</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设定延迟时间，定期执行。通过源码可以看出底层调用的是一个ScheduledThreadPoolExecutor，然后传入线程数量。同newWorkStealingPool一样也不是直接使用ThreadPoolExecutor进行扩展。可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</p><h3 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>设置线程池状态为关闭，但是只会关闭已经执行完成的线程，对于还未执行完成的线程，会等待执行完成再关闭。</p><p>当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。</p><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><p>立马关闭线程池，线程池里的任务不再执行。</p><p>如果我们调用shutdownNow方法时，线程处于从队列里读取任务而阻塞中，则会导致抛出InterruptedException异常</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png&quot; alt=&quot;线程池&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://zhangjiaheng.cn/tags/ThreadPoolExecutor/"/>
    
      <category term="线程池" scheme="http://zhangjiaheng.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的几种非递归遍历</title>
    <link href="http://zhangjiaheng.cn/blog/20190613/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <id>http://zhangjiaheng.cn/blog/20190613/二叉树的几种非递归遍历/</id>
    <published>2019-06-13T09:36:48.000Z</published>
    <updated>2019-06-24T08:14:52.771Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190613/二叉树的几种非递归遍历/fm.jpg" alt="封面"></p><a id="more"></a><h2 id="二叉树的几种非递归遍历解法"><a href="#二叉树的几种非递归遍历解法" class="headerlink" title="二叉树的几种非递归遍历解法"></a>二叉树的几种非递归遍历解法</h2><p>二叉树的递归遍历想必了解递归以及二叉树的同学都能够轻松写出正确答案，然而二叉树的非递归遍历确是很多人难以理解学会的，所以我在这里进行一下归纳总结，主要是复习巩固一下这方面的知识。</p><h3 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将根节点入栈</li><li>然后循环判断栈不为空</li><li>则弹出栈顶元素</li><li>如果弹出元素的右子树不为空则入栈</li><li>如果弹出元素的左子树不为空则入栈</li><li>继续循环</li></ul><p>解析：由于先序遍历为[根-左-右]，所以根节点应该先入栈，然后出栈的同时依次入栈右-左子树即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">frontPrintByLoop</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将根节点入栈</li><li>循环判断根节点是否有左子树，有则入栈继续循环，否则循环结束</li><li>然后循环判断栈不为空</li><li>则弹出栈顶元素</li><li>如果栈顶元素右子树不为空</li><li>则循环入栈右子树及其右子树的左子树</li><li>继续循环</li></ul><p>解析：因为中序遍历为[左-根-又]，所以树的左子树应该先入栈，循环入栈左子树之后循环出栈，出栈的同时判断出栈元素是否有右子树，如果右子树不为空则对右子树执行相同的操作，即入栈右子树的左子树。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midPrintByLoop</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            TreeNode n = node.right;</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(n);</span><br><span class="line">                n = n.left;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h4><ul><li>逆向思考先序遍历，因为后序遍历为[根-左-右]，我们可以以类似先序遍历的方式先将[右-左-根]的顺序找出来存入另一个栈，然后再依次出栈该栈元素即可</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastPrintByOtherStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;TreeNode&gt; stackReverse = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stackReverse.push(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackReverse.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stackReverse.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h4><ul><li>只使用一个栈</li><li>先将根节点入栈</li><li>设置一个标识引用 h首先指向root</li><li>循环判断栈非空</li><li>在循环中判断栈顶元素node</li><li>如果node左子树不为空并且左右子树都不为h指向的元素</li><li>入栈左子树</li><li>否则再判断右子树是否为空以及右子树是否为h节点</li><li>入栈右子树</li><li>否则，弹出栈顶元素，并且将h指向该弹出的栈顶元素</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码 2"></a>代码 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastPrintByOneStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        TreeNode h = root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.left != h &amp;&amp; node.right != h) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != node.right &amp;&amp; node.right != h) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">                h = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：使用一个栈进行后序遍历的时候需要使用一个h引用来标识上一个节点是否被遍历过，是的话就往上判断之后的树节点即可。</p><h3 id="按层遍历二叉树"><a href="#按层遍历二叉树" class="headerlink" title="按层遍历二叉树"></a>按层遍历二叉树</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>以上前中后序遍历二叉树都是用到了栈这种数据结构，而按层遍历二叉树就非常简单了，只需要引入先入先出的队列，然后依次在出队的时候将出队元素的左右子树入队即可。</p><ul><li>根节点入队</li><li>队列不为空则开始循环</li><li>如果队首元素左子树不为空，就入队</li><li>右子树不为空，也入队</li><li>队首元素出队输出</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelPrintOutTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        TreeNode i = root;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(i.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(i.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i.val + <span class="string">" | "</span>);</span><br><span class="line">            queue.poll();</span><br><span class="line">            i = queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190613/二叉树的几种非递归遍历/fm.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>深度分析如何写出一个线程安全的单例</title>
    <link href="http://zhangjiaheng.cn/blog/20190607/%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B/"/>
    <id>http://zhangjiaheng.cn/blog/20190607/深度分析如何写出一个线程安全的单例/</id>
    <published>2019-06-07T12:51:33.000Z</published>
    <updated>2019-06-24T08:20:06.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190607/深度分析如何写出一个线程安全的单例/fm.png" alt="封面"></p><a id="more"></a><h3 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h3><p>单例模式是在Java编程中除了工厂模式之外最常用的创建型设计模式之一。单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。</p><p><strong>单例模式在创建时的注意事项：</strong></p><ul><li>因为每个类只能创建一个实例，所以需要将其构造方法封闭起来不能被外部调用，即私有化；</li><li>需要提供一个获取类实例的公有方法，所有使用该类实例的人都通过这个方法拿到单例对象；</li><li>在多线程环境下需要注意线程安全问题，避免多个线程同时创建出多个不同的实例，违背了单例的原则。</li></ul><h3 id="创建单例模式的方法及其优缺点"><a href="#创建单例模式的方法及其优缺点" class="headerlink" title="创建单例模式的方法及其优缺点"></a>创建单例模式的方法及其优缺点</h3><h4 id="饿汉型"><a href="#饿汉型" class="headerlink" title="饿汉型"></a>饿汉型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton INSTANCE = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取类在加载的时候就创建好的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：饿汉型单例是最简单的单例创建方法，在类中维护一个该类私有不可变的实例，然后提供一个获取该实例的静态方法即可。</li><li>优点：代码编写简单，线程安全（使用类加载机制保证线程安全，classloader在加载类的时候使用synchronized同步）</li><li>缺点：无法实现懒加载，在使用较少的时候浪费资源，无法防止反射破坏以及反序列化破坏单例唯一性</li></ul><h4 id="普通懒汉型"><a href="#普通懒汉型" class="headerlink" title="普通懒汉型"></a>普通懒汉型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton INSTANCE ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == INSTANCE)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：这种懒汉型单例也是一种比较简单的单例实现方式，与第一种不同在于这种实例是在调用获取实例的静态方法的时候才创建</li><li>优点：代码简单，可以实现懒加载</li><li>缺点：多线程环境下会有线程安全问题，多个线程同时走到第8行代码，判断实例未创建，则会创建出多个实例;无法防止反射破坏以及反序列化破坏</li></ul><p><em>那么为了实现线程安全我们可以在方法上加上同步关键字，但是这种方式的缺点就是多线程环境调用该方法都会阻塞，导致性能存在不必要的浪费</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == INSTANCE)&#123;</span><br><span class="line">INSTANCE = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="双重检测锁实现懒加载单例"><a href="#双重检测锁实现懒加载单例" class="headerlink" title="双重检测锁实现懒加载单例"></a>双重检测锁实现懒加载单例</h4><p>上述懒汉型同步机制可以改进如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleLockSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DoubleLockSingleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleLockSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 进入方法后先判断一次 大幅减少多线程环境同步阻塞问题 </span></span><br><span class="line"><span class="comment">// 但是这种方式在多线程第一次调用创建实例的时候会出现线程安全问题</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleLockSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line"><span class="comment">// 问题的根源所在</span></span><br><span class="line"><span class="comment">// 此处可能会出现指令重排序 </span></span><br><span class="line"><span class="comment">// new对象并不是原子操作</span></span><br><span class="line">INSTANCE = <span class="keyword">new</span> DoubleLockSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：双重检测锁机制在进入<code>getInstance()</code>方法的时候会判断实例是否被创建，如果被创建，那么直接返回，如果没有，进入同步代码块，创建实例。这个方法貌似没有问题，而且还大大减少线程进入同步代码块阻塞的情况（因为只有第一次判断对象还没有创建的时候才会有线程进入同步代码块）。但是这种方法仍然存在线程安全性问题。<font color="#db1414">问题出在第17行：<code>INSTANCE = new DoubleLockSingleton();</code>由于JVM虚拟机内部会对代码进行优化，在使用new创建对象的时候并不是一个原子操作且会被虚拟机进行指令重排序。这个步骤会被分成三步：<strong>1、在堆上为对象分配空间；2、对象进行初始化；3、将引用指向该堆上的地址。 </strong>由于在虚拟机中，指令重排序优化导致第2步和第3步的执行顺序可以被打乱，那么在代码执行到第11行的时候发现，INSTANCE不为null，直接返回一个未初始化完成的对象，导致程序崩溃。</font><strong>注意：synchronzed关键字没有屏蔽指令重排序的功能</strong>，那么如何优化呢？答案是使用<code>volatile</code>关键字修饰实例变量引用，即<code>private volatile static TripleLockSingleton INSTANCE;</code>。<code>volatile</code>关键字才有屏蔽指令重排序的语义。</li><li>优点：多线程环境下大部分时间线程安全</li><li>缺点：有可能会出现线程安全问题；不能避免反射和反序列化破坏</li><li>优化：<code>private volatile static TripleLockSingleton INSTANCE;</code></li></ul><h4 id="静态内部类单例"><a href="#静态内部类单例" class="headerlink" title="静态内部类单例"></a>静态内部类单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton INSTANCE = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：静态内部类实现单例也是借助了类加载的线程安全机制，并同时基于内部类的使用时再创建的懒加载机制实现线程安全的懒加载模式的单例</li><li>优点：线程安全，可以实现懒加载</li><li>缺点：无法防止被反射以及反序列化破坏单例的唯一性</li></ul><h4 id="枚举类单例"><a href="#枚举类单例" class="headerlink" title="枚举类单例"></a>枚举类单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：<strong>Joshua Bloch</strong>大神说过：“单元素的枚举类型已经成为实现Singleton的最佳方法”。足以见证枚举类在创建单例中的优势。</li><li>优点：代码简单，线程安全，可以防止反射和反序列化破坏</li><li>缺点：暂无</li></ul><h4 id="CAS创建单例"><a href="#CAS创建单例" class="headerlink" title="CAS创建单例"></a>CAS创建单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;CASSingleton&gt; INSTANCE = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CASSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用原子操作 实现获取唯一实例</span></span><br><span class="line"><span class="comment">     * 理论上在大量竞争的环境中 原子操作自旋等待消耗大量性能 但是实际上当一个线程创建好实例之后其余线程不会出现死循环</span></span><br><span class="line"><span class="comment">     * 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CASSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            CASSingleton instance = INSTANCE.get();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != instance) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> CASSingleton();</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE.compareAndSet(<span class="keyword">null</span>, instance)) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：使用原子操作<code>AtomicReference</code>进行单例的创建，事实上目前相对于双重检查锁性能上差的也不是也别大</li><li>优点：线程安全，懒加载，相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</li><li>缺点：代码编写相对复杂，不能防止被反射和反序列化破坏</li></ul><h3 id="防止反射和反序列化破坏单例的方式"><a href="#防止反射和反序列化破坏单例的方式" class="headerlink" title="防止反射和反序列化破坏单例的方式"></a>防止反射和反序列化破坏单例的方式</h3><p>上述几个创建单例的方式中，除了使用枚举类创建单例，都会产生被反射和反序列化破坏的情况，避免该问题的方式如下，大家需要深究的话可以打开搜索引擎… 这里不再展开了~</p><h4 id="枚举类防止反射和反序列化破坏"><a href="#枚举类防止反射和反序列化破坏" class="headerlink" title="枚举类防止反射和反序列化破坏"></a>枚举类防止反射和反序列化破坏</h4><blockquote><p><strong> 参考文章：<a href="https://www.cnblogs.com/chiclee/p/9097772.html" target="_blank" rel="noopener">https://www.cnblogs.com/chiclee/p/9097772.html</a> </strong></p></blockquote><h4 id="防止反射破坏"><a href="#防止反射破坏" class="headerlink" title="防止反射破坏"></a>防止反射破坏</h4><p>因为反射是通过class对象来调用类的构造方法创建对象的，我们只需要在构造方法中进行判断，如果实例已经存在，就抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(INSTANCE != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="防止反序列化破坏"><a href="#防止反序列化破坏" class="headerlink" title="防止反序列化破坏"></a>防止反序列化破坏</h4><p>在反序列化的时候<code>ObjectInputStream.readObject()</code>中会去判断是否存在<code>readResolve()</code>方法，如果存在的话会调用该方法返回一个实例，所以在单例类中编写<code>readResolve()</code>方法返回<code>INSTANCE</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在反序列化时，直接调用这个方法，返回指定的对象，无需再新建一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190607/深度分析如何写出一个线程安全的单例/fm.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://zhangjiaheng.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(三)：CountDownLatch的实现原理及使用</title>
    <link href="http://zhangjiaheng.cn/blog/20190602/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%89-%EF%BC%9ACountDownLatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://zhangjiaheng.cn/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/</id>
    <published>2019-06-02T13:36:53.000Z</published>
    <updated>2019-06-24T08:14:12.663Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png" alt="什么是CountDownLatch？"></p><a id="more"></a><h3 id="什么是CountDownLatch？"><a href="#什么是CountDownLatch？" class="headerlink" title="什么是CountDownLatch？"></a>什么是<code>CountDownLatch</code>？</h3><p>  在本篇博客的封面，我放了一个截图，上面对于<code>CountDownLatch</code>的翻译是这样的：<em>闭锁，倒计时门闩</em>。其实顾名思义，<code>CountDownLatch</code>实际上就是一个计数器：<strong>计数-计数完成后做一些事</strong>。其实这个东西可以类比为一个水坝：当水还没有装满水库的时候水坝是关闭的，当水装满之后开闸放水，水库中的水”一起”涌出水库。</p><p>  拥有同样功能的还有<code>CyclicBarrier</code>这个类，但是这个类相对较复杂，并且相对于<code>CountDownLatch</code>还可以重复使用，实际上前者一般被叫做线程计数器，后者被叫做循环屏障，还是有很大区别的。这个 <strong>在后面再进行源码学习</strong>。</p><h3 id="CountDownLatch是如何实现的？"><a href="#CountDownLatch是如何实现的？" class="headerlink" title="CountDownLatch是如何实现的？"></a><code>CountDownLatch</code>是如何实现的？</h3><p>  同<code>ReentrantLock</code>类似，内部也是有一个实现了<code>AbstractQueueSynchronizer</code>的内部类。内部类做了父类的共享式的显示锁的方法实现，维护一个初始为N的状态<code>state</code>，每次有线程调用之后阻塞，然后<code>state</code>减1，直到减为0之后所有阻塞的线程重新开始执行。</p><h4 id="首先是内部类Sync的实现"><a href="#首先是内部类Sync的实现" class="headerlink" title="首先是内部类Sync的实现"></a>首先是内部类Sync的实现</h4><p>  构造器接收一个int参数初始化state的值。<code>tryAcquireShared()</code>方法不会对state做改变，当state不为0的时候返回-1即失败，当state等于0其返回1，表示计数器已经计数完成，<code>await()</code>方法不再阻塞。<code>tryReleaseShared()</code>方法会使用原子操作当<code>countDown()</code>被调用的时候释放一个state的占用，即state-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">      Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">          setState(count);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> getState();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">int</span> c = getState();</span><br><span class="line">              <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                  <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch的countDown方法"><a href="#CountDownLatch的countDown方法" class="headerlink" title="CountDownLatch的countDown方法"></a>CountDownLatch的countDown方法</h4><p>  countDown方法主要作用就是使state-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AQS中的<code>releaseShared()</code>方法的实现，如果释放成功执行<code>doReleaseShared();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch的await方法"><a href="#CountDownLatch的await方法" class="headerlink" title="CountDownLatch的await方法"></a>CountDownLatch的await方法</h4><p>  await方法会等待当前state值是否是0，如果不是的话就一直阻塞。直到state为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AQS中的<code>acquireSharedInterruptibly()</code>方法实现如下，在AQS的实现中，判断当前线程是否中断，是的话抛出中断异常，否则判断当前线程是否继续需要阻塞，即调用<code>tryAcquireShared()</code>。是的话进入<code>doAcquireSharedInterruptibly()</code>方法，不断的判断<code>int r = tryAcquireShared(arg);</code>，state如果一直不等于0，r就一直是负数，就会继续进入循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实以上代码的整体流程非常简单，即初始化<code>CountDownLatch</code>的state=N，每次调用countDown时state-1，减到0的时候停止阻塞，继续向下执行。</p><h3 id="我可以用CountDownLatch来做什么事情？"><a href="#我可以用CountDownLatch来做什么事情？" class="headerlink" title="我可以用CountDownLatch来做什么事情？"></a>我可以用<code>CountDownLatch</code>来做什么事情？</h3><h4 id="使用CountDownLatch模拟并发场景"><a href="#使用CountDownLatch模拟并发场景" class="headerlink" title="使用CountDownLatch模拟并发场景"></a>使用<code>CountDownLatch</code>模拟并发场景</h4><ul><li>可以使用<code>CountDownLatch</code>，创建多个线程并等待线程全部就绪之后唤醒所有线程。可以用这种方式测试代码的可用性，或者测试单例类等；</li></ul><p>我在自己学习过程中也有写过类似的测试类 - <a href="https://github.com/Fatezhang/Concurrent/tree/master/src/main/java/com/mime/concurrent/CountDownLatchStudy" target="_blank" rel="noopener">github</a></p><h4 id="使用CountDownLatch等待依赖线程执行"><a href="#使用CountDownLatch等待依赖线程执行" class="headerlink" title="使用CountDownLatch等待依赖线程执行"></a>使用<code>CountDownLatch</code>等待依赖线程执行</h4><ul><li><code>CountDownLatch</code>用来等待其他依赖服务都启动好之后在进行自身线程的任务处理</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  <code>CountDownLatch</code>是面试的时候多线程这块很容易被问到的点，实际上会考察这几个方面：</p><ul><li>1、内部实现原理 <strong>——</strong> 使用内部类继承AQS实现；</li><li>2、需要注意的方面 <strong>——</strong> 计数器为0时，await后面的方法才会执行，否则一直阻塞，countDown方法尽量写在finally代码块中，避免出现异常导致死锁；</li><li>3、使用场景 <strong>——</strong> 监控一些依赖服务启动完成之后执行代码，或者造“水坝”，即模拟大量并发场景等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png&quot; alt=&quot;什么是CountDownLatch？&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AQS" scheme="http://zhangjiaheng.cn/tags/AQS/"/>
    
      <category term="CountDownLatch" scheme="http://zhangjiaheng.cn/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>编写自己的SpringMVC框架</title>
    <link href="http://zhangjiaheng.cn/blog/20190531/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84SpringMVC%E6%A1%86%E6%9E%B6/"/>
    <id>http://zhangjiaheng.cn/blog/20190531/编写自己的SpringMVC框架/</id>
    <published>2019-05-31T07:25:00.000Z</published>
    <updated>2019-06-24T08:20:06.216Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190531/编写自己的SpringMVC框架/aaa.jpeg" alt="封面"><br><a id="more"></a></p><h2 id="Summer项目"><a href="#Summer项目" class="headerlink" title="Summer项目"></a>Summer项目</h2><p><strong><a href="https://github.com/Fatezhang/Summer" target="_blank" rel="noopener">项目github地址</a></strong></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>Summer项目是本人在学习Spring源码的时候按照SpringMVC的流程编写的一个简易的SpringMVC框架，主要完成以下功能：<ul><li>读取配置文件进行包的扫描</li><li>对所有加入注解的bean进行装配</li><li>对加了注解的字段进行依赖自动注入</li><li>URL与相应方法的映射</li><li>请求的分发处理</li></ul></li></ul><p>项目通过实现以上流程完成SpringMVC框架工作的整体过程演示</p><h3 id="以下是框架流程的详细步骤说明"><a href="#以下是框架流程的详细步骤说明" class="headerlink" title="以下是框架流程的详细步骤说明"></a>以下是框架流程的详细步骤说明</h3><h4 id="项目的结构"><a href="#项目的结构" class="headerlink" title="项目的结构"></a>项目的结构</h4><p>Summer项目仅仅是一个单独的Servlet项目，没有引入Spring相关的任何依赖，仅仅使用了一些外部的工具类，我的pom.xml文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.3.12.v20160915<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>项目使用jetty启动，所以我还配置了jetty插件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- jetty插件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jetty-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>0<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/Summer<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">connectors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">connector</span> <span class="attr">implementation</span>=<span class="string">"org.mortbay.jetty.nio.SelectChannelConnector"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">port</span>&gt;</span>4000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">connectors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="整体框架结构"><a href="#整体框架结构" class="headerlink" title="整体框架结构"></a>整体框架结构</h4><p><img src="/blog/20190531/编写自己的SpringMVC框架/zj.png" alt="注解"><br>除了自定义的这几个注解之外其他的就和平常编写Controller以及Service的流程一样，我的核心代码主要在MyServlet中</p><h4 id="MyServlet主要做了什么"><a href="#MyServlet主要做了什么" class="headerlink" title="MyServlet主要做了什么"></a>MyServlet主要做了什么</h4><h5 id="加载配置文件，首先读取web-xml中配置的配置文件"><a href="#加载配置文件，首先读取web-xml中配置的配置文件" class="headerlink" title="加载配置文件，首先读取web.xml中配置的配置文件"></a>加载配置文件，首先读取web.xml中配置的配置文件</h5><p>把扫描到的所有类全链路径名保存在list中</p><blockquote><p>以下是servlet的配置</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明Servlet对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面一句指定Servlet对象的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.zhang.summer.servlet.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面一句指定Servlet对象的完整位置，包含包名和类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config.properties<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下面一句是在启动时加载servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射Servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;servlet-name&gt;与上面&lt;Servlet&gt;标签的&lt;servlet-name&gt;元素相对应，不可以随便起名  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面一句话用于映射访问URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="遍历所有类，使用反射创建对象class-forName"><a href="#遍历所有类，使用反射创建对象class-forName" class="headerlink" title="遍历所有类，使用反射创建对象class.forName"></a>遍历所有类，使用反射创建对象<code>class.forName</code></h5><p>创建对象，将所有我们声明了自己注解的类加入到一个Map中，即IOC-Map</p><h5 id="遍历IOC-Map中的所有对象，进行依赖注入"><a href="#遍历IOC-Map中的所有对象，进行依赖注入" class="headerlink" title="遍历IOC-Map中的所有对象，进行依赖注入"></a>遍历IOC-Map中的所有对象，进行依赖注入</h5><p>在这里我只判断是<code>@MyController</code>注解的类才进行依赖注入</p><h5 id="处理URL和方法之间的映射"><a href="#处理URL和方法之间的映射" class="headerlink" title="处理URL和方法之间的映射"></a>处理URL和方法之间的映射</h5><p>将注解了<code>@MyRequestMapping</code>的类和方法路径拼接起来，对方法和拼接起来的url路径进行映射，并且对方法参数做特殊处理</p><h5 id="请求分发"><a href="#请求分发" class="headerlink" title="请求分发"></a>请求分发</h5><p>在doGet或者doPost请求中通过映射好的url-method找到方法进行请求的分发处理</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190531/编写自己的SpringMVC框架/aaa.jpeg&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringMVC框架" scheme="http://zhangjiaheng.cn/categories/SpringMVC%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Spring" scheme="http://zhangjiaheng.cn/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://zhangjiaheng.cn/tags/SpringMVC/"/>
    
      <category term="Servlet" scheme="http://zhangjiaheng.cn/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(二)：使用AQS编写可重入锁</title>
    <link href="http://zhangjiaheng.cn/blog/20190525/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%EF%BC%9A%E4%BD%BF%E7%94%A8AQS%E7%BC%96%E5%86%99%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <id>http://zhangjiaheng.cn/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/</id>
    <published>2019-05-25T06:07:35.000Z</published>
    <updated>2019-06-24T08:14:12.658Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/aqs.png" alt="AQS中文文档介绍"></p><div style="width:100%;text-align: center;"><a href="http://www.matools.com/api/java8" target="_blank" rel="noopener">AQS中文文档介绍</a></div><a id="more"></a><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong> <a href="/blog/20190517/编写一个简易的可重入锁-一/">上一章</a> </strong> 我使用实现<code>Lock</code>接口的方式并结合<code>Synchronized</code>关键字实现了自己的可重入锁，学习并了解了可重入锁的原理机制。这一章我在学习了AQS之后结合AQS实现自己的显示可重入锁。</p><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>如上所述，Java8中文文档中描述的，AQS即<code>AbstractQueuedSynchronizer</code>。它提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状态。 子类必须定义改变此状态的受保护方法，以及根据该对象被获取或释放来定义该状态的含义。 给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。<strong>子类应定义为非公共内部助手类，用于实现其封闭类的同步属性。 AbstractQueuedSynchronizer类不实现任何同步接口。 相反，它定义了一些方法，如acquireInterruptibly(int) ，可以通过具体的锁和相关同步器来调用适当履行其公共方法。</strong></p><p>其实AQS类是一个使用了模板方法模式的抽象框架类。它将核心实现封装在模板方法中，提供给程序员去实现具体的加锁和释放的机制，以便于实现一些特殊功能的锁，比如JDK提供的可重入锁和可重入读写锁等等。</p><h3 id="如何使用AQS"><a href="#如何使用AQS" class="headerlink" title="如何使用AQS"></a>如何使用AQS</h3><p><strong>AQS在使用的时候主要需要重写以下方法</strong></p><ul><li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><h3 id="使用AQS实现自己的可重入独占非公平锁的伪代码如下"><a href="#使用AQS实现自己的可重入独占非公平锁的伪代码如下" class="headerlink" title="使用AQS实现自己的可重入独占非公平锁的伪代码如下"></a>使用AQS实现自己的可重入独占非公平锁的伪代码如下</h3><h4 id="加锁步骤伪代码"><a href="#加锁步骤伪代码" class="headerlink" title="加锁步骤伪代码"></a>加锁步骤伪代码</h4><p>线程调用<code>lock</code>方法加锁，直接调用<code>sync.acquire(1);</code>，具体实现在<code>tryAcquire</code></p><ul><li>首先线程进入想要获取锁</li><li>拿到当前线程的引用</li><li>判断加锁状态，如果是未加锁状态<ul><li>使用<code>compareAndSetState</code>自旋原子操作加锁</li><li>设置当前线程</li><li>返回true加锁成功</li></ul></li><li>如果是加锁状态<ul><li>判断是否是当前线程重入</li><li>如果是当前线程重入，state加1，并返回true加锁成功</li></ul></li><li>最后如果都不是就返回false加锁失败</li></ul><h4 id="释放锁步骤伪代码"><a href="#释放锁步骤伪代码" class="headerlink" title="释放锁步骤伪代码"></a>释放锁步骤伪代码</h4><p>线程调用<code>unLock</code>方法加锁，直接调用<code>sync.release(1);</code>，具体实现在<code>tryRelease</code></p><ul><li>首先线程进入方法想要释放锁</li><li>判断如果不是当前线程，就抛出异常</li><li>如果是当前线程，state就减1（arg一般为1），表示释放一次</li><li>当state释放到0时，设置拥有锁的线程为null，然后返回true</li></ul><p><strong>具体的代码实现如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> zhangjiaheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 使用AQS重写一个可重入锁</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReentrantLockByAQS</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类Sync ReentrantLock使用的内部抽象类 并派生两个子类实现两种(公平/非公平)锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            Thread t = Thread.currentThread();</span><br><span class="line">            <span class="comment">// 如果第一个线程进来 可以拿到锁 则返回true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果第二个线程进来 如果不等于当前线程 返回false 否则更新当前线程值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> state = getState();</span><br><span class="line">            <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(t);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">// 当前线程再进来</span></span><br><span class="line">                setState(getState() + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 锁的获取和释放时一一对应的</span></span><br><span class="line">            <span class="comment">// 调用此方法的线程肯定是当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - arg;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newCondition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/aqs.png&quot; alt=&quot;AQS中文文档介绍&quot;&gt;&lt;/p&gt;
&lt;div style=&quot;width:100%;text-align: center;&quot;&gt;&lt;a href=&quot;http://www.matools.com/api/java8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AQS中文文档介绍&lt;/a&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="可重入锁" scheme="http://zhangjiaheng.cn/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
      <category term="AQS" scheme="http://zhangjiaheng.cn/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(一)：编写一个简易的可重入锁</title>
    <link href="http://zhangjiaheng.cn/blog/20190517/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E4%B8%80/"/>
    <id>http://zhangjiaheng.cn/blog/20190517/编写一个简易的可重入锁-一/</id>
    <published>2019-05-17T12:22:23.000Z</published>
    <updated>2019-06-24T08:20:06.178Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190517/编写一个简易的可重入锁-一/nullIsMistake.jpg" alt="封面"></p><a id="more"></a><h4 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h4><p>在Java多线程编程中，锁是用来控制代码操作的原子性的重要机制，即对某线程共享的数据进行操作的时候，保证该操作同一时间段只有一个线程操作，整个过程是原子操作，其他线程再操作的时候只能等待锁的释放(排他锁)。一般我们的锁都是声明在方法上或者代码块中，那么在实际编程中我们经常会出现一个类的实例方法调用另一个实例方法的情况，我们不希望这个时候同一个线程进入另一实例方法时还要再去等待锁的释放，可重入锁就是为了解决这个问题，即 <strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>。</p><h4 id="如何实现一个简单的可重入锁"><a href="#如何实现一个简单的可重入锁" class="headerlink" title="如何实现一个简单的可重入锁"></a>如何实现一个简单的可重入锁</h4><ul><li>首先加锁的时候需要记录当前是哪一个线程加锁，加锁之后加锁标志位标记锁已被占用</li><li>维护一个加锁计数器，线程每次加锁计数器都要加1，每释放一次计数器减1</li><li>当非占用锁的线程进来之后自旋等待锁的释放，如果锁还在被占用，就wait();</li><li>所释放的时候只有当前获取锁的线程调用才有用，锁释放加锁计数器减1，当减到0的时候，加锁标志位置为false，然后唤醒其他等待的线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;<span class="comment">// 当前锁是否已经被线程使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lockCount;<span class="comment">// 保存当前线程加锁的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread thread;<span class="comment">// 保存当前线程是哪一个</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">            <span class="comment">// 可重入：如果获取锁的不是当前线程并且当前已经有线程加锁，则等待</span></span><br><span class="line">            <span class="keyword">while</span> (locked &amp;&amp; Thread.currentThread() != <span class="keyword">this</span>.thread) &#123;</span><br><span class="line">                System.out.println(<span class="string">"我等会儿。。。"</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有线程使用锁或者获取锁的是当前线程 加锁计数器+1 然后thread指向获取锁的线程</span></span><br><span class="line">            <span class="keyword">this</span>.thread = Thread.currentThread();</span><br><span class="line">            lockCount++;</span><br><span class="line">            locked = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是当前线程 不需要做任何操作</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.thread == Thread.currentThread())&#123;</span><br><span class="line">                <span class="comment">// 锁计数器减1 如果当前线程获取锁个数释放完成</span></span><br><span class="line">                lockCount--;</span><br><span class="line">                <span class="keyword">if</span>(lockCount == <span class="number">0</span> )&#123;</span><br><span class="line">                    <span class="comment">// 释放完成 加锁标志置为false 再唤醒等待锁的线程</span></span><br><span class="line">                    locked = <span class="keyword">false</span>;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在Java中常用的可重入锁"><a href="#在Java中常用的可重入锁" class="headerlink" title="在Java中常用的可重入锁"></a>在Java中常用的可重入锁</h4><ul><li>synchronized 关键字加锁</li><li>java.util.concurrent.locks.ReentrantLock</li><li>java.util.concurrent.locks.ReentrantReadWriteLock<blockquote><p>上述ReentrantLock内部实际上还是使用AQS，关于AQS，后面还要进行学习与整理</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190517/编写一个简易的可重入锁-一/nullIsMistake.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="可重入锁" scheme="http://zhangjiaheng.cn/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://zhangjiaheng.cn/blog/20190512/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://zhangjiaheng.cn/blog/20190512/无重复字符的最长子串/</id>
    <published>2019-05-12T06:36:15.000Z</published>
    <updated>2019-06-24T08:20:06.243Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190512/无重复字符的最长子串/bb.png" alt="封面"></p><h4 id="算法题解：无重复字符的最长子串"><a href="#算法题解：无重复字符的最长子串" class="headerlink" title="算法题解：无重复字符的最长子串"></a>算法题解：无重复字符的最长子串</h4><p>leetcode地址： <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">leetcode</a></p><blockquote><p><strong>题目：</strong> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="解法1：暴力求解"><a href="#解法1：暴力求解" class="headerlink" title="解法1：暴力求解"></a>解法1：暴力求解</h4><ul><li><p>思路：遍历字符串，以每一个字符作为子串的起始字符，向后查找直到遇到和该字符相同的字符，记录长度，依次执行直到找到最长长度。</p></li><li><p>题解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIndexStrLength</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; s.length(); index++) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> i = index + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= s.length()) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           String ts = s.substring(index, i);</span><br><span class="line">           <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (ts.contains(c + <span class="string">""</span>)) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           length++;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       maxLength = maxLength &gt; length ? maxLength : length;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="解法2：滑动窗口法"><a href="#解法2：滑动窗口法" class="headerlink" title="解法2：滑动窗口法"></a>解法2：滑动窗口法</h4><ul><li>思路：在使用暴力解法时我们会发现实际上对于无重复子串来讲，我们产生了一些冗余的判断操作。例如对于串<code>sdabcabcbb</code>，判断了子串<code>sdabc</code>之后，当后面再出现字符<code>a</code>，那么重复字符之前的串直接舍弃就好。即直接从<code>bca</code>…开始判断即可。这样可以减少大量的不必要的判断与计算操作。</li><li>题解如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIndexStrLength</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">      <span class="comment">//如果当前元素与滑动窗口中的元素重复：</span></span><br><span class="line">      <span class="keyword">if</span> (map.containsKey(c) &amp;&amp; map.get(c) &gt;= start) &#123;</span><br><span class="line">          max = Math.max(max, i - start);</span><br><span class="line">          start = map.get(c) + <span class="number">1</span>;</span><br><span class="line">          <span class="comment">//如果当前元素与滑动窗口中的元素不重复，但已经遍历到了最后一个字符：</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">          max = Math.max(max, i - start + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      map.put(c, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>滑动窗口法的思路可以用来解决很多字符串相关的问题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190512/无重复字符的最长子串/bb.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;算法题解：无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#算法题解：无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;算法题解：无重复字符的最长子串&quot;&gt;&lt;/a&gt;算法题解：无重复字符的最长子串&lt;/h4&gt;&lt;p&gt;leetcode地址： &lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt; 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;span class=&quot;string&quot;&gt;&quot;abcabcbb&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 因为无重复字符的最长子串是 &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;，所以其长度为 &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化和transient关键字的理解与学习</title>
    <link href="http://zhangjiaheng.cn/blog/20190511/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8Ctransient%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zhangjiaheng.cn/blog/20190511/Java序列化和transient关键字的理解与学习/</id>
    <published>2019-05-11T12:44:31.000Z</published>
    <updated>2019-06-24T08:20:06.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h4><p><img src="/blog/20190511/Java序列化和transient关键字的理解与学习/xuliehua.png" alt="Java序列化过程"></p><blockquote><p>在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。</p></blockquote><a id="more"></a><h5 id="Java中如何进行序列化与反序列化"><a href="#Java中如何进行序列化与反序列化" class="headerlink" title="Java中如何进行序列化与反序列化"></a>Java中如何进行序列化与反序列化</h5><ul><li><p>在Java中，对象一般是无法进行序列化与反序列化的。而使得对象能够被序列化的方式也很简单，即实现接口 <code>Serializable</code> 。如下代码即将对象序列化以及反序列化的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerializable</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    TestSerializable() &#123;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        name = <span class="string">"aachuanpu"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        TestSerializable test = <span class="keyword">new</span> TestSerializable();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"e:/test.txt"</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class="line">        System.out.println(newTest.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h5><ul><li>serialVersionUID作为实现序列化接口的一个非必须非必须声明的静态常量经常不被开发者所重视，忘记声明。其实serialVersionUID的作用是为了保证序列化之前和之后的对象是同一对象。我们知道JVM判断对象是否相同是根据对象的类路径全限定名确定的，而虚拟机决定一个对象是否允许序列化和反序列化成这个类还取决于其serialVersionUID是否一致。不一致的话会导致<code>java.io.InvalidClassException的异常</code>，也可以不指定serialVersionUID，如果不指定的话java会根据class计算serialVersionUID。</li><li>对于两个相同的类及拥有相同的serialVersionUID，如果两个类字段不一致也会序列化和反序列化成功。这时Java会在反序列化的时候忽略掉不一致的字段。</li></ul><h5 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h5><ul><li><p>在序列化的时候，静态变量能够被序列化成功吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerializable</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    TestSerializable() &#123;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        name = <span class="string">"aachuanpu"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        TestSerializable test = <span class="keyword">new</span> TestSerializable();</span><br><span class="line">        TestSerializable.staticName = <span class="string">"name11111"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"e:/test.txt"</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        TestSerializable.staticName = <span class="string">"name222"</span>;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class="line">        System.out.println(newTest.name);</span><br><span class="line">        System.out.println(TestSerializable.staticName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上代码会输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aachuanpu</span><br><span class="line">name222</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li><li><p>如上所见：将对象序列化之后，修改静态变量的值，再将对象反序列化，输出的静态变量的值是修改之后的。即序列化保存的是对象的状态，静态变量属于类，因此序列化并不保存静态变量。</p></li></ul><h5 id="transient关键字与自定义序列化"><a href="#transient关键字与自定义序列化" class="headerlink" title="transient关键字与自定义序列化"></a>transient关键字与自定义序列化</h5><ul><li><p>对象的序列化是将对象中的数据写入本地文件或者用于网络传输的过程，但是很多时候会有一些数据无需进行序列化保存起来或者传输出去。我们可以使用<code>transient</code>关键字修饰成员变量。那么在Java序列化的时候就<strong>不会使用Java本身的序列化方式对其进行序列化</strong>。但是我们依然可以自定义自己的序列化行为对其进行序列化！</p><p><strong>自定义序列化：</strong> 定义自己的<code>writeObject</code>和<code>readObject</code>方法</p></li><li><p>对于使用transient修饰的成员变量，可以编写<code>writeObject</code>和<code>readObject</code>方法实现对于该成员变量(不仅仅只是针对该成员变量)的自定义序列化。在编写<code>writeObject</code>和<code>readObject</code>方法的时候需要注意的地方在于：这俩方法没有在Object中定义，也没有在<code>Serializable</code>接口中声明，JVM是如何调用到这俩方法的呢？答案是通过反射，去根据方法名和参数寻找到相应的方法，找到之后会被ObjectOutputStream调用，没有这俩方法就调用默认的序列化呗。还有就是因为ObjectOutputStream使用getPrivateMethod，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。</p></li><li><p>通过这种方法，我们实现自己的序列化与反序列化可以实现很多场景下的需求。比如网络传输的时候对于特殊字段进行加密等等。</p></li><li><p>如下，你会发现我在这俩方法中调用了defaultWriteObject()和defaultReadObject()用于处理未被transient修饰的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerializable</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name;</span><br><span class="line">    TestSerializable() &#123;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        name = <span class="string">"aachuanpu"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        TestSerializable test = <span class="keyword">new</span> TestSerializable();</span><br><span class="line">        TestSerializable.staticName = <span class="string">"name11111"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"e:/test.txt"</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        TestSerializable.staticName = <span class="string">"name222"</span>;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class="line">        System.out.println(newTest.name);</span><br><span class="line">        System.out.println(TestSerializable.staticName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream oos)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        oos.defaultWriteObject();</span><br><span class="line">        name = <span class="string">"自定义名称"</span>;</span><br><span class="line">        oos.writeObject(name);</span><br><span class="line">        System.out.println(<span class="string">"调用writeObject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ois.defaultReadObject();</span><br><span class="line">        String name = (String) ois.readObject();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">"读出的name="</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"调用readObject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">调用writeObject</span><br><span class="line">读出的name=自定义名称</span><br><span class="line">调用readObject</span><br><span class="line">自定义名称</span><br><span class="line">name222</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li></ul><h5 id="父类的序列化"><a href="#父类的序列化" class="headerlink" title="父类的序列化"></a>父类的序列化</h5><ul><li>一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取 父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都 是默认声明的值。</li></ul><h5 id="常问：ArrayList中数组使用transient修饰为何还能被序列化"><a href="#常问：ArrayList中数组使用transient修饰为何还能被序列化" class="headerlink" title="常问：ArrayList中数组使用transient修饰为何还能被序列化"></a>常问：ArrayList中数组使用transient修饰为何还能被序列化</h5><p>  <strong>ArrayList源码：</strong><br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure></p><p>  transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。但是ArrayList又是可序行化的类，elementData是ArrayList具体存放元素的成员，用transient来修饰elementData，需要实现自己的序列化方式去处理。即对于数组中多余的空间不去进行序列化。如下：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment"> * is, serialize it).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment"> *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span></span><br><span class="line"><span class="comment"> * deserialize it).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  <strong>elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。</strong></p><h5 id="其余补充"><a href="#其余补充" class="headerlink" title="其余补充"></a>其余补充</h5><p><a href="https://bluepopopo.iteye.com/blog/486548" target="_blank" rel="noopener">来自文章</a> ← 点击链接查看参考博客</p><blockquote><p>1.Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值;</p></blockquote><blockquote><p>2.Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。Serializable是内建支持的也就是直接implement即可，但Externalizable的实现类必须提供readExternal和writeExternal实现。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。</p></blockquote><blockquote><p>3.正如Effectvie Java中提到的，序列化就如同另外一个构造函数，只不过是有由stream进行创建的。如果字段有一些条件限制的，特别是非可变的类定义了可变的字段会反序列化可能会有问题。可以在readObject方法中添加条件限制，也可以在readResolve中做。参考56条“保护性的编写readObject”和“提供一个readResolve方法”。</p></blockquote><blockquote><p>4.当有非常复杂的对象需要提供deep clone时，可以考虑将其声明为可序列化，不过缺点也显而易见，性能开销。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Java序列化&quot;&gt;&lt;a href=&quot;#Java序列化&quot; class=&quot;headerlink&quot; title=&quot;Java序列化&quot;&gt;&lt;/a&gt;Java序列化&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/blog/20190511/Java序列化和transient关键字的理解与学习/xuliehua.png&quot; alt=&quot;Java序列化过程&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="序列化" scheme="http://zhangjiaheng.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="transient关键字" scheme="http://zhangjiaheng.cn/tags/transient%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>你的内心比拳头更强大</title>
    <link href="http://zhangjiaheng.cn/blog/20190509/%E4%BD%A0%E7%9A%84%E5%86%85%E5%BF%83%E6%AF%94%E6%8B%B3%E5%A4%B4%E6%9B%B4%E5%BC%BA%E5%A4%A7/"/>
    <id>http://zhangjiaheng.cn/blog/20190509/你的内心比拳头更强大/</id>
    <published>2019-05-09T15:37:36.000Z</published>
    <updated>2019-05-13T06:27:50.123Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">加密博客请输入密码访问</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      最近真的很不开心，将烦躁的感受记录下来吧~
    
    </summary>
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>使用[幕布]创建Java知识体系思维导图</title>
    <link href="http://zhangjiaheng.cn/blog/20190507/%E4%BD%BF%E7%94%A8-%E5%B9%95%E5%B8%83-%E5%88%9B%E5%BB%BAJava%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://zhangjiaheng.cn/blog/20190507/使用-幕布-创建Java知识体系思维导图/</id>
    <published>2019-05-07T11:24:43.000Z</published>
    <updated>2019-05-07T11:55:42.398Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190507/使用-幕布-创建Java知识体系思维导图/java_core.png" alt="Java思维导图"></p><a id="more"></a><p><strong>昨天在V2EX上逛的时候突然发现有人推荐一个很不错的东西——幕布。我本身就是一个对一些名称很敏感的人，看到这个名字就很想知道这到底是个什么东西，没想到竟偶然发现这么一个好东西。</strong></p><p>幕布是一个制作笔记与记录事件的文本编辑工具（这样说要把幕布开发者气死了哈哈）。编辑视图如下：<br><img src="/blog/20190507/使用-幕布-创建Java知识体系思维导图/mb.png" alt="幕布"><br>一键转换成思维导图就是本文最上面的那个图片。</p><p>其实我个人是比较喜欢幕布的一键转换思维导图的功能，以及它的导出.mm文件的功能，而且可以自动同步云端。这样就可以随时随地无论是在电脑还是手机上都可以打开来编辑以及查看了。</p><p>这里是我自己编写的<a href="https://mubu.com/doc/hpBd1e5h6z" target="_blank" rel="noopener">Java知识体系</a>，还没有写的很完整。希望自己能够坚持不断更新知识点，总结与巩固自己的技术水平！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190507/使用-幕布-创建Java知识体系思维导图/java_core.png&quot; alt=&quot;Java思维导图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树与完全二叉树</title>
    <link href="http://zhangjiaheng.cn/blog/20190504/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://zhangjiaheng.cn/blog/20190504/二叉搜索树与完全二叉树/</id>
    <published>2019-05-04T02:29:36.000Z</published>
    <updated>2019-06-24T08:20:06.226Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h4><p>在数据结构中，对于树，每一个分支，称之为一个度。那么，度最大为2的树我们称之为二叉树。通常子树我们会称之为左子树和右子树。二叉树通常用于实现二叉查找树和二叉堆。那么在Java中如何定义一个二叉树节点？</p><p>首先，每一个节点需要有一个值域。其次，其还应该持有两个树节点的引用，即指向自己的左子树和自己的右子树。</p><a id="more"></a><p>具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + val + <span class="string">")[left:"</span> + left + <span class="string">",right:"</span> + right + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="如何创建二叉树"><a href="#如何创建二叉树" class="headerlink" title="如何创建二叉树"></a>如何创建二叉树</h4><p>二叉树的节点的数据结构已经用Java代码表示出来了，那么如何用这些节点来构造出一个完整的二叉树呢？请看下图二叉树的结构：</p><p><img src="/blog/20190504/二叉搜索树与完全二叉树/ecs.png" alt="二叉树结构"></p><p>如上图，对于一个二叉树，需要有一个根节点。每个节点最多有两课子树，分别区分左子树还是右子树。即就算有一个子树，还是需要区分是左子树还是右子树。创建二叉树我们只需要将每一个树节点按照这样的规则连接起来即可。</p><h5 id="创建二叉搜索树"><a href="#创建二叉搜索树" class="headerlink" title="创建二叉搜索树"></a>创建二叉搜索树</h5><ul><li>概念：二叉搜索树，又叫二叉查找树。他是一棵特殊的二叉树，对于二叉搜索树中的每一个节点，它的左子树都不大于父节点，右子树都不小于父节点。空树是特殊的二叉搜索树。</li><li><p>创建：本例根据一个已有的数组进行二叉树的创建，基本的思路就是遍历数组，每个元素创建一个树节点，然后继续根据节点值得大小向下遍历判断，最后将值域小的放在节点的左子树，将值大的放在节点的右子树即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createSearchTree</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            TreeNode c = root;</span><br><span class="line">            TreeNode p = c;</span><br><span class="line">            TreeNode q = <span class="keyword">new</span> TreeNode(a[i]);</span><br><span class="line">            <span class="keyword">while</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p = c;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &lt;= c.val) &#123;</span><br><span class="line">                    c = c.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = c.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q.val &lt; p.val) &#123;</span><br><span class="line">                p.left = q;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p.right = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特点：二叉搜索树在应用于经常查找元素的场景效率会比较快，因为它的数据结构类似于二分查找，查找元素时根据其特性向下搜索即可。</p></li></ul><h5 id="创建完全二叉树"><a href="#创建完全二叉树" class="headerlink" title="创建完全二叉树"></a>创建完全二叉树</h5><ul><li><p>概念：首先介绍一下满二叉树：即树中的所有节点除了叶节点都有左子树和右子树，叶节点的左右子树都为空，这样的树称之为满二叉树。而对于一棵完全二叉树，只有树的最后一层连续缺失右边节点。满二叉树一定是完全二叉树，反之则不一定成立。如图分别是一棵满二叉树和一棵完全二叉树：<br><img src="/blog/20190504/二叉搜索树与完全二叉树/mecs.png" alt="满二叉树"><br><img src="/blog/20190504/二叉搜索树与完全二叉树/wqecs.png" alt="完全二叉树"></p></li><li><p>创建： 完全二叉树的创建需要按层去创建。这边我们借助队列的特点，将二叉树的节点连接起来，构造成完全二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createWholeTree</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(a[<span class="number">0</span>]);</span><br><span class="line">            queue.add(root);</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                TreeNode curn = queue.get(index);</span><br><span class="line">                TreeNode ti = <span class="keyword">new</span> TreeNode(a[i]);</span><br><span class="line">                queue.add(ti);</span><br><span class="line">                <span class="keyword">if</span> (curn.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    curn.left = ti;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curn.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    curn.right = ti;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>特点：对于一个h层的完全二叉树，前h-1层是满的，第h层连续缺失右边节点。所以叶子结点只能出现在最下层和次下层，最下层的叶子结点集中在树的左部，倒数第二层若存在叶子结点，一定在右部连续位置，如果结点度为1，则该结点只有左孩子，即没有右子树，同样结点数目的二叉树，完全二叉树深度最小。</p></li></ul><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><ul><li><p>前中后序递归遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归先序遍历二叉树 左-根-右</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">frontPrintOutTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        frontPrintOutTree(root.left);</span><br><span class="line">        frontPrintOutTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归中序遍历二叉树 左-根-右</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midPrintOutTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        midPrintOutTree(root.left);</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">        midPrintOutTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归先序遍历二叉树 左-根-右</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastPrintOutTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        lastPrintOutTree(root.left);</span><br><span class="line">        lastPrintOutTree(root.right);</span><br><span class="line">        System.out.print(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按层遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按层遍历二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelPrintOutTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        TreeNode i = root;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(i.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(i.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i.val);</span><br><span class="line">            queue.poll();</span><br><span class="line">            i = queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="以上代码的github地址：GITHUB地址"><a href="#以上代码的github地址：GITHUB地址" class="headerlink" title="以上代码的github地址：GITHUB地址"></a>以上代码的github地址：<a href="https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/src/main/java/DataStructure/Tree" target="_blank" rel="noopener">GITHUB地址</a></h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是二叉树？&quot;&gt;&lt;a href=&quot;#什么是二叉树？&quot; class=&quot;headerlink&quot; title=&quot;什么是二叉树？&quot;&gt;&lt;/a&gt;什么是二叉树？&lt;/h4&gt;&lt;p&gt;在数据结构中，对于树，每一个分支，称之为一个度。那么，度最大为2的树我们称之为二叉树。通常子树我们会称之为左子树和右子树。二叉树通常用于实现二叉查找树和二叉堆。那么在Java中如何定义一个二叉树节点？&lt;/p&gt;
&lt;p&gt;首先，每一个节点需要有一个值域。其次，其还应该持有两个树节点的引用，即指向自己的左子树和自己的右子树。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>如何在Springboot服务启动之后执行一些代码(三种方式)</title>
    <link href="http://zhangjiaheng.cn/blog/20190419/%E5%A6%82%E4%BD%95%E5%9C%A8springboot%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81(%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F)/"/>
    <id>http://zhangjiaheng.cn/blog/20190419/如何在springboot服务启动之后执行一些代码(三种方式)/</id>
    <published>2019-04-19T09:01:21.000Z</published>
    <updated>2019-06-24T08:20:06.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  通常的我们的项目开发中，经常会遇到那种在服务一启动就需要自动执行一些业务代码的情况。比如将数据库中的配置信息或者数据字典之类的缓存到redis，或者在服务启动的时候将一些配置化的定时任务开起来。关于spring mvc或者springboot如何在项目启动的时候就执行一些代码，方法其实有很多，我这边介绍一下我使用过的三种。</p>  <a id="more"></a><h4 id="1、-PostConstruct-注解"><a href="#1、-PostConstruct-注解" class="headerlink" title="1、@PostConstruct 注解"></a>1、<code>@PostConstruct</code> 注解</h4><p>从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，<code>@PostConstruct</code>和<code>@PreDestroy</code>，这两个注解被用来修饰一个非静态的void（）方法。<code>@PostConstruct</code>会在所在类的构造函数执行之后执行，在init()方法执行之前执行。(<code>@PreDestroy</code>注解的方法会在这个类的destory()方法执行之后执行。)</p><ul><li>使用示例：在Spring容器加载之后，我需要启动定时任务去做任务的处理（我的定时任务采用的是读取数据库配置的方式）。在这里我使用<code>@PostConstruct</code> 指定了需要启动的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 注意 这里必须有</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAllJobInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JobInfoService jobInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JobTaskUtil jobTaskUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">// 构造函数之后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"容器启动后执行"</span>);</span><br><span class="line">        startJob();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;JobInfoBO&gt; list = jobInfoService.findList();</span><br><span class="line">        <span class="keyword">for</span> (JobInfoBO jobinfo :list) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"0"</span>.equals(jobinfo.getStartWithrun()))&#123;</span><br><span class="line">                    logger.info(<span class="string">"任务&#123;&#125;未设置自动启动。"</span>, jobinfo.getJobName());</span><br><span class="line">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    logger.info(<span class="string">"任务&#123;&#125;设置了自动启动。"</span>, jobinfo.getJobName());</span><br><span class="line">                    jobTaskUtil.addOrUpdateJob(jobinfo);</span><br><span class="line">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">                logger.error(<span class="string">"执行定时任务出错，任务名称 &#123;&#125; "</span>, jobinfo.getJobName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、实现CommandLineRunner接口并重写run-方法"><a href="#2、实现CommandLineRunner接口并重写run-方法" class="headerlink" title="2、实现CommandLineRunner接口并重写run()方法"></a>2、实现<code>CommandLineRunner</code>接口并重写run()方法</h4><p><code>CommandLineRunner</code>接口文档描述如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@link</span> SpringApplication&#125;. Multiple &#123;<span class="doctag">@link</span> CommandLineRunner&#125; beans can be defined</span></span><br><span class="line"><span class="comment"> * within the same application context and can be ordered using the &#123;<span class="doctag">@link</span> Ordered&#125;</span></span><br><span class="line"><span class="comment"> * interface or &#123;<span class="doctag">@link</span> Order <span class="doctag">@Order</span>&#125; annotation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If you need access to &#123;<span class="doctag">@link</span> ApplicationArguments&#125; instead of the raw String array</span></span><br><span class="line"><span class="comment"> * consider using &#123;<span class="doctag">@link</span> ApplicationRunner&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ApplicationRunner</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback used to run the bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args incoming main method arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所说：接口被用作加入Spring容器中时执行run(String… args)方法，通过命令行传递参数。SpringBoot在项目启动后会遍历所有实现CommandLineRunner的实体类并执行run方法，多个实现类可以并存并且根据order注解排序顺序执行。这边还有个<code>ApplicationRunner</code>接口，但是接收参数是使用的<code>ApplicationArguments</code>。这边不再赘述。</p><p><strong>同样是启动时执行定时任务，使用这种方式我的写法如下：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 注意 这里必须有</span></span><br><span class="line"><span class="comment">//@Order(2) 如果有多个类需要启动后执行 order注解中的值为启动的顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAllJobInit</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JobInfoService jobInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JobTaskUtil jobTaskUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        List&lt;JobInfoBO&gt; list = jobInfoService.findList();</span><br><span class="line">        <span class="keyword">for</span> (JobInfoBO jobinfo :list) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"0"</span>.equals(jobinfo.getStartWithrun()))&#123;</span><br><span class="line">                    logger.info(<span class="string">"任务&#123;&#125;未设置自动启动。"</span>, jobinfo.getJobName());</span><br><span class="line">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    logger.info(<span class="string">"任务&#123;&#125;设置了自动启动。"</span>, jobinfo.getJobName());</span><br><span class="line">                    jobTaskUtil.addOrUpdateJob(jobinfo);</span><br><span class="line">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">                logger.error(<span class="string">"执行定时任务出错，任务名称 &#123;&#125; "</span>, jobinfo.getJobName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3、使用ContextRefreshedEvent事件-上下文件刷新事件"><a href="#3、使用ContextRefreshedEvent事件-上下文件刷新事件" class="headerlink" title="3、使用ContextRefreshedEvent事件(上下文件刷新事件)"></a>3、使用<code>ContextRefreshedEvent</code>事件(上下文件刷新事件)</h4><blockquote><p>ContextRefreshedEvent 官方在接口上的doc说明<br><br>Event raised when an {@code ApplicationContext} gets initialized or refreshed.</p></blockquote><p>ContextRefreshedEvent是Spring的ApplicationContextEvent一个实现，ContextRefreshedEvent 事件会在Spring容器初始化完成后以及刷新时触发。</p><p><strong>在这里我需要在springboot程序启动之后加载配置信息和字典信息到Redis缓存中去，我可以这样写：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 注意 这个也是必须有的注解 三种都需要 使spring扫描到这个类并交给它管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitRedisCache</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory</span><br><span class="line">            .getLogger(InitRedisCache.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysConfigService sysConfigService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysDictService sysDictService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"-------加载配置信息 start-------"</span>);</span><br><span class="line">        sysConfigService.loadConfigIntoRedis();</span><br><span class="line">        logger.info(<span class="string">"-------加载配置信息 end-------"</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"-------加载字典信息 start-------"</span>);</span><br><span class="line">        sysDictService.loadDictIntoRedis();</span><br><span class="line">        logger.info(<span class="string">"-------加载字典信息 end-------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```java</span><br><span class="line">**注意**：这种方式在springmvc-spring的项目中使用的时候会出现执行两次的情况。这种是因为在加载spring和springmvc的时候会创建两个容器，都会触发这个事件的执行。这时候只需要在`onApplicationEvent`方法中判断是否有父容器即可。</span><br></pre></td></tr></table></figure><p>@Override<br>  public void onApplicationEvent(ContextRefreshedEvent event) {<br>      if(event.getApplicationContext().getParent() == null){//root application context 没有parent，他就是老大.<br>           //需要执行的逻辑代码，当spring容器初始化完成后就会执行该方法。<br>      }<br>  }<br><code>`</code></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上，就是我在实际开发中常用的三种，在项目启动时执行代码的方式，开发者可以根据不同的使用情况选择合适的方法去执行自己的业务逻辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;  通常的我们的项目开发中，经常会遇到那种在服务一启动就需要自动执行一些业务代码的情况。比如将数据库中的配置信息或者数据字典之类的缓存到redis，或者在服务启动的时候将一些配置化的定时任务开起来。关于spring mvc或者springboot如何在项目启动的时候就执行一些代码，方法其实有很多，我这边介绍一下我使用过的三种。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="spring" scheme="http://zhangjiaheng.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Java内存分配与垃圾回收的复习整理</title>
    <link href="http://zhangjiaheng.cn/blog/20190414/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <id>http://zhangjiaheng.cn/blog/20190414/Java内存分配与垃圾回收的复习整理/</id>
    <published>2019-04-14T13:18:36.000Z</published>
    <updated>2019-05-22T12:36:48.900Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190414/Java内存分配与垃圾回收的复习整理/zy.png" alt="摘要"></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>众所周知Java作为一个“一次编译，到处运行”的编译型语言，JVM虚拟机当之无愧的是Java语言世界的先锋将军。作为一个Java程序员，JVM虚拟机其相关知识是我们必须要了解以及深入掌握的重点。在本篇博客我将总结一下JVM虚拟机的内存结构、对象内存分配以及垃圾回收算法。这也是经常找工作求职必问的点。</p><a id="more"></a><h3 id="Java内存分配与垃圾回收的复习整理"><a href="#Java内存分配与垃圾回收的复习整理" class="headerlink" title="Java内存分配与垃圾回收的复习整理"></a>Java内存分配与垃圾回收的复习整理</h3><h4 id="Java内存区域划分"><a href="#Java内存区域划分" class="headerlink" title="Java内存区域划分"></a>Java内存区域划分</h4><p>Java虚拟机在执行Java程序的过程中会将它所管理的内存划分为若干个不同的区域。每个区域各司其职，其创建与销毁数据的规则也都各不相同。根据《Java虚拟机规范（Java SE 7版）》的规定，主要分为如下图几个区域。</p><p><img src="/blog/20190414/Java内存分配与垃圾回收的复习整理/jvm.png" alt="Java内存划分"></p><ul><li><strong>程序计数器</strong>：当前线程执行字节码的行号指示器。[<em>线程私有</em>]</li><li><strong>虚拟机栈</strong>：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。平常我们所说的Java虚拟机划分为堆和栈中的“栈”中的一部分就是虚拟机栈。其中局部变量表存放着编译期可知的所有基本数据类型、对象引用等。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法所需要的帧的大小是已经确定了的。[<em>线程私有</em>]</li><li><strong>本地方法栈</strong>：与虚拟机栈发挥的作用相似，只不过这个区域执行的是native方法，即由c/c++或者其他语言编写的方法。[<em>线程私有</em>]</li><li><strong>Java堆</strong>：用来存放对象实例，即我们最熟悉的一块区域。Java堆是垃圾收集器管理的主要区域，所以有时也叫“GC堆”。[<em>线程共享</em>]</li><li><strong>方法区</strong>：用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 [<em>线程共享</em>]</li><li><strong>运行时常量池</strong>：这是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。[<em>线程共享</em>]</li></ul><h4 id="常用的垃圾回收算法"><a href="#常用的垃圾回收算法" class="headerlink" title="常用的垃圾回收算法"></a>常用的垃圾回收算法</h4><blockquote><p>在Java代码中，我们程序员通常只关注广义上的“栈”和“堆”这两种区域。上述划分的Java内存区域告诉我们，栈是朝生夕死的一块区域，当线程进入的时候，栈空间被分配，线程结束之后，栈的内存空间即被回收用来去做其他的任务，栈中的栈帧随着线程的进入与退出有条不紊的执行着入栈和出栈的操作，每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的。而堆却不同，我们只有在程序运行期间才会知道创建那些对象，这部分内存分配和回收都是动态的。都由虚拟机的垃圾回收器进行“已死”对象的回收。</p></blockquote><h5 id="如何判断对象已死"><a href="#如何判断对象已死" class="headerlink" title="如何判断对象已死"></a>如何判断对象已死</h5><ul><li><strong>引用计数法</strong>：给对象添加一个引用计数器，每当有引用指向它时计数器加1，引用失效后计数器减1。垃圾回收器回收对象计数器为0的对象昂即可。但是当出现对象之间循环引用，而对象却无实际作用的时候，这种方式就会出现内存泄漏。</li><li><strong>可达性分析</strong>：通过一系列的称为“GC ROOTS”的对象作为起点，向下搜索，搜索走过的路径都称为引用链，当一个对象到“GC ROOTS”没有引用链的时候，证明这个对象不可达。此时会被判定为可回收对象。（此时并非一定死亡，在此之后还会进行两次标记处理，与finalize()方法有关，此处不再整理。注意一个知识点：任何对象的finalize()方法只会被系统调用一次，并且不建议使用）</li></ul><blockquote><p>知道哪些对象是“垃圾”，接下来就是回收操作了</p></blockquote><h5 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h5><ul><li>首先标记出所有需要回收的对象，然后统一回收。是最基础的回收算法。</li><li>不足之处：1、效率低下，标记和清除的效率都不高；2、产生大量内存碎片，使得之后程序要分配大对象却没有空间，不得不除法GC。</li></ul><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><ul><li>首先将内存区域划分为两等分，每次只使用其中一块内存，当用完之后，将活着的对象复制到另一块内存，然后整个回收上一半。这种按顺序分配内存，实现简单，运行高效。</li><li>不足之处：直接将内存缩小了一半，产生大量的空间浪费。然而很多垃圾收集器都是用这种方式，但是有过改进。因为堆中的对象90%都是朝生夕死的，只有10%是会长期存活下来的对象，那么对于这90%的对象，完全可以使用这种高效的复制收集算法。首先将内存区域划分三份，10%的对象存在其中较大的一分中，另外的两份等份分配，处理这90%的“死的快”的对象。这就是Form,To,Eden区域。即Eden:From:To=8:1:1</li></ul><h5 id="标记-整理法"><a href="#标记-整理法" class="headerlink" title="标记-整理法"></a>标记-整理法</h5><ul><li>标记整理的方式实际上也是先将可回收对象标记起来，然后对于这些存活着的对象，并不直接回收，而是先向一端移动，最后直接回收端边界之外的对象。这种做法解决了处理存活率较高的大对象的回收，适合老年代堆对象回收。</li></ul><h5 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h5><ul><li>当前商业虚拟机基本上都会采取分代收集算法。即根据对象存活周期的不同将内存划分为不同区域，分别使用不同的垃圾回收算法进行垃圾回收。比如在新生代使用复制算法，因为新生代大量对象都是朝生夕死需要很高的回收效率，而对于老年代则使用标记清除或者标记整理。</li></ul><h4 id="Java虚拟机的对象内存分配"><a href="#Java虚拟机的对象内存分配" class="headerlink" title="Java虚拟机的对象内存分配"></a>Java虚拟机的对象内存分配</h4><p>Java对象内存分配实际上就指的是将对象分配在堆上的过程。不过实际上堆还被虚拟机划分成了不同的区域，并且每个区域的分配策略都不相同。上面我们说到虚拟机根据对象存活周期的不同将对内存分为几种不同的区域，即新生代Eden,From Survivor,To Survivor和老年代。那么这几种区域是如何进行内存分配的呢？</p><ul><li>对象优先再Eden区域分配：大多数情况下，对象会在Eden区域分配，在Eden区域空间不够的情况下，会先进行一次MinorGC（MinorGC是新生代垃圾回收，Full GC是老年代垃圾回收）。</li><li>大对象直接进入老年代：大对象即指的是需要大量连续空间的对象，例如很长的字符串以及数组。虚拟机提供参数<code>-XX:PretenureSizeThreadhold</code>参数设置大于多少算是大对象，避免在新生代几个区域中发生大量的内存复制。</li><li>长期存活的对象直接进入老年代：每经过一次MinorGC对象的年龄都会加1。当年龄加到<code>-XX:MaxTenuringThreadhold</code>（默认15）指定的值时，判断为长期存活，对象会被移动到老年代。</li><li>动态对象年龄判断：为了适应多变的内存情况，一般虚拟机都会使用动态对象年龄判定。如果Survivor中相同年龄的所有对象大小总和大于该空间的一半，该年龄以上的对象就会直接进入老年代，无需等到年龄大于<code>-XX:MaxTenuringThreadhold</code>（默认15）指定的值。</li><li>空间分配担保：在发生MinorGC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，是的话MinorGC可以被认定是安全的。如果不成立，虚拟机会先检查<code>HandlerPromotionFailure</code>参数是否允许担保失败，不允许的话会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于的话或者<code>HandlerPromotionFailure</code>设置不允许冒险，那么就会执行一次FullGC。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>内存回收与垃圾收集很多时候都是影响系统性能和并发能力的主要因素之一，虚拟机提供了多种垃圾收集器以及大量的调节参数，方便开发人员根据实际应用调整以便程序可以获得最高的性能。这些垃圾收集器和虚拟机参数没有固定的标准的组合，需要开发人员对于内存分配与垃圾回收相当了解，才得以根据实际情况实际配置。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190414/Java内存分配与垃圾回收的复习整理/zy.png&quot; alt=&quot;摘要&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;众所周知Java作为一个“一次编译，到处运行”的编译型语言，JVM虚拟机当之无愧的是Java语言世界的先锋将军。作为一个Java程序员，JVM虚拟机其相关知识是我们必须要了解以及深入掌握的重点。在本篇博客我将总结一下JVM虚拟机的内存结构、对象内存分配以及垃圾回收算法。这也是经常找工作求职必问的点。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="内存分配" scheme="http://zhangjiaheng.cn/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
      <category term="垃圾回收" scheme="http://zhangjiaheng.cn/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
</feed>
