{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/baidu_verify_mJpFi2Z3mB.html","path":"baidu_verify_mJpFi2Z3mB.html","modified":0,"renderable":0},{"_id":"source/google05dcfde650a3d64e.html","path":"google05dcfde650a3d64e.html","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/scroll.png","path":"images/scroll.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/wx.jpg","path":"images/wx.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/bgbk.jpg","path":"images/bgbk.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/cursor/fireworks.js","path":"js/cursor/fireworks.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/tx.jpg","path":"images/tx.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/bg.jpg","path":"images/bg.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/about/me.jpg","path":"about/me.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/images/nml.jpg","path":"images/nml.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1557222509896},{"_id":"source/CNAME","hash":"e9145000c4ed0a2dfe0cfb56286b6fe127836bbd","modified":1557222509895},{"_id":"source/baidu_verify_mJpFi2Z3mB.html","hash":"6c01876f88c2e62035182f93e0e17b30f0312754","modified":1559549742042},{"_id":"source/google05dcfde650a3d64e.html","hash":"78a4b5927270f670ef72540ff23a9d31377095e4","modified":1559549756021},{"_id":"source/robots.txt","hash":"07c57cfe432ec3b672299dbac91766620c8259f2","modified":1557222509966},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1557222510006},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1557222510008},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1557222510010},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1557222510012},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1557222510014},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1557222510017},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1557222510015},{"_id":"themes/next/baidu_verify_HlvKEOqagE.html","hash":"502ff1491fffd9742de55b594b481bc9f3c8f1c9","modified":1557222510027},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1557222510019},{"_id":"themes/next/README.md","hash":"50abff86ffe4113051a409c1ed9261195d2aead0","modified":1557222510023},{"_id":"themes/next/_config.yml","hash":"a56c04ede36f657d81bdcff16984eb7b770de3d3","modified":1559791206806},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1557222510030},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1557222510028},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1557222510238},{"_id":"themes/next/README.cn.md","hash":"23e92a2599725db2f8dbd524fbef2087c6d11c7b","modified":1557222510021},{"_id":"source/_posts/Java中map新的骚操作.md","hash":"e6450a754a848fce0a2d8e75555231dca5490e36","modified":1557222509898},{"_id":"source/_posts/hexo博客文章置顶方式.md","hash":"c8fa20b5ea8d47746c2c9891ec7008976abc7c40","modified":1557222509915},{"_id":"source/_posts/Java序列化和transient关键字的理解与学习.md","hash":"704f67ff77a3482c62156c89ea543c8bd19346cf","modified":1557821997989},{"_id":"source/_posts/dubbo 服务降级.md","hash":"c60c4a94b6e20fa7af1a6c28fa7f847aa9bb9e31","modified":1557222509913},{"_id":"source/_posts/Java内存分配与垃圾回收的复习整理.md","hash":"8d8d97ee84ffaec43546eefc9bfa4bb73a9a2646","modified":1558528608900},{"_id":"source/_posts/vlog-程序员的一天.md","hash":"01e4e548b84c27a56bff24a682389b1b6cfb6992","modified":1557222509926},{"_id":"source/_posts/nodepad-不用插件去重的方法.md","hash":"be87aa7294b2113e1d5965724f0e08600a3f4ec3","modified":1557222509920},{"_id":"source/_posts/layui开发中结合freemarker展示字典数据.md","hash":"3870e596832b3e49c1c3096c6bd456248f967c34","modified":1557222509916},{"_id":"source/_posts/leetcode-Z字形变换.md","hash":"f6496a9aba5cd4c1e3caacf448ad84f436131db2","modified":1557222509918},{"_id":"source/_posts/spring-boot微服务搭建.md","hash":"b98797bbfefe46b1cc8a68b79503dce74ae682e7","modified":1557222509922},{"_id":"source/_posts/一个菜鸟在三星实习的感受.md","hash":"3407fc9d4ef748ba5a0a47928391778f1e0ae73a","modified":1557222509929},{"_id":"source/_posts/springboot+shiro解决session污染问题.md","hash":"413bb40f520934e305b878029dd1511237249a21","modified":1557222509924},{"_id":"source/_posts/事务传播机制以及隔离级别.md","hash":"47a76e4e5e68512c6074cc7492d19b18b1582511","modified":1557222509931},{"_id":"source/_posts/二叉搜索树与完全二叉树.md","hash":"ac24fa92e96be41b795e95757e2418803cb61a68","modified":1560419088591},{"_id":"source/_posts/二叉树的几种非递归遍历.md","hash":"c285189098c1dc72269e1030a177f998b42cbd73","modified":1560424868319},{"_id":"source/_posts/你的内心比拳头更强大.md","hash":"c3213b2bd09b7660992b7f413cb8bf4c4199ab37","modified":1557728870123},{"_id":"source/_posts/使用-幕布-创建Java知识体系思维导图.md","hash":"77650bf1118aea01a7bc5fff2a0dea066ef80ee5","modified":1557230142398},{"_id":"source/_posts/关于IDEA再从git或者svn上导入项目时不能加载字模块的问题.md","hash":"8609e1ae84db47367711b2b2824a837b875a2bcd","modified":1557222509935},{"_id":"source/_posts/关于git-pull-拉取不到最新记录.md","hash":"d7798fd152b7826581ba375b1479956d217645be","modified":1557222509937},{"_id":"source/_posts/使用springboot进行国际化时自定义读取数据库配置.md","hash":"6c1bda2de7f7b2f9da8e8788e750e6e1a6635a6c","modified":1557222509933},{"_id":"source/_posts/并发编程学习-三-：CountDownLatch的实现原理及使用.md","hash":"64b0d2ed190cce977aba681a40f59782a9dad6c8","modified":1560752282563},{"_id":"source/_posts/并发编程学习-二-：使用AQS编写可重入锁.md","hash":"090d18242e821622599e6c9abf7da178ea43567f","modified":1560752282563},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池.md","hash":"bfd1f25e5de8b762d8f89bc9416637d3ef909309","modified":1560766580628},{"_id":"source/_posts/如何在springboot服务启动之后执行一些代码(三种方式).md","hash":"3544b38d50a9ce823e6a4db4e132a30d849d223b","modified":1557222509939},{"_id":"source/_posts/无重复字符的最长子串.md","hash":"4fcda47f6ac02b86a40bbafbfbdeb43f4ce25725","modified":1558594768435},{"_id":"source/_posts/开发日记-20180718.md","hash":"8916cd660b941574cbf75d5b329627e0184c9c4c","modified":1557222509941},{"_id":"source/_posts/深度分析如何写出一个线程安全的单例.md","hash":"91022c9f6464043fc7e79a373cf0eeb6a2f76705","modified":1560752282564},{"_id":"source/_posts/编写一个简易的可重入锁-一.md","hash":"98b4a56cf2f6347a891dee8591c2ff7c8cf7b9eb","modified":1560752282565},{"_id":"source/_posts/泰国7天6晚自由行攻略.md","hash":"ec28eff7d4ad11ba160bd14a75bfd1c802b3a2a3","modified":1557222509945},{"_id":"source/_posts/校招面试经历.md","hash":"33e845c141d48ecac66a00354029d9542283a0f5","modified":1557222509943},{"_id":"source/_posts/纪念即将结束的第一份工作.md","hash":"870530d0f01183c7382c0909ea98031f5d124333","modified":1557222509948},{"_id":"source/_posts/编写自己的SpringMVC框架.md","hash":"5b4c13de18d5d5f43a117adf1b04cb300ea2539e","modified":1559720743787},{"_id":"source/about/index.md","hash":"88001986e2242a6d408569a4594544c4f9cea7f7","modified":1557460237848},{"_id":"source/archives/index.md","hash":"7a9b6a9d98941aabaebb2b5321d9e6a951b20156","modified":1557222509954},{"_id":"source/categories/index.md","hash":"154591dd29c732c370f342a6c2cfdff61a21e1e8","modified":1557222509959},{"_id":"source/message/index.md","hash":"bf250e0936cbad84deeb8c3b55f9e300e8a2b3ab","modified":1557222509964},{"_id":"source/tags/tags.md","hash":"3f929add403fbec904b8ba8b66c331022e5f813f","modified":1557222509969},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1557222510035},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1557222510037},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1557222510033},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1557222510038},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1557222510042},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1557222510040},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1557222510045},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1557222510044},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1557222510047},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1557222510049},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1557222510053},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1557222510051},{"_id":"themes/next/languages/zh-Hans.yml","hash":"75f30c3e083ba0951a8e804593faa1d335558344","modified":1560911611136},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1557222510059},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1557222510060},{"_id":"themes/next/layout/_layout.swig","hash":"01bd596be11a8e46607165c98d7b9c6cd632dc90","modified":1559628350614},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1557222510054},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1557222510226},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1557222510224},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1557222510228},{"_id":"themes/next/layout/page.swig","hash":"e1e19fd7a92a8cb21fa7e923d450c39a220ece07","modified":1557222510230},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1557222510232},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1557222510234},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1557222510244},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1557222510241},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1557222510236},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1557222510785},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1557222510789},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1557222510791},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1557222510505},{"_id":"source/_posts/Java内存分配与垃圾回收的复习整理/jvm.png","hash":"ed2cd768d0ea7947980868a0d1c27f7741272e30","modified":1557222509904},{"_id":"source/_posts/Java序列化和transient关键字的理解与学习/xuliehua.png","hash":"6d05b369f7c45f1929c0efd716aaae2d9236de7f","modified":1557804559716},{"_id":"source/_posts/二叉搜索树与完全二叉树/mecs.png","hash":"1adf18fab93a477a9b3815006b40b12529fe57e8","modified":1557471367303},{"_id":"source/_posts/二叉搜索树与完全二叉树/ecs.png","hash":"8c9ad27ce41bf46d060c47df227cb76492cf81b4","modified":1557469259863},{"_id":"source/_posts/二叉搜索树与完全二叉树/wqecs.png","hash":"2a42954bfe81c37886d32428639292cac4aab680","modified":1557471403746},{"_id":"source/_posts/使用-幕布-创建Java知识体系思维导图/java_core.png","hash":"fb2aa77e2e8b61a59184e9344a4b31de902f6941","modified":1557228171612},{"_id":"source/_posts/编写一个简易的可重入锁-一/nullIsMistake.jpg","hash":"91ae918495c5cd3e874244e27237795b4732c456","modified":1558604296584},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1557222510078},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1557222510116},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1557222510119},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1557222510073},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1557222510071},{"_id":"themes/next/layout/_partials/comments.swig","hash":"cd6d6556accb898f38fb8f6c14cf6353e94a4e68","modified":1557222510080},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1557222510131},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4b5c88f3e66eb8b5656c311dde6024fde3656028","modified":1557222510083},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1557222510094},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"d8162d38f43f834af9baf11e8fa4886e260a16d3","modified":1557222510076},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1557222510096},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1557222510092},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1557222510084},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1557222510097},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1557222510074},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1557222510194},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1557222510196},{"_id":"themes/next/layout/_macro/post.swig","hash":"c0d64b2ad475d3a61428b944ee718eaf1eb4b8b8","modified":1557222510073},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1557222510198},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1557222510206},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1557222510202},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1557222510065},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1557222510249},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1557222510247},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1557222510251},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1557222510253},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1557222510255},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1557222510258},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1557222510259},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1557222510261},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1557222510200},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1557222510204},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1557222510264},{"_id":"themes/next/layout/_custom/custom.swig","hash":"ffcd6ac08e5c68762ac95666bf4a2018d9e54fa5","modified":1559627541624},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1557222510503},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1557222510067},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"14d0e19754b86dab0848d71ef52dae0b56ee89cc","modified":1557222510511},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1557222510513},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1557222510508},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1557222510516},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1557222510522},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"bc43dbac0ba5764d2d4a258d95d148883c292336","modified":1557222510527},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1557222510520},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1557222510530},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1557222510533},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"d39e0e79040504c3aef8817bf7f3ee2f0e4ac5a1","modified":1557222510528},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1557222510532},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1557222510525},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1557222510535},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1557222510523},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1557222510537},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1557222510539},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1557222510515},{"_id":"themes/next/source/images/scroll.png","hash":"443930af0ee54778babad7724291bfed9b431dd5","modified":1559627301744},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1557222510518},{"_id":"themes/next/source/images/wx.jpg","hash":"5dd9e4fec63bf41a3705f1d217f6991ac4e7ef28","modified":1557222510545},{"_id":"source/_posts/使用-幕布-创建Java知识体系思维导图/mb.png","hash":"919809f7bee72af986a10a8e86ba206417d8d6dc","modified":1557230021255},{"_id":"source/_posts/并发编程学习-二-：使用AQS编写可重入锁/aqs.png","hash":"7c88add3afb0bcbc3b55f5c44ec3ab4b4c05317b","modified":1559196742800},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1557222510127},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1557222510126},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1557222510434},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1557222510432},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1557222510439},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1557222510496},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1557222510501},{"_id":"themes/next/source/images/bgbk.jpg","hash":"c4767682f8d19e2de255d029cd25e9b94365a8d7","modified":1559129716156},{"_id":"source/_posts/编写自己的SpringMVC框架/zj.png","hash":"783d80c117b0dd3912f05bfc0d268d3c2b90a872","modified":1559543981625},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1557222510124},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1557222510121},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1557222510130},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1557222510087},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1557222510108},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1557222510110},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1557222510090},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1557222510140},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1557222510144},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1557222510146},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1557222510112},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1557222510155},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1557222510114},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1557222510157},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1557222510161},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1557222510164},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1557222510138},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1557222510147},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1557222510159},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1557222510167},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1557222510170},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1557222510136},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1557222510175},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1557222510188},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"16cb23818909f57dac1a5ada66869971c33d7bd8","modified":1557222510142},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1557222510192},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1557222510100},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1557222510102},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1557222510177},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1557222510172},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1557222510105},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1557222510215},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1557222510190},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1557222510217},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1557222510188},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1557222510179},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1557222510222},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1557222510219},{"_id":"themes/next/source/css/_common/custom.styl","hash":"ca6d45f19dc1fe7c687ee8e74a56add495606a04","modified":1559548149868},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1557222510430},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1557222510436},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1557222510438},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"87fb0809d3db2b92040cc40408e6fbf03d9c0abc","modified":1560755041545},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1557222510494},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1557222510491},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1557222510498},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1557222510549},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1557222510553},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1557222510551},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1557222510557},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1557222510558},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1557222510560},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1557222510560},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1557222510555},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1557222510568},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1557222510566},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1557222510613},{"_id":"themes/next/source/js/cursor/fireworks.js","hash":"7443501c01e707954304d30824a1082ecdf2f4e9","modified":1559627477239},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1557222510570},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1557222510606},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1557222510616},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1557222510652},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1557222510658},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1557222510610},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1557222510655},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1557222510656},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1557222510668},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1557222510666},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1557222510670},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1557222510595},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1557222510716},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1557222510708},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1557222510712},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1557222510703},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1557222510714},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1557222510717},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1557222510719},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1557222510722},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1557222510724},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1557222510726},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1557222510729},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1557222510731},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1557222510733},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1557222510735},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1557222510736},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1557222510734},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1557222510738},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1557222510672},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1557222510673},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1557222510740},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1557222510741},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1557222510746},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1557222510743},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1557222510742},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1557222510744},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1557222510747},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1557222510751},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1557222510756},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1557222510753},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1557222510769},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1557222510772},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1557222510777},{"_id":"themes/next/source/images/tx.jpg","hash":"5128ccf6ace6dd52f41d1a6d164cb271ab6b8104","modified":1557222510542},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1557222510780},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1557222510782},{"_id":"themes/next/source/css/_variables/base.styl","hash":"125f287a6aba2b1f52e97c877e0734831064d606","modified":1559706972463},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1557222510706},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1557222510210},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1557222510213},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1557222510269},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1557222510274},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1557222510276},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"c8ccfc3a387adbfceabddbca67497828cde93342","modified":1557222510278},{"_id":"themes/next/source/css/_common/components/gitment.styl","hash":"a3c9aaa4372c1302e7611a4de9b1ef9d583ee244","modified":1557222510284},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1557222510272},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1557222510317},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1557222510369},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1557222510426},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1557222510418},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1557222510421},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1557222510425},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1557222510422},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1557222510427},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1557222510415},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1557222510446},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1557222510450},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1557222510443},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1557222510456},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"41456dbbab82b6cf4fcdae94f035367a4e502bfb","modified":1557459397784},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4389abc4fbaa536cd62b5d410ef7b4774b4adbb7","modified":1559548428957},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1557222510465},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1557222510468},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1557222510474},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1557222510470},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1557222510472},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c4306f8133b1e2887fb2604b1858d51b871f23d0","modified":1560238333930},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1557222510452},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1557222510479},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1557222510485},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1557222510489},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"59d29ce3cd9d513f0533b75543523821940cb794","modified":1557222510482},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1557222510483},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1557222510487},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1557222510592},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1557222510619},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1557222510587},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1557222510564},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1557222510621},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1557222510623},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1557222510628},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1557222510624},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1557222510626},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1557222510646},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1557222510649},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1557222510644},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1557222510661},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1557222510664},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1557222510679},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1557222510681},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1557222510676},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1557222510765},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1557222510767},{"_id":"source/_posts/编写自己的SpringMVC框架/aaa.jpeg","hash":"b30446a2a98d3e713a67e047f762a32520c56536","modified":1559547044727},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1557222510590},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1557222510591},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1557222510699},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1557222510701},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1557222510775},{"_id":"source/_posts/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png","hash":"e1a8f3d009354bbd0989403a0022e81eab155fa6","modified":1559720400680},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1557222510281},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1557222510287},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1557222510289},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1557222510295},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1557222510298},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1557222510306},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1557222510308},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1557222510310},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1557222510313},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1557314708278},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1557222510291},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1557222510319},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1557222510303},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1557222510300},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1557222510325},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1557222510323},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1557222510315},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1557222510332},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1557222510330},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1557222510328},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1557222510339},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1557222510337},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1557222510334},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1557222510343},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1557222510335},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1557222510341},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1557222510327},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1557222510345},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1557222510354},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"1183fbb9acf0ef0b7de468d8ae7e66dd0f85d1c0","modified":1559649874233},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1557222510356},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1557222510358},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1557222510349},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"1d94f152477d150a262b3801540f2f28a96b4004","modified":1557222510352},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1557222510362},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1557222510363},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"11d20052d4d547283097397dc2ca4134589d7a01","modified":1559706288085},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1557222510375},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1557222510377},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1557222510360},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1557222510372},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1557222510367},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1557222510381},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1557222510379},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1557222510389},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1557222510383},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1557222510387},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1557222510397},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1557222510395},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1557222510401},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1557222510386},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1557222510405},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1557222510403},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1557222510411},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1557222510408},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1557222510392},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1557222510399},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1557222510407},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1557222510460},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1557222510463},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1557222510476},{"_id":"themes/next/source/images/bg.jpg","hash":"4522825a9d678fbd74bbd16283b30d14f0e228bb","modified":1559548073863},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1557222510582},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1557222510583},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1557222510577},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1557222510585},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1557222510580},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1557222510631},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1557222510638},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1557222510634},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1557222510640},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1557222510642},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1557222510636},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1557222510685},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1557222510689},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1557222510698},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1557222510601},{"_id":"source/_posts/无重复字符的最长子串/bb.png","hash":"14430c3e60f3ac7350bee6319263b8ef1da0c759","modified":1558594863610},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1557222510761},{"_id":"source/_posts/二叉树的几种非递归遍历/fm.jpg","hash":"298e3aebf74380f50c521dce149057116a35c417","modified":1560418710463},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1557222510692},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png","hash":"5867c0272859dac4b467386c7623136ae1b75a10","modified":1560752991078},{"_id":"source/_posts/深度分析如何写出一个线程安全的单例/fm.png","hash":"d5a13983d9856c69ab583561a15255be0f0b7a27","modified":1560237558365},{"_id":"source/_posts/Java内存分配与垃圾回收的复习整理/zy.png","hash":"7e40bcb940caddfc676d7c265abf8be139040112","modified":1557222509911},{"_id":"source/_posts/你的内心比拳头更强大/xx.png","hash":"cfdfb9263c10833aca6b3c729618993216a276e9","modified":1557454739231},{"_id":"source/about/me.jpg","hash":"db0b93a401f31faafee0a77c81911c7eba7a0727","modified":1557460056970},{"_id":"themes/next/source/images/nml.jpg","hash":"a7e6e1f40f69d8b2a23fc04d4df8902eb11fd101","modified":1560755470838},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池/gzhs.png","hash":"5e5e68c503b370f406edad52f86e30ea73976c2c","modified":1560753830225},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池/bhcl.png","hash":"fea4784e095123eabea069b92c81d838aa2841a3","modified":1560756127139},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcc.png","hash":"c486417d89a1bb2294cc427e801c99219b032bb2","modified":1560758490853},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcgz.png","hash":"21a72fdd92b0553621ebd66732e7df67a276d8b3","modified":1560762420947},{"_id":"public/atom.xml","hash":"d77f59f431e37e725cf8449df548a8c11ed89497","modified":1560766634775},{"_id":"public/baidusitemap.xml","hash":"bbab7ab8dc801fd3d00ecd5b113c9295b97a3450","modified":1560766634830},{"_id":"public/search.xml","hash":"121be21b358d11b1fb7b2f6b176e5254457a0567","modified":1560766634830},{"_id":"public/sitemap.xml","hash":"015645519a8ec8dcc0a475c07ba2e416b48b6e3e","modified":1560766634831},{"_id":"public/about/index.html","hash":"4e849a2860fef55f74446d492e2bd53f376a8404","modified":1560911656432},{"_id":"public/archives/index.html","hash":"b3108044a146f77ddad4763081b312263441fbb9","modified":1560911656399},{"_id":"public/message/index.html","hash":"12372df028b54612fb4f685c60551ec711bccc9d","modified":1560911656431},{"_id":"public/tags/tags.html","hash":"4e4a76aff47a22f2d9b87fea80a344051d039593","modified":1560911656430},{"_id":"public/blog/20190613/二叉树的几种非递归遍历/index.html","hash":"5337cd9fceab937b398972bb95ea900cb9906b3f","modified":1560911656430},{"_id":"public/blog/20190607/深度分析如何写出一个线程安全的单例/index.html","hash":"f799d3a9283d8fb4b5ee29c62ea91d395dd474bd","modified":1560911656431},{"_id":"public/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/index.html","hash":"2d4300efc12be868e5a15b07e8e9651015ef8b62","modified":1560911656432},{"_id":"public/blog/20190531/编写自己的SpringMVC框架/index.html","hash":"fb7f19e6a4b6c950e201b14b75606f96dec49d87","modified":1560911656433},{"_id":"public/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/index.html","hash":"adcd848758476a0069feb1a97cef6c345fee08c3","modified":1560911656433},{"_id":"public/blog/20190512/无重复字符的最长子串/index.html","hash":"1aa9781860a6b01ca098bd736085ccd1043e268b","modified":1560911656433},{"_id":"public/blog/20190517/编写一个简易的可重入锁-一/index.html","hash":"f0df8061113e707e9597e3b645cdd886629c3c52","modified":1560911656433},{"_id":"public/blog/20190511/Java序列化和transient关键字的理解与学习/index.html","hash":"ef20b5ae836a2e5a4f6849379bef0b6f3f97b927","modified":1560911656433},{"_id":"public/blog/20190509/你的内心比拳头更强大/index.html","hash":"b6d681cf106f3b00b2da220990e0ce415ba13d2c","modified":1560911656433},{"_id":"public/blog/20190507/使用-幕布-创建Java知识体系思维导图/index.html","hash":"081b749fce4b295d20badb0f7a26d57f1c2bda70","modified":1560911656433},{"_id":"public/blog/20190504/二叉搜索树与完全二叉树/index.html","hash":"546d8a321d494d992214d0daa71ce473f64d025d","modified":1560911656434},{"_id":"public/blog/20190419/如何在springboot服务启动之后执行一些代码(三种方式)/index.html","hash":"85406050061facb99e6da4b618f96e301a02f010","modified":1560911656434},{"_id":"public/blog/20190414/Java内存分配与垃圾回收的复习整理/index.html","hash":"df3adec90e836743f5f38f9a74a6515391610faf","modified":1560911656434},{"_id":"public/blog/20190412/dubbo 服务降级/index.html","hash":"f837fcd564ac5f3427af69a8be6c26af4d3a285c","modified":1560911656434},{"_id":"public/blog/20190323/事务传播机制以及隔离级别/index.html","hash":"12fab0f91aca92b54fee1da4e85a405167634307","modified":1560911656449},{"_id":"public/categories/index.html","hash":"f302ea2a6441ff6b4f705e4d87e15185b2fbcd0e","modified":1560911656431},{"_id":"public/blog/20190320/使用springboot进行国际化时自定义读取数据库配置/index.html","hash":"77b78c5fd63525ee9597e6895d3ff5f6d81cf8cd","modified":1560911656451},{"_id":"public/blog/20190316/layui开发中结合freemarker展示字典数据/index.html","hash":"1c20be410ba7c0242f38da5b984a80656e26128c","modified":1560911656451},{"_id":"public/blog/20181223/leetcode-Z字形变换/index.html","hash":"dcec351d9f5fe3772fb276ac53cc7e9673ce32c3","modified":1560911656449},{"_id":"public/blog/20190309/springboot+shiro解决session污染问题/index.html","hash":"3e9040d715fc0f8fd3955ffdfdd2834c9cb2f34a","modified":1560911656449},{"_id":"public/blog/20181209/Java中map新的骚操作/index.html","hash":"76839678dc5b0cf6946cd067a3e362750c701365","modified":1560911656451},{"_id":"public/blog/20181112/nodepad-不用插件去重的方法/index.html","hash":"06c71b1bded063d0ea2ffb7735dd24425508b457","modified":1560911656450},{"_id":"public/blog/20180904/hexo博客文章置顶方式/index.html","hash":"4bd86cd428036340e76c96d6a767cb0e238e5f87","modified":1560911656450},{"_id":"public/blog/20180708/关于IDEA再从git或者svn上导入项目时不能加载字模块的问题/index.html","hash":"29d8c16036c4a0d5e2e6d5dfa7036cac38f4c4af","modified":1560911656451},{"_id":"public/blog/20180719/开发日记-20180718/index.html","hash":"198d381e13f309e82ccac71c36206934bf1703ad","modified":1560911656450},{"_id":"public/blog/20180628/纪念即将结束的第一份工作/index.html","hash":"a130f4b3ac8f91575917836d79125f332ddaa73f","modified":1560911656451},{"_id":"public/blog/20180531/关于git-pull-拉取不到最新记录/index.html","hash":"5d294a3fcc5fd528c68a11954c262b1e44279998","modified":1560911656452},{"_id":"public/blog/20180421/vlog-程序员的一天/index.html","hash":"5e31d7ab28f53ad8c92c96336bb1ba0d3fed20d7","modified":1560911656451},{"_id":"public/blog/20160927/校招面试经历/index.html","hash":"8a5c7cdc0bd8afd8838b687c555800055e224d50","modified":1560911656452},{"_id":"public/blog/20180327/spring-boot微服务搭建/index.html","hash":"0145fdd5ca06e02724c02c65173c02b890121072","modified":1560911656452},{"_id":"public/blog/20160911/一个菜鸟在三星实习的感受/index.html","hash":"6775ccc8f1dbab8881c6c4a13a4b8c78875e576d","modified":1560911656452},{"_id":"public/archives/page/3/index.html","hash":"18bd90a5e9da95e94d83a8f7ccefdcf1d4461ae7","modified":1560911656452},{"_id":"public/archives/page/2/index.html","hash":"ba53a47a7e39e4df43a3afabd3c7b79545a567f7","modified":1560911656453},{"_id":"public/archives/page/4/index.html","hash":"fa2b24680d9fe15032aee319143821ee55852d32","modified":1560911656452},{"_id":"public/archives/2016/index.html","hash":"852e404c74bc6e74b72f48bdd044154d4e80c229","modified":1560911656452},{"_id":"public/archives/2016/09/index.html","hash":"8415befdc5aadb6125495e02d468b469c3c76a57","modified":1560911656452},{"_id":"public/archives/2018/index.html","hash":"08aef037c67c94df55f6560bc542515d8fd515b7","modified":1560911656452},{"_id":"public/archives/2018/page/2/index.html","hash":"51e3090bf108dc7b72ad7cb69bf055f9b1749a9a","modified":1560911656453},{"_id":"public/archives/2018/03/index.html","hash":"70bac3e3b00bc571ab585283126fbb9323a20239","modified":1560911656452},{"_id":"public/archives/2018/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560911656449},{"_id":"public/archives/2018/06/index.html","hash":"27d18b4645271e3b6fd51bf2e6e68472ce415853","modified":1560911656453},{"_id":"public/archives/2018/05/index.html","hash":"4c320c2a0da246b266abe6969af7fa5c39624f75","modified":1560911656453},{"_id":"public/archives/2018/07/index.html","hash":"502b7efd13ae2ef79dab39ac666a05c433c3767c","modified":1560911656453},{"_id":"public/blog/20180904/泰国7天6晚自由行攻略/index.html","hash":"e018cc0ae086b00c4406a1742e819721aa2af691","modified":1560911656450},{"_id":"public/archives/2018/09/index.html","hash":"55f4cccbe91ec79fc2e72833881e9609b4643a47","modified":1560911656453},{"_id":"public/archives/2018/11/index.html","hash":"c0527f2295449ffe54d635fc7b0a78a9e7cb1edf","modified":1560911656453},{"_id":"public/archives/2018/12/index.html","hash":"f4a6f41936cc38849b99d0d83ab48e42316e0d21","modified":1560911656453},{"_id":"public/archives/2019/index.html","hash":"e970a2992790edd7dcb2c01a877b2bdb2a19ec87","modified":1560911656453},{"_id":"public/archives/2019/page/2/index.html","hash":"90e6fca0802e6eb72fa28954383fc9f0813095c9","modified":1560911656453},{"_id":"public/archives/2019/03/index.html","hash":"2d5c842785e7566d54070d409e7015d4fda6ecfe","modified":1560911656453},{"_id":"public/archives/2019/04/index.html","hash":"4e6df55613278a6c051f3a208317d0fc404a91a0","modified":1560911656453},{"_id":"public/archives/2019/05/index.html","hash":"5154005a7eed032067d8d2d8d7e3fd4a7649c538","modified":1560911656454},{"_id":"public/archives/2019/06/index.html","hash":"3a497cfa0b82ab6f0ddc2cf267eb9a309f867cac","modified":1560911656454},{"_id":"public/categories/Java基础/index.html","hash":"a15a1872b867b7265c6ec16ba4184fd3c3786ba3","modified":1560911656453},{"_id":"public/categories/hexo博客配置/index.html","hash":"7462b2d61fe5a7354865715c5987921f0fd6759b","modified":1560911656453},{"_id":"public/categories/dubbo/index.html","hash":"02e2a31ea41eeba8ebd59b48dc705abfc69bc132","modified":1560911656453},{"_id":"public/categories/程序人生/index.html","hash":"4e440b3542998c0c99a69831b754353a0af8f863","modified":1560911656454},{"_id":"public/categories/开发工具/index.html","hash":"de7013f89b760559ba0639233c025bcedc2c0489","modified":1560911656455},{"_id":"public/categories/算法题解/index.html","hash":"9327725aefc1ffe037bdd440d22790def635c554","modified":1560911656454},{"_id":"public/categories/springboot/index.html","hash":"9ab88a01f2cd188effdb7d436cc0485b66c98fed","modified":1560911656454},{"_id":"public/categories/数据结构与算法/index.html","hash":"a15e9acac1703b946e5fb36e61bc5705b2abd6d6","modified":1560911656454},{"_id":"public/categories/个人随笔/index.html","hash":"070f46b67da5471ff98bc4a05b6bae47c6d033ef","modified":1560911656454},{"_id":"public/categories/git/index.html","hash":"4337c8355cbdaea413bd69c5efdb8c47c3434627","modified":1560911656455},{"_id":"public/categories/数据结构与算法/二叉树/index.html","hash":"6bb63ee7fe4731088f55e3cc5b5ff03f3e23db74","modified":1560911656454},{"_id":"public/categories/Java基础/并发编程/index.html","hash":"db8a1f5c36f38aac57933274c61cd57037e5f1aa","modified":1560911656454},{"_id":"public/categories/SpringMVC框架/index.html","hash":"1bee9084dbdf6a7cd5019055b44512d6793c0c8b","modified":1560911656455},{"_id":"public/index.html","hash":"369a6705b03748b72ef99854a2c75c04d27e4f46","modified":1560911656455},{"_id":"public/page/2/index.html","hash":"ff4f66ec3301140d28f65e09fa019e6b6b839101","modified":1560911656455},{"_id":"public/page/3/index.html","hash":"4ce8c5d11d0b67030bbc0139cf916317609d8326","modified":1560911656455},{"_id":"public/tags/开发日记/index.html","hash":"9d60a794c5e9657e22e15ea9cec0f045dec81934","modified":1560911656455},{"_id":"public/tags/Java基础/index.html","hash":"a0dc5df27689da016bfebc15236be178b21ea03c","modified":1560911656456},{"_id":"public/tags/hexo/index.html","hash":"11bf7658b1a9a734cf70eeb41fb3f6f96c08d9aa","modified":1560911656456},{"_id":"public/tags/springboot/index.html","hash":"35bf73a606432d5f6d7e852ac52a2589ccee6503","modified":1560911656456},{"_id":"public/tags/dubbo/index.html","hash":"aaf6b474608624c4ec260b28ec636354511d4099","modified":1560911656455},{"_id":"public/tags/分布式服务降级/index.html","hash":"287809e0f8d68ee53a3b95fe99952935f08312ce","modified":1560911656456},{"_id":"public/tags/程序人生/index.html","hash":"1f77bf3d210711c52eb0b6216c19c2b27a0a892e","modified":1560911656457},{"_id":"public/tags/工作技巧/index.html","hash":"fd3a7a9ca8a98e257ce344a77079192c3c328598","modified":1560911656456},{"_id":"public/tags/nodepad/index.html","hash":"1f5fb330579151b433dd8b41e747aa6b20c17267","modified":1560911656458},{"_id":"public/tags/leetcode/index.html","hash":"0d0cf3fb32ec4839521771356e52725355420b9c","modified":1560911656458},{"_id":"public/tags/算法题解/index.html","hash":"64f320e2d97e4d54420ad556367201d0b21201c4","modified":1560911656457},{"_id":"public/tags/实习/index.html","hash":"ed4c0543c9af6f94cc98f5828afa6c126f1e6424","modified":1560911656457},{"_id":"public/tags/三星/index.html","hash":"c9bcefc744a757269f4c0504bdc832fa2be1b21a","modified":1560911656457},{"_id":"public/tags/shell自动化测试/index.html","hash":"e79c5ac510282e53cfcc7213bc29680827f9d042","modified":1560911656458},{"_id":"public/tags/shiro/index.html","hash":"c2d6d8f5f5de47698645ed37d51872f3e131b4ca","modified":1560911656458},{"_id":"public/tags/session污染/index.html","hash":"8c7486ac85546bf22c1d57108373b8d6a5c48885","modified":1560911656458},{"_id":"public/tags/事务/index.html","hash":"ea6965e65fcecce1a40297652d80853d830f6592","modified":1560911656458},{"_id":"public/tags/数据库/index.html","hash":"9579ee5cdbe1872d18fedf65bd1f0592ca65ff16","modified":1560911656458},{"_id":"public/tags/数据结构与算法/index.html","hash":"e92a19d5301345d4c997cbd339a2ad0bb511a008","modified":1560911656458},{"_id":"public/tags/二叉树/index.html","hash":"d5647830db9b6aff95000525a5f9c3a28a3b70c9","modified":1560911656458},{"_id":"public/tags/个人随笔/index.html","hash":"a8d985f584d44677e68570f2c2fe7baba042c9e5","modified":1560911656458},{"_id":"public/tags/开发工具/index.html","hash":"42056816b27df0223373eb5e752efb1ada02cedc","modified":1560911656458},{"_id":"public/tags/IDEA/index.html","hash":"85a28288659e4ec73ba967a5a4f356448cee53bc","modified":1560911656459},{"_id":"public/tags/git/index.html","hash":"274fa869116ac4b2d94e99f74e5331d130a25900","modified":1560911656459},{"_id":"public/tags/国际化/index.html","hash":"1f649566b1dcf5c2f22377061d67adceeb314f14","modified":1560911656458},{"_id":"public/tags/并发编程/index.html","hash":"86086959d9b8f7a3cc6d5464c59733f04a7df4c0","modified":1560911656458},{"_id":"public/tags/AQS/index.html","hash":"3c3cbe5b5e12f8b4c1bff0457432522eb03f11e9","modified":1560911656458},{"_id":"public/tags/CountDownLatch/index.html","hash":"48d30d4b8b44ade7cca81721635b65bdd7aa56b0","modified":1560911656459},{"_id":"public/tags/可重入锁/index.html","hash":"6923fc731896ded2d0a5c0431636d881b0704adf","modified":1560911656459},{"_id":"public/tags/spring/index.html","hash":"e715d5b01f26c94da2a02735411c81a4868dd032","modified":1560911656459},{"_id":"public/tags/面试经历/index.html","hash":"cd47677c6185a42c555cf1390e5cfa06f178cebe","modified":1560911656459},{"_id":"public/tags/Spring/index.html","hash":"219fdbe7d54a36d0d5a85189523bfbb989719cee","modified":1560911656459},{"_id":"public/tags/SpringMVC/index.html","hash":"e359f69604105bc7356d51016b14feaf4e023385","modified":1560911656459},{"_id":"public/tags/Servlet/index.html","hash":"b1053ba12ffb7ddcf93f77e26fb18b71e32b30fa","modified":1560911656459},{"_id":"public/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/index.html","hash":"182266949d0ceeddb5da483d2a259e2fbc4ac20e","modified":1560911656430},{"_id":"public/tags/ThreadPoolExecutor/index.html","hash":"e82ed16b8ff954060b1e6676fdf2ad47931e51b3","modified":1560911656459},{"_id":"public/tags/线程池/index.html","hash":"a30cf05fb83457ad9c1b6064ef7e2719716180dd","modified":1560911656459},{"_id":"public/tags/内存分配/index.html","hash":"27926bb2ff5758f6bec21d4386c98f3859ffa9fa","modified":1560911656459},{"_id":"public/tags/垃圾回收/index.html","hash":"aa7f0851fdbed3ebd46eaf3d4a7efc821238e1da","modified":1560911656460},{"_id":"public/tags/序列化/index.html","hash":"f30ed0ddfaae32ff667c7a7638a1771c4626077d","modified":1560911656459},{"_id":"public/tags/transient关键字/index.html","hash":"4db7c4c8361e863dd25721ff83c1ac30fedb849b","modified":1560911656459},{"_id":"public/tags/freemarker/index.html","hash":"2f774c3c79bc4360c87793d419ebf3caa38865b6","modified":1560911656459},{"_id":"public/tags/工厂模式/index.html","hash":"5744a8372981d5119a62ec4de58a37f3c1a14619","modified":1560911656460},{"_id":"public/tags/layui/index.html","hash":"a19770dd2787774c0e1890bad20888a075808239","modified":1560911656460},{"_id":"public/tags/单例模式/index.html","hash":"7c3bdde08f16f0a81136b30801083e85d255ee7b","modified":1560911656459},{"_id":"public/tags/设计模式/index.html","hash":"3ac1fc648c0c67df659b97f9cace4fddef709e22","modified":1560911656459},{"_id":"public/images/nml.jpg","hash":"a7e6e1f40f69d8b2a23fc04d4df8902eb11fd101","modified":1560766635855},{"_id":"public/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/bhcl.png","hash":"fea4784e095123eabea069b92c81d838aa2841a3","modified":1560766635855},{"_id":"public/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcc.png","hash":"c486417d89a1bb2294cc427e801c99219b032bb2","modified":1560766635861},{"_id":"public/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/gzhs.png","hash":"5e5e68c503b370f406edad52f86e30ea73976c2c","modified":1560766635862},{"_id":"public/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcgz.png","hash":"21a72fdd92b0553621ebd66732e7df67a276d8b3","modified":1560766635883},{"_id":"public/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png","hash":"5867c0272859dac4b467386c7623136ae1b75a10","modified":1560766635892},{"_id":"public/css/main.css","hash":"9e34192109842236076697a3774466ea065b7d50","modified":1560771207031}],"Category":[{"name":"Java基础","_id":"cjwzzwvuq0004cwnki3jkhofy"},{"name":"hexo博客配置","_id":"cjwzzwvuz000bcwnkmpec2649"},{"name":"dubbo","_id":"cjwzzwvv3000hcwnkdfg0snou"},{"name":"程序人生","_id":"cjwzzwvv8000pcwnkw2rl15k8"},{"name":"开发工具","_id":"cjwzzwvvb000ucwnkqisizy1q"},{"name":"算法题解","_id":"cjwzzwvve0013cwnk0pstrdgm"},{"name":"springboot","_id":"cjwzzwvvh0018cwnku8d62424"},{"name":"数据结构与算法","_id":"cjwzzwvvq001tcwnka4xm0vhy"},{"name":"个人随笔","_id":"cjwzzwvvw0028cwnkx5kcl3o4"},{"name":"git","_id":"cjwzzwvw1002gcwnk5k6sq7r7"},{"name":"并发编程","parent":"cjwzzwvuq0004cwnki3jkhofy","_id":"cjwzzwvw2002mcwnk5e1w0r77"},{"name":"二叉树","parent":"cjwzzwvvq001tcwnka4xm0vhy","_id":"cjwzzwvw6002xcwnk2g8c7gj4"},{"name":"SpringMVC框架","_id":"cjwzzwvwb003hcwnkdx5axlt3"}],"Data":[],"Page":[{"title":"个人简历","date":"2019-04-23T12:59:33.000Z","type":"about","comments":0,"_content":"<link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.0.13/css/all.css\">\n<style>\nbody {\n    font-family: \"微软雅黑\", Helvetica, \"微软雅黑\", Arial, sans-serif;\n    font-size: 13px;\n    line-height: 18px;\n    margin: 10px 13px 10px 13px;\n}\n</style>\n<div style=\"float:right\">\n    <a href=\"https://github.com/Fatezhang\"><img src=\"me.jpg\" width=\"100\"></a>\n</div>\n## <i class=\"fa fa-address-book\"></i> 张嘉恒 <font size=\"3\">/ <i class=\"fa fa-mars\"></i> Jiaheng Zhang</font>\n### <i class=\"fa fa-star\"></i> Java后端开发工程师 <font size=\"2\">/ Java Web Engineer</font> <!-- *<font size=\"2\" color=\"#BDB76B\">/ 期望薪资15K+</font>* -->\n  - <i class=\"fa fa-home\"></i>  陕西西安\n  - <i class=\"fa fa-envelope-o fa-fw\"></i> 762344938@qq.com\n  - <i class=\"fa fa-mobile-phone\"></i>  18829291537\n  - <i class=\"fa fa-file-text\"></i>  http://zhangjiaheng.cn\n  - <i class=\"fa fa-university\"></i> 西安邮电大学 (2013/07 - 2017/09) *<font size=\"2\" color=\"#BDB76B\">本科</font>*\n\n### <i class=\"fa fa-user-circle-o\"></i>  关于我\n\n- 我是一个乐观开朗，热爱技术，喜欢新鲜事物而且一点儿也不宅的程序员。对于工作认真负责，并能够尝试使用高效率的解决方式去完成。对于自己渴求不断进步，人总是希望能够跳出现有的圈子去与更厉害的人交流学习，我也是。生活中有很多的兴趣爱好，除了技术类的以及逛逛V2EX，掘金等论坛之外，平时也喜欢旅行，户外徒步，也因此拥有来自天南海北的各种朋友。喜欢健身，街舞等，为自己的业余生活增加一些很酷的元素。会通过视频vlog记录自己，并尝试不断地探索着其他更多未知领域。\n\n### <i class=\"fa fa-code\"></i> 技能清单\n\n  - Java基础扎实，熟悉集合、多线程等操作，熟悉常用的设计模式以及数据结构与算法\n  - 熟练使用Spring、SpringMvc、Springboot、Mybatis等框架进行web后端开发\n  - 拥有分布式服务开发经验，多个使用dubbo/zookeeper进行分布式服务开发的项目经验\n  - 熟悉Redis/Memcache等缓存服务，熟悉使用Mysql数据库\n  - 了解Linux常用操作，能够独立进行项目搭建部署以及各种依赖环境的配置\n  - 熟悉nginx、tomcat等，能够使用Jenkins进行代码的持续集成部署\n  - 掌握前端常用的html/css/JS/jQuery等语言或库\n  - 熟练使用git，svn，maven等开发管理工具，熟练使用markdown进行文档编写\n\n\n### <i class=\"fa fa-id-badge\"></i>  工作经历\n#### <i class=\"fa fa-bookmark-o\"></i> 杭州51公积金 ( *2018/07 - 今* ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">Java后端开发工程师</font>\n  - **51有钱理财后台**：负责理财后台业务以及APP相关接口开发。项目管理后台前端使用TopjUI框架，后台使用Springboot+MyBatis框架搭建，结合dubbo+zookeeper进行服务拆分，使用rocketmq作为消息队列以对系统进行削峰和某些业务解耦，使用redis完成业务的一些缓存服务，使用[TX-LCN](https://www.txlcn.org/zh-cn/docs/demo/env.html)解决dubbo中的分布式事务问题。使用Jenkins进行代码可持续集成部署。我主要负责的有：开发**风控模块**，对接新颜以及同盾数据接口，对商户推来的订单进行风控的自动审核，提高风控人员的工作效率；开发报表数据等页面**异步导出**功能，后台结合阿里OSS追加上传实现大数据量异步导出，前端只需要添加一个页面导出按钮即可无需再编写其他代码，很大程度上减少了同事的开发时间；开发**定时任务管理模块**，整合quartz完成定时任务的可配置化操作，减少编写定时任务的大量冗余代码，提高了同事们的工作效率。\n  - **贷款超市**：负责框架搭建以及管理系统的开发。项目使用Springboot+MyBatis框架，使用redis作为缓存服务。我主要负责框架搭建部署以及后台管理系统权限相关、资源位等相关模块的开发。\n\n#### <i class=\"fa fa-bookmark-o\"></i> 浙江核新同花顺 ( *2017/02 - 2018/07* ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">Java后端开发工程师</font>\n  - **level2后台管理系统**：负责level2十档权限订单管理系统后台开发以及APP的服务端开发。项目使用SpringMVC+MyBatis框架搭建，使用dubbo+zookeeper进行服务拆分。主要包括商品、活动、订单、报表等模块。使用百度开源的disconf做统一配置管理，使用memcache作为缓存服务，提高部分查询频率高的接口响应速度。使用quartz实现分布式定时任务。\n  - **投顾中台管理系统**：投顾中台是为券商提供的进行组合策略、工作室、观点文章、图文直播发布的后台管理系统。同样使用SpringMVC+MyBatis以及dubbo+zookeeper搭建分布式服务。使用redis存取直播内容，同时同步到mysql进行数据落地。前端使用h5轮询的方式实现投资顾问的直播内容展现。\n\n#### <i class=\"fa fa-bookmark-o\"></i> 西安三星电子研究所 ( *2016/03 - 2016/08* ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">测试开发实习</font>\n  - 根据组长提供的测试用例或者自己编写测试用例，编写shell脚本，针对ARTIK芯片进行自动化测试。如针对芯片间的蓝牙连接进行文件传输测试等，编写脚本发送文件以及检测文件是否传输成功等工作。实习期间学习到了不少Linux相关知识，以及其他硬件自动化测试知识。\n\n#### - 致谢 -\n\n感谢您花时间阅读我的简历，期待能够机会与您一起共事！\n","source":"about/index.md","raw":"---\ntitle: 个人简历\ndate: 2019-04-23 20:59:33\ntype: \"about\"\ncomments: false\n---\n<link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.0.13/css/all.css\">\n<style>\nbody {\n    font-family: \"微软雅黑\", Helvetica, \"微软雅黑\", Arial, sans-serif;\n    font-size: 13px;\n    line-height: 18px;\n    margin: 10px 13px 10px 13px;\n}\n</style>\n<div style=\"float:right\">\n    <a href=\"https://github.com/Fatezhang\"><img src=\"me.jpg\" width=\"100\"></a>\n</div>\n## <i class=\"fa fa-address-book\"></i> 张嘉恒 <font size=\"3\">/ <i class=\"fa fa-mars\"></i> Jiaheng Zhang</font>\n### <i class=\"fa fa-star\"></i> Java后端开发工程师 <font size=\"2\">/ Java Web Engineer</font> <!-- *<font size=\"2\" color=\"#BDB76B\">/ 期望薪资15K+</font>* -->\n  - <i class=\"fa fa-home\"></i>  陕西西安\n  - <i class=\"fa fa-envelope-o fa-fw\"></i> 762344938@qq.com\n  - <i class=\"fa fa-mobile-phone\"></i>  18829291537\n  - <i class=\"fa fa-file-text\"></i>  http://zhangjiaheng.cn\n  - <i class=\"fa fa-university\"></i> 西安邮电大学 (2013/07 - 2017/09) *<font size=\"2\" color=\"#BDB76B\">本科</font>*\n\n### <i class=\"fa fa-user-circle-o\"></i>  关于我\n\n- 我是一个乐观开朗，热爱技术，喜欢新鲜事物而且一点儿也不宅的程序员。对于工作认真负责，并能够尝试使用高效率的解决方式去完成。对于自己渴求不断进步，人总是希望能够跳出现有的圈子去与更厉害的人交流学习，我也是。生活中有很多的兴趣爱好，除了技术类的以及逛逛V2EX，掘金等论坛之外，平时也喜欢旅行，户外徒步，也因此拥有来自天南海北的各种朋友。喜欢健身，街舞等，为自己的业余生活增加一些很酷的元素。会通过视频vlog记录自己，并尝试不断地探索着其他更多未知领域。\n\n### <i class=\"fa fa-code\"></i> 技能清单\n\n  - Java基础扎实，熟悉集合、多线程等操作，熟悉常用的设计模式以及数据结构与算法\n  - 熟练使用Spring、SpringMvc、Springboot、Mybatis等框架进行web后端开发\n  - 拥有分布式服务开发经验，多个使用dubbo/zookeeper进行分布式服务开发的项目经验\n  - 熟悉Redis/Memcache等缓存服务，熟悉使用Mysql数据库\n  - 了解Linux常用操作，能够独立进行项目搭建部署以及各种依赖环境的配置\n  - 熟悉nginx、tomcat等，能够使用Jenkins进行代码的持续集成部署\n  - 掌握前端常用的html/css/JS/jQuery等语言或库\n  - 熟练使用git，svn，maven等开发管理工具，熟练使用markdown进行文档编写\n\n\n### <i class=\"fa fa-id-badge\"></i>  工作经历\n#### <i class=\"fa fa-bookmark-o\"></i> 杭州51公积金 ( *2018/07 - 今* ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">Java后端开发工程师</font>\n  - **51有钱理财后台**：负责理财后台业务以及APP相关接口开发。项目管理后台前端使用TopjUI框架，后台使用Springboot+MyBatis框架搭建，结合dubbo+zookeeper进行服务拆分，使用rocketmq作为消息队列以对系统进行削峰和某些业务解耦，使用redis完成业务的一些缓存服务，使用[TX-LCN](https://www.txlcn.org/zh-cn/docs/demo/env.html)解决dubbo中的分布式事务问题。使用Jenkins进行代码可持续集成部署。我主要负责的有：开发**风控模块**，对接新颜以及同盾数据接口，对商户推来的订单进行风控的自动审核，提高风控人员的工作效率；开发报表数据等页面**异步导出**功能，后台结合阿里OSS追加上传实现大数据量异步导出，前端只需要添加一个页面导出按钮即可无需再编写其他代码，很大程度上减少了同事的开发时间；开发**定时任务管理模块**，整合quartz完成定时任务的可配置化操作，减少编写定时任务的大量冗余代码，提高了同事们的工作效率。\n  - **贷款超市**：负责框架搭建以及管理系统的开发。项目使用Springboot+MyBatis框架，使用redis作为缓存服务。我主要负责框架搭建部署以及后台管理系统权限相关、资源位等相关模块的开发。\n\n#### <i class=\"fa fa-bookmark-o\"></i> 浙江核新同花顺 ( *2017/02 - 2018/07* ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">Java后端开发工程师</font>\n  - **level2后台管理系统**：负责level2十档权限订单管理系统后台开发以及APP的服务端开发。项目使用SpringMVC+MyBatis框架搭建，使用dubbo+zookeeper进行服务拆分。主要包括商品、活动、订单、报表等模块。使用百度开源的disconf做统一配置管理，使用memcache作为缓存服务，提高部分查询频率高的接口响应速度。使用quartz实现分布式定时任务。\n  - **投顾中台管理系统**：投顾中台是为券商提供的进行组合策略、工作室、观点文章、图文直播发布的后台管理系统。同样使用SpringMVC+MyBatis以及dubbo+zookeeper搭建分布式服务。使用redis存取直播内容，同时同步到mysql进行数据落地。前端使用h5轮询的方式实现投资顾问的直播内容展现。\n\n#### <i class=\"fa fa-bookmark-o\"></i> 西安三星电子研究所 ( *2016/03 - 2016/08* ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">测试开发实习</font>\n  - 根据组长提供的测试用例或者自己编写测试用例，编写shell脚本，针对ARTIK芯片进行自动化测试。如针对芯片间的蓝牙连接进行文件传输测试等，编写脚本发送文件以及检测文件是否传输成功等工作。实习期间学习到了不少Linux相关知识，以及其他硬件自动化测试知识。\n\n#### - 致谢 -\n\n感谢您花时间阅读我的简历，期待能够机会与您一起共事！\n","updated":"2019-05-10T03:50:37.848Z","path":"about/index.html","layout":"page","_id":"cjwzzwvul0001cwnkyjhqbz1z","content":"<p><link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.0.13/css/all.css\"></p>\n<p><style><br>body {<br>    font-family: “微软雅黑”, Helvetica, “微软雅黑”, Arial, sans-serif;<br>    font-size: 13px;<br>    line-height: 18px;<br>    margin: 10px 13px 10px 13px;<br>}<br></style></p>\n<p><div style=\"float:right\"><br>    <a href=\"https://github.com/Fatezhang\" target=\"_blank\" rel=\"noopener\"><img src=\"/about/me.jpg\" width=\"100\"></a><br></div></p>\n<h2 id=\"张嘉恒-Jiaheng-Zhang\"><a href=\"#张嘉恒-Jiaheng-Zhang\" class=\"headerlink\" title=\" 张嘉恒 /  Jiaheng Zhang\"></a><i class=\"fa fa-address-book\"></i> 张嘉恒 <font size=\"3\">/ <i class=\"fa fa-mars\"></i> Jiaheng Zhang</font></h2><h3 id=\"Java后端开发工程师-Java-Web-Engineer\"><a href=\"#Java后端开发工程师-Java-Web-Engineer\" class=\"headerlink\" title=\" Java后端开发工程师 / Java Web Engineer \"></a><i class=\"fa fa-star\"></i> Java后端开发工程师 <font size=\"2\">/ Java Web Engineer</font> <!-- *<font size=\"2\" color=\"#BDB76B\">/ 期望薪资15K+</font>* --></h3><ul>\n<li><i class=\"fa fa-home\"></i>  陕西西安</li>\n<li><i class=\"fa fa-envelope-o fa-fw\"></i> <a href=\"mailto:762344938@qq.com\" target=\"_blank\" rel=\"noopener\">762344938@qq.com</a></li>\n<li><i class=\"fa fa-mobile-phone\"></i>  18829291537</li>\n<li><i class=\"fa fa-file-text\"></i>  <a href=\"http://zhangjiaheng.cn\">http://zhangjiaheng.cn</a></li>\n<li><i class=\"fa fa-university\"></i> 西安邮电大学 (2013/07 - 2017/09) <em><font size=\"2\" color=\"#BDB76B\">本科</font></em></li>\n</ul>\n<h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"  关于我\"></a><i class=\"fa fa-user-circle-o\"></i>  关于我</h3><ul>\n<li>我是一个乐观开朗，热爱技术，喜欢新鲜事物而且一点儿也不宅的程序员。对于工作认真负责，并能够尝试使用高效率的解决方式去完成。对于自己渴求不断进步，人总是希望能够跳出现有的圈子去与更厉害的人交流学习，我也是。生活中有很多的兴趣爱好，除了技术类的以及逛逛V2EX，掘金等论坛之外，平时也喜欢旅行，户外徒步，也因此拥有来自天南海北的各种朋友。喜欢健身，街舞等，为自己的业余生活增加一些很酷的元素。会通过视频vlog记录自己，并尝试不断地探索着其他更多未知领域。</li>\n</ul>\n<h3 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\" 技能清单\"></a><i class=\"fa fa-code\"></i> 技能清单</h3><ul>\n<li>Java基础扎实，熟悉集合、多线程等操作，熟悉常用的设计模式以及数据结构与算法</li>\n<li>熟练使用Spring、SpringMvc、Springboot、Mybatis等框架进行web后端开发</li>\n<li>拥有分布式服务开发经验，多个使用dubbo/zookeeper进行分布式服务开发的项目经验</li>\n<li>熟悉Redis/Memcache等缓存服务，熟悉使用Mysql数据库</li>\n<li>了解Linux常用操作，能够独立进行项目搭建部署以及各种依赖环境的配置</li>\n<li>熟悉nginx、tomcat等，能够使用Jenkins进行代码的持续集成部署</li>\n<li>掌握前端常用的html/css/JS/jQuery等语言或库</li>\n<li>熟练使用git，svn，maven等开发管理工具，熟练使用markdown进行文档编写</li>\n</ul>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"  工作经历\"></a><i class=\"fa fa-id-badge\"></i>  工作经历</h3><h4 id=\"杭州51公积金-2018-07-今-nbsp-nbsp-nbsp-nbsp-Java后端开发工程师\"><a href=\"#杭州51公积金-2018-07-今-nbsp-nbsp-nbsp-nbsp-Java后端开发工程师\" class=\"headerlink\" title=\" 杭州51公积金 ( 2018/07 - 今 ) &nbsp;&nbsp;&nbsp;&nbsp; Java后端开发工程师\"></a><i class=\"fa fa-bookmark-o\"></i> 杭州51公积金 ( <em>2018/07 - 今</em> ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">Java后端开发工程师</font></h4><ul>\n<li><strong>51有钱理财后台</strong>：负责理财后台业务以及APP相关接口开发。项目管理后台前端使用TopjUI框架，后台使用Springboot+MyBatis框架搭建，结合dubbo+zookeeper进行服务拆分，使用rocketmq作为消息队列以对系统进行削峰和某些业务解耦，使用redis完成业务的一些缓存服务，使用<a href=\"https://www.txlcn.org/zh-cn/docs/demo/env.html\" target=\"_blank\" rel=\"noopener\">TX-LCN</a>解决dubbo中的分布式事务问题。使用Jenkins进行代码可持续集成部署。我主要负责的有：开发<strong>风控模块</strong>，对接新颜以及同盾数据接口，对商户推来的订单进行风控的自动审核，提高风控人员的工作效率；开发报表数据等页面<strong>异步导出</strong>功能，后台结合阿里OSS追加上传实现大数据量异步导出，前端只需要添加一个页面导出按钮即可无需再编写其他代码，很大程度上减少了同事的开发时间；开发<strong>定时任务管理模块</strong>，整合quartz完成定时任务的可配置化操作，减少编写定时任务的大量冗余代码，提高了同事们的工作效率。</li>\n<li><strong>贷款超市</strong>：负责框架搭建以及管理系统的开发。项目使用Springboot+MyBatis框架，使用redis作为缓存服务。我主要负责框架搭建部署以及后台管理系统权限相关、资源位等相关模块的开发。</li>\n</ul>\n<h4 id=\"浙江核新同花顺-2017-02-2018-07-nbsp-nbsp-nbsp-nbsp-Java后端开发工程师\"><a href=\"#浙江核新同花顺-2017-02-2018-07-nbsp-nbsp-nbsp-nbsp-Java后端开发工程师\" class=\"headerlink\" title=\" 浙江核新同花顺 ( 2017/02 - 2018/07 ) &nbsp;&nbsp;&nbsp;&nbsp; Java后端开发工程师\"></a><i class=\"fa fa-bookmark-o\"></i> 浙江核新同花顺 ( <em>2017/02 - 2018/07</em> ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">Java后端开发工程师</font></h4><ul>\n<li><strong>level2后台管理系统</strong>：负责level2十档权限订单管理系统后台开发以及APP的服务端开发。项目使用SpringMVC+MyBatis框架搭建，使用dubbo+zookeeper进行服务拆分。主要包括商品、活动、订单、报表等模块。使用百度开源的disconf做统一配置管理，使用memcache作为缓存服务，提高部分查询频率高的接口响应速度。使用quartz实现分布式定时任务。</li>\n<li><strong>投顾中台管理系统</strong>：投顾中台是为券商提供的进行组合策略、工作室、观点文章、图文直播发布的后台管理系统。同样使用SpringMVC+MyBatis以及dubbo+zookeeper搭建分布式服务。使用redis存取直播内容，同时同步到mysql进行数据落地。前端使用h5轮询的方式实现投资顾问的直播内容展现。</li>\n</ul>\n<h4 id=\"西安三星电子研究所-2016-03-2016-08-nbsp-nbsp-nbsp-nbsp-测试开发实习\"><a href=\"#西安三星电子研究所-2016-03-2016-08-nbsp-nbsp-nbsp-nbsp-测试开发实习\" class=\"headerlink\" title=\" 西安三星电子研究所 ( 2016/03 - 2016/08 ) &nbsp;&nbsp;&nbsp;&nbsp; 测试开发实习\"></a><i class=\"fa fa-bookmark-o\"></i> 西安三星电子研究所 ( <em>2016/03 - 2016/08</em> ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">测试开发实习</font></h4><ul>\n<li>根据组长提供的测试用例或者自己编写测试用例，编写shell脚本，针对ARTIK芯片进行自动化测试。如针对芯片间的蓝牙连接进行文件传输测试等，编写脚本发送文件以及检测文件是否传输成功等工作。实习期间学习到了不少Linux相关知识，以及其他硬件自动化测试知识。</li>\n</ul>\n<h4 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"- 致谢 -\"></a>- 致谢 -</h4><p>感谢您花时间阅读我的简历，期待能够机会与您一起共事！</p>\n","site":{"data":{}},"excerpt":"","more":"<p><link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.0.13/css/all.css\"></p>\n<p><style><br>body {<br>    font-family: “微软雅黑”, Helvetica, “微软雅黑”, Arial, sans-serif;<br>    font-size: 13px;<br>    line-height: 18px;<br>    margin: 10px 13px 10px 13px;<br>}<br></style></p>\n<p><div style=\"float:right\"><br>    <a href=\"https://github.com/Fatezhang\" target=\"_blank\" rel=\"noopener\"><img src=\"/about/me.jpg\" width=\"100\"></a><br></div></p>\n<h2 id=\"张嘉恒-Jiaheng-Zhang\"><a href=\"#张嘉恒-Jiaheng-Zhang\" class=\"headerlink\" title=\" 张嘉恒 /  Jiaheng Zhang\"></a><i class=\"fa fa-address-book\"></i> 张嘉恒 <font size=\"3\">/ <i class=\"fa fa-mars\"></i> Jiaheng Zhang</font></h2><h3 id=\"Java后端开发工程师-Java-Web-Engineer\"><a href=\"#Java后端开发工程师-Java-Web-Engineer\" class=\"headerlink\" title=\" Java后端开发工程师 / Java Web Engineer \"></a><i class=\"fa fa-star\"></i> Java后端开发工程师 <font size=\"2\">/ Java Web Engineer</font> <!-- *<font size=\"2\" color=\"#BDB76B\">/ 期望薪资15K+</font>* --></h3><ul>\n<li><i class=\"fa fa-home\"></i>  陕西西安</li>\n<li><i class=\"fa fa-envelope-o fa-fw\"></i> <a href=\"mailto:762344938@qq.com\" target=\"_blank\" rel=\"noopener\">762344938@qq.com</a></li>\n<li><i class=\"fa fa-mobile-phone\"></i>  18829291537</li>\n<li><i class=\"fa fa-file-text\"></i>  <a href=\"http://zhangjiaheng.cn\">http://zhangjiaheng.cn</a></li>\n<li><i class=\"fa fa-university\"></i> 西安邮电大学 (2013/07 - 2017/09) <em><font size=\"2\" color=\"#BDB76B\">本科</font></em></li>\n</ul>\n<h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"  关于我\"></a><i class=\"fa fa-user-circle-o\"></i>  关于我</h3><ul>\n<li>我是一个乐观开朗，热爱技术，喜欢新鲜事物而且一点儿也不宅的程序员。对于工作认真负责，并能够尝试使用高效率的解决方式去完成。对于自己渴求不断进步，人总是希望能够跳出现有的圈子去与更厉害的人交流学习，我也是。生活中有很多的兴趣爱好，除了技术类的以及逛逛V2EX，掘金等论坛之外，平时也喜欢旅行，户外徒步，也因此拥有来自天南海北的各种朋友。喜欢健身，街舞等，为自己的业余生活增加一些很酷的元素。会通过视频vlog记录自己，并尝试不断地探索着其他更多未知领域。</li>\n</ul>\n<h3 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\" 技能清单\"></a><i class=\"fa fa-code\"></i> 技能清单</h3><ul>\n<li>Java基础扎实，熟悉集合、多线程等操作，熟悉常用的设计模式以及数据结构与算法</li>\n<li>熟练使用Spring、SpringMvc、Springboot、Mybatis等框架进行web后端开发</li>\n<li>拥有分布式服务开发经验，多个使用dubbo/zookeeper进行分布式服务开发的项目经验</li>\n<li>熟悉Redis/Memcache等缓存服务，熟悉使用Mysql数据库</li>\n<li>了解Linux常用操作，能够独立进行项目搭建部署以及各种依赖环境的配置</li>\n<li>熟悉nginx、tomcat等，能够使用Jenkins进行代码的持续集成部署</li>\n<li>掌握前端常用的html/css/JS/jQuery等语言或库</li>\n<li>熟练使用git，svn，maven等开发管理工具，熟练使用markdown进行文档编写</li>\n</ul>\n<h3 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"  工作经历\"></a><i class=\"fa fa-id-badge\"></i>  工作经历</h3><h4 id=\"杭州51公积金-2018-07-今-nbsp-nbsp-nbsp-nbsp-Java后端开发工程师\"><a href=\"#杭州51公积金-2018-07-今-nbsp-nbsp-nbsp-nbsp-Java后端开发工程师\" class=\"headerlink\" title=\" 杭州51公积金 ( 2018/07 - 今 ) &nbsp;&nbsp;&nbsp;&nbsp; Java后端开发工程师\"></a><i class=\"fa fa-bookmark-o\"></i> 杭州51公积金 ( <em>2018/07 - 今</em> ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">Java后端开发工程师</font></h4><ul>\n<li><strong>51有钱理财后台</strong>：负责理财后台业务以及APP相关接口开发。项目管理后台前端使用TopjUI框架，后台使用Springboot+MyBatis框架搭建，结合dubbo+zookeeper进行服务拆分，使用rocketmq作为消息队列以对系统进行削峰和某些业务解耦，使用redis完成业务的一些缓存服务，使用<a href=\"https://www.txlcn.org/zh-cn/docs/demo/env.html\" target=\"_blank\" rel=\"noopener\">TX-LCN</a>解决dubbo中的分布式事务问题。使用Jenkins进行代码可持续集成部署。我主要负责的有：开发<strong>风控模块</strong>，对接新颜以及同盾数据接口，对商户推来的订单进行风控的自动审核，提高风控人员的工作效率；开发报表数据等页面<strong>异步导出</strong>功能，后台结合阿里OSS追加上传实现大数据量异步导出，前端只需要添加一个页面导出按钮即可无需再编写其他代码，很大程度上减少了同事的开发时间；开发<strong>定时任务管理模块</strong>，整合quartz完成定时任务的可配置化操作，减少编写定时任务的大量冗余代码，提高了同事们的工作效率。</li>\n<li><strong>贷款超市</strong>：负责框架搭建以及管理系统的开发。项目使用Springboot+MyBatis框架，使用redis作为缓存服务。我主要负责框架搭建部署以及后台管理系统权限相关、资源位等相关模块的开发。</li>\n</ul>\n<h4 id=\"浙江核新同花顺-2017-02-2018-07-nbsp-nbsp-nbsp-nbsp-Java后端开发工程师\"><a href=\"#浙江核新同花顺-2017-02-2018-07-nbsp-nbsp-nbsp-nbsp-Java后端开发工程师\" class=\"headerlink\" title=\" 浙江核新同花顺 ( 2017/02 - 2018/07 ) &nbsp;&nbsp;&nbsp;&nbsp; Java后端开发工程师\"></a><i class=\"fa fa-bookmark-o\"></i> 浙江核新同花顺 ( <em>2017/02 - 2018/07</em> ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">Java后端开发工程师</font></h4><ul>\n<li><strong>level2后台管理系统</strong>：负责level2十档权限订单管理系统后台开发以及APP的服务端开发。项目使用SpringMVC+MyBatis框架搭建，使用dubbo+zookeeper进行服务拆分。主要包括商品、活动、订单、报表等模块。使用百度开源的disconf做统一配置管理，使用memcache作为缓存服务，提高部分查询频率高的接口响应速度。使用quartz实现分布式定时任务。</li>\n<li><strong>投顾中台管理系统</strong>：投顾中台是为券商提供的进行组合策略、工作室、观点文章、图文直播发布的后台管理系统。同样使用SpringMVC+MyBatis以及dubbo+zookeeper搭建分布式服务。使用redis存取直播内容，同时同步到mysql进行数据落地。前端使用h5轮询的方式实现投资顾问的直播内容展现。</li>\n</ul>\n<h4 id=\"西安三星电子研究所-2016-03-2016-08-nbsp-nbsp-nbsp-nbsp-测试开发实习\"><a href=\"#西安三星电子研究所-2016-03-2016-08-nbsp-nbsp-nbsp-nbsp-测试开发实习\" class=\"headerlink\" title=\" 西安三星电子研究所 ( 2016/03 - 2016/08 ) &nbsp;&nbsp;&nbsp;&nbsp; 测试开发实习\"></a><i class=\"fa fa-bookmark-o\"></i> 西安三星电子研究所 ( <em>2016/03 - 2016/08</em> ) &nbsp;&nbsp;&nbsp;&nbsp; <font size=\"2\" color=\"#BDB76B\">测试开发实习</font></h4><ul>\n<li>根据组长提供的测试用例或者自己编写测试用例，编写shell脚本，针对ARTIK芯片进行自动化测试。如针对芯片间的蓝牙连接进行文件传输测试等，编写脚本发送文件以及检测文件是否传输成功等工作。实习期间学习到了不少Linux相关知识，以及其他硬件自动化测试知识。</li>\n</ul>\n<h4 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"- 致谢 -\"></a>- 致谢 -</h4><p>感谢您花时间阅读我的简历，期待能够机会与您一起共事！</p>\n"},{"title":"记昨日书","date":"2018-06-28T03:02:51.000Z","_content":"","source":"archives/index.md","raw":"---\ntitle: 记昨日书\ndate: 2018-06-28 11:02:51\n---\n","updated":"2019-05-07T09:48:29.954Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cjwzzwvuo0003cwnknl72n7sv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"林深时见鹿","date":"2018-07-15T03:53:27.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 林深时见鹿\ndate: 2018-07-15 11:53:27\ntype: \"categories\"\ncomments: false\n---\n","updated":"2019-05-07T09:48:29.959Z","path":"categories/index.html","layout":"page","_id":"cjwzzwvut0007cwnknxjda1et","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Message","date":"2018-06-29T09:19:02.000Z","_content":"","source":"message/index.md","raw":"---\ntitle: message\ndate: 2018-06-29 17:19:02\n---\n","updated":"2019-05-07T09:48:29.964Z","path":"message/index.html","comments":1,"layout":"page","_id":"cjwzzwvuw0009cwnkguixnuv5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"寒星三两","date":"2018-06-26T16:00:00.000Z","type":"tags","comments":0,"_content":"\n","source":"tags/tags.md","raw":"---\ntitle: 寒星三两\ndate: 2018-06-27 \ntype: \"tags\"\ncomments: false\n---\n\n","updated":"2019-05-07T09:48:29.969Z","path":"tags/tags.html","layout":"page","_id":"cjwzzwvuz000dcwnkni8vrtbt","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Java中map新的骚操作","date":"2018-12-09T15:03:05.000Z","_content":"#### 在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：\n\n> #### 总结\n> `computeIfPresent` 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null\n> `computeIfAbsent`  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值\n> `compute`          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。\n\n\n<!--more-->\n```\npackage test;\n\nimport java.util.HashMap;\n\npublic class MapTest {\n\n    public static void main(String[] args) {\n        HashMap<Integer, String> map = new HashMap<>();\n        map.put(1,\"zhang\");\n        // computeIfPresent 根据之前的key/value 如果oldValue 不为null 则根据提供的方法返回一个新的值 并进行新值对旧值的替换\n        System.out.println(\" 1 ---> \" + map.computeIfPresent(1,(key,value)->{\n            return key + value;//原值不为null新值不为null 新值替换旧值\n        }));\n        // 否则删除键值对\n        System.out.println(\" 2 ---> \" + map.computeIfPresent(1,(key,value)->{\n            return null;//原值不为null新值为null 删除键值对\n        }));\n        map.put(1,null);\n        System.out.println(\" 3 ---> \" + map.computeIfPresent(1,(key,value)->{\n            return \"jiaheng\";//原值为null 不做更改\n        }));\n        // computeIfAbsent 根据之前的key 如果旧值为空或者key不存在 就按照方法用新值替换旧值 新值为null不做替换\n        map.put(1,\"zhang\");\n        System.out.println(\" 4 ---> \" + map.computeIfAbsent(1,k->{\n            return null;// 不会被替换旧值 返回原值\n        }));\n        System.out.println(\" 5 ---> \" + map.computeIfAbsent(2,k->{\n            k = k*k;\n            return k.toString();// key=2不存在 直接新建并存入新值\n        }));\n        // compute类似于computeIfAbsent和computeIfPresent的合体\n        map.put(1,null);\n        System.out.println(\" 6 ---> \" + map.compute(1,(k,v)->{\n            return \"张\";// 原值为null新值不为null 新值替换旧值 此处与computeIfPresent不同\n        }));\n        System.out.println(\" 7 ---> \" + map.compute(1,(k,v)->{\n            v = (k*10) + v;\n            return v;// 新值不为null 替换旧值\n        }));\n        System.out.println(\" 8 ---> \" + map.compute(1,(k,v)->{\n            return null;// 新值为null 删除键值对\n        }));\n\n        // 总结\n        // computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null\n        // computeIfAbsent  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值\n        // compute          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。\n    }\n\n}\n\n```\n","source":"_posts/Java中map新的骚操作.md","raw":"---\ntitle: Java中map新的骚操作\ndate: 2018-12-09 23:03:05\ncategories: [Java基础]\ntags: [开发日记,Java基础]\n---\n#### 在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：\n\n> #### 总结\n> `computeIfPresent` 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null\n> `computeIfAbsent`  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值\n> `compute`          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。\n\n\n<!--more-->\n```\npackage test;\n\nimport java.util.HashMap;\n\npublic class MapTest {\n\n    public static void main(String[] args) {\n        HashMap<Integer, String> map = new HashMap<>();\n        map.put(1,\"zhang\");\n        // computeIfPresent 根据之前的key/value 如果oldValue 不为null 则根据提供的方法返回一个新的值 并进行新值对旧值的替换\n        System.out.println(\" 1 ---> \" + map.computeIfPresent(1,(key,value)->{\n            return key + value;//原值不为null新值不为null 新值替换旧值\n        }));\n        // 否则删除键值对\n        System.out.println(\" 2 ---> \" + map.computeIfPresent(1,(key,value)->{\n            return null;//原值不为null新值为null 删除键值对\n        }));\n        map.put(1,null);\n        System.out.println(\" 3 ---> \" + map.computeIfPresent(1,(key,value)->{\n            return \"jiaheng\";//原值为null 不做更改\n        }));\n        // computeIfAbsent 根据之前的key 如果旧值为空或者key不存在 就按照方法用新值替换旧值 新值为null不做替换\n        map.put(1,\"zhang\");\n        System.out.println(\" 4 ---> \" + map.computeIfAbsent(1,k->{\n            return null;// 不会被替换旧值 返回原值\n        }));\n        System.out.println(\" 5 ---> \" + map.computeIfAbsent(2,k->{\n            k = k*k;\n            return k.toString();// key=2不存在 直接新建并存入新值\n        }));\n        // compute类似于computeIfAbsent和computeIfPresent的合体\n        map.put(1,null);\n        System.out.println(\" 6 ---> \" + map.compute(1,(k,v)->{\n            return \"张\";// 原值为null新值不为null 新值替换旧值 此处与computeIfPresent不同\n        }));\n        System.out.println(\" 7 ---> \" + map.compute(1,(k,v)->{\n            v = (k*10) + v;\n            return v;// 新值不为null 替换旧值\n        }));\n        System.out.println(\" 8 ---> \" + map.compute(1,(k,v)->{\n            return null;// 新值为null 删除键值对\n        }));\n\n        // 总结\n        // computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null\n        // computeIfAbsent  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值\n        // compute          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。\n    }\n\n}\n\n```\n","slug":"Java中map新的骚操作","published":1,"updated":"2019-05-07T09:48:29.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvug0000cwnkkkn3c44s","content":"<h4 id=\"在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：\"><a href=\"#在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：\" class=\"headerlink\" title=\"在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：\"></a>在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：</h4><blockquote>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><code>computeIfPresent</code> 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null<br><code>computeIfAbsent</code>  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值<br><code>compute</code>          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。</p>\n</blockquote>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package test;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MapTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(1,&quot;zhang&quot;);</span><br><span class=\"line\">        // computeIfPresent 根据之前的key/value 如果oldValue 不为null 则根据提供的方法返回一个新的值 并进行新值对旧值的替换</span><br><span class=\"line\">        System.out.println(&quot; 1 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class=\"line\">            return key + value;//原值不为null新值不为null 新值替换旧值</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // 否则删除键值对</span><br><span class=\"line\">        System.out.println(&quot; 2 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class=\"line\">            return null;//原值不为null新值为null 删除键值对</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        map.put(1,null);</span><br><span class=\"line\">        System.out.println(&quot; 3 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class=\"line\">            return &quot;jiaheng&quot;;//原值为null 不做更改</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // computeIfAbsent 根据之前的key 如果旧值为空或者key不存在 就按照方法用新值替换旧值 新值为null不做替换</span><br><span class=\"line\">        map.put(1,&quot;zhang&quot;);</span><br><span class=\"line\">        System.out.println(&quot; 4 ---&gt; &quot; + map.computeIfAbsent(1,k-&gt;&#123;</span><br><span class=\"line\">            return null;// 不会被替换旧值 返回原值</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        System.out.println(&quot; 5 ---&gt; &quot; + map.computeIfAbsent(2,k-&gt;&#123;</span><br><span class=\"line\">            k = k*k;</span><br><span class=\"line\">            return k.toString();// key=2不存在 直接新建并存入新值</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // compute类似于computeIfAbsent和computeIfPresent的合体</span><br><span class=\"line\">        map.put(1,null);</span><br><span class=\"line\">        System.out.println(&quot; 6 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class=\"line\">            return &quot;张&quot;;// 原值为null新值不为null 新值替换旧值 此处与computeIfPresent不同</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        System.out.println(&quot; 7 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class=\"line\">            v = (k*10) + v;</span><br><span class=\"line\">            return v;// 新值不为null 替换旧值</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        System.out.println(&quot; 8 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class=\"line\">            return null;// 新值为null 删除键值对</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 总结</span><br><span class=\"line\">        // computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null</span><br><span class=\"line\">        // computeIfAbsent  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值</span><br><span class=\"line\">        // compute          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：\"><a href=\"#在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：\" class=\"headerlink\" title=\"在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：\"></a>在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下：</h4><blockquote>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><code>computeIfPresent</code> 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null<br><code>computeIfAbsent</code>  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值<br><code>compute</code>          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。</p>\n</blockquote>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package test;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MapTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(1,&quot;zhang&quot;);</span><br><span class=\"line\">        // computeIfPresent 根据之前的key/value 如果oldValue 不为null 则根据提供的方法返回一个新的值 并进行新值对旧值的替换</span><br><span class=\"line\">        System.out.println(&quot; 1 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class=\"line\">            return key + value;//原值不为null新值不为null 新值替换旧值</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // 否则删除键值对</span><br><span class=\"line\">        System.out.println(&quot; 2 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class=\"line\">            return null;//原值不为null新值为null 删除键值对</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        map.put(1,null);</span><br><span class=\"line\">        System.out.println(&quot; 3 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123;</span><br><span class=\"line\">            return &quot;jiaheng&quot;;//原值为null 不做更改</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // computeIfAbsent 根据之前的key 如果旧值为空或者key不存在 就按照方法用新值替换旧值 新值为null不做替换</span><br><span class=\"line\">        map.put(1,&quot;zhang&quot;);</span><br><span class=\"line\">        System.out.println(&quot; 4 ---&gt; &quot; + map.computeIfAbsent(1,k-&gt;&#123;</span><br><span class=\"line\">            return null;// 不会被替换旧值 返回原值</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        System.out.println(&quot; 5 ---&gt; &quot; + map.computeIfAbsent(2,k-&gt;&#123;</span><br><span class=\"line\">            k = k*k;</span><br><span class=\"line\">            return k.toString();// key=2不存在 直接新建并存入新值</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        // compute类似于computeIfAbsent和computeIfPresent的合体</span><br><span class=\"line\">        map.put(1,null);</span><br><span class=\"line\">        System.out.println(&quot; 6 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class=\"line\">            return &quot;张&quot;;// 原值为null新值不为null 新值替换旧值 此处与computeIfPresent不同</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        System.out.println(&quot; 7 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class=\"line\">            v = (k*10) + v;</span><br><span class=\"line\">            return v;// 新值不为null 替换旧值</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        System.out.println(&quot; 8 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123;</span><br><span class=\"line\">            return null;// 新值为null 删除键值对</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 总结</span><br><span class=\"line\">        // computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null</span><br><span class=\"line\">        // computeIfAbsent  就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值</span><br><span class=\"line\">        // compute          就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Hexo博客文章置顶方式","date":"2018-09-04T11:51:53.000Z","_content":"\n### 博文置顶\n#### 目前已经有修改后支持置顶的仓库，可以直接用以下命令安装\n```\nnpm uninstall hexo-generator-index --save\nnpm install hexo-generator-index-pin-top --save\n```\n<!--more-->\n#### 然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：\n```\n---\ntitle: hexo博客置顶\ndate: 2017-09-08 12:00:25\ncategories: 博客搭建系列\ntop: true\n---\n```\n#### 到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：\n##### 打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到`<div class=\"post-meta\">`标签下，紧接着下一行插入如下代码：\n```\n          {% if post.top %}\n            <i class=\"fa fa-thumb-tack\"></i>\n            <font color=7D26CD>置顶</font>\n            <span class=\"post-meta-divider\">|</span>\n          {% endif %}\n```\n---\n至此，博客置顶的方式就全部完成了\n","source":"_posts/hexo博客文章置顶方式.md","raw":"---\ntitle: hexo博客文章置顶方式\ndate: 2018-09-04 19:51:53\ncategories: [hexo博客配置]\ntags: [开发日记,hexo]\n---\n\n### 博文置顶\n#### 目前已经有修改后支持置顶的仓库，可以直接用以下命令安装\n```\nnpm uninstall hexo-generator-index --save\nnpm install hexo-generator-index-pin-top --save\n```\n<!--more-->\n#### 然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：\n```\n---\ntitle: hexo博客置顶\ndate: 2017-09-08 12:00:25\ncategories: 博客搭建系列\ntop: true\n---\n```\n#### 到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：\n##### 打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到`<div class=\"post-meta\">`标签下，紧接着下一行插入如下代码：\n```\n          {% if post.top %}\n            <i class=\"fa fa-thumb-tack\"></i>\n            <font color=7D26CD>置顶</font>\n            <span class=\"post-meta-divider\">|</span>\n          {% endif %}\n```\n---\n至此，博客置顶的方式就全部完成了\n","slug":"hexo博客文章置顶方式","published":1,"updated":"2019-05-07T09:48:29.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvum0002cwnk2xsedldr","content":"<h3 id=\"博文置顶\"><a href=\"#博文置顶\" class=\"headerlink\" title=\"博文置顶\"></a>博文置顶</h3><h4 id=\"目前已经有修改后支持置顶的仓库，可以直接用以下命令安装\"><a href=\"#目前已经有修改后支持置顶的仓库，可以直接用以下命令安装\" class=\"headerlink\" title=\"目前已经有修改后支持置顶的仓库，可以直接用以下命令安装\"></a>目前已经有修改后支持置顶的仓库，可以直接用以下命令安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-generator-index --save</span><br><span class=\"line\">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"然后在需要置顶的文章的Front-matter中加上top-true即可。比如下面这篇文章：\"><a href=\"#然后在需要置顶的文章的Front-matter中加上top-true即可。比如下面这篇文章：\" class=\"headerlink\" title=\"然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：\"></a>然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: hexo博客置顶</span><br><span class=\"line\">date: 2017-09-08 12:00:25</span><br><span class=\"line\">categories: 博客搭建系列</span><br><span class=\"line\">top: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<h4 id=\"到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：\"><a href=\"#到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：\" class=\"headerlink\" title=\"到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：\"></a>到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：</h4><h5 id=\"打开：-blog-themes-next-layout-macro-目录下的post-swig文件，定位到-lt-div-class-quot-post-meta-quot-gt-标签下，紧接着下一行插入如下代码：\"><a href=\"#打开：-blog-themes-next-layout-macro-目录下的post-swig文件，定位到-lt-div-class-quot-post-meta-quot-gt-标签下，紧接着下一行插入如下代码：\" class=\"headerlink\" title=\"打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，紧接着下一行插入如下代码：\"></a>打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，紧接着下一行插入如下代码：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if post.top %&#125;</span><br><span class=\"line\">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class=\"line\">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class=\"line\">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>至此，博客置顶的方式就全部完成了</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"博文置顶\"><a href=\"#博文置顶\" class=\"headerlink\" title=\"博文置顶\"></a>博文置顶</h3><h4 id=\"目前已经有修改后支持置顶的仓库，可以直接用以下命令安装\"><a href=\"#目前已经有修改后支持置顶的仓库，可以直接用以下命令安装\" class=\"headerlink\" title=\"目前已经有修改后支持置顶的仓库，可以直接用以下命令安装\"></a>目前已经有修改后支持置顶的仓库，可以直接用以下命令安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-generator-index --save</span><br><span class=\"line\">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"然后在需要置顶的文章的Front-matter中加上top-true即可。比如下面这篇文章：\"><a href=\"#然后在需要置顶的文章的Front-matter中加上top-true即可。比如下面这篇文章：\" class=\"headerlink\" title=\"然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：\"></a>然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: hexo博客置顶</span><br><span class=\"line\">date: 2017-09-08 12:00:25</span><br><span class=\"line\">categories: 博客搭建系列</span><br><span class=\"line\">top: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<h4 id=\"到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：\"><a href=\"#到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：\" class=\"headerlink\" title=\"到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：\"></a>到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：</h4><h5 id=\"打开：-blog-themes-next-layout-macro-目录下的post-swig文件，定位到-lt-div-class-quot-post-meta-quot-gt-标签下，紧接着下一行插入如下代码：\"><a href=\"#打开：-blog-themes-next-layout-macro-目录下的post-swig文件，定位到-lt-div-class-quot-post-meta-quot-gt-标签下，紧接着下一行插入如下代码：\" class=\"headerlink\" title=\"打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，紧接着下一行插入如下代码：\"></a>打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，紧接着下一行插入如下代码：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if post.top %&#125;</span><br><span class=\"line\">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class=\"line\">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class=\"line\">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>至此，博客置顶的方式就全部完成了</p>"},{"title":"Dubbo服务降级","date":"2019-04-12T03:48:06.000Z","_content":"### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;在分布式服务或者一些微服务当中，经常性的出现各个服务之间相互调用，业务处理流程耦合起来的情况。比如当用户在平台下单时，我们需要给用户生成订单之后发站内信或者短信通知用户订单生成成功。那么很多时候代码的编写就会是：\n&nbsp;&nbsp;&nbsp;&nbsp;`调用订单模块生成订单->调用短信模块通知用户->调用其他模块处理更多业务逻辑`\n&nbsp;&nbsp;&nbsp;&nbsp;可是当我们无足轻重的一个短信通知模块挂掉或者报错的时候，我们当然不希望整个业务逻辑就这样停止。那么这个时候，就需要引入服务降级的机制，为整个业务逻辑进行解耦合。\n\n&nbsp;&nbsp;&nbsp;&nbsp;使用服务降级可以防止我们服务中间不影响整体流程的模块出错导致整个业务处理雪崩。将核心业务保证完整性，非核心业务弱化。\n<!--more-->\n*<font style=\"color: red\">本文使用  `springboot+dubbo` 进行服务降级的演示</font>*\n\n### dubbo自带的mock进行服务降级，也叫本地伪装\n##### dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。\n具体使用\n\ndubbo mock的使用非常简单，即在我们平时进行开发时，编写impl实现类实现接口作为服务提供者的同时，编写mock实现类并覆盖所有接口中的方法。\n官方更详细的文档[戳这里](http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html)\n\n比如有接口：\n```\npublic interface SysOperateFacade {\n    /**\n     * 根据用户名查询操作员信息\n     */\n    SysOperateVO findByUserName(String username);\n}\n```\n在实现类进行相应操作\n```\n@Service //这里Service是dubbo的注解\npublic class SysOperateFacadeImpl implements SysOperateFacade {\n  @Resource\n  SysOperateService sysOperateService;\n\n  @Override\n  public SysOperateVO findByUserName(String username) {\n      return sysOperateService.findByUserName(username);\n  }\n}\n```\n编写mock实现类覆盖findByUserName方法 注意 mock的类名必须是 接口名+Mock\n```\npublic class SysOperateFacadeMock implements SysOperateFacade {\n    @Override\n    public SysOperateVO findByUserName(String username) {\n        System.out.println(\"调用到dubbo mock 的findByUserName方法。。。。。。。\");\n        return new SysOperateVO();\n    }\n}\n```\n最后，在调用的地方加上注解`@Reference(mock = \"true\")`进行使用即可\n```\n@Controller\n@RequestMapping(\"/sys/sysOperate\")\npublic class SysOperateController extends BaseController {\n\n    @Reference(mock = \"true\")\n    private SysOperateFacade sysOperateFacade;\n\n    @ResponseBody\n    @RequestMapping(\"/test\")\n    public SysOperateVO test(String username){\n        return sysOperateFacade.findByUserName(username);\n    }\n}\n```\n\n### 使用 spring cloud Hystrix进行服务降级\n\n在服务调用方模块加入依赖\n```\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n    <version>1.4.6.RELEASE</version>\n</dependency>\n```\n如果出现以下报错也许是由于Springboot与这个依赖版本不对应，修改下版本\n```\njava.lang.NoSuchMethodError: org.springframework.boot.builder.SpringApplicationBuilder.<init>([Ljava/lang/Class;)V at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:170) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:104) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:70) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:122) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:74) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:325) at org.springframework.boot.SpringApplication.run(SpringApplication.java:296) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) at com.gjj.p2p.BasicsApplication.main(BasicsApplication.java:18)\n```\n#####  具体使用`hystrix`进行服务降级\n\n`hystrix`的使用也是非常简单，只需要在服务调用方即消费者方springboot启动类上加上注解 `@EnableHystrix`\n\n然后使用如下方式，指定服务出错或者熔断后调用的方法\n```\n@ResponseBody\n@RequestMapping(\"/test\")\n@HystrixCommand(fallbackMethod = \"fallback\")\npublic String test(String message){\n    return sysMenuFacade.test(message);\n}\n\npublic String fallback(String message){\n    return \"sysMenuFacade挂了 调用到fallback \" + message;\n}\n```\n这样当出现问题之后就会调用得到fallback方法\n还可以在这个controller上直接指定注解`@DefaultProperties(defaultFallback = \"fallback\")`以免编写大量重复代码\n\n### 总结\n\n服务降级与熔断机制在我们实际生产以及日常开发中都是是非常有必要使用的，例如我们在日常开发中，需要调用别人的模块，但是又不是非常依赖这个模块的数据，我们可以使用以上的方式构造“假的”调用结果。这样就不用为了调试某行代码去启动大量的服务了。\n\n最后针对dubbo的mock机制以及`hystrix`，我觉得`hystrix`更像是try{}catch{}。\n","source":"_posts/dubbo 服务降级.md","raw":"---\ntitle: dubbo服务降级\ndate: 2019-04-12 11:48:06\ncategories: [dubbo]\ntags: [springboot,dubbo,分布式服务降级]\n---\n### 前言\n\n&nbsp;&nbsp;&nbsp;&nbsp;在分布式服务或者一些微服务当中，经常性的出现各个服务之间相互调用，业务处理流程耦合起来的情况。比如当用户在平台下单时，我们需要给用户生成订单之后发站内信或者短信通知用户订单生成成功。那么很多时候代码的编写就会是：\n&nbsp;&nbsp;&nbsp;&nbsp;`调用订单模块生成订单->调用短信模块通知用户->调用其他模块处理更多业务逻辑`\n&nbsp;&nbsp;&nbsp;&nbsp;可是当我们无足轻重的一个短信通知模块挂掉或者报错的时候，我们当然不希望整个业务逻辑就这样停止。那么这个时候，就需要引入服务降级的机制，为整个业务逻辑进行解耦合。\n\n&nbsp;&nbsp;&nbsp;&nbsp;使用服务降级可以防止我们服务中间不影响整体流程的模块出错导致整个业务处理雪崩。将核心业务保证完整性，非核心业务弱化。\n<!--more-->\n*<font style=\"color: red\">本文使用  `springboot+dubbo` 进行服务降级的演示</font>*\n\n### dubbo自带的mock进行服务降级，也叫本地伪装\n##### dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。\n具体使用\n\ndubbo mock的使用非常简单，即在我们平时进行开发时，编写impl实现类实现接口作为服务提供者的同时，编写mock实现类并覆盖所有接口中的方法。\n官方更详细的文档[戳这里](http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html)\n\n比如有接口：\n```\npublic interface SysOperateFacade {\n    /**\n     * 根据用户名查询操作员信息\n     */\n    SysOperateVO findByUserName(String username);\n}\n```\n在实现类进行相应操作\n```\n@Service //这里Service是dubbo的注解\npublic class SysOperateFacadeImpl implements SysOperateFacade {\n  @Resource\n  SysOperateService sysOperateService;\n\n  @Override\n  public SysOperateVO findByUserName(String username) {\n      return sysOperateService.findByUserName(username);\n  }\n}\n```\n编写mock实现类覆盖findByUserName方法 注意 mock的类名必须是 接口名+Mock\n```\npublic class SysOperateFacadeMock implements SysOperateFacade {\n    @Override\n    public SysOperateVO findByUserName(String username) {\n        System.out.println(\"调用到dubbo mock 的findByUserName方法。。。。。。。\");\n        return new SysOperateVO();\n    }\n}\n```\n最后，在调用的地方加上注解`@Reference(mock = \"true\")`进行使用即可\n```\n@Controller\n@RequestMapping(\"/sys/sysOperate\")\npublic class SysOperateController extends BaseController {\n\n    @Reference(mock = \"true\")\n    private SysOperateFacade sysOperateFacade;\n\n    @ResponseBody\n    @RequestMapping(\"/test\")\n    public SysOperateVO test(String username){\n        return sysOperateFacade.findByUserName(username);\n    }\n}\n```\n\n### 使用 spring cloud Hystrix进行服务降级\n\n在服务调用方模块加入依赖\n```\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n    <version>1.4.6.RELEASE</version>\n</dependency>\n```\n如果出现以下报错也许是由于Springboot与这个依赖版本不对应，修改下版本\n```\njava.lang.NoSuchMethodError: org.springframework.boot.builder.SpringApplicationBuilder.<init>([Ljava/lang/Class;)V at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:170) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:104) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:70) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:122) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:74) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:325) at org.springframework.boot.SpringApplication.run(SpringApplication.java:296) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) at com.gjj.p2p.BasicsApplication.main(BasicsApplication.java:18)\n```\n#####  具体使用`hystrix`进行服务降级\n\n`hystrix`的使用也是非常简单，只需要在服务调用方即消费者方springboot启动类上加上注解 `@EnableHystrix`\n\n然后使用如下方式，指定服务出错或者熔断后调用的方法\n```\n@ResponseBody\n@RequestMapping(\"/test\")\n@HystrixCommand(fallbackMethod = \"fallback\")\npublic String test(String message){\n    return sysMenuFacade.test(message);\n}\n\npublic String fallback(String message){\n    return \"sysMenuFacade挂了 调用到fallback \" + message;\n}\n```\n这样当出现问题之后就会调用得到fallback方法\n还可以在这个controller上直接指定注解`@DefaultProperties(defaultFallback = \"fallback\")`以免编写大量重复代码\n\n### 总结\n\n服务降级与熔断机制在我们实际生产以及日常开发中都是是非常有必要使用的，例如我们在日常开发中，需要调用别人的模块，但是又不是非常依赖这个模块的数据，我们可以使用以上的方式构造“假的”调用结果。这样就不用为了调试某行代码去启动大量的服务了。\n\n最后针对dubbo的mock机制以及`hystrix`，我觉得`hystrix`更像是try{}catch{}。\n","slug":"dubbo 服务降级","published":1,"updated":"2019-05-07T09:48:29.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvus0006cwnk074ktnpn","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在分布式服务或者一些微服务当中，经常性的出现各个服务之间相互调用，业务处理流程耦合起来的情况。比如当用户在平台下单时，我们需要给用户生成订单之后发站内信或者短信通知用户订单生成成功。那么很多时候代码的编写就会是：<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>调用订单模块生成订单-&gt;调用短信模块通知用户-&gt;调用其他模块处理更多业务逻辑</code><br>&nbsp;&nbsp;&nbsp;&nbsp;可是当我们无足轻重的一个短信通知模块挂掉或者报错的时候，我们当然不希望整个业务逻辑就这样停止。那么这个时候，就需要引入服务降级的机制，为整个业务逻辑进行解耦合。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;使用服务降级可以防止我们服务中间不影响整体流程的模块出错导致整个业务处理雪崩。将核心业务保证完整性，非核心业务弱化。<br><a id=\"more\"></a><br><em><font style=\"color: red\">本文使用  <code>springboot+dubbo</code> 进行服务降级的演示</font></em></p>\n<h3 id=\"dubbo自带的mock进行服务降级，也叫本地伪装\"><a href=\"#dubbo自带的mock进行服务降级，也叫本地伪装\" class=\"headerlink\" title=\"dubbo自带的mock进行服务降级，也叫本地伪装\"></a>dubbo自带的mock进行服务降级，也叫本地伪装</h3><h5 id=\"dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。\"><a href=\"#dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。\" class=\"headerlink\" title=\"dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。\"></a>dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。</h5><p>具体使用</p>\n<p>dubbo mock的使用非常简单，即在我们平时进行开发时，编写impl实现类实现接口作为服务提供者的同时，编写mock实现类并覆盖所有接口中的方法。<br>官方更详细的文档<a href=\"http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n<p>比如有接口：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface SysOperateFacade &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 根据用户名查询操作员信息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    SysOperateVO findByUserName(String username);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在实现类进行相应操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service //这里Service是dubbo的注解</span><br><span class=\"line\">public class SysOperateFacadeImpl implements SysOperateFacade &#123;</span><br><span class=\"line\">  @Resource</span><br><span class=\"line\">  SysOperateService sysOperateService;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public SysOperateVO findByUserName(String username) &#123;</span><br><span class=\"line\">      return sysOperateService.findByUserName(username);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编写mock实现类覆盖findByUserName方法 注意 mock的类名必须是 接口名+Mock<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SysOperateFacadeMock implements SysOperateFacade &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public SysOperateVO findByUserName(String username) &#123;</span><br><span class=\"line\">        System.out.println(&quot;调用到dubbo mock 的findByUserName方法。。。。。。。&quot;);</span><br><span class=\"line\">        return new SysOperateVO();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后，在调用的地方加上注解<code>@Reference(mock = &quot;true&quot;)</code>进行使用即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">@RequestMapping(&quot;/sys/sysOperate&quot;)</span><br><span class=\"line\">public class SysOperateController extends BaseController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Reference(mock = &quot;true&quot;)</span><br><span class=\"line\">    private SysOperateFacade sysOperateFacade;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    @RequestMapping(&quot;/test&quot;)</span><br><span class=\"line\">    public SysOperateVO test(String username)&#123;</span><br><span class=\"line\">        return sysOperateFacade.findByUserName(username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-spring-cloud-Hystrix进行服务降级\"><a href=\"#使用-spring-cloud-Hystrix进行服务降级\" class=\"headerlink\" title=\"使用 spring cloud Hystrix进行服务降级\"></a>使用 spring cloud Hystrix进行服务降级</h3><p>在服务调用方模块加入依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果出现以下报错也许是由于Springboot与这个依赖版本不对应，修改下版本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.NoSuchMethodError: org.springframework.boot.builder.SpringApplicationBuilder.&lt;init&gt;([Ljava/lang/Class;)V at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:170) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:104) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:70) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:122) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:74) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:325) at org.springframework.boot.SpringApplication.run(SpringApplication.java:296) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) at com.gjj.p2p.BasicsApplication.main(BasicsApplication.java:18)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"具体使用hystrix进行服务降级\"><a href=\"#具体使用hystrix进行服务降级\" class=\"headerlink\" title=\"具体使用hystrix进行服务降级\"></a>具体使用<code>hystrix</code>进行服务降级</h5><p><code>hystrix</code>的使用也是非常简单，只需要在服务调用方即消费者方springboot启动类上加上注解 <code>@EnableHystrix</code></p>\n<p>然后使用如下方式，指定服务出错或者熔断后调用的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ResponseBody</span><br><span class=\"line\">@RequestMapping(&quot;/test&quot;)</span><br><span class=\"line\">@HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span><br><span class=\"line\">public String test(String message)&#123;</span><br><span class=\"line\">    return sysMenuFacade.test(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public String fallback(String message)&#123;</span><br><span class=\"line\">    return &quot;sysMenuFacade挂了 调用到fallback &quot; + message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样当出现问题之后就会调用得到fallback方法<br>还可以在这个controller上直接指定注解<code>@DefaultProperties(defaultFallback = &quot;fallback&quot;)</code>以免编写大量重复代码</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>服务降级与熔断机制在我们实际生产以及日常开发中都是是非常有必要使用的，例如我们在日常开发中，需要调用别人的模块，但是又不是非常依赖这个模块的数据，我们可以使用以上的方式构造“假的”调用结果。这样就不用为了调试某行代码去启动大量的服务了。</p>\n<p>最后针对dubbo的mock机制以及<code>hystrix</code>，我觉得<code>hystrix</code>更像是try{}catch{}。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在分布式服务或者一些微服务当中，经常性的出现各个服务之间相互调用，业务处理流程耦合起来的情况。比如当用户在平台下单时，我们需要给用户生成订单之后发站内信或者短信通知用户订单生成成功。那么很多时候代码的编写就会是：<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>调用订单模块生成订单-&gt;调用短信模块通知用户-&gt;调用其他模块处理更多业务逻辑</code><br>&nbsp;&nbsp;&nbsp;&nbsp;可是当我们无足轻重的一个短信通知模块挂掉或者报错的时候，我们当然不希望整个业务逻辑就这样停止。那么这个时候，就需要引入服务降级的机制，为整个业务逻辑进行解耦合。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;使用服务降级可以防止我们服务中间不影响整体流程的模块出错导致整个业务处理雪崩。将核心业务保证完整性，非核心业务弱化。<br></p>","more":"<br><em><font style=\"color: red\">本文使用  <code>springboot+dubbo</code> 进行服务降级的演示</font></em><p></p>\n<h3 id=\"dubbo自带的mock进行服务降级，也叫本地伪装\"><a href=\"#dubbo自带的mock进行服务降级，也叫本地伪装\" class=\"headerlink\" title=\"dubbo自带的mock进行服务降级，也叫本地伪装\"></a>dubbo自带的mock进行服务降级，也叫本地伪装</h3><h5 id=\"dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。\"><a href=\"#dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。\" class=\"headerlink\" title=\"dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。\"></a>dubbo作为阿里巴巴开源的最流行的服务治理框架，在提供了远程调用的同时也提供了服务降级的功能。</h5><p>具体使用</p>\n<p>dubbo mock的使用非常简单，即在我们平时进行开发时，编写impl实现类实现接口作为服务提供者的同时，编写mock实现类并覆盖所有接口中的方法。<br>官方更详细的文档<a href=\"http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n<p>比如有接口：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface SysOperateFacade &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 根据用户名查询操作员信息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    SysOperateVO findByUserName(String username);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在实现类进行相应操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service //这里Service是dubbo的注解</span><br><span class=\"line\">public class SysOperateFacadeImpl implements SysOperateFacade &#123;</span><br><span class=\"line\">  @Resource</span><br><span class=\"line\">  SysOperateService sysOperateService;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public SysOperateVO findByUserName(String username) &#123;</span><br><span class=\"line\">      return sysOperateService.findByUserName(username);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编写mock实现类覆盖findByUserName方法 注意 mock的类名必须是 接口名+Mock<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SysOperateFacadeMock implements SysOperateFacade &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public SysOperateVO findByUserName(String username) &#123;</span><br><span class=\"line\">        System.out.println(&quot;调用到dubbo mock 的findByUserName方法。。。。。。。&quot;);</span><br><span class=\"line\">        return new SysOperateVO();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后，在调用的地方加上注解<code>@Reference(mock = &quot;true&quot;)</code>进行使用即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">@RequestMapping(&quot;/sys/sysOperate&quot;)</span><br><span class=\"line\">public class SysOperateController extends BaseController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Reference(mock = &quot;true&quot;)</span><br><span class=\"line\">    private SysOperateFacade sysOperateFacade;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    @RequestMapping(&quot;/test&quot;)</span><br><span class=\"line\">    public SysOperateVO test(String username)&#123;</span><br><span class=\"line\">        return sysOperateFacade.findByUserName(username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-spring-cloud-Hystrix进行服务降级\"><a href=\"#使用-spring-cloud-Hystrix进行服务降级\" class=\"headerlink\" title=\"使用 spring cloud Hystrix进行服务降级\"></a>使用 spring cloud Hystrix进行服务降级</h3><p>在服务调用方模块加入依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果出现以下报错也许是由于Springboot与这个依赖版本不对应，修改下版本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.NoSuchMethodError: org.springframework.boot.builder.SpringApplicationBuilder.&lt;init&gt;([Ljava/lang/Class;)V at org.springframework.cloud.bootstrap.BootstrapApplicationListener.bootstrapServiceContext(BootstrapApplicationListener.java:170) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:104) at org.springframework.cloud.bootstrap.BootstrapApplicationListener.onApplicationEvent(BootstrapApplicationListener.java:70) at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:122) at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:74) at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54) at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:325) at org.springframework.boot.SpringApplication.run(SpringApplication.java:296) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1118) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1107) at com.gjj.p2p.BasicsApplication.main(BasicsApplication.java:18)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"具体使用hystrix进行服务降级\"><a href=\"#具体使用hystrix进行服务降级\" class=\"headerlink\" title=\"具体使用hystrix进行服务降级\"></a>具体使用<code>hystrix</code>进行服务降级</h5><p><code>hystrix</code>的使用也是非常简单，只需要在服务调用方即消费者方springboot启动类上加上注解 <code>@EnableHystrix</code></p>\n<p>然后使用如下方式，指定服务出错或者熔断后调用的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ResponseBody</span><br><span class=\"line\">@RequestMapping(&quot;/test&quot;)</span><br><span class=\"line\">@HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span><br><span class=\"line\">public String test(String message)&#123;</span><br><span class=\"line\">    return sysMenuFacade.test(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public String fallback(String message)&#123;</span><br><span class=\"line\">    return &quot;sysMenuFacade挂了 调用到fallback &quot; + message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样当出现问题之后就会调用得到fallback方法<br>还可以在这个controller上直接指定注解<code>@DefaultProperties(defaultFallback = &quot;fallback&quot;)</code>以免编写大量重复代码</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>服务降级与熔断机制在我们实际生产以及日常开发中都是是非常有必要使用的，例如我们在日常开发中，需要调用别人的模块，但是又不是非常依赖这个模块的数据，我们可以使用以上的方式构造“假的”调用结果。这样就不用为了调试某行代码去启动大量的服务了。</p>\n<p>最后针对dubbo的mock机制以及<code>hystrix</code>，我觉得<code>hystrix</code>更像是try{}catch{}。</p>"},{"title":"【陈年风楼】VLOG-000001 一个普通的程序员的普通的一天","date":"2018-04-21T02:21:02.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=22367659&cid=37047708&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 100%;height: 700px\"> </iframe>","source":"_posts/vlog-程序员的一天.md","raw":"---\ntitle: 【陈年风楼】VLOG-000001 一个普通的程序员的普通的一天\ndate: 2018-04-21 10:21:02\ncategories: [程序人生]\ntags: [程序人生]\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=22367659&cid=37047708&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 100%;height: 700px\"> </iframe>","slug":"vlog-程序员的一天","published":1,"updated":"2019-05-07T09:48:29.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvuv0008cwnk5k1pohqt","content":"<iframe src=\"//player.bilibili.com/player.html?aid=22367659&cid=37047708&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 100%;height: 700px\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=22367659&cid=37047708&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 100%;height: 700px\"> </iframe>"},{"title":"Nodepad++不用插件去重的方法","date":"2018-11-12T05:54:14.000Z","_content":"\n在工作中，当我们需要对一个文本中的行进行去重统计的时候，会发现对于文本的去重并不是那么好处理。而nodepad++的去重插件一般人又懒得去安装，不巧在网上找到这样一个去重的小技巧，即使用正则表达式进行去重，简直方便快捷。\n在这里分享出来，希望大家能够用的上。\n```\n^(.*?)$\\s+?^(?=.*^\\1$)\n```\n![使用nodepad++去重](https://blog.yimik.com/wp-content/uploads/2015/11/rm_duplicate_rows.png)\n\n点击全部替换，就可以将重复行全部去掉喽\n","source":"_posts/nodepad-不用插件去重的方法.md","raw":"---\ntitle: nodepad++不用插件去重的方法\ndate: 2018-11-12 13:54:14\ncategories: [开发工具]\ntags: [开发日记,工作技巧,nodepad++]\n---\n\n在工作中，当我们需要对一个文本中的行进行去重统计的时候，会发现对于文本的去重并不是那么好处理。而nodepad++的去重插件一般人又懒得去安装，不巧在网上找到这样一个去重的小技巧，即使用正则表达式进行去重，简直方便快捷。\n在这里分享出来，希望大家能够用的上。\n```\n^(.*?)$\\s+?^(?=.*^\\1$)\n```\n![使用nodepad++去重](https://blog.yimik.com/wp-content/uploads/2015/11/rm_duplicate_rows.png)\n\n点击全部替换，就可以将重复行全部去掉喽\n","slug":"nodepad-不用插件去重的方法","published":1,"updated":"2019-05-07T09:48:29.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvuy000acwnkplx0e4d9","content":"<p>在工作中，当我们需要对一个文本中的行进行去重统计的时候，会发现对于文本的去重并不是那么好处理。而nodepad++的去重插件一般人又懒得去安装，不巧在网上找到这样一个去重的小技巧，即使用正则表达式进行去重，简直方便快捷。<br>在这里分享出来，希望大家能够用的上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^(.*?)$\\s+?^(?=.*^\\1$)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://blog.yimik.com/wp-content/uploads/2015/11/rm_duplicate_rows.png\" alt=\"使用nodepad++去重\"></p>\n<p>点击全部替换，就可以将重复行全部去掉喽</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在工作中，当我们需要对一个文本中的行进行去重统计的时候，会发现对于文本的去重并不是那么好处理。而nodepad++的去重插件一般人又懒得去安装，不巧在网上找到这样一个去重的小技巧，即使用正则表达式进行去重，简直方便快捷。<br>在这里分享出来，希望大家能够用的上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^(.*?)$\\s+?^(?=.*^\\1$)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://blog.yimik.com/wp-content/uploads/2015/11/rm_duplicate_rows.png\" alt=\"使用nodepad++去重\"></p>\n<p>点击全部替换，就可以将重复行全部去掉喽</p>\n"},{"title":"leetcode:Z字形变换","date":"2018-12-23T11:43:02.000Z","_content":"#### 题目如下\n\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下：\n\n```$xslt\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n```\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。\n<!--more-->\n请你实现这个将字符串进行指定行数变换的函数：\n\n```\nstring convert(string s, int numRows);\n```\n\n\n\n示例 1:\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 3\n输出: \"LCIRETOESIIGEDHN\"\n```\n\n示例 2:\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 4\n输出: \"LDREOEIIECIHNTSG\"\n```\n\n解释:\n\n```\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n```\n\n#### 解题思路\n\n拿到这个题目，第一时间就可以想到，根据题中图示构造二维数组，先将数据按照相应的样子存储进去，最后再从数组中按行取出，但是这样会有占用更多内存空间的风险。所以，我这边还思考了第二种解法：就是直接根据规律计算出下一个要输出的字符的下标，直接输出即可，无需再创建多余的二维数组。\n\n- 第一种解法：构造二维数组\n\n构造二位数组最主要的就是计算出这个二维数组有多少列，列数有了，按照Z型规律将原字符串塞进去就行了，计算列数代码如下\n\n```\nprivate int getColNum(String s, int n) {\n        int x = s.length() / (2 * n - 2);\n        int y = s.length() % (2 * n - 2);\n        int l = x + 1 + x * (n - 2);\n        if (y >= n) {\n            l = l + 1 + y % n;\n        }\n        return l;\n    }\n```\n\n- 第二种解法：计算下一个要输出的字符的下标\n直接看github代码吧：[点这里](https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/Algorithm/src/main/java/Alogrithm/Alogrithm/ZigZagConversion)\n","source":"_posts/leetcode-Z字形变换.md","raw":"---\ntitle: 'leetcode:Z字形变换'\ndate: 2018-12-23 19:43:02\ncategories: [算法题解]\ntags: [leetcode,算法题解]\n---\n#### 题目如下\n\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。\n\n比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下：\n\n```$xslt\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n```\n\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。\n<!--more-->\n请你实现这个将字符串进行指定行数变换的函数：\n\n```\nstring convert(string s, int numRows);\n```\n\n\n\n示例 1:\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 3\n输出: \"LCIRETOESIIGEDHN\"\n```\n\n示例 2:\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 4\n输出: \"LDREOEIIECIHNTSG\"\n```\n\n解释:\n\n```\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n```\n\n#### 解题思路\n\n拿到这个题目，第一时间就可以想到，根据题中图示构造二维数组，先将数据按照相应的样子存储进去，最后再从数组中按行取出，但是这样会有占用更多内存空间的风险。所以，我这边还思考了第二种解法：就是直接根据规律计算出下一个要输出的字符的下标，直接输出即可，无需再创建多余的二维数组。\n\n- 第一种解法：构造二维数组\n\n构造二位数组最主要的就是计算出这个二维数组有多少列，列数有了，按照Z型规律将原字符串塞进去就行了，计算列数代码如下\n\n```\nprivate int getColNum(String s, int n) {\n        int x = s.length() / (2 * n - 2);\n        int y = s.length() % (2 * n - 2);\n        int l = x + 1 + x * (n - 2);\n        if (y >= n) {\n            l = l + 1 + y % n;\n        }\n        return l;\n    }\n```\n\n- 第二种解法：计算下一个要输出的字符的下标\n直接看github代码吧：[点这里](https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/Algorithm/src/main/java/Alogrithm/Alogrithm/ZigZagConversion)\n","slug":"leetcode-Z字形变换","published":1,"updated":"2019-05-07T09:48:29.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvv1000ecwnkkrg74ufm","content":"<h4 id=\"题目如下\"><a href=\"#题目如下\" class=\"headerlink\" title=\"题目如下\"></a>题目如下</h4><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>\n<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L   C   I   R</span><br><span class=\"line\">E T O E S I I G</span><br><span class=\"line\">E   D   H   N</span><br></pre></td></tr></table></figure>\n<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。<br><a id=\"more\"></a><br>请你实现这个将字符串进行指定行数变换的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class=\"line\">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class=\"line\">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br></pre></td></tr></table></figure>\n<p>解释:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L     D     R</span><br><span class=\"line\">E   O E   I I</span><br><span class=\"line\">E C   I H   N</span><br><span class=\"line\">T     S     G</span><br></pre></td></tr></table></figure>\n<h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><p>拿到这个题目，第一时间就可以想到，根据题中图示构造二维数组，先将数据按照相应的样子存储进去，最后再从数组中按行取出，但是这样会有占用更多内存空间的风险。所以，我这边还思考了第二种解法：就是直接根据规律计算出下一个要输出的字符的下标，直接输出即可，无需再创建多余的二维数组。</p>\n<ul>\n<li>第一种解法：构造二维数组</li>\n</ul>\n<p>构造二位数组最主要的就是计算出这个二维数组有多少列，列数有了，按照Z型规律将原字符串塞进去就行了，计算列数代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int getColNum(String s, int n) &#123;</span><br><span class=\"line\">        int x = s.length() / (2 * n - 2);</span><br><span class=\"line\">        int y = s.length() % (2 * n - 2);</span><br><span class=\"line\">        int l = x + 1 + x * (n - 2);</span><br><span class=\"line\">        if (y &gt;= n) &#123;</span><br><span class=\"line\">            l = l + 1 + y % n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return l;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第二种解法：计算下一个要输出的字符的下标<br>直接看github代码吧：<a href=\"https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/Algorithm/src/main/java/Alogrithm/Alogrithm/ZigZagConversion\" target=\"_blank\" rel=\"noopener\">点这里</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"题目如下\"><a href=\"#题目如下\" class=\"headerlink\" title=\"题目如下\"></a>题目如下</h4><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>\n<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L   C   I   R</span><br><span class=\"line\">E T O E S I I G</span><br><span class=\"line\">E   D   H   N</span><br></pre></td></tr></table></figure>\n<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。<br></p>","more":"<br>请你实现这个将字符串进行指定行数变换的函数：<p></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class=\"line\">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class=\"line\">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br></pre></td></tr></table></figure>\n<p>解释:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L     D     R</span><br><span class=\"line\">E   O E   I I</span><br><span class=\"line\">E C   I H   N</span><br><span class=\"line\">T     S     G</span><br></pre></td></tr></table></figure>\n<h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><p>拿到这个题目，第一时间就可以想到，根据题中图示构造二维数组，先将数据按照相应的样子存储进去，最后再从数组中按行取出，但是这样会有占用更多内存空间的风险。所以，我这边还思考了第二种解法：就是直接根据规律计算出下一个要输出的字符的下标，直接输出即可，无需再创建多余的二维数组。</p>\n<ul>\n<li>第一种解法：构造二维数组</li>\n</ul>\n<p>构造二位数组最主要的就是计算出这个二维数组有多少列，列数有了，按照Z型规律将原字符串塞进去就行了，计算列数代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int getColNum(String s, int n) &#123;</span><br><span class=\"line\">        int x = s.length() / (2 * n - 2);</span><br><span class=\"line\">        int y = s.length() % (2 * n - 2);</span><br><span class=\"line\">        int l = x + 1 + x * (n - 2);</span><br><span class=\"line\">        if (y &gt;= n) &#123;</span><br><span class=\"line\">            l = l + 1 + y % n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return l;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第二种解法：计算下一个要输出的字符的下标<br>直接看github代码吧：<a href=\"https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/Algorithm/src/main/java/Alogrithm/Alogrithm/ZigZagConversion\" target=\"_blank\" rel=\"noopener\">点这里</a></li>\n</ul>"},{"title":"Spring-Boot微服务搭建","date":"2018-03-27T09:01:21.000Z","_content":"\n[本人的csdn传送门](http://blog.csdn.net/qq_26627671/article/details/76563127)\n### 前言\n> 进行web开发的时候Java程序员们难免会碰到那种很小的服务，比如就提供一个生成订单号的接口，或者一个上传文件的服务。而这时我们再去使用SpringMVC这种体量稍大、配置繁琐的框架开发难免会加大工作量，而且是不必要的。这个时候我们就可以选择使用这个微服务框架——springboot进行开发。\n\nSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。\n\n<!--more-->\n\n----------\n### springboot框架的搭建与简单的REST风格的MVC架构demo\n#### 首先，建立一个新的maven工程，pom文件主要内容如下：\n```\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.2.1.RELEASE</version>\n    <relativePath/>\n  </parent>\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <java.version>1.8</java.version>\n  </properties>\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <scope>test</scope>\n    </dependency>\n    \n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n  </dependencies>\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n```\n其中核心依赖是\t`spring-boot-starter-web`\n```\n\t<dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n```\n访问静态资源文件可以加入模板：\n```\n\t<dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n```\n#### 编写Application.java文件，存放于src/main/java这个目录下\n##### 这里是springboot的核心启动类\n```\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n@Configuration\n@ComponentScan\n@EnableAutoConfiguration\npublic class Application{\n\t\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n}\n```\n事实上，这个时候已经把框架搭建好了，运行以上main方法即可启动这个项目，但是我们现在看不到效果，接下来，就可以像SpringMVC一样加入MVC三层结构的代码了，目录结构如下图：\n\n![REST风格的MVC架构demo项目目录结构](http://upload-images.jianshu.io/upload_images/3327380-fb0da321cb7b5abb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中各层代码如下：\n#### controller\n```\npackage com.zhang.controller;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.servlet.ModelAndView;\nimport com.zhang.entity.Photo;\nimport com.zhang.service.mainService;\n@RestController\n@RequestMapping(\"/photo\")\npublic class mainController {\n\n\t@Autowired\n\tprivate mainService mainservice;\n\t@RequestMapping(\"/\")\n\tpublic ModelAndView index(ModelAndView mav){\n\t\tmav.addObject(\"hello\", \"这是项目主页，访问根目录到达~~\");\n\t\tmav.setViewName(\"index\");\n\t\treturn mav;\n\t}\n\t@RequestMapping(\"/getPhoto\")\n\tpublic Object doIt(){\n\t\tMap<String, Photo> map = new HashMap<String, Photo>();\n\t\tmap.put(\"photo\", mainservice.getPhotoById(123));\n\t\treturn map;\n\t}\n}\n\n```\n#### service实现类\n```\npackage com.zhang.service.impl;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport com.zhang.dao.mainDao;\nimport com.zhang.entity.Photo;\nimport com.zhang.service.mainService;\n@Service(\"mainservice\")\npublic class mainServiceImpl implements mainService {\n\n\t@Autowired\n\tprivate mainDao maindao;\n\t@Override\n\tpublic Photo getPhotoById(int id) {\n\t\treturn maindao.getPhotoNameById(id);\n\t}\n\n}\n\n```\n#### dao实现类\n```\npackage com.zhang.dao.impl;\n\nimport org.springframework.stereotype.Repository;\n\nimport com.zhang.dao.mainDao;\nimport com.zhang.entity.Photo;\n\n@Repository(\"maindao\")\npublic class mainDaoImpl implements mainDao {\n\n\t@Override\n\tpublic Photo getPhotoNameById(int id) {\n\t\tPhoto p = new Photo();\n\t\tp.setId(123);\n\t\tp.setName(\"雪山行纪念照\");\n\t\treturn p;\n\t}\n\n}\n\n```\n#### 实体类photo\n```\npackage com.zhang.entity;\npublic class Photo {\n\tprivate int id;\n\tprivate String name;\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n\n```\n#### 启动项目\n\n![项目启动日志](http://upload-images.jianshu.io/upload_images/3327380-8ed38aa7e3e43e40?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 项目默认端口为8080，在浏览器中访问刚才的controller会看到：\n\n![访问结果](http://upload-images.jianshu.io/upload_images/3327380-75812c968f3ff846?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n----------\n### 如上，一个REST风格的MVC架构的demo项目就搭建完成了。\n","source":"_posts/spring-boot微服务搭建.md","raw":"---\ntitle: spring-boot微服务搭建\ndate: 2018-03-27 17:01:21\ncategories: [springboot]\ntags: [springboot]\n---\n\n[本人的csdn传送门](http://blog.csdn.net/qq_26627671/article/details/76563127)\n### 前言\n> 进行web开发的时候Java程序员们难免会碰到那种很小的服务，比如就提供一个生成订单号的接口，或者一个上传文件的服务。而这时我们再去使用SpringMVC这种体量稍大、配置繁琐的框架开发难免会加大工作量，而且是不必要的。这个时候我们就可以选择使用这个微服务框架——springboot进行开发。\n\nSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。\n\n<!--more-->\n\n----------\n### springboot框架的搭建与简单的REST风格的MVC架构demo\n#### 首先，建立一个新的maven工程，pom文件主要内容如下：\n```\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>1.2.1.RELEASE</version>\n    <relativePath/>\n  </parent>\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <java.version>1.8</java.version>\n  </properties>\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <scope>test</scope>\n    </dependency>\n    \n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n  </dependencies>\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n```\n其中核心依赖是\t`spring-boot-starter-web`\n```\n\t<dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n```\n访问静态资源文件可以加入模板：\n```\n\t<dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n```\n#### 编写Application.java文件，存放于src/main/java这个目录下\n##### 这里是springboot的核心启动类\n```\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n@Configuration\n@ComponentScan\n@EnableAutoConfiguration\npublic class Application{\n\t\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n}\n```\n事实上，这个时候已经把框架搭建好了，运行以上main方法即可启动这个项目，但是我们现在看不到效果，接下来，就可以像SpringMVC一样加入MVC三层结构的代码了，目录结构如下图：\n\n![REST风格的MVC架构demo项目目录结构](http://upload-images.jianshu.io/upload_images/3327380-fb0da321cb7b5abb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中各层代码如下：\n#### controller\n```\npackage com.zhang.controller;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.servlet.ModelAndView;\nimport com.zhang.entity.Photo;\nimport com.zhang.service.mainService;\n@RestController\n@RequestMapping(\"/photo\")\npublic class mainController {\n\n\t@Autowired\n\tprivate mainService mainservice;\n\t@RequestMapping(\"/\")\n\tpublic ModelAndView index(ModelAndView mav){\n\t\tmav.addObject(\"hello\", \"这是项目主页，访问根目录到达~~\");\n\t\tmav.setViewName(\"index\");\n\t\treturn mav;\n\t}\n\t@RequestMapping(\"/getPhoto\")\n\tpublic Object doIt(){\n\t\tMap<String, Photo> map = new HashMap<String, Photo>();\n\t\tmap.put(\"photo\", mainservice.getPhotoById(123));\n\t\treturn map;\n\t}\n}\n\n```\n#### service实现类\n```\npackage com.zhang.service.impl;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport com.zhang.dao.mainDao;\nimport com.zhang.entity.Photo;\nimport com.zhang.service.mainService;\n@Service(\"mainservice\")\npublic class mainServiceImpl implements mainService {\n\n\t@Autowired\n\tprivate mainDao maindao;\n\t@Override\n\tpublic Photo getPhotoById(int id) {\n\t\treturn maindao.getPhotoNameById(id);\n\t}\n\n}\n\n```\n#### dao实现类\n```\npackage com.zhang.dao.impl;\n\nimport org.springframework.stereotype.Repository;\n\nimport com.zhang.dao.mainDao;\nimport com.zhang.entity.Photo;\n\n@Repository(\"maindao\")\npublic class mainDaoImpl implements mainDao {\n\n\t@Override\n\tpublic Photo getPhotoNameById(int id) {\n\t\tPhoto p = new Photo();\n\t\tp.setId(123);\n\t\tp.setName(\"雪山行纪念照\");\n\t\treturn p;\n\t}\n\n}\n\n```\n#### 实体类photo\n```\npackage com.zhang.entity;\npublic class Photo {\n\tprivate int id;\n\tprivate String name;\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n\n```\n#### 启动项目\n\n![项目启动日志](http://upload-images.jianshu.io/upload_images/3327380-8ed38aa7e3e43e40?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 项目默认端口为8080，在浏览器中访问刚才的controller会看到：\n\n![访问结果](http://upload-images.jianshu.io/upload_images/3327380-75812c968f3ff846?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n----------\n### 如上，一个REST风格的MVC架构的demo项目就搭建完成了。\n","slug":"spring-boot微服务搭建","published":1,"updated":"2019-05-07T09:48:29.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvv2000fcwnk7v01pz8s","content":"<p><a href=\"http://blog.csdn.net/qq_26627671/article/details/76563127\" target=\"_blank\" rel=\"noopener\">本人的csdn传送门</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>进行web开发的时候Java程序员们难免会碰到那种很小的服务，比如就提供一个生成订单号的接口，或者一个上传文件的服务。而这时我们再去使用SpringMVC这种体量稍大、配置繁琐的框架开发难免会加大工作量，而且是不必要的。这个时候我们就可以选择使用这个微服务框架——springboot进行开发。</p>\n</blockquote>\n<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"springboot框架的搭建与简单的REST风格的MVC架构demo\"><a href=\"#springboot框架的搭建与简单的REST风格的MVC架构demo\" class=\"headerlink\" title=\"springboot框架的搭建与简单的REST风格的MVC架构demo\"></a>springboot框架的搭建与简单的REST风格的MVC架构demo</h3><h4 id=\"首先，建立一个新的maven工程，pom文件主要内容如下：\"><a href=\"#首先，建立一个新的maven工程，pom文件主要内容如下：\" class=\"headerlink\" title=\"首先，建立一个新的maven工程，pom文件主要内容如下：\"></a>首先，建立一个新的maven工程，pom文件主要内容如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.2.1.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;relativePath/&gt;</span><br><span class=\"line\">  &lt;/parent&gt;</span><br><span class=\"line\">  &lt;properties&gt;</span><br><span class=\"line\">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class=\"line\">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class=\"line\">  &lt;/properties&gt;</span><br><span class=\"line\">  &lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class=\"line\">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;/dependencies&gt;</span><br><span class=\"line\">  &lt;build&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">      &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;/plugin&gt;</span><br><span class=\"line\">    &lt;/plugins&gt;</span><br><span class=\"line\">  &lt;/build&gt;</span><br></pre></td></tr></table></figure>\n<p>其中核心依赖是    <code>spring-boot-starter-web</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>访问静态资源文件可以加入模板：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">       &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class=\"line\">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编写Application-java文件，存放于src-main-java这个目录下\"><a href=\"#编写Application-java文件，存放于src-main-java这个目录下\" class=\"headerlink\" title=\"编写Application.java文件，存放于src/main/java这个目录下\"></a>编写Application.java文件，存放于src/main/java这个目录下</h4><h5 id=\"这里是springboot的核心启动类\"><a href=\"#这里是springboot的核心启动类\" class=\"headerlink\" title=\"这里是springboot的核心启动类\"></a>这里是springboot的核心启动类</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.boot.SpringApplication;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class=\"line\">import org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">@ComponentScan</span><br><span class=\"line\">@EnableAutoConfiguration</span><br><span class=\"line\">public class Application&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tSpringApplication.run(Application.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>事实上，这个时候已经把框架搭建好了，运行以上main方法即可启动这个项目，但是我们现在看不到效果，接下来，就可以像SpringMVC一样加入MVC三层结构的代码了，目录结构如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3327380-fb0da321cb7b5abb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"REST风格的MVC架构demo项目目录结构\"></p>\n<p>其中各层代码如下：</p>\n<h4 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.zhang.controller;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\">import org.springframework.web.servlet.ModelAndView;</span><br><span class=\"line\">import com.zhang.entity.Photo;</span><br><span class=\"line\">import com.zhang.service.mainService;</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/photo&quot;)</span><br><span class=\"line\">public class mainController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Autowired</span><br><span class=\"line\">\tprivate mainService mainservice;</span><br><span class=\"line\">\t@RequestMapping(&quot;/&quot;)</span><br><span class=\"line\">\tpublic ModelAndView index(ModelAndView mav)&#123;</span><br><span class=\"line\">\t\tmav.addObject(&quot;hello&quot;, &quot;这是项目主页，访问根目录到达~~&quot;);</span><br><span class=\"line\">\t\tmav.setViewName(&quot;index&quot;);</span><br><span class=\"line\">\t\treturn mav;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@RequestMapping(&quot;/getPhoto&quot;)</span><br><span class=\"line\">\tpublic Object doIt()&#123;</span><br><span class=\"line\">\t\tMap&lt;String, Photo&gt; map = new HashMap&lt;String, Photo&gt;();</span><br><span class=\"line\">\t\tmap.put(&quot;photo&quot;, mainservice.getPhotoById(123));</span><br><span class=\"line\">\t\treturn map;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"service实现类\"><a href=\"#service实现类\" class=\"headerlink\" title=\"service实现类\"></a>service实现类</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.zhang.service.impl;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.zhang.dao.mainDao;</span><br><span class=\"line\">import com.zhang.entity.Photo;</span><br><span class=\"line\">import com.zhang.service.mainService;</span><br><span class=\"line\">@Service(&quot;mainservice&quot;)</span><br><span class=\"line\">public class mainServiceImpl implements mainService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Autowired</span><br><span class=\"line\">\tprivate mainDao maindao;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic Photo getPhotoById(int id) &#123;</span><br><span class=\"line\">\t\treturn maindao.getPhotoNameById(id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"dao实现类\"><a href=\"#dao实现类\" class=\"headerlink\" title=\"dao实现类\"></a>dao实现类</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.zhang.dao.impl;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.stereotype.Repository;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.zhang.dao.mainDao;</span><br><span class=\"line\">import com.zhang.entity.Photo;</span><br><span class=\"line\"></span><br><span class=\"line\">@Repository(&quot;maindao&quot;)</span><br><span class=\"line\">public class mainDaoImpl implements mainDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic Photo getPhotoNameById(int id) &#123;</span><br><span class=\"line\">\t\tPhoto p = new Photo();</span><br><span class=\"line\">\t\tp.setId(123);</span><br><span class=\"line\">\t\tp.setName(&quot;雪山行纪念照&quot;);</span><br><span class=\"line\">\t\treturn p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实体类photo\"><a href=\"#实体类photo\" class=\"headerlink\" title=\"实体类photo\"></a>实体类photo</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.zhang.entity;</span><br><span class=\"line\">public class Photo &#123;</span><br><span class=\"line\">\tprivate int id;</span><br><span class=\"line\">\tprivate String name;</span><br><span class=\"line\">\tpublic int getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void setId(int id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic String getName() &#123;</span><br><span class=\"line\">\t\treturn name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void setName(String name) &#123;</span><br><span class=\"line\">\t\tthis.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/3327380-8ed38aa7e3e43e40?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"项目启动日志\"></p>\n<h4 id=\"项目默认端口为8080，在浏览器中访问刚才的controller会看到：\"><a href=\"#项目默认端口为8080，在浏览器中访问刚才的controller会看到：\" class=\"headerlink\" title=\"项目默认端口为8080，在浏览器中访问刚才的controller会看到：\"></a>项目默认端口为8080，在浏览器中访问刚才的controller会看到：</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/3327380-75812c968f3ff846?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"访问结果\"></p>\n<hr>\n<h3 id=\"如上，一个REST风格的MVC架构的demo项目就搭建完成了。\"><a href=\"#如上，一个REST风格的MVC架构的demo项目就搭建完成了。\" class=\"headerlink\" title=\"如上，一个REST风格的MVC架构的demo项目就搭建完成了。\"></a>如上，一个REST风格的MVC架构的demo项目就搭建完成了。</h3>","site":{"data":{}},"excerpt":"<p><a href=\"http://blog.csdn.net/qq_26627671/article/details/76563127\" target=\"_blank\" rel=\"noopener\">本人的csdn传送门</a></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><blockquote>\n<p>进行web开发的时候Java程序员们难免会碰到那种很小的服务，比如就提供一个生成订单号的接口，或者一个上传文件的服务。而这时我们再去使用SpringMVC这种体量稍大、配置繁琐的框架开发难免会加大工作量，而且是不必要的。这个时候我们就可以选择使用这个微服务框架——springboot进行开发。</p>\n</blockquote>\n<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p>","more":"<hr>\n<h3 id=\"springboot框架的搭建与简单的REST风格的MVC架构demo\"><a href=\"#springboot框架的搭建与简单的REST风格的MVC架构demo\" class=\"headerlink\" title=\"springboot框架的搭建与简单的REST风格的MVC架构demo\"></a>springboot框架的搭建与简单的REST风格的MVC架构demo</h3><h4 id=\"首先，建立一个新的maven工程，pom文件主要内容如下：\"><a href=\"#首先，建立一个新的maven工程，pom文件主要内容如下：\" class=\"headerlink\" title=\"首先，建立一个新的maven工程，pom文件主要内容如下：\"></a>首先，建立一个新的maven工程，pom文件主要内容如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.2.1.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;relativePath/&gt;</span><br><span class=\"line\">  &lt;/parent&gt;</span><br><span class=\"line\">  &lt;properties&gt;</span><br><span class=\"line\">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class=\"line\">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class=\"line\">  &lt;/properties&gt;</span><br><span class=\"line\">  &lt;dependencies&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class=\"line\">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;/dependencies&gt;</span><br><span class=\"line\">  &lt;build&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">      &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;/plugin&gt;</span><br><span class=\"line\">    &lt;/plugins&gt;</span><br><span class=\"line\">  &lt;/build&gt;</span><br></pre></td></tr></table></figure>\n<p>其中核心依赖是    <code>spring-boot-starter-web</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>访问静态资源文件可以加入模板：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">       &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class=\"line\">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编写Application-java文件，存放于src-main-java这个目录下\"><a href=\"#编写Application-java文件，存放于src-main-java这个目录下\" class=\"headerlink\" title=\"编写Application.java文件，存放于src/main/java这个目录下\"></a>编写Application.java文件，存放于src/main/java这个目录下</h4><h5 id=\"这里是springboot的核心启动类\"><a href=\"#这里是springboot的核心启动类\" class=\"headerlink\" title=\"这里是springboot的核心启动类\"></a>这里是springboot的核心启动类</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import org.springframework.boot.SpringApplication;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class=\"line\">import org.springframework.context.annotation.ComponentScan;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">@ComponentScan</span><br><span class=\"line\">@EnableAutoConfiguration</span><br><span class=\"line\">public class Application&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tSpringApplication.run(Application.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>事实上，这个时候已经把框架搭建好了，运行以上main方法即可启动这个项目，但是我们现在看不到效果，接下来，就可以像SpringMVC一样加入MVC三层结构的代码了，目录结构如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3327380-fb0da321cb7b5abb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"REST风格的MVC架构demo项目目录结构\"></p>\n<p>其中各层代码如下：</p>\n<h4 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.zhang.controller;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\">import org.springframework.web.servlet.ModelAndView;</span><br><span class=\"line\">import com.zhang.entity.Photo;</span><br><span class=\"line\">import com.zhang.service.mainService;</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/photo&quot;)</span><br><span class=\"line\">public class mainController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Autowired</span><br><span class=\"line\">\tprivate mainService mainservice;</span><br><span class=\"line\">\t@RequestMapping(&quot;/&quot;)</span><br><span class=\"line\">\tpublic ModelAndView index(ModelAndView mav)&#123;</span><br><span class=\"line\">\t\tmav.addObject(&quot;hello&quot;, &quot;这是项目主页，访问根目录到达~~&quot;);</span><br><span class=\"line\">\t\tmav.setViewName(&quot;index&quot;);</span><br><span class=\"line\">\t\treturn mav;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t@RequestMapping(&quot;/getPhoto&quot;)</span><br><span class=\"line\">\tpublic Object doIt()&#123;</span><br><span class=\"line\">\t\tMap&lt;String, Photo&gt; map = new HashMap&lt;String, Photo&gt;();</span><br><span class=\"line\">\t\tmap.put(&quot;photo&quot;, mainservice.getPhotoById(123));</span><br><span class=\"line\">\t\treturn map;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"service实现类\"><a href=\"#service实现类\" class=\"headerlink\" title=\"service实现类\"></a>service实现类</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.zhang.service.impl;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.zhang.dao.mainDao;</span><br><span class=\"line\">import com.zhang.entity.Photo;</span><br><span class=\"line\">import com.zhang.service.mainService;</span><br><span class=\"line\">@Service(&quot;mainservice&quot;)</span><br><span class=\"line\">public class mainServiceImpl implements mainService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Autowired</span><br><span class=\"line\">\tprivate mainDao maindao;</span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic Photo getPhotoById(int id) &#123;</span><br><span class=\"line\">\t\treturn maindao.getPhotoNameById(id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"dao实现类\"><a href=\"#dao实现类\" class=\"headerlink\" title=\"dao实现类\"></a>dao实现类</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.zhang.dao.impl;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.stereotype.Repository;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.zhang.dao.mainDao;</span><br><span class=\"line\">import com.zhang.entity.Photo;</span><br><span class=\"line\"></span><br><span class=\"line\">@Repository(&quot;maindao&quot;)</span><br><span class=\"line\">public class mainDaoImpl implements mainDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic Photo getPhotoNameById(int id) &#123;</span><br><span class=\"line\">\t\tPhoto p = new Photo();</span><br><span class=\"line\">\t\tp.setId(123);</span><br><span class=\"line\">\t\tp.setName(&quot;雪山行纪念照&quot;);</span><br><span class=\"line\">\t\treturn p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实体类photo\"><a href=\"#实体类photo\" class=\"headerlink\" title=\"实体类photo\"></a>实体类photo</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.zhang.entity;</span><br><span class=\"line\">public class Photo &#123;</span><br><span class=\"line\">\tprivate int id;</span><br><span class=\"line\">\tprivate String name;</span><br><span class=\"line\">\tpublic int getId() &#123;</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void setId(int id) &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic String getName() &#123;</span><br><span class=\"line\">\t\treturn name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic void setName(String name) &#123;</span><br><span class=\"line\">\t\tthis.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/3327380-8ed38aa7e3e43e40?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"项目启动日志\"></p>\n<h4 id=\"项目默认端口为8080，在浏览器中访问刚才的controller会看到：\"><a href=\"#项目默认端口为8080，在浏览器中访问刚才的controller会看到：\" class=\"headerlink\" title=\"项目默认端口为8080，在浏览器中访问刚才的controller会看到：\"></a>项目默认端口为8080，在浏览器中访问刚才的controller会看到：</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/3327380-75812c968f3ff846?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"访问结果\"></p>\n<hr>\n<h3 id=\"如上，一个REST风格的MVC架构的demo项目就搭建完成了。\"><a href=\"#如上，一个REST风格的MVC架构的demo项目就搭建完成了。\" class=\"headerlink\" title=\"如上，一个REST风格的MVC架构的demo项目就搭建完成了。\"></a>如上，一个REST风格的MVC架构的demo项目就搭建完成了。</h3>"},{"title":"一个菜鸟在三星实习的那点儿感受","date":"2016-09-11T12:20:45.000Z","_content":"&nbsp;&nbsp;&nbsp;&nbsp;2016年暑假，在大学这片沃土上的第三个学期就这样结束了，回想大学这三年，为了自己的未来迷茫过，也为自己努力过，也为了不少事情烦恼过，不知道将来自己可以在什么地方过着怎样的生活。曾经以为自己将会平凡地与大部分人一样，每天上着不知老师所云的课程，浑浑噩噩地度过这大学四年的生活，然后找一个普普通通的工作，但是也算自己运气好吧，在大一第二学期遇到了一位让自己眼前一亮的老师，慢慢学习并了解程序员这个行业，最后决定走上学习Java开发的道路。\n\n&nbsp;&nbsp;&nbsp;&nbsp;很早就听说，在大三暑假如果能够找到一个好的专业对口的暑期实习的话，那么在大学毕业以后找工作就方便许多。于是在2016年3月，我便一边努力学习着web开发的相关知识，一边在网上投简历找着实习，终于在一个学长的内推下，我进入了西安三星半导体有限公司，原西安三星电子研究所。\n\n&nbsp;&nbsp;&nbsp;&nbsp;三星是一个气氛非常好的公司，直到现在我都觉得能够进入这个公司是我大学期间的很幸运的一件事。在这儿我遇到了对我很好的师傅们，和那些谦逊和善的同事们。\n\n&nbsp;&nbsp;&nbsp;&nbsp;一开始进入公司，我被派的任务是进行artik芯片的测试执行，输出测试执行报告并且开发相应的shell脚本进行自动化测试。因为之前没有过Linux开发经验，所以对于这项工作还是有很多畏惧，怕自己不能完成相应的任务。后来进过一个礼拜的熟悉以后，对于自动化测试的脚本开发和测试执行更加得心应手起来。Artik芯片包含许多模块如MQTT、wifi、TLS、ZigBee、BT/BLE、Ethernet等，在进行这些模块的测试脚本的开发的时候，不仅要熟悉脚本开发的shell语言，还要对这些协议也有一定的学习。由于我之前没有接触过Linux，所以对于shell脚本的编写知识懂一丁点儿简单的命令，后来边工作边学习，对于一些常用的Linux命令也掌握的很熟悉了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;其实作自动化测试这个工作不是我期望的工作，但是来到公司里，对于公司的安排还是要服从的，毕竟也是能够学习到很多东西的。而且有很多有常年工作经验的师傅们的带领，不管是技术方面还是工作习惯与工作流程的熟悉上我也学习了不少。由于自己在学校是主要学习WEB开发的，所以一直希望自己能够在实习时得到一些这方面的工作经验，在接下来的两个月，我便被leader调到web组进行一个公司内部的项目管理系统的开发。\n\n&nbsp;&nbsp;&nbsp;&nbsp;在做第二个项目之前，我不会想到这个项目的短短一个多月比我之前所有时间加起来都学到的多。因为这个项目几乎是由我独自完成前端与后台代码的编写，而且使用的是我之前没有任何经验的PHP语言进行开发。领导要求一个月内完成整个项目的开发，所以压力非常大。我一边在工作中学习，工作，一边再回到寝室后仍查资料学习希望能够把这个项目做到最好。前端方面我更加熟悉了jquery和bootstrap框架以及html/css，后端方面我又掌握了新的技能–PHP。从数据库的设计到前端页面的设计，再到后台业务代码的编写，投入了自己非常大的精力。不管最后结果如何，这个项目经历的确使我对于web开发的相关技术知识增长不少。在经历了一个多月的边学边做，最后总算（不是很完美的）完成了这项工作。\n\n&nbsp;&nbsp;&nbsp;&nbsp;9月，由于学校开学以及准备毕业找工作（想找Java开发的岗位），便不能继续在公司继续实习，对于这里很不舍，因为这儿是一个工作气氛非常舒服愉快的地方。在这里我遇到了很多和我一起在这里实习的小伙伴，也结识了很多已经毕业很多年工作近十年的朋友，我相信这些人和事在未来的日子里都是我最宝贵的财富，而这次的实习经历也希望将会是我走上成功的路上的一块踏板。希望自己的努力能够对得起自己的理想！\n","source":"_posts/一个菜鸟在三星实习的感受.md","raw":"---\ntitle: 一个菜鸟在三星实习的那点儿感受\ndate: 2016-09-11 20:20:45\ncategories: [程序人生]\ntags: [程序人生,实习,三星,shell自动化测试]\n---\n&nbsp;&nbsp;&nbsp;&nbsp;2016年暑假，在大学这片沃土上的第三个学期就这样结束了，回想大学这三年，为了自己的未来迷茫过，也为自己努力过，也为了不少事情烦恼过，不知道将来自己可以在什么地方过着怎样的生活。曾经以为自己将会平凡地与大部分人一样，每天上着不知老师所云的课程，浑浑噩噩地度过这大学四年的生活，然后找一个普普通通的工作，但是也算自己运气好吧，在大一第二学期遇到了一位让自己眼前一亮的老师，慢慢学习并了解程序员这个行业，最后决定走上学习Java开发的道路。\n\n&nbsp;&nbsp;&nbsp;&nbsp;很早就听说，在大三暑假如果能够找到一个好的专业对口的暑期实习的话，那么在大学毕业以后找工作就方便许多。于是在2016年3月，我便一边努力学习着web开发的相关知识，一边在网上投简历找着实习，终于在一个学长的内推下，我进入了西安三星半导体有限公司，原西安三星电子研究所。\n\n&nbsp;&nbsp;&nbsp;&nbsp;三星是一个气氛非常好的公司，直到现在我都觉得能够进入这个公司是我大学期间的很幸运的一件事。在这儿我遇到了对我很好的师傅们，和那些谦逊和善的同事们。\n\n&nbsp;&nbsp;&nbsp;&nbsp;一开始进入公司，我被派的任务是进行artik芯片的测试执行，输出测试执行报告并且开发相应的shell脚本进行自动化测试。因为之前没有过Linux开发经验，所以对于这项工作还是有很多畏惧，怕自己不能完成相应的任务。后来进过一个礼拜的熟悉以后，对于自动化测试的脚本开发和测试执行更加得心应手起来。Artik芯片包含许多模块如MQTT、wifi、TLS、ZigBee、BT/BLE、Ethernet等，在进行这些模块的测试脚本的开发的时候，不仅要熟悉脚本开发的shell语言，还要对这些协议也有一定的学习。由于我之前没有接触过Linux，所以对于shell脚本的编写知识懂一丁点儿简单的命令，后来边工作边学习，对于一些常用的Linux命令也掌握的很熟悉了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;其实作自动化测试这个工作不是我期望的工作，但是来到公司里，对于公司的安排还是要服从的，毕竟也是能够学习到很多东西的。而且有很多有常年工作经验的师傅们的带领，不管是技术方面还是工作习惯与工作流程的熟悉上我也学习了不少。由于自己在学校是主要学习WEB开发的，所以一直希望自己能够在实习时得到一些这方面的工作经验，在接下来的两个月，我便被leader调到web组进行一个公司内部的项目管理系统的开发。\n\n&nbsp;&nbsp;&nbsp;&nbsp;在做第二个项目之前，我不会想到这个项目的短短一个多月比我之前所有时间加起来都学到的多。因为这个项目几乎是由我独自完成前端与后台代码的编写，而且使用的是我之前没有任何经验的PHP语言进行开发。领导要求一个月内完成整个项目的开发，所以压力非常大。我一边在工作中学习，工作，一边再回到寝室后仍查资料学习希望能够把这个项目做到最好。前端方面我更加熟悉了jquery和bootstrap框架以及html/css，后端方面我又掌握了新的技能–PHP。从数据库的设计到前端页面的设计，再到后台业务代码的编写，投入了自己非常大的精力。不管最后结果如何，这个项目经历的确使我对于web开发的相关技术知识增长不少。在经历了一个多月的边学边做，最后总算（不是很完美的）完成了这项工作。\n\n&nbsp;&nbsp;&nbsp;&nbsp;9月，由于学校开学以及准备毕业找工作（想找Java开发的岗位），便不能继续在公司继续实习，对于这里很不舍，因为这儿是一个工作气氛非常舒服愉快的地方。在这里我遇到了很多和我一起在这里实习的小伙伴，也结识了很多已经毕业很多年工作近十年的朋友，我相信这些人和事在未来的日子里都是我最宝贵的财富，而这次的实习经历也希望将会是我走上成功的路上的一块踏板。希望自己的努力能够对得起自己的理想！\n","slug":"一个菜鸟在三星实习的感受","published":1,"updated":"2019-05-07T09:48:29.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvv5000jcwnkchnbiv6f","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;2016年暑假，在大学这片沃土上的第三个学期就这样结束了，回想大学这三年，为了自己的未来迷茫过，也为自己努力过，也为了不少事情烦恼过，不知道将来自己可以在什么地方过着怎样的生活。曾经以为自己将会平凡地与大部分人一样，每天上着不知老师所云的课程，浑浑噩噩地度过这大学四年的生活，然后找一个普普通通的工作，但是也算自己运气好吧，在大一第二学期遇到了一位让自己眼前一亮的老师，慢慢学习并了解程序员这个行业，最后决定走上学习Java开发的道路。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;很早就听说，在大三暑假如果能够找到一个好的专业对口的暑期实习的话，那么在大学毕业以后找工作就方便许多。于是在2016年3月，我便一边努力学习着web开发的相关知识，一边在网上投简历找着实习，终于在一个学长的内推下，我进入了西安三星半导体有限公司，原西安三星电子研究所。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;三星是一个气氛非常好的公司，直到现在我都觉得能够进入这个公司是我大学期间的很幸运的一件事。在这儿我遇到了对我很好的师傅们，和那些谦逊和善的同事们。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;一开始进入公司，我被派的任务是进行artik芯片的测试执行，输出测试执行报告并且开发相应的shell脚本进行自动化测试。因为之前没有过Linux开发经验，所以对于这项工作还是有很多畏惧，怕自己不能完成相应的任务。后来进过一个礼拜的熟悉以后，对于自动化测试的脚本开发和测试执行更加得心应手起来。Artik芯片包含许多模块如MQTT、wifi、TLS、ZigBee、BT/BLE、Ethernet等，在进行这些模块的测试脚本的开发的时候，不仅要熟悉脚本开发的shell语言，还要对这些协议也有一定的学习。由于我之前没有接触过Linux，所以对于shell脚本的编写知识懂一丁点儿简单的命令，后来边工作边学习，对于一些常用的Linux命令也掌握的很熟悉了。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;其实作自动化测试这个工作不是我期望的工作，但是来到公司里，对于公司的安排还是要服从的，毕竟也是能够学习到很多东西的。而且有很多有常年工作经验的师傅们的带领，不管是技术方面还是工作习惯与工作流程的熟悉上我也学习了不少。由于自己在学校是主要学习WEB开发的，所以一直希望自己能够在实习时得到一些这方面的工作经验，在接下来的两个月，我便被leader调到web组进行一个公司内部的项目管理系统的开发。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;在做第二个项目之前，我不会想到这个项目的短短一个多月比我之前所有时间加起来都学到的多。因为这个项目几乎是由我独自完成前端与后台代码的编写，而且使用的是我之前没有任何经验的PHP语言进行开发。领导要求一个月内完成整个项目的开发，所以压力非常大。我一边在工作中学习，工作，一边再回到寝室后仍查资料学习希望能够把这个项目做到最好。前端方面我更加熟悉了jquery和bootstrap框架以及html/css，后端方面我又掌握了新的技能–PHP。从数据库的设计到前端页面的设计，再到后台业务代码的编写，投入了自己非常大的精力。不管最后结果如何，这个项目经历的确使我对于web开发的相关技术知识增长不少。在经历了一个多月的边学边做，最后总算（不是很完美的）完成了这项工作。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;9月，由于学校开学以及准备毕业找工作（想找Java开发的岗位），便不能继续在公司继续实习，对于这里很不舍，因为这儿是一个工作气氛非常舒服愉快的地方。在这里我遇到了很多和我一起在这里实习的小伙伴，也结识了很多已经毕业很多年工作近十年的朋友，我相信这些人和事在未来的日子里都是我最宝贵的财富，而这次的实习经历也希望将会是我走上成功的路上的一块踏板。希望自己的努力能够对得起自己的理想！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&nbsp;&nbsp;&nbsp;&nbsp;2016年暑假，在大学这片沃土上的第三个学期就这样结束了，回想大学这三年，为了自己的未来迷茫过，也为自己努力过，也为了不少事情烦恼过，不知道将来自己可以在什么地方过着怎样的生活。曾经以为自己将会平凡地与大部分人一样，每天上着不知老师所云的课程，浑浑噩噩地度过这大学四年的生活，然后找一个普普通通的工作，但是也算自己运气好吧，在大一第二学期遇到了一位让自己眼前一亮的老师，慢慢学习并了解程序员这个行业，最后决定走上学习Java开发的道路。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;很早就听说，在大三暑假如果能够找到一个好的专业对口的暑期实习的话，那么在大学毕业以后找工作就方便许多。于是在2016年3月，我便一边努力学习着web开发的相关知识，一边在网上投简历找着实习，终于在一个学长的内推下，我进入了西安三星半导体有限公司，原西安三星电子研究所。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;三星是一个气氛非常好的公司，直到现在我都觉得能够进入这个公司是我大学期间的很幸运的一件事。在这儿我遇到了对我很好的师傅们，和那些谦逊和善的同事们。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;一开始进入公司，我被派的任务是进行artik芯片的测试执行，输出测试执行报告并且开发相应的shell脚本进行自动化测试。因为之前没有过Linux开发经验，所以对于这项工作还是有很多畏惧，怕自己不能完成相应的任务。后来进过一个礼拜的熟悉以后，对于自动化测试的脚本开发和测试执行更加得心应手起来。Artik芯片包含许多模块如MQTT、wifi、TLS、ZigBee、BT/BLE、Ethernet等，在进行这些模块的测试脚本的开发的时候，不仅要熟悉脚本开发的shell语言，还要对这些协议也有一定的学习。由于我之前没有接触过Linux，所以对于shell脚本的编写知识懂一丁点儿简单的命令，后来边工作边学习，对于一些常用的Linux命令也掌握的很熟悉了。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;其实作自动化测试这个工作不是我期望的工作，但是来到公司里，对于公司的安排还是要服从的，毕竟也是能够学习到很多东西的。而且有很多有常年工作经验的师傅们的带领，不管是技术方面还是工作习惯与工作流程的熟悉上我也学习了不少。由于自己在学校是主要学习WEB开发的，所以一直希望自己能够在实习时得到一些这方面的工作经验，在接下来的两个月，我便被leader调到web组进行一个公司内部的项目管理系统的开发。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;在做第二个项目之前，我不会想到这个项目的短短一个多月比我之前所有时间加起来都学到的多。因为这个项目几乎是由我独自完成前端与后台代码的编写，而且使用的是我之前没有任何经验的PHP语言进行开发。领导要求一个月内完成整个项目的开发，所以压力非常大。我一边在工作中学习，工作，一边再回到寝室后仍查资料学习希望能够把这个项目做到最好。前端方面我更加熟悉了jquery和bootstrap框架以及html/css，后端方面我又掌握了新的技能–PHP。从数据库的设计到前端页面的设计，再到后台业务代码的编写，投入了自己非常大的精力。不管最后结果如何，这个项目经历的确使我对于web开发的相关技术知识增长不少。在经历了一个多月的边学边做，最后总算（不是很完美的）完成了这项工作。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;9月，由于学校开学以及准备毕业找工作（想找Java开发的岗位），便不能继续在公司继续实习，对于这里很不舍，因为这儿是一个工作气氛非常舒服愉快的地方。在这里我遇到了很多和我一起在这里实习的小伙伴，也结识了很多已经毕业很多年工作近十年的朋友，我相信这些人和事在未来的日子里都是我最宝贵的财富，而这次的实习经历也希望将会是我走上成功的路上的一块踏板。希望自己的努力能够对得起自己的理想！</p>\n"},{"title":"Springboot+shiro解决session污染的问题","date":"2019-03-09T07:26:49.000Z","_content":"\n#### 同一个服务器启动多个web项目造成session污染\n\n昨天在敲代码的时候遇到了一个问题，同一个项目，我创建了两个分支，分别使用不同的端口。\n但是在测试环境启动的时候我发现，在同一个浏览器上，我只能登陆其中的一个后台。在登陆另一个后台之后，前面那个\n又需要再重新登陆了。\n\n原因找了好久，最后F12控制台查看session发现，这两个web项目，使用的都是JSessionId作为cookie的key，在登陆另一个时，浏览器的这个cookie值就会被改变，所以前者就需要在重新登陆了。\n\n<!--more-->\n#### 解决方法\n在springboot中，对shiro配置进行更改session保存时的cookie的key名称，如下。\n```\n@Bean\npublic DefaultWebSessionManager sessionManager() {\n    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\n    Cookie cookie = sessionManager.getSessionIdCookie();\n    cookie.setName(\"MySessionId\");\n    return sessionManager;\n}\n```\n然后在`securityManager`中将我们的`sessionManager`注入进去。\n```\n/**\n * SecurityManager，权限管理，这个类组合了登陆，登出，权限，session的处理，是个比较重要的类。\n */\n@Bean\npublic DefaultWebSecurityManager securityManager() {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    securityManager.setRealm(myShiroRealm());\n    securityManager.setSessionManager(sessionManager());\n    return securityManager;\n}\n```\n只需要这样修改好就可以了。然后重启项目，就会发现，两个web项目都可以同时登陆了。\n","source":"_posts/springboot+shiro解决session污染问题.md","raw":"---\ntitle: springboot+shiro解决session污染的问题\ndate: 2019-03-09 15:26:49\ncategories: [springboot]\ntags: [springboot,shiro,session污染]\n---\n\n#### 同一个服务器启动多个web项目造成session污染\n\n昨天在敲代码的时候遇到了一个问题，同一个项目，我创建了两个分支，分别使用不同的端口。\n但是在测试环境启动的时候我发现，在同一个浏览器上，我只能登陆其中的一个后台。在登陆另一个后台之后，前面那个\n又需要再重新登陆了。\n\n原因找了好久，最后F12控制台查看session发现，这两个web项目，使用的都是JSessionId作为cookie的key，在登陆另一个时，浏览器的这个cookie值就会被改变，所以前者就需要在重新登陆了。\n\n<!--more-->\n#### 解决方法\n在springboot中，对shiro配置进行更改session保存时的cookie的key名称，如下。\n```\n@Bean\npublic DefaultWebSessionManager sessionManager() {\n    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\n    Cookie cookie = sessionManager.getSessionIdCookie();\n    cookie.setName(\"MySessionId\");\n    return sessionManager;\n}\n```\n然后在`securityManager`中将我们的`sessionManager`注入进去。\n```\n/**\n * SecurityManager，权限管理，这个类组合了登陆，登出，权限，session的处理，是个比较重要的类。\n */\n@Bean\npublic DefaultWebSecurityManager securityManager() {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    securityManager.setRealm(myShiroRealm());\n    securityManager.setSessionManager(sessionManager());\n    return securityManager;\n}\n```\n只需要这样修改好就可以了。然后重启项目，就会发现，两个web项目都可以同时登陆了。\n","slug":"springboot+shiro解决session污染问题","published":1,"updated":"2019-05-07T09:48:29.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvv7000lcwnklz02nogp","content":"<h4 id=\"同一个服务器启动多个web项目造成session污染\"><a href=\"#同一个服务器启动多个web项目造成session污染\" class=\"headerlink\" title=\"同一个服务器启动多个web项目造成session污染\"></a>同一个服务器启动多个web项目造成session污染</h4><p>昨天在敲代码的时候遇到了一个问题，同一个项目，我创建了两个分支，分别使用不同的端口。<br>但是在测试环境启动的时候我发现，在同一个浏览器上，我只能登陆其中的一个后台。在登陆另一个后台之后，前面那个<br>又需要再重新登陆了。</p>\n<p>原因找了好久，最后F12控制台查看session发现，这两个web项目，使用的都是JSessionId作为cookie的key，在登陆另一个时，浏览器的这个cookie值就会被改变，所以前者就需要在重新登陆了。</p>\n<a id=\"more\"></a>\n<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><p>在springboot中，对shiro配置进行更改session保存时的cookie的key名称，如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public DefaultWebSessionManager sessionManager() &#123;</span><br><span class=\"line\">    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();</span><br><span class=\"line\">    Cookie cookie = sessionManager.getSessionIdCookie();</span><br><span class=\"line\">    cookie.setName(&quot;MySessionId&quot;);</span><br><span class=\"line\">    return sessionManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在<code>securityManager</code>中将我们的<code>sessionManager</code>注入进去。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * SecurityManager，权限管理，这个类组合了登陆，登出，权限，session的处理，是个比较重要的类。</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Bean</span><br><span class=\"line\">public DefaultWebSecurityManager securityManager() &#123;</span><br><span class=\"line\">    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class=\"line\">    securityManager.setRealm(myShiroRealm());</span><br><span class=\"line\">    securityManager.setSessionManager(sessionManager());</span><br><span class=\"line\">    return securityManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只需要这样修改好就可以了。然后重启项目，就会发现，两个web项目都可以同时登陆了。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"同一个服务器启动多个web项目造成session污染\"><a href=\"#同一个服务器启动多个web项目造成session污染\" class=\"headerlink\" title=\"同一个服务器启动多个web项目造成session污染\"></a>同一个服务器启动多个web项目造成session污染</h4><p>昨天在敲代码的时候遇到了一个问题，同一个项目，我创建了两个分支，分别使用不同的端口。<br>但是在测试环境启动的时候我发现，在同一个浏览器上，我只能登陆其中的一个后台。在登陆另一个后台之后，前面那个<br>又需要再重新登陆了。</p>\n<p>原因找了好久，最后F12控制台查看session发现，这两个web项目，使用的都是JSessionId作为cookie的key，在登陆另一个时，浏览器的这个cookie值就会被改变，所以前者就需要在重新登陆了。</p>","more":"<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><p>在springboot中，对shiro配置进行更改session保存时的cookie的key名称，如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public DefaultWebSessionManager sessionManager() &#123;</span><br><span class=\"line\">    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();</span><br><span class=\"line\">    Cookie cookie = sessionManager.getSessionIdCookie();</span><br><span class=\"line\">    cookie.setName(&quot;MySessionId&quot;);</span><br><span class=\"line\">    return sessionManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在<code>securityManager</code>中将我们的<code>sessionManager</code>注入进去。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * SecurityManager，权限管理，这个类组合了登陆，登出，权限，session的处理，是个比较重要的类。</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Bean</span><br><span class=\"line\">public DefaultWebSecurityManager securityManager() &#123;</span><br><span class=\"line\">    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class=\"line\">    securityManager.setRealm(myShiroRealm());</span><br><span class=\"line\">    securityManager.setSessionManager(sessionManager());</span><br><span class=\"line\">    return securityManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只需要这样修改好就可以了。然后重启项目，就会发现，两个web项目都可以同时登陆了。</p>"},{"title":"事务传播机制和事务隔离级别","date":"2019-03-23T13:41:16.000Z","_content":"#### 事务的四个特性(ACID)\n\n- 原子性\n\t事务执行开始之后的一系列操作都堪称是一个原子操作，要么全部做完，要么全部失败，不能出现部分操作成功的情况。“原子”顾名思义，就是一个不可分割的最小单元。\n\t\n- 一致性\n\t事务开始执行之后，数据的正确性需要得到保证。如A向B转账，B却未收到钱。\n\t\n- 隔离性\n\t同一时间只能由一个事务对数据进行修改操作，对于其他事务来说这个修改操作时透明的。\n\t\n- 持久性\n\t事务对数据进行修改操作完成之后，数据发生的改变是持久不变的，不会自己恢复到改变之前的状态。\n\n<!--more-->\n#### spring中的事务传播机制 以及事务隔离级别\n\n**在接口TransactionDefinition中，定义了7种传播机制**\n```\npackage org.springframework.transaction;\n\npublic interface TransactionDefinition {\n    \n\t// 事务传播机制\n\tint PROPAGATION_REQUIRED = 0;\t\t\t// 默认的 也是最常用的 ，如果当前有事务，就加入当前这个事务，如果没有事务，就新建一个事务\n    int PROPAGATION_SUPPORTS = 1;\t\t\t// 如果有事务，就加入当前这个事务，如果没有事务，也不新建\n    int PROPAGATION_MANDATORY = 2;\t\t\t// 如果有事务，就会使用当前这个事务，如果没有就会抛出异常\n    int PROPAGATION_REQUIRES_NEW = 3;\t\t// 总是会开启一个新的事务，如果当前已经有事务，就将当前事务挂起\n    int PROPAGATION_NOT_SUPPORTED = 4;\t\t// 代码总是会在非事务的环境执行，如果当前有事务，先将事务挂起，执行完成之后再恢复\n    int PROPAGATION_NEVER = 5;\t\t\t\t// 绝对不允许代码在有事务的环境执行，有事务就抛出异常停止执行\n    int PROPAGATION_NESTED = 6;\t\t\t\t// 嵌套事务级别：如果没有父事务，就使用默认机制，如果有，子事务执行完成之后父事务才会提交\n\t\n\t// 事务隔离级别\n    int ISOLATION_DEFAULT = -1;\t\t\t\t// 默认级别 \n    int ISOLATION_READ_UNCOMMITTED = 1;\t\t// 读未提交 即脏读，可以读取别的事务已修改未提交的数据，会导致脏读、幻读和不可重复度\n    int ISOLATION_READ_COMMITTED = 2;\t\t// 提交读\t即不可重复读，一个事物能读取到另一个事务已经提交的数据，在多次读取同一数据时，该数据被另一事务修改，读取的数据不一致\n    int ISOLATION_REPEATABLE_READ = 4;\t\t// 可重复读 即一个事物只能读取到另一事务提交之前的数据，确保每次读取到的数据一致。但是数据又新增或者修改时不可预见\n    int ISOLATION_SERIALIZABLE = 8;\t\t\t// 序列化读 即事务串行读取数据，性能最差，安全性最高，保证数据准确性\n    int TIMEOUT_DEFAULT = -1;\n\n    int getPropagationBehavior();\n\n    int getIsolationLevel();\n\n    int getTimeout();\n\n    boolean isReadOnly();\n\n    String getName();\n}\n```","source":"_posts/事务传播机制以及隔离级别.md","raw":"---\ntitle: 事务传播机制和事务隔离级别\ndate: 2019-03-23 21:41:16\ncategories: [Java基础]\ntags: [Java基础,事务,数据库]\n---\n#### 事务的四个特性(ACID)\n\n- 原子性\n\t事务执行开始之后的一系列操作都堪称是一个原子操作，要么全部做完，要么全部失败，不能出现部分操作成功的情况。“原子”顾名思义，就是一个不可分割的最小单元。\n\t\n- 一致性\n\t事务开始执行之后，数据的正确性需要得到保证。如A向B转账，B却未收到钱。\n\t\n- 隔离性\n\t同一时间只能由一个事务对数据进行修改操作，对于其他事务来说这个修改操作时透明的。\n\t\n- 持久性\n\t事务对数据进行修改操作完成之后，数据发生的改变是持久不变的，不会自己恢复到改变之前的状态。\n\n<!--more-->\n#### spring中的事务传播机制 以及事务隔离级别\n\n**在接口TransactionDefinition中，定义了7种传播机制**\n```\npackage org.springframework.transaction;\n\npublic interface TransactionDefinition {\n    \n\t// 事务传播机制\n\tint PROPAGATION_REQUIRED = 0;\t\t\t// 默认的 也是最常用的 ，如果当前有事务，就加入当前这个事务，如果没有事务，就新建一个事务\n    int PROPAGATION_SUPPORTS = 1;\t\t\t// 如果有事务，就加入当前这个事务，如果没有事务，也不新建\n    int PROPAGATION_MANDATORY = 2;\t\t\t// 如果有事务，就会使用当前这个事务，如果没有就会抛出异常\n    int PROPAGATION_REQUIRES_NEW = 3;\t\t// 总是会开启一个新的事务，如果当前已经有事务，就将当前事务挂起\n    int PROPAGATION_NOT_SUPPORTED = 4;\t\t// 代码总是会在非事务的环境执行，如果当前有事务，先将事务挂起，执行完成之后再恢复\n    int PROPAGATION_NEVER = 5;\t\t\t\t// 绝对不允许代码在有事务的环境执行，有事务就抛出异常停止执行\n    int PROPAGATION_NESTED = 6;\t\t\t\t// 嵌套事务级别：如果没有父事务，就使用默认机制，如果有，子事务执行完成之后父事务才会提交\n\t\n\t// 事务隔离级别\n    int ISOLATION_DEFAULT = -1;\t\t\t\t// 默认级别 \n    int ISOLATION_READ_UNCOMMITTED = 1;\t\t// 读未提交 即脏读，可以读取别的事务已修改未提交的数据，会导致脏读、幻读和不可重复度\n    int ISOLATION_READ_COMMITTED = 2;\t\t// 提交读\t即不可重复读，一个事物能读取到另一个事务已经提交的数据，在多次读取同一数据时，该数据被另一事务修改，读取的数据不一致\n    int ISOLATION_REPEATABLE_READ = 4;\t\t// 可重复读 即一个事物只能读取到另一事务提交之前的数据，确保每次读取到的数据一致。但是数据又新增或者修改时不可预见\n    int ISOLATION_SERIALIZABLE = 8;\t\t\t// 序列化读 即事务串行读取数据，性能最差，安全性最高，保证数据准确性\n    int TIMEOUT_DEFAULT = -1;\n\n    int getPropagationBehavior();\n\n    int getIsolationLevel();\n\n    int getTimeout();\n\n    boolean isReadOnly();\n\n    String getName();\n}\n```","slug":"事务传播机制以及隔离级别","published":1,"updated":"2019-05-07T09:48:29.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvv9000qcwnk2iprmxes","content":"<h4 id=\"事务的四个特性-ACID\"><a href=\"#事务的四个特性-ACID\" class=\"headerlink\" title=\"事务的四个特性(ACID)\"></a>事务的四个特性(ACID)</h4><ul>\n<li><p>原子性<br>  事务执行开始之后的一系列操作都堪称是一个原子操作，要么全部做完，要么全部失败，不能出现部分操作成功的情况。“原子”顾名思义，就是一个不可分割的最小单元。</p>\n</li>\n<li><p>一致性<br>  事务开始执行之后，数据的正确性需要得到保证。如A向B转账，B却未收到钱。</p>\n</li>\n<li><p>隔离性<br>  同一时间只能由一个事务对数据进行修改操作，对于其他事务来说这个修改操作时透明的。</p>\n</li>\n<li><p>持久性<br>  事务对数据进行修改操作完成之后，数据发生的改变是持久不变的，不会自己恢复到改变之前的状态。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"spring中的事务传播机制-以及事务隔离级别\"><a href=\"#spring中的事务传播机制-以及事务隔离级别\" class=\"headerlink\" title=\"spring中的事务传播机制 以及事务隔离级别\"></a>spring中的事务传播机制 以及事务隔离级别</h4><p><strong>在接口TransactionDefinition中，定义了7种传播机制</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.springframework.transaction;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface TransactionDefinition &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t// 事务传播机制</span><br><span class=\"line\">\tint PROPAGATION_REQUIRED = 0;\t\t\t// 默认的 也是最常用的 ，如果当前有事务，就加入当前这个事务，如果没有事务，就新建一个事务</span><br><span class=\"line\">    int PROPAGATION_SUPPORTS = 1;\t\t\t// 如果有事务，就加入当前这个事务，如果没有事务，也不新建</span><br><span class=\"line\">    int PROPAGATION_MANDATORY = 2;\t\t\t// 如果有事务，就会使用当前这个事务，如果没有就会抛出异常</span><br><span class=\"line\">    int PROPAGATION_REQUIRES_NEW = 3;\t\t// 总是会开启一个新的事务，如果当前已经有事务，就将当前事务挂起</span><br><span class=\"line\">    int PROPAGATION_NOT_SUPPORTED = 4;\t\t// 代码总是会在非事务的环境执行，如果当前有事务，先将事务挂起，执行完成之后再恢复</span><br><span class=\"line\">    int PROPAGATION_NEVER = 5;\t\t\t\t// 绝对不允许代码在有事务的环境执行，有事务就抛出异常停止执行</span><br><span class=\"line\">    int PROPAGATION_NESTED = 6;\t\t\t\t// 嵌套事务级别：如果没有父事务，就使用默认机制，如果有，子事务执行完成之后父事务才会提交</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// 事务隔离级别</span><br><span class=\"line\">    int ISOLATION_DEFAULT = -1;\t\t\t\t// 默认级别 </span><br><span class=\"line\">    int ISOLATION_READ_UNCOMMITTED = 1;\t\t// 读未提交 即脏读，可以读取别的事务已修改未提交的数据，会导致脏读、幻读和不可重复度</span><br><span class=\"line\">    int ISOLATION_READ_COMMITTED = 2;\t\t// 提交读\t即不可重复读，一个事物能读取到另一个事务已经提交的数据，在多次读取同一数据时，该数据被另一事务修改，读取的数据不一致</span><br><span class=\"line\">    int ISOLATION_REPEATABLE_READ = 4;\t\t// 可重复读 即一个事物只能读取到另一事务提交之前的数据，确保每次读取到的数据一致。但是数据又新增或者修改时不可预见</span><br><span class=\"line\">    int ISOLATION_SERIALIZABLE = 8;\t\t\t// 序列化读 即事务串行读取数据，性能最差，安全性最高，保证数据准确性</span><br><span class=\"line\">    int TIMEOUT_DEFAULT = -1;</span><br><span class=\"line\"></span><br><span class=\"line\">    int getPropagationBehavior();</span><br><span class=\"line\"></span><br><span class=\"line\">    int getIsolationLevel();</span><br><span class=\"line\"></span><br><span class=\"line\">    int getTimeout();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean isReadOnly();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getName();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"事务的四个特性-ACID\"><a href=\"#事务的四个特性-ACID\" class=\"headerlink\" title=\"事务的四个特性(ACID)\"></a>事务的四个特性(ACID)</h4><ul>\n<li><p>原子性<br>  事务执行开始之后的一系列操作都堪称是一个原子操作，要么全部做完，要么全部失败，不能出现部分操作成功的情况。“原子”顾名思义，就是一个不可分割的最小单元。</p>\n</li>\n<li><p>一致性<br>  事务开始执行之后，数据的正确性需要得到保证。如A向B转账，B却未收到钱。</p>\n</li>\n<li><p>隔离性<br>  同一时间只能由一个事务对数据进行修改操作，对于其他事务来说这个修改操作时透明的。</p>\n</li>\n<li><p>持久性<br>  事务对数据进行修改操作完成之后，数据发生的改变是持久不变的，不会自己恢复到改变之前的状态。</p>\n</li>\n</ul>","more":"<h4 id=\"spring中的事务传播机制-以及事务隔离级别\"><a href=\"#spring中的事务传播机制-以及事务隔离级别\" class=\"headerlink\" title=\"spring中的事务传播机制 以及事务隔离级别\"></a>spring中的事务传播机制 以及事务隔离级别</h4><p><strong>在接口TransactionDefinition中，定义了7种传播机制</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.springframework.transaction;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface TransactionDefinition &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t// 事务传播机制</span><br><span class=\"line\">\tint PROPAGATION_REQUIRED = 0;\t\t\t// 默认的 也是最常用的 ，如果当前有事务，就加入当前这个事务，如果没有事务，就新建一个事务</span><br><span class=\"line\">    int PROPAGATION_SUPPORTS = 1;\t\t\t// 如果有事务，就加入当前这个事务，如果没有事务，也不新建</span><br><span class=\"line\">    int PROPAGATION_MANDATORY = 2;\t\t\t// 如果有事务，就会使用当前这个事务，如果没有就会抛出异常</span><br><span class=\"line\">    int PROPAGATION_REQUIRES_NEW = 3;\t\t// 总是会开启一个新的事务，如果当前已经有事务，就将当前事务挂起</span><br><span class=\"line\">    int PROPAGATION_NOT_SUPPORTED = 4;\t\t// 代码总是会在非事务的环境执行，如果当前有事务，先将事务挂起，执行完成之后再恢复</span><br><span class=\"line\">    int PROPAGATION_NEVER = 5;\t\t\t\t// 绝对不允许代码在有事务的环境执行，有事务就抛出异常停止执行</span><br><span class=\"line\">    int PROPAGATION_NESTED = 6;\t\t\t\t// 嵌套事务级别：如果没有父事务，就使用默认机制，如果有，子事务执行完成之后父事务才会提交</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// 事务隔离级别</span><br><span class=\"line\">    int ISOLATION_DEFAULT = -1;\t\t\t\t// 默认级别 </span><br><span class=\"line\">    int ISOLATION_READ_UNCOMMITTED = 1;\t\t// 读未提交 即脏读，可以读取别的事务已修改未提交的数据，会导致脏读、幻读和不可重复度</span><br><span class=\"line\">    int ISOLATION_READ_COMMITTED = 2;\t\t// 提交读\t即不可重复读，一个事物能读取到另一个事务已经提交的数据，在多次读取同一数据时，该数据被另一事务修改，读取的数据不一致</span><br><span class=\"line\">    int ISOLATION_REPEATABLE_READ = 4;\t\t// 可重复读 即一个事物只能读取到另一事务提交之前的数据，确保每次读取到的数据一致。但是数据又新增或者修改时不可预见</span><br><span class=\"line\">    int ISOLATION_SERIALIZABLE = 8;\t\t\t// 序列化读 即事务串行读取数据，性能最差，安全性最高，保证数据准确性</span><br><span class=\"line\">    int TIMEOUT_DEFAULT = -1;</span><br><span class=\"line\"></span><br><span class=\"line\">    int getPropagationBehavior();</span><br><span class=\"line\"></span><br><span class=\"line\">    int getIsolationLevel();</span><br><span class=\"line\"></span><br><span class=\"line\">    int getTimeout();</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean isReadOnly();</span><br><span class=\"line\"></span><br><span class=\"line\">    String getName();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"二叉搜索树与完全二叉树","date":"2019-05-04T02:29:36.000Z","_content":"\n#### 什么是二叉树？\n\n在数据结构中，对于树，每一个分支，称之为一个度。那么，度最大为2的树我们称之为二叉树。通常子树我们会称之为左子树和右子树。二叉树通常用于实现二叉查找树和二叉堆。那么在Java中如何定义一个二叉树节点？\n\n首先，每一个节点需要有一个值域。其次，其还应该持有两个树节点的引用，即指向自己的左子树和自己的右子树。\n\n<!--more-->\n\n具体代码如下：\n```\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode() {\n        this.val = 0;\n        this.left = null;\n        this.right = null;\n    }\n\n    TreeNode(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + val + \")[left:\" + left + \",right:\" + right + \"]\";\n    }\n}\n```\n\n\n#### 如何创建二叉树\n\n二叉树的节点的数据结构已经用Java代码表示出来了，那么如何用这些节点来构造出一个完整的二叉树呢？请看下图二叉树的结构：\n\n![二叉树结构](ecs.png)\n\n如上图，对于一个二叉树，需要有一个根节点。每个节点最多有两课子树，分别区分左子树还是右子树。即就算有一个子树，还是需要区分是左子树还是右子树。创建二叉树我们只需要将每一个树节点按照这样的规则连接起来即可。\n\n##### 创建二叉搜索树\n\n- 概念：二叉搜索树，又叫二叉查找树。他是一棵特殊的二叉树，对于二叉搜索树中的每一个节点，它的左子树都不大于父节点，右子树都不小于父节点。空树是特殊的二叉搜索树。\n- 创建：本例根据一个已有的数组进行二叉树的创建，基本的思路就是遍历数组，每个元素创建一个树节点，然后继续根据节点值得大小向下遍历判断，最后将值域小的放在节点的左子树，将值大的放在节点的右子树即可。\n  ```\n  public static TreeNode createSearchTree(int[] a) {\n      if (a.length > 0) {\n          TreeNode root = new TreeNode(a[0]);\n          for (int i = 1; i < a.length; i++) {\n              TreeNode c = root;\n              TreeNode p = c;\n              TreeNode q = new TreeNode(a[i]);\n              while (c != null) {\n                  p = c;\n                  if (a[i] <= c.val) {\n                      c = c.left;\n                  } else {\n                      c = c.right;\n                  }\n              }\n              if (q.val < p.val) {\n                  p.left = q;\n              } else {\n                  p.right = q;\n              }\n          }\n          return root;\n      }\n      return null;\n  }\n  ```\n\n- 特点：二叉搜索树在应用于经常查找元素的场景效率会比较快，因为它的数据结构类似于二分查找，查找元素时根据其特性向下搜索即可。\n\n##### 创建完全二叉树\n\n  - 概念：首先介绍一下满二叉树：即树中的所有节点除了叶节点都有左子树和右子树，叶节点的左右子树都为空，这样的树称之为满二叉树。而对于一棵完全二叉树，只有树的最后一层连续缺失右边节点。满二叉树一定是完全二叉树，反之则不一定成立。如图分别是一棵满二叉树和一棵完全二叉树：\n    ![满二叉树](mecs.png)\n    ![完全二叉树](wqecs.png)\n\n  - 创建： 完全二叉树的创建需要按层去创建。这边我们借助队列的特点，将二叉树的节点连接起来，构造成完全二叉树\n    ```\n    public static TreeNode createWholeTree(int[] a) {\n            if (a.length > 0) {\n                LinkedList<TreeNode> queue = new LinkedList<>();\n                TreeNode root = new TreeNode(a[0]);\n                queue.add(root);\n                int index = 0;\n                for (int i = 1; i < a.length; i++) {\n                    TreeNode curn = queue.get(index);\n                    TreeNode ti = new TreeNode(a[i]);\n                    queue.add(ti);\n                    if (curn.left == null) {\n                        curn.left = ti;\n                    } else if (curn.right == null) {\n                        curn.right = ti;\n                        index++;\n                    }\n                }\n                return root;\n            }\n            return null;\n        }\n    ```\n\n  - 特点：对于一个h层的完全二叉树，前h-1层是满的，第h层连续缺失右边节点。所以叶子结点只能出现在最下层和次下层，最下层的叶子结点集中在树的左部，倒数第二层若存在叶子结点，一定在右部连续位置，如果结点度为1，则该结点只有左孩子，即没有右子树，同样结点数目的二叉树，完全二叉树深度最小。\n\n#### 二叉树的遍历\n\n  - 前中后序递归遍历：\n    ```\n    /**\n     * 递归先序遍历二叉树 左-根-右\n     */\n    public static void frontPrintOutTree(TreeNode root) {\n        if (null != root) {\n            System.out.print(root.val);\n            frontPrintOutTree(root.left);\n            frontPrintOutTree(root.right);\n        }\n    }\n\n    /**\n     * 递归中序遍历二叉树 左-根-右\n     */\n    public static void midPrintOutTree(TreeNode root) {\n        if (null != root) {\n            midPrintOutTree(root.left);\n            System.out.print(root.val);\n            midPrintOutTree(root.right);\n        }\n    }\n\n    /**\n     * 递归先序遍历二叉树 左-根-右\n     */\n    public static void lastPrintOutTree(TreeNode root) {\n        if (null != root) {\n            lastPrintOutTree(root.left);\n            lastPrintOutTree(root.right);\n            System.out.print(root.val);\n        }\n    }\n    ```\n\n  - 按层遍历：\n    ```\n    /**\n     * 按层遍历二叉树\n     */\n    public static void levelPrintOutTree(TreeNode root) {\n        if (null != root) {\n            LinkedList<TreeNode> queue = new LinkedList<>();\n            queue.add(root);\n            TreeNode i = root;\n            while (!queue.isEmpty()) {\n                if (i.left != null) {\n                    queue.add(i.left);\n                }\n                if (i.right != null) {\n                    queue.add(i.right);\n                }\n                System.out.print(i.val);\n                queue.poll();\n                i = queue.peek();\n            }\n        }\n    }\n    ```\n#### 以上代码的github地址：[GITHUB地址](https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/src/main/java/DataStructure/Tree)\n","source":"_posts/二叉搜索树与完全二叉树.md","raw":"---\ntitle: 二叉搜索树与完全二叉树\ndate: 2019-05-04 10:29:36\ncategories: [数据结构与算法,二叉树]\ntags: [数据结构与算法,二叉树]\n---\n\n#### 什么是二叉树？\n\n在数据结构中，对于树，每一个分支，称之为一个度。那么，度最大为2的树我们称之为二叉树。通常子树我们会称之为左子树和右子树。二叉树通常用于实现二叉查找树和二叉堆。那么在Java中如何定义一个二叉树节点？\n\n首先，每一个节点需要有一个值域。其次，其还应该持有两个树节点的引用，即指向自己的左子树和自己的右子树。\n\n<!--more-->\n\n具体代码如下：\n```\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode() {\n        this.val = 0;\n        this.left = null;\n        this.right = null;\n    }\n\n    TreeNode(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + val + \")[left:\" + left + \",right:\" + right + \"]\";\n    }\n}\n```\n\n\n#### 如何创建二叉树\n\n二叉树的节点的数据结构已经用Java代码表示出来了，那么如何用这些节点来构造出一个完整的二叉树呢？请看下图二叉树的结构：\n\n![二叉树结构](ecs.png)\n\n如上图，对于一个二叉树，需要有一个根节点。每个节点最多有两课子树，分别区分左子树还是右子树。即就算有一个子树，还是需要区分是左子树还是右子树。创建二叉树我们只需要将每一个树节点按照这样的规则连接起来即可。\n\n##### 创建二叉搜索树\n\n- 概念：二叉搜索树，又叫二叉查找树。他是一棵特殊的二叉树，对于二叉搜索树中的每一个节点，它的左子树都不大于父节点，右子树都不小于父节点。空树是特殊的二叉搜索树。\n- 创建：本例根据一个已有的数组进行二叉树的创建，基本的思路就是遍历数组，每个元素创建一个树节点，然后继续根据节点值得大小向下遍历判断，最后将值域小的放在节点的左子树，将值大的放在节点的右子树即可。\n  ```\n  public static TreeNode createSearchTree(int[] a) {\n      if (a.length > 0) {\n          TreeNode root = new TreeNode(a[0]);\n          for (int i = 1; i < a.length; i++) {\n              TreeNode c = root;\n              TreeNode p = c;\n              TreeNode q = new TreeNode(a[i]);\n              while (c != null) {\n                  p = c;\n                  if (a[i] <= c.val) {\n                      c = c.left;\n                  } else {\n                      c = c.right;\n                  }\n              }\n              if (q.val < p.val) {\n                  p.left = q;\n              } else {\n                  p.right = q;\n              }\n          }\n          return root;\n      }\n      return null;\n  }\n  ```\n\n- 特点：二叉搜索树在应用于经常查找元素的场景效率会比较快，因为它的数据结构类似于二分查找，查找元素时根据其特性向下搜索即可。\n\n##### 创建完全二叉树\n\n  - 概念：首先介绍一下满二叉树：即树中的所有节点除了叶节点都有左子树和右子树，叶节点的左右子树都为空，这样的树称之为满二叉树。而对于一棵完全二叉树，只有树的最后一层连续缺失右边节点。满二叉树一定是完全二叉树，反之则不一定成立。如图分别是一棵满二叉树和一棵完全二叉树：\n    ![满二叉树](mecs.png)\n    ![完全二叉树](wqecs.png)\n\n  - 创建： 完全二叉树的创建需要按层去创建。这边我们借助队列的特点，将二叉树的节点连接起来，构造成完全二叉树\n    ```\n    public static TreeNode createWholeTree(int[] a) {\n            if (a.length > 0) {\n                LinkedList<TreeNode> queue = new LinkedList<>();\n                TreeNode root = new TreeNode(a[0]);\n                queue.add(root);\n                int index = 0;\n                for (int i = 1; i < a.length; i++) {\n                    TreeNode curn = queue.get(index);\n                    TreeNode ti = new TreeNode(a[i]);\n                    queue.add(ti);\n                    if (curn.left == null) {\n                        curn.left = ti;\n                    } else if (curn.right == null) {\n                        curn.right = ti;\n                        index++;\n                    }\n                }\n                return root;\n            }\n            return null;\n        }\n    ```\n\n  - 特点：对于一个h层的完全二叉树，前h-1层是满的，第h层连续缺失右边节点。所以叶子结点只能出现在最下层和次下层，最下层的叶子结点集中在树的左部，倒数第二层若存在叶子结点，一定在右部连续位置，如果结点度为1，则该结点只有左孩子，即没有右子树，同样结点数目的二叉树，完全二叉树深度最小。\n\n#### 二叉树的遍历\n\n  - 前中后序递归遍历：\n    ```\n    /**\n     * 递归先序遍历二叉树 左-根-右\n     */\n    public static void frontPrintOutTree(TreeNode root) {\n        if (null != root) {\n            System.out.print(root.val);\n            frontPrintOutTree(root.left);\n            frontPrintOutTree(root.right);\n        }\n    }\n\n    /**\n     * 递归中序遍历二叉树 左-根-右\n     */\n    public static void midPrintOutTree(TreeNode root) {\n        if (null != root) {\n            midPrintOutTree(root.left);\n            System.out.print(root.val);\n            midPrintOutTree(root.right);\n        }\n    }\n\n    /**\n     * 递归先序遍历二叉树 左-根-右\n     */\n    public static void lastPrintOutTree(TreeNode root) {\n        if (null != root) {\n            lastPrintOutTree(root.left);\n            lastPrintOutTree(root.right);\n            System.out.print(root.val);\n        }\n    }\n    ```\n\n  - 按层遍历：\n    ```\n    /**\n     * 按层遍历二叉树\n     */\n    public static void levelPrintOutTree(TreeNode root) {\n        if (null != root) {\n            LinkedList<TreeNode> queue = new LinkedList<>();\n            queue.add(root);\n            TreeNode i = root;\n            while (!queue.isEmpty()) {\n                if (i.left != null) {\n                    queue.add(i.left);\n                }\n                if (i.right != null) {\n                    queue.add(i.right);\n                }\n                System.out.print(i.val);\n                queue.poll();\n                i = queue.peek();\n            }\n        }\n    }\n    ```\n#### 以上代码的github地址：[GITHUB地址](https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/src/main/java/DataStructure/Tree)\n","slug":"二叉搜索树与完全二叉树","published":1,"updated":"2019-06-13T09:44:48.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvva000rcwnky3aoxc2o","content":"<h4 id=\"什么是二叉树？\"><a href=\"#什么是二叉树？\" class=\"headerlink\" title=\"什么是二叉树？\"></a>什么是二叉树？</h4><p>在数据结构中，对于树，每一个分支，称之为一个度。那么，度最大为2的树我们称之为二叉树。通常子树我们会称之为左子树和右子树。二叉树通常用于实现二叉查找树和二叉堆。那么在Java中如何定义一个二叉树节点？</p>\n<p>首先，每一个节点需要有一个值域。其次，其还应该持有两个树节点的引用，即指向自己的左子树和自己的右子树。</p>\n<a id=\"more\"></a>\n<p>具体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TreeNode &#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    TreeNode left;</span><br><span class=\"line\">    TreeNode right;</span><br><span class=\"line\"></span><br><span class=\"line\">    TreeNode() &#123;</span><br><span class=\"line\">        this.val = 0;</span><br><span class=\"line\">        this.left = null;</span><br><span class=\"line\">        this.right = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    TreeNode(int val) &#123;</span><br><span class=\"line\">        this.val = val;</span><br><span class=\"line\">        this.left = null;</span><br><span class=\"line\">        this.right = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;(&quot; + val + &quot;)[left:&quot; + left + &quot;,right:&quot; + right + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"如何创建二叉树\"><a href=\"#如何创建二叉树\" class=\"headerlink\" title=\"如何创建二叉树\"></a>如何创建二叉树</h4><p>二叉树的节点的数据结构已经用Java代码表示出来了，那么如何用这些节点来构造出一个完整的二叉树呢？请看下图二叉树的结构：</p>\n<p><img src=\"/blog/20190504/二叉搜索树与完全二叉树/ecs.png\" alt=\"二叉树结构\"></p>\n<p>如上图，对于一个二叉树，需要有一个根节点。每个节点最多有两课子树，分别区分左子树还是右子树。即就算有一个子树，还是需要区分是左子树还是右子树。创建二叉树我们只需要将每一个树节点按照这样的规则连接起来即可。</p>\n<h5 id=\"创建二叉搜索树\"><a href=\"#创建二叉搜索树\" class=\"headerlink\" title=\"创建二叉搜索树\"></a>创建二叉搜索树</h5><ul>\n<li>概念：二叉搜索树，又叫二叉查找树。他是一棵特殊的二叉树，对于二叉搜索树中的每一个节点，它的左子树都不大于父节点，右子树都不小于父节点。空树是特殊的二叉搜索树。</li>\n<li><p>创建：本例根据一个已有的数组进行二叉树的创建，基本的思路就是遍历数组，每个元素创建一个树节点，然后继续根据节点值得大小向下遍历判断，最后将值域小的放在节点的左子树，将值大的放在节点的右子树即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static TreeNode createSearchTree(int[] a) &#123;</span><br><span class=\"line\">    if (a.length &gt; 0) &#123;</span><br><span class=\"line\">        TreeNode root = new TreeNode(a[0]);</span><br><span class=\"line\">        for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">            TreeNode c = root;</span><br><span class=\"line\">            TreeNode p = c;</span><br><span class=\"line\">            TreeNode q = new TreeNode(a[i]);</span><br><span class=\"line\">            while (c != null) &#123;</span><br><span class=\"line\">                p = c;</span><br><span class=\"line\">                if (a[i] &lt;= c.val) &#123;</span><br><span class=\"line\">                    c = c.left;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    c = c.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (q.val &lt; p.val) &#123;</span><br><span class=\"line\">                p.left = q;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                p.right = q;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特点：二叉搜索树在应用于经常查找元素的场景效率会比较快，因为它的数据结构类似于二分查找，查找元素时根据其特性向下搜索即可。</p>\n</li>\n</ul>\n<h5 id=\"创建完全二叉树\"><a href=\"#创建完全二叉树\" class=\"headerlink\" title=\"创建完全二叉树\"></a>创建完全二叉树</h5><ul>\n<li><p>概念：首先介绍一下满二叉树：即树中的所有节点除了叶节点都有左子树和右子树，叶节点的左右子树都为空，这样的树称之为满二叉树。而对于一棵完全二叉树，只有树的最后一层连续缺失右边节点。满二叉树一定是完全二叉树，反之则不一定成立。如图分别是一棵满二叉树和一棵完全二叉树：<br><img src=\"/blog/20190504/二叉搜索树与完全二叉树/mecs.png\" alt=\"满二叉树\"><br><img src=\"/blog/20190504/二叉搜索树与完全二叉树/wqecs.png\" alt=\"完全二叉树\"></p>\n</li>\n<li><p>创建： 完全二叉树的创建需要按层去创建。这边我们借助队列的特点，将二叉树的节点连接起来，构造成完全二叉树</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static TreeNode createWholeTree(int[] a) &#123;</span><br><span class=\"line\">        if (a.length &gt; 0) &#123;</span><br><span class=\"line\">            LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">            TreeNode root = new TreeNode(a[0]);</span><br><span class=\"line\">            queue.add(root);</span><br><span class=\"line\">            int index = 0;</span><br><span class=\"line\">            for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">                TreeNode curn = queue.get(index);</span><br><span class=\"line\">                TreeNode ti = new TreeNode(a[i]);</span><br><span class=\"line\">                queue.add(ti);</span><br><span class=\"line\">                if (curn.left == null) &#123;</span><br><span class=\"line\">                    curn.left = ti;</span><br><span class=\"line\">                &#125; else if (curn.right == null) &#123;</span><br><span class=\"line\">                    curn.right = ti;</span><br><span class=\"line\">                    index++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特点：对于一个h层的完全二叉树，前h-1层是满的，第h层连续缺失右边节点。所以叶子结点只能出现在最下层和次下层，最下层的叶子结点集中在树的左部，倒数第二层若存在叶子结点，一定在右部连续位置，如果结点度为1，则该结点只有左孩子，即没有右子树，同样结点数目的二叉树，完全二叉树深度最小。</p>\n</li>\n</ul>\n<h4 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h4><ul>\n<li><p>前中后序递归遍历：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 递归先序遍历二叉树 左-根-右</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void frontPrintOutTree(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        System.out.print(root.val);</span><br><span class=\"line\">        frontPrintOutTree(root.left);</span><br><span class=\"line\">        frontPrintOutTree(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 递归中序遍历二叉树 左-根-右</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void midPrintOutTree(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        midPrintOutTree(root.left);</span><br><span class=\"line\">        System.out.print(root.val);</span><br><span class=\"line\">        midPrintOutTree(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 递归先序遍历二叉树 左-根-右</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void lastPrintOutTree(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        lastPrintOutTree(root.left);</span><br><span class=\"line\">        lastPrintOutTree(root.right);</span><br><span class=\"line\">        System.out.print(root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>按层遍历：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 按层遍历二叉树</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void levelPrintOutTree(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        TreeNode i = root;</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            if (i.left != null) &#123;</span><br><span class=\"line\">                queue.add(i.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i.right != null) &#123;</span><br><span class=\"line\">                queue.add(i.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(i.val);</span><br><span class=\"line\">            queue.poll();</span><br><span class=\"line\">            i = queue.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"以上代码的github地址：GITHUB地址\"><a href=\"#以上代码的github地址：GITHUB地址\" class=\"headerlink\" title=\"以上代码的github地址：GITHUB地址\"></a>以上代码的github地址：<a href=\"https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/src/main/java/DataStructure/Tree\" target=\"_blank\" rel=\"noopener\">GITHUB地址</a></h4>","site":{"data":{}},"excerpt":"<h4 id=\"什么是二叉树？\"><a href=\"#什么是二叉树？\" class=\"headerlink\" title=\"什么是二叉树？\"></a>什么是二叉树？</h4><p>在数据结构中，对于树，每一个分支，称之为一个度。那么，度最大为2的树我们称之为二叉树。通常子树我们会称之为左子树和右子树。二叉树通常用于实现二叉查找树和二叉堆。那么在Java中如何定义一个二叉树节点？</p>\n<p>首先，每一个节点需要有一个值域。其次，其还应该持有两个树节点的引用，即指向自己的左子树和自己的右子树。</p>","more":"<p>具体代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TreeNode &#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    TreeNode left;</span><br><span class=\"line\">    TreeNode right;</span><br><span class=\"line\"></span><br><span class=\"line\">    TreeNode() &#123;</span><br><span class=\"line\">        this.val = 0;</span><br><span class=\"line\">        this.left = null;</span><br><span class=\"line\">        this.right = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    TreeNode(int val) &#123;</span><br><span class=\"line\">        this.val = val;</span><br><span class=\"line\">        this.left = null;</span><br><span class=\"line\">        this.right = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;(&quot; + val + &quot;)[left:&quot; + left + &quot;,right:&quot; + right + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"如何创建二叉树\"><a href=\"#如何创建二叉树\" class=\"headerlink\" title=\"如何创建二叉树\"></a>如何创建二叉树</h4><p>二叉树的节点的数据结构已经用Java代码表示出来了，那么如何用这些节点来构造出一个完整的二叉树呢？请看下图二叉树的结构：</p>\n<p><img src=\"/blog/20190504/二叉搜索树与完全二叉树/ecs.png\" alt=\"二叉树结构\"></p>\n<p>如上图，对于一个二叉树，需要有一个根节点。每个节点最多有两课子树，分别区分左子树还是右子树。即就算有一个子树，还是需要区分是左子树还是右子树。创建二叉树我们只需要将每一个树节点按照这样的规则连接起来即可。</p>\n<h5 id=\"创建二叉搜索树\"><a href=\"#创建二叉搜索树\" class=\"headerlink\" title=\"创建二叉搜索树\"></a>创建二叉搜索树</h5><ul>\n<li>概念：二叉搜索树，又叫二叉查找树。他是一棵特殊的二叉树，对于二叉搜索树中的每一个节点，它的左子树都不大于父节点，右子树都不小于父节点。空树是特殊的二叉搜索树。</li>\n<li><p>创建：本例根据一个已有的数组进行二叉树的创建，基本的思路就是遍历数组，每个元素创建一个树节点，然后继续根据节点值得大小向下遍历判断，最后将值域小的放在节点的左子树，将值大的放在节点的右子树即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static TreeNode createSearchTree(int[] a) &#123;</span><br><span class=\"line\">    if (a.length &gt; 0) &#123;</span><br><span class=\"line\">        TreeNode root = new TreeNode(a[0]);</span><br><span class=\"line\">        for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">            TreeNode c = root;</span><br><span class=\"line\">            TreeNode p = c;</span><br><span class=\"line\">            TreeNode q = new TreeNode(a[i]);</span><br><span class=\"line\">            while (c != null) &#123;</span><br><span class=\"line\">                p = c;</span><br><span class=\"line\">                if (a[i] &lt;= c.val) &#123;</span><br><span class=\"line\">                    c = c.left;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    c = c.right;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (q.val &lt; p.val) &#123;</span><br><span class=\"line\">                p.left = q;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                p.right = q;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特点：二叉搜索树在应用于经常查找元素的场景效率会比较快，因为它的数据结构类似于二分查找，查找元素时根据其特性向下搜索即可。</p>\n</li>\n</ul>\n<h5 id=\"创建完全二叉树\"><a href=\"#创建完全二叉树\" class=\"headerlink\" title=\"创建完全二叉树\"></a>创建完全二叉树</h5><ul>\n<li><p>概念：首先介绍一下满二叉树：即树中的所有节点除了叶节点都有左子树和右子树，叶节点的左右子树都为空，这样的树称之为满二叉树。而对于一棵完全二叉树，只有树的最后一层连续缺失右边节点。满二叉树一定是完全二叉树，反之则不一定成立。如图分别是一棵满二叉树和一棵完全二叉树：<br><img src=\"/blog/20190504/二叉搜索树与完全二叉树/mecs.png\" alt=\"满二叉树\"><br><img src=\"/blog/20190504/二叉搜索树与完全二叉树/wqecs.png\" alt=\"完全二叉树\"></p>\n</li>\n<li><p>创建： 完全二叉树的创建需要按层去创建。这边我们借助队列的特点，将二叉树的节点连接起来，构造成完全二叉树</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static TreeNode createWholeTree(int[] a) &#123;</span><br><span class=\"line\">        if (a.length &gt; 0) &#123;</span><br><span class=\"line\">            LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">            TreeNode root = new TreeNode(a[0]);</span><br><span class=\"line\">            queue.add(root);</span><br><span class=\"line\">            int index = 0;</span><br><span class=\"line\">            for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">                TreeNode curn = queue.get(index);</span><br><span class=\"line\">                TreeNode ti = new TreeNode(a[i]);</span><br><span class=\"line\">                queue.add(ti);</span><br><span class=\"line\">                if (curn.left == null) &#123;</span><br><span class=\"line\">                    curn.left = ti;</span><br><span class=\"line\">                &#125; else if (curn.right == null) &#123;</span><br><span class=\"line\">                    curn.right = ti;</span><br><span class=\"line\">                    index++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特点：对于一个h层的完全二叉树，前h-1层是满的，第h层连续缺失右边节点。所以叶子结点只能出现在最下层和次下层，最下层的叶子结点集中在树的左部，倒数第二层若存在叶子结点，一定在右部连续位置，如果结点度为1，则该结点只有左孩子，即没有右子树，同样结点数目的二叉树，完全二叉树深度最小。</p>\n</li>\n</ul>\n<h4 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h4><ul>\n<li><p>前中后序递归遍历：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 递归先序遍历二叉树 左-根-右</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void frontPrintOutTree(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        System.out.print(root.val);</span><br><span class=\"line\">        frontPrintOutTree(root.left);</span><br><span class=\"line\">        frontPrintOutTree(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 递归中序遍历二叉树 左-根-右</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void midPrintOutTree(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        midPrintOutTree(root.left);</span><br><span class=\"line\">        System.out.print(root.val);</span><br><span class=\"line\">        midPrintOutTree(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 递归先序遍历二叉树 左-根-右</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void lastPrintOutTree(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        lastPrintOutTree(root.left);</span><br><span class=\"line\">        lastPrintOutTree(root.right);</span><br><span class=\"line\">        System.out.print(root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>按层遍历：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 按层遍历二叉树</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static void levelPrintOutTree(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        TreeNode i = root;</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            if (i.left != null) &#123;</span><br><span class=\"line\">                queue.add(i.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i.right != null) &#123;</span><br><span class=\"line\">                queue.add(i.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(i.val);</span><br><span class=\"line\">            queue.poll();</span><br><span class=\"line\">            i = queue.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"以上代码的github地址：GITHUB地址\"><a href=\"#以上代码的github地址：GITHUB地址\" class=\"headerlink\" title=\"以上代码的github地址：GITHUB地址\"></a>以上代码的github地址：<a href=\"https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/src/main/java/DataStructure/Tree\" target=\"_blank\" rel=\"noopener\">GITHUB地址</a></h4>"},{"title":"二叉树的几种非递归遍历","date":"2019-06-13T09:36:48.000Z","_content":"![封面](fm.jpg)\n\n<!--more-->\n\n## 二叉树的几种非递归遍历解法\n二叉树的递归遍历想必了解递归以及二叉树的同学都能够轻松写出正确答案，然而二叉树的非递归遍历确是很多人难以理解学会的，所以我在这里进行一下归纳总结，主要是复习巩固一下这方面的知识。\n\n### 非递归先序遍历\n#### 思路\n- 首先将根节点入栈\n- 然后循环判断栈不为空\n- 则弹出栈顶元素\n- 如果弹出元素的右子树不为空则入栈\n- 如果弹出元素的左子树不为空则入栈\n- 继续循环\n\n解析：由于先序遍历为[根-左-右]，所以根节点应该先入栈，然后出栈的同时依次入栈右-左子树即可。\n\n#### 代码\n```\npublic static void frontPrintByLoop(TreeNode root) {\n    if (root != null) {\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            System.out.print(node.val + \" | \");\n            if (node.right != null) {\n                stack.push(node.right);\n            }\n            if (node.left != null) {\n                stack.push(node.left);\n            }\n        }\n    }\n}\n```\n\n### 非递归中序遍历\n#### 思路\n- 首先将根节点入栈\n- 循环判断根节点是否有左子树，有则入栈继续循环，否则循环结束\n- 然后循环判断栈不为空\n- 则弹出栈顶元素\n- 如果栈顶元素右子树不为空\n- 则循环入栈右子树及其右子树的左子树\n- 继续循环\n\n解析：因为中序遍历为[左-根-又]，所以树的左子树应该先入栈，循环入栈左子树之后循环出栈，出栈的同时判断出栈元素是否有右子树，如果右子树不为空则对右子树执行相同的操作，即入栈右子树的左子树。\n#### 代码\n```\npublic static void midPrintByLoop(TreeNode root) {\n    if (root != null) {\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode node = root;\n        stack.push(node);\n        while (node.left != null) {\n            stack.push(node.left);\n            node = node.left;\n        }\n        while (!stack.isEmpty()) {\n            node = stack.pop();\n            TreeNode n = node.right;\n            while (n != null) {\n                stack.push(n);\n                n = n.left;\n            }\n            System.out.print(node.val + \" | \");\n        }\n\n    }\n}\n```\n\n### 非递归后序遍历\n#### 思路 1\n- 逆向思考先序遍历，因为后序遍历为[根-左-右]，我们可以以类似先序遍历的方式先将[右-左-根]的顺序找出来存入另一个栈，然后再依次出栈该栈元素即可\n\n#### 代码 1\n```\npublic static void lastPrintByOtherStack(TreeNode root) {\n    if (root != null) {\n        final Stack<TreeNode> stack = new Stack<>();\n        final Stack<TreeNode> stackReverse = new Stack<>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            if (node != null) {\n                stackReverse.push(node);\n                if (node.left != null) {\n                    stack.push(node.left);\n                }\n                if (node.right != null) {\n                    stack.push(node.right);\n                }\n            }\n        }\n        while (!stackReverse.isEmpty()) {\n            TreeNode node = stackReverse.pop();\n            System.out.print(node.val + \" | \");\n        }\n    }\n}\n```\n\n#### 思路 2\n- 只使用一个栈\n- 先将根节点入栈\n- 设置一个标识引用 h首先指向root\n- 循环判断栈非空\n- 在循环中判断栈顶元素node\n- 如果node左子树不为空并且左右子树都不为h指向的元素\n- 入栈左子树\n- 否则再判断右子树是否为空以及右子树是否为h节点\n- 入栈右子树\n- 否则，弹出栈顶元素，并且将h指向该弹出的栈顶元素\n\n#### 代码 2\n```\npublic static void lastPrintByOneStack(TreeNode root) {\n    if (null != root) {\n        TreeNode h = root;\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(h);\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.peek();\n            if (node.left != null && node.left != h && node.right != h) {\n                stack.push(node.left);\n            } else if (null != node.right && node.right != h) {\n                stack.push(node.right);\n            } else {\n                node = stack.pop();\n                System.out.print(node.val + \" | \");\n                h = node;\n            }\n        }\n    }\n}\n```\n解析：使用一个栈进行后序遍历的时候需要使用一个h引用来标识上一个节点是否被遍历过，是的话就往上判断之后的树节点即可。\n\n### 按层遍历二叉树\n#### 思路\n以上前中后序遍历二叉树都是用到了栈这种数据结构，而按层遍历二叉树就非常简单了，只需要引入先入先出的队列，然后依次在出队的时候将出队元素的左右子树入队即可。\n\n- 根节点入队\n- 队列不为空则开始循环\n- 如果队首元素左子树不为空，就入队\n- 右子树不为空，也入队\n- 队首元素出队输出\n\n#### 代码\n```\npublic static void levelPrintOutTree(TreeNode root) {\n    if (null != root) {\n        LinkedList<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        TreeNode i = root;\n        while (!queue.isEmpty()) {\n            if (i.left != null) {\n                queue.add(i.left);\n            }\n            if (i.right != null) {\n                queue.add(i.right);\n            }\n            System.out.print(i.val + \" | \");\n            queue.poll();\n            i = queue.peek();\n        }\n    }\n}\n```\n","source":"_posts/二叉树的几种非递归遍历.md","raw":"---\ntitle: 二叉树的几种非递归遍历\ndate: 2019-06-13 17:36:48\ncategories: [数据结构与算法,二叉树]\ntags: [数据结构与算法,二叉树]\n---\n![封面](fm.jpg)\n\n<!--more-->\n\n## 二叉树的几种非递归遍历解法\n二叉树的递归遍历想必了解递归以及二叉树的同学都能够轻松写出正确答案，然而二叉树的非递归遍历确是很多人难以理解学会的，所以我在这里进行一下归纳总结，主要是复习巩固一下这方面的知识。\n\n### 非递归先序遍历\n#### 思路\n- 首先将根节点入栈\n- 然后循环判断栈不为空\n- 则弹出栈顶元素\n- 如果弹出元素的右子树不为空则入栈\n- 如果弹出元素的左子树不为空则入栈\n- 继续循环\n\n解析：由于先序遍历为[根-左-右]，所以根节点应该先入栈，然后出栈的同时依次入栈右-左子树即可。\n\n#### 代码\n```\npublic static void frontPrintByLoop(TreeNode root) {\n    if (root != null) {\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            System.out.print(node.val + \" | \");\n            if (node.right != null) {\n                stack.push(node.right);\n            }\n            if (node.left != null) {\n                stack.push(node.left);\n            }\n        }\n    }\n}\n```\n\n### 非递归中序遍历\n#### 思路\n- 首先将根节点入栈\n- 循环判断根节点是否有左子树，有则入栈继续循环，否则循环结束\n- 然后循环判断栈不为空\n- 则弹出栈顶元素\n- 如果栈顶元素右子树不为空\n- 则循环入栈右子树及其右子树的左子树\n- 继续循环\n\n解析：因为中序遍历为[左-根-又]，所以树的左子树应该先入栈，循环入栈左子树之后循环出栈，出栈的同时判断出栈元素是否有右子树，如果右子树不为空则对右子树执行相同的操作，即入栈右子树的左子树。\n#### 代码\n```\npublic static void midPrintByLoop(TreeNode root) {\n    if (root != null) {\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode node = root;\n        stack.push(node);\n        while (node.left != null) {\n            stack.push(node.left);\n            node = node.left;\n        }\n        while (!stack.isEmpty()) {\n            node = stack.pop();\n            TreeNode n = node.right;\n            while (n != null) {\n                stack.push(n);\n                n = n.left;\n            }\n            System.out.print(node.val + \" | \");\n        }\n\n    }\n}\n```\n\n### 非递归后序遍历\n#### 思路 1\n- 逆向思考先序遍历，因为后序遍历为[根-左-右]，我们可以以类似先序遍历的方式先将[右-左-根]的顺序找出来存入另一个栈，然后再依次出栈该栈元素即可\n\n#### 代码 1\n```\npublic static void lastPrintByOtherStack(TreeNode root) {\n    if (root != null) {\n        final Stack<TreeNode> stack = new Stack<>();\n        final Stack<TreeNode> stackReverse = new Stack<>();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            if (node != null) {\n                stackReverse.push(node);\n                if (node.left != null) {\n                    stack.push(node.left);\n                }\n                if (node.right != null) {\n                    stack.push(node.right);\n                }\n            }\n        }\n        while (!stackReverse.isEmpty()) {\n            TreeNode node = stackReverse.pop();\n            System.out.print(node.val + \" | \");\n        }\n    }\n}\n```\n\n#### 思路 2\n- 只使用一个栈\n- 先将根节点入栈\n- 设置一个标识引用 h首先指向root\n- 循环判断栈非空\n- 在循环中判断栈顶元素node\n- 如果node左子树不为空并且左右子树都不为h指向的元素\n- 入栈左子树\n- 否则再判断右子树是否为空以及右子树是否为h节点\n- 入栈右子树\n- 否则，弹出栈顶元素，并且将h指向该弹出的栈顶元素\n\n#### 代码 2\n```\npublic static void lastPrintByOneStack(TreeNode root) {\n    if (null != root) {\n        TreeNode h = root;\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(h);\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.peek();\n            if (node.left != null && node.left != h && node.right != h) {\n                stack.push(node.left);\n            } else if (null != node.right && node.right != h) {\n                stack.push(node.right);\n            } else {\n                node = stack.pop();\n                System.out.print(node.val + \" | \");\n                h = node;\n            }\n        }\n    }\n}\n```\n解析：使用一个栈进行后序遍历的时候需要使用一个h引用来标识上一个节点是否被遍历过，是的话就往上判断之后的树节点即可。\n\n### 按层遍历二叉树\n#### 思路\n以上前中后序遍历二叉树都是用到了栈这种数据结构，而按层遍历二叉树就非常简单了，只需要引入先入先出的队列，然后依次在出队的时候将出队元素的左右子树入队即可。\n\n- 根节点入队\n- 队列不为空则开始循环\n- 如果队首元素左子树不为空，就入队\n- 右子树不为空，也入队\n- 队首元素出队输出\n\n#### 代码\n```\npublic static void levelPrintOutTree(TreeNode root) {\n    if (null != root) {\n        LinkedList<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        TreeNode i = root;\n        while (!queue.isEmpty()) {\n            if (i.left != null) {\n                queue.add(i.left);\n            }\n            if (i.right != null) {\n                queue.add(i.right);\n            }\n            System.out.print(i.val + \" | \");\n            queue.poll();\n            i = queue.peek();\n        }\n    }\n}\n```\n","slug":"二叉树的几种非递归遍历","published":1,"updated":"2019-06-13T11:21:08.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvb000vcwnkqmj4tx7m","content":"<p><img src=\"/blog/20190613/二叉树的几种非递归遍历/fm.jpg\" alt=\"封面\"></p>\n<a id=\"more\"></a>\n<h2 id=\"二叉树的几种非递归遍历解法\"><a href=\"#二叉树的几种非递归遍历解法\" class=\"headerlink\" title=\"二叉树的几种非递归遍历解法\"></a>二叉树的几种非递归遍历解法</h2><p>二叉树的递归遍历想必了解递归以及二叉树的同学都能够轻松写出正确答案，然而二叉树的非递归遍历确是很多人难以理解学会的，所以我在这里进行一下归纳总结，主要是复习巩固一下这方面的知识。</p>\n<h3 id=\"非递归先序遍历\"><a href=\"#非递归先序遍历\" class=\"headerlink\" title=\"非递归先序遍历\"></a>非递归先序遍历</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>首先将根节点入栈</li>\n<li>然后循环判断栈不为空</li>\n<li>则弹出栈顶元素</li>\n<li>如果弹出元素的右子树不为空则入栈</li>\n<li>如果弹出元素的左子树不为空则入栈</li>\n<li>继续循环</li>\n</ul>\n<p>解析：由于先序遍历为[根-左-右]，所以根节点应该先入栈，然后出栈的同时依次入栈右-左子树即可。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void frontPrintByLoop(TreeNode root) &#123;</span><br><span class=\"line\">    if (root != null) &#123;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = stack.pop();</span><br><span class=\"line\">            System.out.print(node.val + &quot; | &quot;);</span><br><span class=\"line\">            if (node.right != null) &#123;</span><br><span class=\"line\">                stack.push(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (node.left != null) &#123;</span><br><span class=\"line\">                stack.push(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"非递归中序遍历\"><a href=\"#非递归中序遍历\" class=\"headerlink\" title=\"非递归中序遍历\"></a>非递归中序遍历</h3><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>首先将根节点入栈</li>\n<li>循环判断根节点是否有左子树，有则入栈继续循环，否则循环结束</li>\n<li>然后循环判断栈不为空</li>\n<li>则弹出栈顶元素</li>\n<li>如果栈顶元素右子树不为空</li>\n<li>则循环入栈右子树及其右子树的左子树</li>\n<li>继续循环</li>\n</ul>\n<p>解析：因为中序遍历为[左-根-又]，所以树的左子树应该先入栈，循环入栈左子树之后循环出栈，出栈的同时判断出栈元素是否有右子树，如果右子树不为空则对右子树执行相同的操作，即入栈右子树的左子树。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void midPrintByLoop(TreeNode root) &#123;</span><br><span class=\"line\">    if (root != null) &#123;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        TreeNode node = root;</span><br><span class=\"line\">        stack.push(node);</span><br><span class=\"line\">        while (node.left != null) &#123;</span><br><span class=\"line\">            stack.push(node.left);</span><br><span class=\"line\">            node = node.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            node = stack.pop();</span><br><span class=\"line\">            TreeNode n = node.right;</span><br><span class=\"line\">            while (n != null) &#123;</span><br><span class=\"line\">                stack.push(n);</span><br><span class=\"line\">                n = n.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(node.val + &quot; | &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"非递归后序遍历\"><a href=\"#非递归后序遍历\" class=\"headerlink\" title=\"非递归后序遍历\"></a>非递归后序遍历</h3><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路 1\"></a>思路 1</h4><ul>\n<li>逆向思考先序遍历，因为后序遍历为[根-左-右]，我们可以以类似先序遍历的方式先将[右-左-根]的顺序找出来存入另一个栈，然后再依次出栈该栈元素即可</li>\n</ul>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码 1\"></a>代码 1</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void lastPrintByOtherStack(TreeNode root) &#123;</span><br><span class=\"line\">    if (root != null) &#123;</span><br><span class=\"line\">        final Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        final Stack&lt;TreeNode&gt; stackReverse = new Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = stack.pop();</span><br><span class=\"line\">            if (node != null) &#123;</span><br><span class=\"line\">                stackReverse.push(node);</span><br><span class=\"line\">                if (node.left != null) &#123;</span><br><span class=\"line\">                    stack.push(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (node.right != null) &#123;</span><br><span class=\"line\">                    stack.push(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (!stackReverse.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = stackReverse.pop();</span><br><span class=\"line\">            System.out.print(node.val + &quot; | &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路 2\"></a>思路 2</h4><ul>\n<li>只使用一个栈</li>\n<li>先将根节点入栈</li>\n<li>设置一个标识引用 h首先指向root</li>\n<li>循环判断栈非空</li>\n<li>在循环中判断栈顶元素node</li>\n<li>如果node左子树不为空并且左右子树都不为h指向的元素</li>\n<li>入栈左子树</li>\n<li>否则再判断右子树是否为空以及右子树是否为h节点</li>\n<li>入栈右子树</li>\n<li>否则，弹出栈顶元素，并且将h指向该弹出的栈顶元素</li>\n</ul>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码 2\"></a>代码 2</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void lastPrintByOneStack(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        TreeNode h = root;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(h);</span><br><span class=\"line\">        while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = stack.peek();</span><br><span class=\"line\">            if (node.left != null &amp;&amp; node.left != h &amp;&amp; node.right != h) &#123;</span><br><span class=\"line\">                stack.push(node.left);</span><br><span class=\"line\">            &#125; else if (null != node.right &amp;&amp; node.right != h) &#123;</span><br><span class=\"line\">                stack.push(node.right);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                node = stack.pop();</span><br><span class=\"line\">                System.out.print(node.val + &quot; | &quot;);</span><br><span class=\"line\">                h = node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解析：使用一个栈进行后序遍历的时候需要使用一个h引用来标识上一个节点是否被遍历过，是的话就往上判断之后的树节点即可。</p>\n<h3 id=\"按层遍历二叉树\"><a href=\"#按层遍历二叉树\" class=\"headerlink\" title=\"按层遍历二叉树\"></a>按层遍历二叉树</h3><h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>以上前中后序遍历二叉树都是用到了栈这种数据结构，而按层遍历二叉树就非常简单了，只需要引入先入先出的队列，然后依次在出队的时候将出队元素的左右子树入队即可。</p>\n<ul>\n<li>根节点入队</li>\n<li>队列不为空则开始循环</li>\n<li>如果队首元素左子树不为空，就入队</li>\n<li>右子树不为空，也入队</li>\n<li>队首元素出队输出</li>\n</ul>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void levelPrintOutTree(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        TreeNode i = root;</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            if (i.left != null) &#123;</span><br><span class=\"line\">                queue.add(i.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i.right != null) &#123;</span><br><span class=\"line\">                queue.add(i.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(i.val + &quot; | &quot;);</span><br><span class=\"line\">            queue.poll();</span><br><span class=\"line\">            i = queue.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><img src=\"/blog/20190613/二叉树的几种非递归遍历/fm.jpg\" alt=\"封面\"></p>","more":"<h2 id=\"二叉树的几种非递归遍历解法\"><a href=\"#二叉树的几种非递归遍历解法\" class=\"headerlink\" title=\"二叉树的几种非递归遍历解法\"></a>二叉树的几种非递归遍历解法</h2><p>二叉树的递归遍历想必了解递归以及二叉树的同学都能够轻松写出正确答案，然而二叉树的非递归遍历确是很多人难以理解学会的，所以我在这里进行一下归纳总结，主要是复习巩固一下这方面的知识。</p>\n<h3 id=\"非递归先序遍历\"><a href=\"#非递归先序遍历\" class=\"headerlink\" title=\"非递归先序遍历\"></a>非递归先序遍历</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>首先将根节点入栈</li>\n<li>然后循环判断栈不为空</li>\n<li>则弹出栈顶元素</li>\n<li>如果弹出元素的右子树不为空则入栈</li>\n<li>如果弹出元素的左子树不为空则入栈</li>\n<li>继续循环</li>\n</ul>\n<p>解析：由于先序遍历为[根-左-右]，所以根节点应该先入栈，然后出栈的同时依次入栈右-左子树即可。</p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void frontPrintByLoop(TreeNode root) &#123;</span><br><span class=\"line\">    if (root != null) &#123;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = stack.pop();</span><br><span class=\"line\">            System.out.print(node.val + &quot; | &quot;);</span><br><span class=\"line\">            if (node.right != null) &#123;</span><br><span class=\"line\">                stack.push(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (node.left != null) &#123;</span><br><span class=\"line\">                stack.push(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"非递归中序遍历\"><a href=\"#非递归中序遍历\" class=\"headerlink\" title=\"非递归中序遍历\"></a>非递归中序遍历</h3><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><ul>\n<li>首先将根节点入栈</li>\n<li>循环判断根节点是否有左子树，有则入栈继续循环，否则循环结束</li>\n<li>然后循环判断栈不为空</li>\n<li>则弹出栈顶元素</li>\n<li>如果栈顶元素右子树不为空</li>\n<li>则循环入栈右子树及其右子树的左子树</li>\n<li>继续循环</li>\n</ul>\n<p>解析：因为中序遍历为[左-根-又]，所以树的左子树应该先入栈，循环入栈左子树之后循环出栈，出栈的同时判断出栈元素是否有右子树，如果右子树不为空则对右子树执行相同的操作，即入栈右子树的左子树。</p>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void midPrintByLoop(TreeNode root) &#123;</span><br><span class=\"line\">    if (root != null) &#123;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        TreeNode node = root;</span><br><span class=\"line\">        stack.push(node);</span><br><span class=\"line\">        while (node.left != null) &#123;</span><br><span class=\"line\">            stack.push(node.left);</span><br><span class=\"line\">            node = node.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            node = stack.pop();</span><br><span class=\"line\">            TreeNode n = node.right;</span><br><span class=\"line\">            while (n != null) &#123;</span><br><span class=\"line\">                stack.push(n);</span><br><span class=\"line\">                n = n.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(node.val + &quot; | &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"非递归后序遍历\"><a href=\"#非递归后序遍历\" class=\"headerlink\" title=\"非递归后序遍历\"></a>非递归后序遍历</h3><h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路 1\"></a>思路 1</h4><ul>\n<li>逆向思考先序遍历，因为后序遍历为[根-左-右]，我们可以以类似先序遍历的方式先将[右-左-根]的顺序找出来存入另一个栈，然后再依次出栈该栈元素即可</li>\n</ul>\n<h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码 1\"></a>代码 1</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void lastPrintByOtherStack(TreeNode root) &#123;</span><br><span class=\"line\">    if (root != null) &#123;</span><br><span class=\"line\">        final Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        final Stack&lt;TreeNode&gt; stackReverse = new Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = stack.pop();</span><br><span class=\"line\">            if (node != null) &#123;</span><br><span class=\"line\">                stackReverse.push(node);</span><br><span class=\"line\">                if (node.left != null) &#123;</span><br><span class=\"line\">                    stack.push(node.left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (node.right != null) &#123;</span><br><span class=\"line\">                    stack.push(node.right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        while (!stackReverse.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = stackReverse.pop();</span><br><span class=\"line\">            System.out.print(node.val + &quot; | &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路 2\"></a>思路 2</h4><ul>\n<li>只使用一个栈</li>\n<li>先将根节点入栈</li>\n<li>设置一个标识引用 h首先指向root</li>\n<li>循环判断栈非空</li>\n<li>在循环中判断栈顶元素node</li>\n<li>如果node左子树不为空并且左右子树都不为h指向的元素</li>\n<li>入栈左子树</li>\n<li>否则再判断右子树是否为空以及右子树是否为h节点</li>\n<li>入栈右子树</li>\n<li>否则，弹出栈顶元素，并且将h指向该弹出的栈顶元素</li>\n</ul>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码 2\"></a>代码 2</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void lastPrintByOneStack(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        TreeNode h = root;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(h);</span><br><span class=\"line\">        while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode node = stack.peek();</span><br><span class=\"line\">            if (node.left != null &amp;&amp; node.left != h &amp;&amp; node.right != h) &#123;</span><br><span class=\"line\">                stack.push(node.left);</span><br><span class=\"line\">            &#125; else if (null != node.right &amp;&amp; node.right != h) &#123;</span><br><span class=\"line\">                stack.push(node.right);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                node = stack.pop();</span><br><span class=\"line\">                System.out.print(node.val + &quot; | &quot;);</span><br><span class=\"line\">                h = node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解析：使用一个栈进行后序遍历的时候需要使用一个h引用来标识上一个节点是否被遍历过，是的话就往上判断之后的树节点即可。</p>\n<h3 id=\"按层遍历二叉树\"><a href=\"#按层遍历二叉树\" class=\"headerlink\" title=\"按层遍历二叉树\"></a>按层遍历二叉树</h3><h4 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>以上前中后序遍历二叉树都是用到了栈这种数据结构，而按层遍历二叉树就非常简单了，只需要引入先入先出的队列，然后依次在出队的时候将出队元素的左右子树入队即可。</p>\n<ul>\n<li>根节点入队</li>\n<li>队列不为空则开始循环</li>\n<li>如果队首元素左子树不为空，就入队</li>\n<li>右子树不为空，也入队</li>\n<li>队首元素出队输出</li>\n</ul>\n<h4 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void levelPrintOutTree(TreeNode root) &#123;</span><br><span class=\"line\">    if (null != root) &#123;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        TreeNode i = root;</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            if (i.left != null) &#123;</span><br><span class=\"line\">                queue.add(i.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (i.right != null) &#123;</span><br><span class=\"line\">                queue.add(i.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(i.val + &quot; | &quot;);</span><br><span class=\"line\">            queue.poll();</span><br><span class=\"line\">            i = queue.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"你的内心比拳头更强大","date":"2019-05-09T15:37:36.000Z","password":"zhangjiaheng","abstract":"最近真的很不开心，将烦躁的感受记录下来吧~","message":"加密博客请输入密码访问","_content":"\n![封面](xx.png)\n\n<!--more-->\n\n&nbsp;&nbsp;&nbsp;&nbsp;最近真的很不开心。觉得今年从一开始所有事情都和自己对着干，看着别人每天的生活过的那么精彩，而自己却还是平庸的一个人，看不到这段迷雾的路的尽头。也许真的是本命年？不对，我怎么能将事情的因果都放在自身之外。所有事情的原因当然是自己不够努力不够好啊，技术不够厉害啊。是这样的吧，所以才会事事事与愿违？细数一下今年，新换的工作来年就遇到最大的危机，四月初就大量的裁员；从年初到现在股票亏了一万多，我喜欢投机靠运气的事情，所以好像真的不是一个能够从股票赚钱的人；还有我原本还以为是我最好的女生朋友也和我断了联系，也许按照她的想法，和一个消耗心力的人保持关系觉得很累吧，没错我就是那消耗心力的关系的人之一，既然别人都觉得你是个不值得去保持联系的人，我又何必再去给她添堵呢。有句话说人的消极情绪的来源总是对自己无能的愤怒，我觉得说的很对。我确实是这样，想要得到更好的，却发现自己无法通过努力或者需要耗费大量时间去获得。也许我是个急性子，不愿意去等待。\n\t\n&nbsp;&nbsp;&nbsp;&nbsp;其实可能是身边的朋友少了，自己做什么事情都是一个人去做。哈，不知道从何时开始自己变成了这么一个特别依赖朋友的人，当和朋友一起出去玩就会感觉心情特别好，难道是孤独恐惧症？但是在杭州的几个朋友都有了自己的女朋友，也开始自己的新的生活，很少和我再出去玩了，下班之后的时间也只剩自己。有朋友说我其实就是缺一个女朋友。有了女朋友周末也不会无聊，生活也不会失去动力。可是我怎么可以拥有爱情。我应该不配吧。没有存款，没车没房，家庭条件也不好。目前自己的心态、状态都没有调整到一个很合适的点，真的很难。其实我还想出国工作来着，可是自己的英语口语长时间不用已经还给老师了，要练好也得个一年半载的吧，唉其实练练吧，也好。\n\n&nbsp;&nbsp;&nbsp;&nbsp;有时候心情不好的时候也非常想念姥姥姥爷，想给他们打电话的时候看看时间却是十一二点。这个时间他们也都休息了。姥姥姥爷看着自己长大，而自己长大之后却没有留在他们身边，来到一千多公里外的城市工作，感觉他们一定很伤心。可是我还没有赚到钱，怎么让你们享福呢。在这里工作至少还有一丝可能完成自己的人生目标，回去了会不会就会变成一个彻底的平庸的人了呢？\n\n&nbsp;&nbsp;&nbsp;&nbsp;其实博客写到这里就已经明白自己目前是一个怎样的状态了 —— 我有在努力去学习能够使我改变的知识，努力去做能够让我改变的事情，可是经受不住时间在慢慢熬。没有一个稳定合适的计划和一个恰当的目标，却渴望一个突如其来的惊喜将自己拉出脚踩的泥潭。这几点才是我每天痛苦的原因吧。写完一通发牢骚的话，然后在心中制定一个计划吧。\n\n总之，还是将目前这段[人生低谷]的感受记录在博客里，也许再次打开博客看到这篇文章，就会发现当时的自己的那些烦恼，其实都不是事儿。希望如此吧。\n\n---\n\n最近在B站上看到了这个视频，真的很治愈。也许多看看这些视频心情就会好了呢。\n\n<iframe src=\"//player.bilibili.com/player.html?aid=50503953&cid=88415184&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 100%;height: 700px\"> </iframe>","source":"_posts/你的内心比拳头更强大.md","raw":"---\ntitle: 你的内心比拳头更强大\ndate: 2019-05-09 23:37:36\ncategories: [个人随笔]\ntags: [个人随笔]\npassword: zhangjiaheng\nabstract: 最近真的很不开心，将烦躁的感受记录下来吧~\nmessage: 加密博客请输入密码访问\n---\n\n![封面](xx.png)\n\n<!--more-->\n\n&nbsp;&nbsp;&nbsp;&nbsp;最近真的很不开心。觉得今年从一开始所有事情都和自己对着干，看着别人每天的生活过的那么精彩，而自己却还是平庸的一个人，看不到这段迷雾的路的尽头。也许真的是本命年？不对，我怎么能将事情的因果都放在自身之外。所有事情的原因当然是自己不够努力不够好啊，技术不够厉害啊。是这样的吧，所以才会事事事与愿违？细数一下今年，新换的工作来年就遇到最大的危机，四月初就大量的裁员；从年初到现在股票亏了一万多，我喜欢投机靠运气的事情，所以好像真的不是一个能够从股票赚钱的人；还有我原本还以为是我最好的女生朋友也和我断了联系，也许按照她的想法，和一个消耗心力的人保持关系觉得很累吧，没错我就是那消耗心力的关系的人之一，既然别人都觉得你是个不值得去保持联系的人，我又何必再去给她添堵呢。有句话说人的消极情绪的来源总是对自己无能的愤怒，我觉得说的很对。我确实是这样，想要得到更好的，却发现自己无法通过努力或者需要耗费大量时间去获得。也许我是个急性子，不愿意去等待。\n\t\n&nbsp;&nbsp;&nbsp;&nbsp;其实可能是身边的朋友少了，自己做什么事情都是一个人去做。哈，不知道从何时开始自己变成了这么一个特别依赖朋友的人，当和朋友一起出去玩就会感觉心情特别好，难道是孤独恐惧症？但是在杭州的几个朋友都有了自己的女朋友，也开始自己的新的生活，很少和我再出去玩了，下班之后的时间也只剩自己。有朋友说我其实就是缺一个女朋友。有了女朋友周末也不会无聊，生活也不会失去动力。可是我怎么可以拥有爱情。我应该不配吧。没有存款，没车没房，家庭条件也不好。目前自己的心态、状态都没有调整到一个很合适的点，真的很难。其实我还想出国工作来着，可是自己的英语口语长时间不用已经还给老师了，要练好也得个一年半载的吧，唉其实练练吧，也好。\n\n&nbsp;&nbsp;&nbsp;&nbsp;有时候心情不好的时候也非常想念姥姥姥爷，想给他们打电话的时候看看时间却是十一二点。这个时间他们也都休息了。姥姥姥爷看着自己长大，而自己长大之后却没有留在他们身边，来到一千多公里外的城市工作，感觉他们一定很伤心。可是我还没有赚到钱，怎么让你们享福呢。在这里工作至少还有一丝可能完成自己的人生目标，回去了会不会就会变成一个彻底的平庸的人了呢？\n\n&nbsp;&nbsp;&nbsp;&nbsp;其实博客写到这里就已经明白自己目前是一个怎样的状态了 —— 我有在努力去学习能够使我改变的知识，努力去做能够让我改变的事情，可是经受不住时间在慢慢熬。没有一个稳定合适的计划和一个恰当的目标，却渴望一个突如其来的惊喜将自己拉出脚踩的泥潭。这几点才是我每天痛苦的原因吧。写完一通发牢骚的话，然后在心中制定一个计划吧。\n\n总之，还是将目前这段[人生低谷]的感受记录在博客里，也许再次打开博客看到这篇文章，就会发现当时的自己的那些烦恼，其实都不是事儿。希望如此吧。\n\n---\n\n最近在B站上看到了这个视频，真的很治愈。也许多看看这些视频心情就会好了呢。\n\n<iframe src=\"//player.bilibili.com/player.html?aid=50503953&cid=88415184&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 100%;height: 700px\"> </iframe>","slug":"你的内心比拳头更强大","published":1,"updated":"2019-05-13T06:27:50.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvc000xcwnk2tt3m3cu","content":"<script src=\"/crypto-js.js\"></script><script src=\"/mcommon.js\"></script><h3 id=\"encrypt-message\">加密博客请输入密码访问</h3><link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css\"> <link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css\"> <script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script> <script src=\"//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js\"></script> <div id=\"security\"> <div> <div class=\"input-group\"> <input type=\"text\" class=\"form-control\" aria-label=\"Enter the password.\" id=\"pass\"/> <div class=\"input-group-btn\"> <button type=\"button\" class=\"btn btn-default\" onclick=\"decryptAES()\">Decrypt</button> </div> </div> </div> </div> <div id=\"encrypt-blog\" style=\"display:none\"> U2FsdGVkX1/HRPvZo2LD3pCtWezD8Knw7fhZrWZiGdAD1bpy+JArlgxzxZDETE8x4x3Me09DIkfYpnfqLk82642PPiGMasgLTsrRMhZeu8RbotNv7TNU5s6N/hQQuA2MrGFyrQzJj2E/jtC5oCw8yKoLhF57uZjicuUqtXPWI1zWz8m3IDRscIdhRxiUlwR12wdAqCUBhoUt3NIfix1YSwTq8ZLQOa6+IQzTxNDUsNMuvQBs/TLwuhT+fV351MLudpE/e/3imlL+dlLHDnzZY77hmU3v+9G8DJbIqWxikftMNkKxRc003nwhHjZZ4GvTiT35UXMXCoRWuEwCNAfQ1tx/PISfZc5Ye+A+v66Rm5hG4kSccLR4tmR5N31ytUmTTkvy0v9fMcRDt2QDQDjw7roZHIKwrLpj764OdMYsNfR+jzuM+T9Sn0QSo0UzU+WRV/2rkLPz5RAFBudYXEgngSMPCCr8kXnuU2kP1QgJsvkVLnc0ULt7QvG2uvdll+kJvyYjOjcc3TH/+CqYR3iToH6C0IynCYUkq072fJHMVfSerSo4IVqfUVAoyavcr66tt4Rqw7YX33Oa7RiF47F/RgSlPRjtuBorFto3Z9sMBtbsZCEged8oBklj2Qo3vOQ/VFEovi2YpGhrG0XA58DGZTKMX+2I/nfYYXPVgVsw9bDzyYhoJE3GBcapagvc6c3dwg1GbjhbSfP1bjVvleveohyi81AJkc7ZZgUDGDLP1GpeqtCLajX0sM4MMM2i0sr/H44l8JrKGsZ0m21/x0Sj0UN8SCvbVF7XBsZc1vmg/jgZOP2DzD69iTUQzt+uPWeinHS2L24SqeMg+VbHa/NwM7ZUUTn5UY9HqplQiN+4HfvxQF7enJ/5TKIIZTeMBNBrXhVTWuk2NG+KD8dsRXiZTyUf/7wKqt398La8Kp9drVO8kawS0nelsDkF5HjVrKq7hlI30Pz0IeUG66yNn8N4FgQe7Xl36wyMJmbnxtwAyTgcJ5F9gkRmlbRqUOA3Ym1fsPX49rzc1UJ867x2hvxjHDRfI3rz0MScH3YQnjln4ppeDN3iuYQkFsDu9D65uRAUAoBDyPG1m5swpSWmGjkfD1fmOEAds5HF7TtLCiw9sdTNZIF3/S45vc3fHpBa4cEOKluZRnNeajIXibpPU2YksvnsqowxVm4jd+3k8s8C2Vp6W8pXyHodoPb410BpiLAEbh7TV3pYpUDWPyhVzPNtf8JKxYR/LH05f83Q+JhQbcxJ/YDRUO9g58ZYcisuJJYPMuzLrXDGFj3IVk4TcMAxPrbkLGDDaW+J4wBStQtpeD3Np6tOZ8FvRvvPjLoCs2OGY1JgJ47gPcKPsPm/ow/geF1FaDms/OXVYN8xe4iIewphwiBIdhcoseTQ7Pa9Yzo+TnVNKtYkPLBsVcKIIEUwmdbxUl+3TFPX9k7DEJfxp5dfVSRiwWzybtSk9v4T+1zAtT7UaoM7fzMdGR8oe5XhA5T7t2yYo5qLvX/PYxIwAKr3c941jgTnTXJo8kNiFUrdDadKYcrWaY8N1qRpZ/ttdGHoAK71FfMqxCpeqmOi9UG3MkM1ARYKUy/NW7vTU/OdHxdYIGV5ZLQKLBqTr4nbB6YpxLuyZHNFVQD3WalrbvpeNOU8ONtTFcbrRoyHDHgBenchQ7uWvufGqcbzRNaDoZEYmzgfz47W0bRzbDgDqB7j0u43lYqm3IF9rS6kJLxNBAC1gWvXXjre4h5sBvBxwHvnlj338YpfDpWAB67deLE93PsKGcJaN2tmbK31jtn/UscbentpOGg08EhkKJ/8t5TGoaD+KTGpsAOROAQMdWkPv9PONom5BdqLclJYuXagO5lOxSXSHHvoWZLhSzfIIPZefiirWm2NFUPgaxJ7oqYF31BHFDhTsSDkSXr3eH8bOhu7iENrMX7mNdAkoRX+WEZbtsDvpfyZ76MsUfr5pCxjB45Z5gXwBHf7p01ZSdoBS/CxjEXLWTPiqsQ5GkgOzi+XWJuWksoijoB5UYWC8XFSQOfCGaJqEZv2Pkf5wVhjMsL/Ia/bFdUVo+PWNiH6HVF1jYLxqb26I9FrBF1RLebrug9HviKbD1T01r3x6uWIxobNv4o/YrQ4tvmJz9eapaRF3uzT6wW0QD6b1yRhEqHj9du8zmQFdXhuDVJc79+gJaymqzxvG2v6RI2HLYR7qXv8nfIBq5ewUK04vSsvo0hZqJ1d6pKzCeMPOon3z5hYklXSF178ESmR+cUecfpEO7/8Fz3y/wMwhPdfL4Vt7Bf1YGYWIcqyDrxNvNg/hMcmY8kKc+YcayQ+I0TNSoEtyeGAf+3Cbt1PZ3uNN3NmeRXroQuCgh41WTr0kuGOljo9OQLyphnELJOf0J+sHQrnUd0fF/ugG8UCpLDPO5jcciCu5z4LiHahFgYbPA4+Sb3mvHGl854ioql02cBiDNW9NXaMT8KpStxQIWysfT5BOoVJOv9qAoxnsMp86htpXyaHb6TVkNaffqmpGPm106t2JMeb30j9/9mtNtkBUhVgE37pHtmU/DHo6buc/tunbAgNjXCBRoSruiR2bFd6RcgFol8dVIJGlQXExpg4FfA4slLx1gdj95Ljf4tTIUDQ1zXVbJf+Y0irF+jVc4zk3TRgVNKPj+jFDYKjKd7OjJx43PDGaEz71GNYYOG9RL/KhZl47o1oxyd5FLeddJZLXAaL4VE2hZPFsAkjQtymiSOpxjc7H2l5Wq5PSv7LdmPKkir8xDSM74qypoAUF/LoJ8UMxJ2HS0JBmHOUU97EC20QmP+bNrbhzl3JN3IGCDCbfn3e3+AwG8kOVhWCxkz4s+1VKebEJZHy1VjGPwR7R1ZlTWVQWtvy8cITWyLtwh4xBxMbikjDwLkpLPUrwRBRa6PgYorXTIPXcF3Q7FOkiMXbJuVSh4QPs3hz4xOXuwvQuIheLwEZUOqMPcsBQkePHDRVROh0vCzsrGolLvLNrwEK/2c9uqGuNnDdAqItb6To3g15K6qKrzpQQrxDTeL44HAXX6iJFsh1CBpjFc4D5vq9wnmST+k1FFOOEU1k/cLuWgQ7jcblRCuxW9OFzZCf6mdvGIK9DMyIYKu9UATieT1IKeS1TeNJBYRL/AFUyhVid1eOTD/hTfLDkooMDDksW1+eZok9r1sE4hqgXfE17lcfgd0kVT41fpsTVdemadFmRCyKv03bVIkZEoktxXTdPROqFiZgf/Id3LuLOrhLf6oWGnriVZPEEizJaQVHtW9U3liCMzbzAbkWMomHs2DPLTgyganHmEuhciZYDp6mTKw0xhG7uzztSUdO69T9FSNSCHMB08+WFEWmAs9fjs7gZFtrNZT10uPTgp/nx9rJyzXx/Z49fGYiZXA7u48lZaBVBelz5O1o72RjM7ll/N1QspCpg2+4ionWZLg5Nqpa3DsRiJTJUkgs1cyFzeRJMcF9j5f3qC6GsBcgMcb/kBPZSSn3nkTL7Qx+ciN7dE3i0qnQ61YgoeEYt3E3Plf9vTNvtW6kdN/xFna35v80yfzviQ2HDqQf/bsT5EQLW7EYqq8q7DtXvFsEeoZbZghxiJGDuPDw4iPoXtqL0XbNj+WXb1nFMSG5Ckh94ovm06DrM6QGa7yS/V5bxUEUJ84z9l2me/rywlX4PpoDTgvpe1mcRtchioOyz8Tskwwuxy4a8LhzKn+CV8eQSAU9CIgnyuP9+Kr5HMZjqM0ut9YeAH2MOX9oF6Bo2lzH6XX0NXvmux2INAU4U0DVNDSXR3Gn46gXk8CJpbl2azU4JSrqdWvakM5m6Pe3N/m3wFNUVQWd1gKpVH6LlYeRu56izO5AZf+4oiqtB2RIMVgTlz3QciCciLsZ4dWhcDTIsannO9le4CrtHezlnC5lKmsBOpihG0PLZ/8phueCJapQDQ97Og7s5qQC4QDAg5ZM4EyHsfE9sHpPWLPuCnqyucJOo4kVvnFr06YzBJDFEZDB01wzfP0d5X3sI34i8hB90LNdYrddX+4csVhK5QwdZl8X170ul0lZW3IRvPL57v66ZVYlfDZQbSK2zheshuV8S2ex9LtNYCECmG7XgfB8m8y12CafL2cUsmM+7hj35qcW3oblTbLAf2BNlS7RIz2tfrLLwvUWaTD4F0inojl1z7p2EQnK6TkmSQ+9+D9fwSGkmPeDjnXkGoNwlZt/FqcbeaaS2SO7SiAODzWi5RC/HtgX8SIxz4hSjV6lgjEaE5w4yi3jhuAukoMgUJTzXl6zeP9+C6NLDEzj1U0i1854O7f8g9sEbYucy9tvru804421kFhEGvXcovHOxWYhhNR+bp/s2q8tm7AG0z2TEk20Wt6620LtyN+UqfflW1LTcCthgxfSCI1xCmDki0XODFPXyt0McnNdxy32tiZAbaETz3PlrTqHf7aPXISz7cZqsCPPuN/7//ZZOCmk6zJBqg0hgElv16oPNjkHjsKtU5B9Hk7ZXQ99Hb8VqaHgbnSV4J0WtRQbssG4b43DhLSZiv9A83On1S3MS0UDbPWa3PMkLBsd1dCcq/rkQyUBIaakno1vLevikDhApTdfUTkZywFavVtqOsqw6KNRFpv3OJaPVS9vccqrkVHRhk1YoDg7kAIE0Ixw8CoFy2nrRMT2oJIolZE0snVL7797OmKcB+Ju/ZpcWMIBxHaFwFfhsPJFSb4d8Qi81trY08I6Gke71UEQSrb0eGY+hmMCgGLXUJF2bsnx4E6wzEZdtDcLVYdGQ6U6fa4ElRXacqWLStQVYrlI8PrNh8X1p6IFHfLc4sZivfdfX1lbEt22NtnJVUk/vaFwOfDfj/Bjz+9x9BKoRuHsE08TUc3RHiTYaY7cWdY1v0C9RTF3BJnj1qkMjabWIF6LvhbFX4jlolJ/WcJf4e+YEOSbaNfmLYGh+4bxCbzAfYuUWQE1wz4SPluWDAfrD2NEDKzumWeta/1oVY5oZbGMS17yYCMV622inx1heSzB3NR7YMaCapz6o7HMsgXayCgKb/Cu7pvtuI6pd1ml+1RByfpQHTUv71+gL+cxr5tN2hF8dyQnp+bapTzvsIhFbnhGTxP4vDoUf/rfVL2m4dYM1c+MIXMkFWFcP+YWCkKH6F7+Tow+LZ0A4Ov47kF4jlvgL4CayDxig+STj85okFYVFgDYNlSm8G7YdsHYqJrMbNHXd+BKPbWViY5PBE9JBkRmr2omvPYpKupyoFm94dNrM/p/0qgEXwQBihgZrw60rqeBbR1KO0a7ipA/Dofnc8mF4tQXyZXdwe4e0gui+63pOWjehpGa8ayZ/dBSr8XHDaCYpszgLYzXHzuOLBhjehjBdEhh9o0BjMLEWSrabvwAW1F0wOpPHYk6xkeZ5xD83Z7NIfZSwEsQQEDYTm5K55HJ/jsieVnDuGA5yRvPi131KVUZX5FIY7cm/Z86Tku3Icz/pDa1p4F0B0+SfeUQKojFnk3bftlnMgRyAwD7z7aBFGfiYBQTYLt02mDJkjZRm/YQlKim/GV8YxKdM5YHsXcTxbGpKuPpjmE+7yltnpDTV/+suRbFkGXi5tIDc8mAETvHHEyJwkM3UhMxfQnapmmUpaUQwaANSk6Knq85RxNAhAOzGqsT4EDDpNce1V5a9SRvcN8T78zARjPvST9IEiCy0dD1Ch83mX+J4lLcJkRTPjnHzPJctocHlIF2mx3k1vRHHB1Q6FxlVsGTlQLcFMqZssr/zAG2sn27rHxYMhQRT0Zn3fd01Ql0N+tnY8iThqwAj8t0L6QxZG2QsZ08tNFFrS51WtebMMiUeKRtwSoM+ep/6IrVNion61wvWEPBQ8DMoZBgF7jCC8RSZbSiMeSDpizu37EXCcZSYILpbUMO08uiSmScVddir9KrTCSrVS9LX7ovYuXpLYhE6t+dLU5QVtaj2qzlR2tAT+OJYRYwSPpUYhYrp01E5zLZlGwZ4UtIPQwnu1gVepe2YZMTjx0hSEC8UMV6BWZhPDHc4OwxJ7h0D/8yDvhJuT9PWUrso6aXvu8J6C+/2FgoUlG21ng38AEHS8COh51c2N7S0Jn5Q3YLyzf9KJeS0DKDfRPD64yYtNd8qA43JCsRyot8LlQcUF8tWi9xws/Vc8PhTKfKahDMxw2sUzRpujSuDhc9Bm/KcjrwZto8N2mZOZxiHE2JAq524sCrP3lV8DlLSThF2rjLNmVQ/RwwIJ/6UiCZtUtBm6mev8xqMYJKBBXQ2Xc0u8RtLjel3v3eOipAx1q6xHH0kcDIUVuiv9FwehOA3LjwcB1HKqJJSOqV9tRz3kW0fV7QwqhibPZoW4UAeo0Mc2KhkTfMppgfA8Rd5MeuST04oYbmyqcuK8goix+dV87ylsch39fshUsD44oMoY6K7cGk04oHJit8Szm7VO2iiWrVabvR3eoiDCIP29fjnhYrpYIEipuS0OHUQi3FgGzqJOvGldrDzzCf87DWubnneALTXnTzVSFCXWOa56xttChES34hMM6yZSJ+dJm0iKi3HjVSKOgLUXSj57xOZYA5ZKhE3Y6di5EgZ0bZp/LsKfO5hls7IKakTyG7Ewc35ThmswzlatxKspXybuTdW96Um3DGoecOozy8LO2pN5qP9yx8QmjMDCjZfUndrElMCiJokucSm4pxsxO162mYIEDzs3nFeiBHchQMrodaf06upVv9yp9WusKlz49dlFRWhWjr8x+u1Xqj4jFPhDRqmK4g3v5WdhSbm0lFjtEPb1qy/I8rnZRE8pCwlP8IVUrPGKcBeI7qVS874x2bvCBm2o9wRHeI4lJ8zgPQh8omTTH6XpJve2PrQZR6z8Z7toybSGaFAUC6Q9Gylb0hrbQ973/txrGK8P0K4gWauyfzzbKoiwiNcFIjdLjF4plIv9nzSVLqASl+j2IoWmyhPJKQZOdB80+MEJofELp29fvWgObLRcuUvG1xK3ox7oIy/UTeCPrz1so9xvvknaGZwirbUBX5VgtVjKY2naNX0/ClI+4+WfuzPsgmuPLY0PpJh8jhBHxZJ3iJDWr02TZObT3fjHYigj7EC6HwIvkJYt0JBvP5BQlupanTLW1q5DbIGgMpmeXp3MkEtlW44wcMGrbcu9/fckRiVRtBnb48e9Omekf1dY+75Q9KxHPfRl8Gh98wMl3xtif5Pp7OfndgkMEzmhEOxSdwR/Q10gi7Tr0qsbjLv71wVTaoCQD72oPSSuAvGKm4keMICZR8x5C0KhgZ4+EfKT448gv0/QHluy8Pq5VA8TMIn07/p1NG/i1XLT/HknaE74UPiw2bIXD5nDmy7LTmKSDh/cXCcmSTohLYlFHg/TNpqOeWKk4DVWp1nP42QHJYzFOPnk4u2ErMWSLPXPtowg45j4K5yAYFr0lP55Q/3+XZDiqQhcXFFehoGt5i1g46nhOSqZzrci/KDW2x1HC5bfJg9l65ozYlIY7hAixLyeRES5WLXqEMtkDQgzE5jhA4BfdoriF4vCRNGJnIyNz7WjWJrF3sFHM0kVaTpYzmjnejr4/13kabzE1qqwiPAo7o/lRHDarnGufakNy/ML9a9QAUMQRpHY7DrtYGvHKl7To2qCvHLLpO6RPLafFw0QKt1Umhe4l1ivyHzGyC9k/xrSP8w2SS7iyW+qMBqqAssy5glcmshUYccX/s2zaJvnMP8G3gPoDdG84QWlr6vDHAw5Dp4KlOqU7KsDI3yYujNwKavhsYxbKL6aFN7pedPwU2ZfnpV/L1AW3EYTepwVjhCq0OzKFCjpN5KxYWZ4Tu9fyWpjk60a4jj6ZrC9k6RHAqRq7yXP58TvIpoR6qbqueLEGrzWqmRnFcpxA5YTotJD/HDPPppGdSQRSaBMqOvom0UrPcCJDRUu0f5V99O0OHJP9vBufSZhQM04W2KT2AhNd86svRw5bCcHC9j6354FpphEgAPHi9bhQ2MkzzdD0WqxEWuqv+G8NEhD4KHAbqhlUgXaXVEALd7LWFEjwbnH1dJvgpBXPS3csDHCnK2taXIdTm8P45KBLt4mREaDbpTbdv5yBLgiwfbm8FS5TpfMSAjyElL9McWjA9BhbB4zesWZimmHqYfhHgwF1qwLxJhOasRylE4NUZMepPIN3aGwUDqIOhn0ux4wtdYl96A41eGAx2UBRVl+Rr+6pO8/EUCTlQpMaJb3fAf7lsqAvt2sh7cpdUdULexg2E12Knx+M2u89STinVs3ayhbvGcEiML7eatxr+2+6U04PIs9SRCWmBCN5nOHVofvBNbH6bRBsQhy0tS964GudviWmhUQ3Ydg9k6s9a4DgmRQd7HhQgMW4HMepeLZw5gaD6gko3n9kDqVJs7EuAuAn8ma3rFfDEy5CAbBt6+rEogsVaBgbYe8cTXFEFUeUnHGKzsOM6rXAwDgnS5Dc1o+d5m8cAh+IshrIrPt1XMM96nLZeYHIP4l3St5ag07kv94bIAEarOflvQ65+G+Zmj/4prJRQs6F+QPw9509SSKnVz4vUCZfi3n/5gQBVNLGJRJ7EJK6wgCMUYDceJuk3e55ace0I405nylt6cIArWI3rbfiu/W9MV6aBF3Fur85GToOIxs7b5+gW3ccV2/RKcixM80jfxnzzFH86S6UKkBvGoCoaSoYqLDRg0v45cROHTmCRQ/QtFwRfaxnT/6ycOX/uWfWr8ggqwnfH59zGieDw6KxlpIyML6fdFxc8khr3C1iiZKah2H7yaeGecMs3GrwwN8+vXQbp9UWmk/YRsjryGALC+yLvthWwmNxwF7IvzUzsUpouJDB7IbBzgFkYeeANnUGh/mfdzeOCYfDAcm/xsS1By4TV9F035oEYunbm8JTbLGQsxQFPgif/YttfIdWKVHG4VdNoeoskFXqMHkSV030P9KpvPy+pgg8peUWTTxu0ag0fewmpMMHK8jMqOgOjrXtyzQM3PLhs2kT1q7mi2N0lEo7RDWqjpROQ2ts8NTn+a5MQga0qlPU0o3J/TafQxBP2179h2x85GtJQs2eA8Yp8qMDaFPMmbzxcKcjee9ak4Q0weHsBzBI8dFxlcB50+HmHzK4icENUs3dUMfusq+riEhkZRUx7v21vuf4kS70KG4gmDT8V+BBx2Oa+fUl8sSRoY6pOD+tlIX5QKGq/ob8GlIpZn89MiXQ6TUTtW00FYO5Do/iEx6KOms8Ly5sh0YXSRQDH+wHsw0epnok3Sh036w+fH9LAKdQVe+WS3Rn6m8eWoLdy71A2ATg5qhBrt+NmnhZ5eUB56rXVUyyBsmgLXRzi3R9RjHny/Cuk7iMg1PV4pHFOS83qSQdwRFpFKgY9O0Lw/E/hTWVklAg8TokGvh6ph7yP5mL3gJVhnsnfIzHT+X1kGbi6joYn22qDKYIvFgJVDp+bzZaQeTVwo1HYg85FEuKWwh5agjyeCImSoNuXv5kTy+xEjOdPthumPipl3tdzHPywkK8DEkQqdew7uqin84PRcxgH8FpfmZAlOyF1UqX7y+mzA4hoyOk/pEZMb+3QOyydx14PxG2j0RbMkCOg3PvkHoFYv7zueek55vyzo+ep1eYVppOD4HqHt5jW9GRhplmlHtXtL+kdF87VdgdHzTMep5g/pLZ6NNHdnC4UUoZpZptVv613H7yUtA+LUdlVB+Q0ghbGdrksSdORKG5sQLfDk0r/IwUGSJUZ+Vwsq1QrFTv2pRZbMc3Km6fu9bsO4WlYTZgD8nzAuR6yCF8X+Lzj4qXqhE/mHTBch0nIpM2CQNA1tUTfOgWusaOgoYQbqAGQbC7MfTshFr+TVlx/mxWjI8wIqYBqv/cBZu3x6/rNCu/xhBuLPmqbtCAnF4hhH7DHUmxdTqICuV18GNzOzA+zirWOkBQfON57/JTctSaLzYpomzaX6e3bqxl8SpMMTrnzVrVKJ0jvYIJPvh6POei3qekqxalyLiH6qBVLFTnSkxCP69MUGFX8xs5f2v97Fqn//E2P7GjJbx8loD3TlNyaXlnuPLtiwKEIH+vDJqb28olKbBL91Zoz4tSS1Em+m5oUj8xEBn5OSihupBjRZB9v6PKHlulf0jpM8W2vxGjz4WTpysDzJ5VsuDW6oHPPLxV6bib2WaS0NSPRUJdSLq9pbB7s98EWN31MM/aa0H3w7fGFqAUmQ1M3iVS8U1kGDgunrJkn+IjVKhhCfhCZQbDAohaCKNfZntPiOA6fhIGkrbRHfz5TRE9UpaohzaoFyFskbZLFrVVr7c9RA/xS2RineWAZ141VeONDBxFZ6zgrYo3mUIqHd4qQmVNBOSU8oBCdjc831BSO3pPtUjZ4mIPIE+vfJqsGmz/yTUldqQ4yiZjxGxuq6hnF31xF4wlvU/a7EronbWo0Bc1RqylsCM7qyxLF41fNIkWkDObacZko9YdJOGg90yaR/Z2DKJPxTc1VxCLxV8s5AzhNCYG7AVpRa9POgqPPnJNpOI+GVaIxen2ChN7G0ShyuKXUd714qSqKIaZWf24v9L1/CzFqCaAmhxOFkrlNCgK+U1V25jdQBIiKM1sj/NEPIMJr6kzilLfh/CulcqPXt9ZsIZkmPxeZk0i9T7/GXOfoD1kNDfggrRhxrLb8Z3LoDU7KHrWeRJ9chQRugyS6wRKpwoVroAStxya4RDHWENnfYtBsTFtImbDQnUwUrQRrMwUzE/hO9N3GOXlbM7PJo11q0fzCRS/9hlq2Fbi59RhD4+svkhW7AhbIhlKDs0NsHwPKrplhiNxx1wQBrajxfEmasqla0Kp8/0yFAhMkuUdcLZ4XiwJaCEOMEshuH2iPqry3Uj7QZarYcRtSaal46t+F0RNjiJK0+ufvrMBRxlk+VR/OvLtSGtwNNsyi+UhjYsksxcoDxeFmUFiurz23GpQlWps1RbGiThKMbW8X9EluUBG+LxeuLEzBUDbZe9GUqZgt5SXak4WCm9myc0SjEwcSwwSm8wbYA+ipVUIpdqBf2+xd8jYGAeXS3QKrG2T017QQ+HJXfejS8AKNLSwgbFYP5lO1pbQvk8dRFDPV1Vmtt2zp21F6SFPenG2r9KiXAn+ksR8XQzOM82EXwrP90iuB6S8WRdv+lStMYvp3BfNzBocEUw5MODTm6E0mqmh17JP/RDK4iJj3KmLAFQj7jZnSfN3gFtbBatwlLjrSG6sQs2SqO/D1KqRZJ8dvtk0rlgSJ69bg8SLqW4AzXlI9Pqez5B/MK9YcnMFT4/XLfSkLWAfacSEEfbtm17idbs74zaXjEbG+vx75B8xvaI00f73IxhQsTrBcQiYFokF06E/6snEonSXyAKlC6zUUrtzaSsHrGfg2xFflkJbA3Mjik59meZWLAl/qrr1ajzQ/U/vVzKrEDb6fvmqktKlND+6mXJw6c1fy/aHOdLfMNwUIzgQzY5uMzNNlld3au0GQNRx2mrWCwnbck96BdR5B4MG98RlQIAm8S42k64jVKXct24+FMl+8Eyr303Ml7GZTCwW/up26JJM04Dseq5/UXbH88SNYFqyowZGPXIXsYOR+i2GytRuXsMMvZ4TnUqbCCKhrQZsn2VxZIU/eBU9Sovpzp5sjyGnQx5cRIXskIlGdMdexmvoBtwRiOQQIafUVpXc4ZPum/8HZr0LKPT//28tXKR9wbbWRWH6D7ApBSHeGr7MjyayKg3/IwD4bc4WQM2t2NcygyfRjJxJYJor6Cz3nPKmmfAUwOZtnNSf6yi+We6eMHArGGekj8YZv+bt9B0YQlXfc6bqce+WFwWc7Djmov6cD5y1a4JS52Z3IfftBdNYd6ZYPAJDHLCg9ahv7BcAERWTxTZGUIXVyU2glBfb+OkuD9UybYDkPa/5FFCbg3h9cnQE0D2zXOxx9rhU4UIEPNby5AX70+6AGme10ydwzt5qxXYtV3/POWBP6iZDUcntG6vjFp8+jmmy68NaEe94/U44X59mvbcgKyv7rDnUoVppMPZe7EBAO7ZYXbzVrnop5HSqDJ3YiJVgTOGtKwi6ke/ZvbHj1CaNjY5qMRDng92KJk2hm4RAqIX9qWLQcLSg/XA2wn2zNGzJCfd7RRxB5NG35Wb9WSpnL6BdzioGSL3qqET2j+hOl/+tW6OaMB1P+sZHWy7IL+1j4Wq4p3k/I5VdA0oH8tk1gGNCF7RinRTQ6Bf77PQbaly+70KDFb9zy2dSuHjJGxK4k4SmglElNDzJ0MGZ2nvGDnBCbsaU73eb+ssWNljrydlhIlvSwBfQR+0M1OPlURbekO/bk3lroCG1+dt9T28Jz5jFPkRCGQ991m79zR/fS0nAq65o/Ayo3mD1I59O1oKTPOLMEB0HeW+aREUCBvnkNhKQyiT/d5eDAsMpYLr/I8yyXtDmrvn3GsnFdP8Nt0wRWG/TsDXtl0KvjLhzJYDCzd8Lgv7bUvYTOhtU7UFxVTqx6n7HJ4SnHhXYDYy4GmqE9zDy2uPUc0eb1KA05Wcs+zbbv20h6o8kB5nFlNd6Y/PX5IDDRqfztTbX2ZEkJqzapKcPkbqpGYur0NPvCe1QKKsJugzt7ekb8qVPbjfC3kRJ+9hjdnNM4sZZ3EPFpDrt25Dp+337lxy+/U/x3S03aP/ClnH83gWAgp++1hwrfSNoqPgitB1pM41Rrp5c6QGynAgfdD3RYnlNAFsudtooGA6J45TVrCeAa8pEYETPpcCO/SlIcreNaXAAQjOn60foozUpFYoMLvT6YcboJg5J5q+pqFpzxEcrafQ3gg3v0AocSafibj+BobJevET+ejY6W1LZyh4cGon98nsCgrvqJCFA65cRiKNfpflOCW9hZJmxz/XB2xLw8AkcLjsIkwKVUEPTBtSO+DKuLJTSKwe788guT9WRCk/DUpOBfgnV3CahSplkXtcZ5neFlvsPlPZ8uWZ+RrTI2ZovcuD6r8s46ACuqGorXhaS+RYFu8IS5wrWQEWMtnD+5nJrELTlaiKHEp+UtHA7Zr+joDTvj8QBEcGBqWEOCpJGgEff7Beu0R1d9++/DLko3iS5Ktx0+GSQpgZn5vIji5BNehHWN4a/juUr3Cjpv96YtAVzZ5bQU880vfyWSKuOo7O9cnx+Czr1VwR4Atlu4T13dQ/WskwDHyIAlZB9MOt+lIEDlzDbWjEuBO+QsOQaNQDkSwTmNc3UMS/p4xP4xvSxfzf9BEP6k48Qbi0IJZEiDkTZ4kmFQVSDgQy5skZIQAD4s5XCk2/JugBzkiI2/wip1z5fRkE4Fw6KQofPTN7wRUkHt+OmOw43RabWBdBDMpHudNWIfEoFgzlTXgReS2mTwR6sZHDmDOWTgBESNuUgwTEnF1ce0XA/QNkWFqrROAFaqGaFfacAubwKJCVj2J9P2vdglkJZaoIDvWhEyW0CP2NHxb2fTHMoSMtl1/2UaT9hMyJwlw2HIdJhDrMjGunAQl9VYfdys5+4Xp1FwGcPhi+vXGtHdFXLeT2ERWfODT2vQ7qnOGguzee71edhg9wyTqFAodRDrntkpRxj60Lzpzp+7KG0CSheSLJ0IwARzZO4YtzHj4he790NU0JtTwTTwz47irbj1HMLltAm33fLdf16zNqqXpmsmJH8HvQn/wrb95hjcaEe+ZqbpGkPwv2dwXRgVE1SOTD8HOBJbDdGpRILEOM61BDBUqPsf5m0iNLvxprmx9YDLoUGzdL9lWT5C/0yAmUUtZvweQ9J8doYW </div>","site":{"data":{}},"excerpt":"最近真的很不开心，将烦躁的感受记录下来吧~","more":"最近真的很不开心，将烦躁的感受记录下来吧~","origin":"<p><img src=\"/blog/20190509/你的内心比拳头更强大/xx.png\" alt=\"封面\"></p>\n<a id=\"more\"></a>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;最近真的很不开心。觉得今年从一开始所有事情都和自己对着干，看着别人每天的生活过的那么精彩，而自己却还是平庸的一个人，看不到这段迷雾的路的尽头。也许真的是本命年？不对，我怎么能将事情的因果都放在自身之外。所有事情的原因当然是自己不够努力不够好啊，技术不够厉害啊。是这样的吧，所以才会事事事与愿违？细数一下今年，新换的工作来年就遇到最大的危机，四月初就大量的裁员；从年初到现在股票亏了一万多，我喜欢投机靠运气的事情，所以好像真的不是一个能够从股票赚钱的人；还有我原本还以为是我最好的女生朋友也和我断了联系，也许按照她的想法，和一个消耗心力的人保持关系觉得很累吧，没错我就是那消耗心力的关系的人之一，既然别人都觉得你是个不值得去保持联系的人，我又何必再去给她添堵呢。有句话说人的消极情绪的来源总是对自己无能的愤怒，我觉得说的很对。我确实是这样，想要得到更好的，却发现自己无法通过努力或者需要耗费大量时间去获得。也许我是个急性子，不愿意去等待。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;其实可能是身边的朋友少了，自己做什么事情都是一个人去做。哈，不知道从何时开始自己变成了这么一个特别依赖朋友的人，当和朋友一起出去玩就会感觉心情特别好，难道是孤独恐惧症？但是在杭州的几个朋友都有了自己的女朋友，也开始自己的新的生活，很少和我再出去玩了，下班之后的时间也只剩自己。有朋友说我其实就是缺一个女朋友。有了女朋友周末也不会无聊，生活也不会失去动力。可是我怎么可以拥有爱情。我应该不配吧。没有存款，没车没房，家庭条件也不好。目前自己的心态、状态都没有调整到一个很合适的点，真的很难。其实我还想出国工作来着，可是自己的英语口语长时间不用已经还给老师了，要练好也得个一年半载的吧，唉其实练练吧，也好。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;有时候心情不好的时候也非常想念姥姥姥爷，想给他们打电话的时候看看时间却是十一二点。这个时间他们也都休息了。姥姥姥爷看着自己长大，而自己长大之后却没有留在他们身边，来到一千多公里外的城市工作，感觉他们一定很伤心。可是我还没有赚到钱，怎么让你们享福呢。在这里工作至少还有一丝可能完成自己的人生目标，回去了会不会就会变成一个彻底的平庸的人了呢？</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;其实博客写到这里就已经明白自己目前是一个怎样的状态了 —— 我有在努力去学习能够使我改变的知识，努力去做能够让我改变的事情，可是经受不住时间在慢慢熬。没有一个稳定合适的计划和一个恰当的目标，却渴望一个突如其来的惊喜将自己拉出脚踩的泥潭。这几点才是我每天痛苦的原因吧。写完一通发牢骚的话，然后在心中制定一个计划吧。</p>\n<p>总之，还是将目前这段[人生低谷]的感受记录在博客里，也许再次打开博客看到这篇文章，就会发现当时的自己的那些烦恼，其实都不是事儿。希望如此吧。</p>\n<hr>\n<p>最近在B站上看到了这个视频，真的很治愈。也许多看看这些视频心情就会好了呢。</p>\n<iframe src=\"//player.bilibili.com/player.html?aid=50503953&cid=88415184&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 100%;height: 700px\"> </iframe>","encrypt":true,"template":"<link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css\"> <link rel=\"stylesheet\" href=\"//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css\"> <script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script> <script src=\"//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js\"></script> <div id=\"security\"> <div> <div class=\"input-group\"> <input type=\"text\" class=\"form-control\" aria-label=\"Enter the password.\" id=\"pass\"/> <div class=\"input-group-btn\"> <button type=\"button\" class=\"btn btn-default\" onclick=\"decryptAES()\">Decrypt</button> </div> </div> </div> </div> <div id=\"encrypt-blog\" style=\"display:none\"> {{content}} </div>"},{"title":"使用[幕布]创建Java知识体系思维导图","date":"2019-05-07T11:24:43.000Z","_content":"\n![Java思维导图](java_core.png)\n\n<!--more-->\n**昨天在V2EX上逛的时候突然发现有人推荐一个很不错的东西——幕布。我本身就是一个对一些名称很敏感的人，看到这个名字就很想知道这到底是个什么东西，没想到竟偶然发现这么一个好东西。**\n\n幕布是一个制作笔记与记录事件的文本编辑工具（这样说要把幕布开发者气死了哈哈）。编辑视图如下：\n![幕布](mb.png)\n一键转换成思维导图就是本文最上面的那个图片。\n\n其实我个人是比较喜欢幕布的一键转换思维导图的功能，以及它的导出.mm文件的功能，而且可以自动同步云端。这样就可以随时随地无论是在电脑还是手机上都可以打开来编辑以及查看了。\n\n这里是我自己编写的[Java知识体系](https://mubu.com/doc/hpBd1e5h6z)，还没有写的很完整。希望自己能够坚持不断更新知识点，总结与巩固自己的技术水平！\n","source":"_posts/使用-幕布-创建Java知识体系思维导图.md","raw":"---\ntitle: '使用[幕布]创建Java知识体系思维导图'\ndate: 2019-05-07 19:24:43\ncategories: [开发工具]\ntags: [开发工具]\n---\n\n![Java思维导图](java_core.png)\n\n<!--more-->\n**昨天在V2EX上逛的时候突然发现有人推荐一个很不错的东西——幕布。我本身就是一个对一些名称很敏感的人，看到这个名字就很想知道这到底是个什么东西，没想到竟偶然发现这么一个好东西。**\n\n幕布是一个制作笔记与记录事件的文本编辑工具（这样说要把幕布开发者气死了哈哈）。编辑视图如下：\n![幕布](mb.png)\n一键转换成思维导图就是本文最上面的那个图片。\n\n其实我个人是比较喜欢幕布的一键转换思维导图的功能，以及它的导出.mm文件的功能，而且可以自动同步云端。这样就可以随时随地无论是在电脑还是手机上都可以打开来编辑以及查看了。\n\n这里是我自己编写的[Java知识体系](https://mubu.com/doc/hpBd1e5h6z)，还没有写的很完整。希望自己能够坚持不断更新知识点，总结与巩固自己的技术水平！\n","slug":"使用-幕布-创建Java知识体系思维导图","published":1,"updated":"2019-05-07T11:55:42.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvd0011cwnkv5q3ziqo","content":"<p><img src=\"/blog/20190507/使用-幕布-创建Java知识体系思维导图/java_core.png\" alt=\"Java思维导图\"></p>\n<a id=\"more\"></a>\n<p><strong>昨天在V2EX上逛的时候突然发现有人推荐一个很不错的东西——幕布。我本身就是一个对一些名称很敏感的人，看到这个名字就很想知道这到底是个什么东西，没想到竟偶然发现这么一个好东西。</strong></p>\n<p>幕布是一个制作笔记与记录事件的文本编辑工具（这样说要把幕布开发者气死了哈哈）。编辑视图如下：<br><img src=\"/blog/20190507/使用-幕布-创建Java知识体系思维导图/mb.png\" alt=\"幕布\"><br>一键转换成思维导图就是本文最上面的那个图片。</p>\n<p>其实我个人是比较喜欢幕布的一键转换思维导图的功能，以及它的导出.mm文件的功能，而且可以自动同步云端。这样就可以随时随地无论是在电脑还是手机上都可以打开来编辑以及查看了。</p>\n<p>这里是我自己编写的<a href=\"https://mubu.com/doc/hpBd1e5h6z\" target=\"_blank\" rel=\"noopener\">Java知识体系</a>，还没有写的很完整。希望自己能够坚持不断更新知识点，总结与巩固自己的技术水平！</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/blog/20190507/使用-幕布-创建Java知识体系思维导图/java_core.png\" alt=\"Java思维导图\"></p>","more":"<p><strong>昨天在V2EX上逛的时候突然发现有人推荐一个很不错的东西——幕布。我本身就是一个对一些名称很敏感的人，看到这个名字就很想知道这到底是个什么东西，没想到竟偶然发现这么一个好东西。</strong></p>\n<p>幕布是一个制作笔记与记录事件的文本编辑工具（这样说要把幕布开发者气死了哈哈）。编辑视图如下：<br><img src=\"/blog/20190507/使用-幕布-创建Java知识体系思维导图/mb.png\" alt=\"幕布\"><br>一键转换成思维导图就是本文最上面的那个图片。</p>\n<p>其实我个人是比较喜欢幕布的一键转换思维导图的功能，以及它的导出.mm文件的功能，而且可以自动同步云端。这样就可以随时随地无论是在电脑还是手机上都可以打开来编辑以及查看了。</p>\n<p>这里是我自己编写的<a href=\"https://mubu.com/doc/hpBd1e5h6z\" target=\"_blank\" rel=\"noopener\">Java知识体系</a>，还没有写的很完整。希望自己能够坚持不断更新知识点，总结与巩固自己的技术水平！</p>"},{"title":"关于IDEA再从git或者svn上导入项目时不能加载字模块的问题","date":"2018-07-08T15:26:49.000Z","_content":"\n### 关于IDEA再从git或者svn上导入项目时不能加载字模块的问题\n\n> 最近入职新公司，很多东西也都算是要从头学起。在之前公司用的都是eclipse，这边要求用IDEA，其实很早就知道这是一个非常强大的编译器，但平时没有机会使用，现在有机会用这个还是挺开心的。\n\n由于公司使用gitlab，在注册好账号导入代码的时候遇到一个情况，就是直接用IDEA的git工具导入的话会出现，maven项目的子模块无法被识别以及被管理的情况。事实上eclipse也有同样的问题。现在只说下使用IDEA遇到这个情况的解决办法。\n\n<!--more-->\n\n#### 有两种解决方式。\n##### 1、手动将module添加到项目管理：\n- 打开文件选项中的项目结构（快捷键ctrl+alt+shift+s）\n[![oLFwe.png](https://s1.ax2x.com/2018/07/08/oLFwe.png)](https://simimg.com/i/oLFwe)\n- 选择 模块-加号-导入module，手动将自己需要的模块一一导入进去\n[![oLTGd.png](https://s1.ax2x.com/2018/07/08/oLTGd.png)](https://simimg.com/i/oLTGd)\n##### 2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了\n[![oLXER.md.png](https://s1.ax2x.com/2018/07/08/oLXER.md.png)](https://simimg.com/i/oLXER)\n[![oLm7r.md.png](https://s1.ax2x.com/2018/07/08/oLm7r.md.png)](https://simimg.com/i/oLm7r)\n\n> 从eclipse转到IDEA前几天是最艰难的，因为很多习惯不是说改就能改掉的，工具的使用总得需要一个学习的时间，但是等这段时间过去，后面一定会体会到IDEA的强大。\n\n","source":"_posts/关于IDEA再从git或者svn上导入项目时不能加载字模块的问题.md","raw":"---\ntitle: 关于IDEA再从git或者svn上导入项目时不能加载字模块的问题\ndate: 2018-07-08 23:26:49\ncategories: [开发工具]\ntags: [IDEA,开发日记,git]\n---\n\n### 关于IDEA再从git或者svn上导入项目时不能加载字模块的问题\n\n> 最近入职新公司，很多东西也都算是要从头学起。在之前公司用的都是eclipse，这边要求用IDEA，其实很早就知道这是一个非常强大的编译器，但平时没有机会使用，现在有机会用这个还是挺开心的。\n\n由于公司使用gitlab，在注册好账号导入代码的时候遇到一个情况，就是直接用IDEA的git工具导入的话会出现，maven项目的子模块无法被识别以及被管理的情况。事实上eclipse也有同样的问题。现在只说下使用IDEA遇到这个情况的解决办法。\n\n<!--more-->\n\n#### 有两种解决方式。\n##### 1、手动将module添加到项目管理：\n- 打开文件选项中的项目结构（快捷键ctrl+alt+shift+s）\n[![oLFwe.png](https://s1.ax2x.com/2018/07/08/oLFwe.png)](https://simimg.com/i/oLFwe)\n- 选择 模块-加号-导入module，手动将自己需要的模块一一导入进去\n[![oLTGd.png](https://s1.ax2x.com/2018/07/08/oLTGd.png)](https://simimg.com/i/oLTGd)\n##### 2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了\n[![oLXER.md.png](https://s1.ax2x.com/2018/07/08/oLXER.md.png)](https://simimg.com/i/oLXER)\n[![oLm7r.md.png](https://s1.ax2x.com/2018/07/08/oLm7r.md.png)](https://simimg.com/i/oLm7r)\n\n> 从eclipse转到IDEA前几天是最艰难的，因为很多习惯不是说改就能改掉的，工具的使用总得需要一个学习的时间，但是等这段时间过去，后面一定会体会到IDEA的强大。\n\n","slug":"关于IDEA再从git或者svn上导入项目时不能加载字模块的问题","published":1,"updated":"2019-05-07T09:48:29.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvf0014cwnkadkjkop1","content":"<h3 id=\"关于IDEA再从git或者svn上导入项目时不能加载字模块的问题\"><a href=\"#关于IDEA再从git或者svn上导入项目时不能加载字模块的问题\" class=\"headerlink\" title=\"关于IDEA再从git或者svn上导入项目时不能加载字模块的问题\"></a>关于IDEA再从git或者svn上导入项目时不能加载字模块的问题</h3><blockquote>\n<p>最近入职新公司，很多东西也都算是要从头学起。在之前公司用的都是eclipse，这边要求用IDEA，其实很早就知道这是一个非常强大的编译器，但平时没有机会使用，现在有机会用这个还是挺开心的。</p>\n</blockquote>\n<p>由于公司使用gitlab，在注册好账号导入代码的时候遇到一个情况，就是直接用IDEA的git工具导入的话会出现，maven项目的子模块无法被识别以及被管理的情况。事实上eclipse也有同样的问题。现在只说下使用IDEA遇到这个情况的解决办法。</p>\n<a id=\"more\"></a>\n<h4 id=\"有两种解决方式。\"><a href=\"#有两种解决方式。\" class=\"headerlink\" title=\"有两种解决方式。\"></a>有两种解决方式。</h4><h5 id=\"1、手动将module添加到项目管理：\"><a href=\"#1、手动将module添加到项目管理：\" class=\"headerlink\" title=\"1、手动将module添加到项目管理：\"></a>1、手动将module添加到项目管理：</h5><ul>\n<li>打开文件选项中的项目结构（快捷键ctrl+alt+shift+s）<br><a href=\"https://simimg.com/i/oLFwe\" target=\"_blank\" rel=\"noopener\"><img src=\"https://s1.ax2x.com/2018/07/08/oLFwe.png\" alt=\"oLFwe.png\"></a></li>\n<li>选择 模块-加号-导入module，手动将自己需要的模块一一导入进去<br><a href=\"https://simimg.com/i/oLTGd\" target=\"_blank\" rel=\"noopener\"><img src=\"https://s1.ax2x.com/2018/07/08/oLTGd.png\" alt=\"oLTGd.png\"></a><h5 id=\"2、先将项目通过命令行导入到本机，然后通过IDEA的New-Project-from-Existing-Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了\"><a href=\"#2、先将项目通过命令行导入到本机，然后通过IDEA的New-Project-from-Existing-Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了\" class=\"headerlink\" title=\"2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了\"></a>2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了</h5><a href=\"https://simimg.com/i/oLXER\" target=\"_blank\" rel=\"noopener\"><img src=\"https://s1.ax2x.com/2018/07/08/oLXER.md.png\" alt=\"oLXER.md.png\"></a><br><a href=\"https://simimg.com/i/oLm7r\" target=\"_blank\" rel=\"noopener\"><img src=\"https://s1.ax2x.com/2018/07/08/oLm7r.md.png\" alt=\"oLm7r.md.png\"></a></li>\n</ul>\n<blockquote>\n<p>从eclipse转到IDEA前几天是最艰难的，因为很多习惯不是说改就能改掉的，工具的使用总得需要一个学习的时间，但是等这段时间过去，后面一定会体会到IDEA的强大。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"关于IDEA再从git或者svn上导入项目时不能加载字模块的问题\"><a href=\"#关于IDEA再从git或者svn上导入项目时不能加载字模块的问题\" class=\"headerlink\" title=\"关于IDEA再从git或者svn上导入项目时不能加载字模块的问题\"></a>关于IDEA再从git或者svn上导入项目时不能加载字模块的问题</h3><blockquote>\n<p>最近入职新公司，很多东西也都算是要从头学起。在之前公司用的都是eclipse，这边要求用IDEA，其实很早就知道这是一个非常强大的编译器，但平时没有机会使用，现在有机会用这个还是挺开心的。</p>\n</blockquote>\n<p>由于公司使用gitlab，在注册好账号导入代码的时候遇到一个情况，就是直接用IDEA的git工具导入的话会出现，maven项目的子模块无法被识别以及被管理的情况。事实上eclipse也有同样的问题。现在只说下使用IDEA遇到这个情况的解决办法。</p>","more":"<h4 id=\"有两种解决方式。\"><a href=\"#有两种解决方式。\" class=\"headerlink\" title=\"有两种解决方式。\"></a>有两种解决方式。</h4><h5 id=\"1、手动将module添加到项目管理：\"><a href=\"#1、手动将module添加到项目管理：\" class=\"headerlink\" title=\"1、手动将module添加到项目管理：\"></a>1、手动将module添加到项目管理：</h5><ul>\n<li>打开文件选项中的项目结构（快捷键ctrl+alt+shift+s）<br><a href=\"https://simimg.com/i/oLFwe\" target=\"_blank\" rel=\"noopener\"><img src=\"https://s1.ax2x.com/2018/07/08/oLFwe.png\" alt=\"oLFwe.png\"></a></li>\n<li>选择 模块-加号-导入module，手动将自己需要的模块一一导入进去<br><a href=\"https://simimg.com/i/oLTGd\" target=\"_blank\" rel=\"noopener\"><img src=\"https://s1.ax2x.com/2018/07/08/oLTGd.png\" alt=\"oLTGd.png\"></a><h5 id=\"2、先将项目通过命令行导入到本机，然后通过IDEA的New-Project-from-Existing-Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了\"><a href=\"#2、先将项目通过命令行导入到本机，然后通过IDEA的New-Project-from-Existing-Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了\" class=\"headerlink\" title=\"2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了\"></a>2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了</h5><a href=\"https://simimg.com/i/oLXER\" target=\"_blank\" rel=\"noopener\"><img src=\"https://s1.ax2x.com/2018/07/08/oLXER.md.png\" alt=\"oLXER.md.png\"></a><br><a href=\"https://simimg.com/i/oLm7r\" target=\"_blank\" rel=\"noopener\"><img src=\"https://s1.ax2x.com/2018/07/08/oLm7r.md.png\" alt=\"oLm7r.md.png\"></a></li>\n</ul>\n<blockquote>\n<p>从eclipse转到IDEA前几天是最艰难的，因为很多习惯不是说改就能改掉的，工具的使用总得需要一个学习的时间，但是等这段时间过去，后面一定会体会到IDEA的强大。</p>\n</blockquote>"},{"title":"关于Git Pull 拉取不到最新记录","date":"2018-05-31T03:39:17.000Z","_content":"//\n//~~~~~~~~~~~~~~~~~~~~~~~_oo0oo_\n//~~~~~~~~~~~~~~~~~~~~~~o8888888o\n//~~~~~~~~~~~~~~~~~~~~~~88\"~.~\"88\n//~~~~~~~~~~~~~~~~~~~~~~(|~-_-~|)\n//~~~~~~~~~~~~~~~~~~~~~~0\\~~=~~/0\n//~~~~~~~~~~~~~~~~~~~~___/`---'\\___\n//~~~~~~~~~~~~~~~~~~.'~\\\\|~~~~~|//~'.\n//~~~~~~~~~~~~~~~~~/~\\\\|||~~:~~|||//~\\\n//~~~~~~~~~~~~~~~~/~_|||||~-:-~|||||-~\\\n//~~~~~~~~~~~~~~~|~~~|~\\\\\\~~-~~///~|~~~|\n//~~~~~~~~~~~~~~~|~\\_|~~''\\---/''~~|_/~|\n//~~~~~~~~~~~~~~~\\~~.-\\__~~'-'~~___/-.~/\n//~~~~~~~~~~~~~___'.~.'~~/--.--\\~~`.~.'___\n//~~~~~~~~~~.\"\"~'<~~`.___\\_<|>_/___.'~>'~\"\".\n//~~~~~~~~~|~|~:~~`-~\\`.;`\\~_~/`;.`/~-~`~:~|~|\n//~~~~~~~~~\\~~\\~`_.~~~\\_~__\\~/__~_/~~~.-`~/~~/\n//~~~~~=====`-.____`.___~\\_____/___.-`___.-'=====\n//~~~~~~~~~~~~~~~~~~~~~~~`=---='\n//\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//~~~~~~~~~~~~~~~佛祖保佑~~~~~~~~~永无BUG\n//\n//\n//\n\n\n> 使用`git pull` 获取不到最新的记录，判断应该是某些时候未pull先commit导致的，使用命令：`git pull origin master`即可解决\n","source":"_posts/关于git-pull-拉取不到最新记录.md","raw":"---\ntitle: 关于git pull 拉取不到最新记录\ndate: 2018-5-31 11:39:17\ncategories: [git]\ntags: 开发日记\n---\n//\n//~~~~~~~~~~~~~~~~~~~~~~~_oo0oo_\n//~~~~~~~~~~~~~~~~~~~~~~o8888888o\n//~~~~~~~~~~~~~~~~~~~~~~88\"~.~\"88\n//~~~~~~~~~~~~~~~~~~~~~~(|~-_-~|)\n//~~~~~~~~~~~~~~~~~~~~~~0\\~~=~~/0\n//~~~~~~~~~~~~~~~~~~~~___/`---'\\___\n//~~~~~~~~~~~~~~~~~~.'~\\\\|~~~~~|//~'.\n//~~~~~~~~~~~~~~~~~/~\\\\|||~~:~~|||//~\\\n//~~~~~~~~~~~~~~~~/~_|||||~-:-~|||||-~\\\n//~~~~~~~~~~~~~~~|~~~|~\\\\\\~~-~~///~|~~~|\n//~~~~~~~~~~~~~~~|~\\_|~~''\\---/''~~|_/~|\n//~~~~~~~~~~~~~~~\\~~.-\\__~~'-'~~___/-.~/\n//~~~~~~~~~~~~~___'.~.'~~/--.--\\~~`.~.'___\n//~~~~~~~~~~.\"\"~'<~~`.___\\_<|>_/___.'~>'~\"\".\n//~~~~~~~~~|~|~:~~`-~\\`.;`\\~_~/`;.`/~-~`~:~|~|\n//~~~~~~~~~\\~~\\~`_.~~~\\_~__\\~/__~_/~~~.-`~/~~/\n//~~~~~=====`-.____`.___~\\_____/___.-`___.-'=====\n//~~~~~~~~~~~~~~~~~~~~~~~`=---='\n//\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n//~~~~~~~~~~~~~~~佛祖保佑~~~~~~~~~永无BUG\n//\n//\n//\n\n\n> 使用`git pull` 获取不到最新的记录，判断应该是某些时候未pull先commit导致的，使用命令：`git pull origin master`即可解决\n","slug":"关于git-pull-拉取不到最新记录","published":1,"updated":"2019-05-07T09:48:29.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvg0015cwnkjvgxevjz","content":"<p>//<br>//<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~o8888888o</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~88&quot;~.~&quot;88</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~(|~-_-~|)</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~0\\~~=~~/0</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~___/`---&apos;\\___</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~.&apos;~\\\\|~~~~~|//~&apos;.</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~/~\\\\|||~~:~~|||//~\\</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~/~_|||||~-:-~|||||-~\\</span><br><span class=\"line\">//~~~~~~~~~~~~~~~|~~~|~\\\\\\~~-~~///~|~~~|</span><br><span class=\"line\">//~~~~~~~~~~~~~~~|~\\_|~~&apos;&apos;\\---/&apos;&apos;~~|_/~|</span><br><span class=\"line\">//~~~~~~~~~~~~~~~\\~~.-\\__~~&apos;-&apos;~~___/-.~/</span><br><span class=\"line\">//~~~~~~~~~~~~~___&apos;.~.&apos;~~/--.--\\~~`.~.&apos;___</span><br><span class=\"line\">//~~~~~~~~~~.&quot;&quot;~&apos;&lt;~~`.___\\_&lt;|&gt;_/___.&apos;~&gt;&apos;~&quot;&quot;.</span><br><span class=\"line\">//~~~~~~~~~|~|~:~~`-~\\`.;`\\~_~/`;.`/~-~`~:~|~|</span><br><span class=\"line\">//~~~~~~~~~\\~~\\~`_.~~~\\_~__\\~/__~_/~~~.-`~/~~/</span><br><span class=\"line\">//~~~~~=====`-.____`.___~\\_____/___.-`___.-&apos;=====</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~~`=---=&apos;</span><br><span class=\"line\">//</span><br><span class=\"line\">//</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure></p>\n<p>//<br>//<del>~</del><del>~</del><del>~</del>佛祖保佑<del>~</del>~~~~永无BUG<br>//<br>//<br>//</p>\n<blockquote>\n<p>使用<code>git pull</code> 获取不到最新的记录，判断应该是某些时候未pull先commit导致的，使用命令：<code>git pull origin master</code>即可解决</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>//<br>//<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~o8888888o</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~88&quot;~.~&quot;88</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~(|~-_-~|)</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~0\\~~=~~/0</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~___/`---&apos;\\___</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~.&apos;~\\\\|~~~~~|//~&apos;.</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~/~\\\\|||~~:~~|||//~\\</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~/~_|||||~-:-~|||||-~\\</span><br><span class=\"line\">//~~~~~~~~~~~~~~~|~~~|~\\\\\\~~-~~///~|~~~|</span><br><span class=\"line\">//~~~~~~~~~~~~~~~|~\\_|~~&apos;&apos;\\---/&apos;&apos;~~|_/~|</span><br><span class=\"line\">//~~~~~~~~~~~~~~~\\~~.-\\__~~&apos;-&apos;~~___/-.~/</span><br><span class=\"line\">//~~~~~~~~~~~~~___&apos;.~.&apos;~~/--.--\\~~`.~.&apos;___</span><br><span class=\"line\">//~~~~~~~~~~.&quot;&quot;~&apos;&lt;~~`.___\\_&lt;|&gt;_/___.&apos;~&gt;&apos;~&quot;&quot;.</span><br><span class=\"line\">//~~~~~~~~~|~|~:~~`-~\\`.;`\\~_~/`;.`/~-~`~:~|~|</span><br><span class=\"line\">//~~~~~~~~~\\~~\\~`_.~~~\\_~__\\~/__~_/~~~.-`~/~~/</span><br><span class=\"line\">//~~~~~=====`-.____`.___~\\_____/___.-`___.-&apos;=====</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~~`=---=&apos;</span><br><span class=\"line\">//</span><br><span class=\"line\">//</span><br><span class=\"line\">//~~~~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure></p>\n<p>//<br>//<del>~</del><del>~</del><del>~</del>佛祖保佑<del>~</del>~~~~永无BUG<br>//<br>//<br>//</p>\n<blockquote>\n<p>使用<code>git pull</code> 获取不到最新的记录，判断应该是某些时候未pull先commit导致的，使用命令：<code>git pull origin master</code>即可解决</p>\n</blockquote>\n"},{"title":"使用Springboot进行国际化时自定义读取数据库配置","date":"2019-03-20T11:27:02.000Z","_content":"## 前言\nspringboot默认就支持国际化的，而且不需要你过多的做什么配置，只需要在`resources/`下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。 具体的关于springboot的国际化配置我这边就不再过多介绍(包括Locale的设置以及如何根据区域设置语言等)，关于页面上得使用可以参考：[springboot国际化](!https://www.baidu.com/s?word=springboot+%E5%9B%BD%E9%99%85%E5%8C%96)。在这篇博客中，我要介绍的是一个很有用的功能并且绝大部分人也会用得到，就是\n<strong><font color=#0099ff size=5 face=\"黑体\">不使用配置文件`messages.properties`储存国际化语言，而使用数据库进行动态配置，做到无需重启更改配置。</font></strong>\n<!-- more -->\n## 如何使用\n#### MessageSource介绍\nSpring提供了一个接口MessageSource用于获取国际化信息，ReloadableResourceBundleMessageSource和ResourceBundleMessageSource都是继承了该接口的一个抽象实现类AbstractMessageSource，在spring官网有一段这样介绍messageSource的话：\n![spring官网对于messageSource的介绍](https://img-blog.csdn.net/20180116154941287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDcyMTEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast \"spring官网对于messageSource的介绍\")\n图中红框画起来的意思就是，上下文加载的时候会查询messageSource的bean，如果没有就会创建一个名为`messageSource`放在上下文中... ...等等。\n#### 在springboot中注入自定义messageSource\n通过上面的介绍，我们就可以自己定义自己的messageSource进行配置的读取了。\n ** 我这边是把这个放在了业务层，大家用的时候也可以直接放在控制层(一般都放在控制层，要用到)，使用@Compnent(\"messageSource\")注解声明下bean名称即可 **\n ```\n // MyMessageSourceService是我自己的接口 你也可以不需要。使用@Compnent(\"messageSource\")注解就行\n @Service(\"messageSource\")\n public class MyMessageSource extends AbstractMessageSource implements ResourceLoaderAware, MyMessageSourceService {\n\n     ResourceLoader resourceLoader;\n\n     // 这个是用来缓存数据库中获取到的配置的 数据库配置更改的时候可以调用reload方法重新加载\n     // 当然 实际使用者也可以不使用这种缓存的方式\n     private static final Map<String, Map<String, String>> LOCAL_CACHE = new ConcurrentHashMap<>(256);\n\n     @Autowired\n     SysI18nService sysI18nService;\n\n     private final Logger logger = LoggerFactory.getLogger(MyMessageSource.class);\n\n     /**\n      * 初始化\n      */\n     @PostConstruct\n     public void init() {\n         this.reload();\n     }\n\n     /**\n      * 重新将数据库中的国际化配置加载\n      */\n     public void reload() {\n         LOCAL_CACHE.clear();\n         LOCAL_CACHE.putAll(loadAllMessageResourcesFromDB());\n     }\n\n     /**\n      * 从数据库中获取所有国际化配置 这边可以根据自己数据库表结构进行相应的业务实现\n      * 对应的语言能够取出来对应的值就行了 无需一定要按照这个方法来\n      */\n     public Map<String, Map<String, String>> loadAllMessageResourcesFromDB() {\n         List<SysI18nBO> list = sysI18nService.findList(new SysI18nAO());\n         if (CollectionUtils.isNotEmpty(list)) {\n             final Map<String, String> zhCnMessageResources = new HashMap<>(list.size());\n             final Map<String, String> enUsMessageResources = new HashMap<>(list.size());\n             final Map<String, String> idIdMessageResources = new HashMap<>(list.size());\n             for (SysI18nBO bo : list) {\n                 String name = bo.getModel() + \".\" + bo.getName();\n                 String zhText = bo.getZhCn();\n                 String enText = bo.getEnUs();\n                 String idText = bo.getInId();\n                 zhCnMessageResources.put(name, zhText);\n                 enUsMessageResources.put(name, enText);\n                 idIdMessageResources.put(name, idText);\n             }\n             LOCAL_CACHE.put(\"zh\", zhCnMessageResources);\n             LOCAL_CACHE.put(\"en\", enUsMessageResources);\n             LOCAL_CACHE.put(\"in\", idIdMessageResources);\n         }\n         return MapUtils.EMPTY_MAP;\n     }\n\n     /**\n      * 从缓存中取出国际化配置对应的数据 或者从父级获取\n      *\n      * @param code\n      * @param locale\n      * @return\n      */\n     public String getSourceFromCache(String code, Locale locale) {\n         String language = locale.getLanguage();\n         Map<String, String> props = LOCAL_CACHE.get(language);\n         if (null != props && props.containsKey(code)) {\n             return props.get(code);\n         } else {\n             try {\n                 if (null != this.getParentMessageSource()) {\n                     return this.getParentMessageSource().getMessage(code, null, locale);\n                 }\n             } catch (Exception ex) {\n                 logger.error(ex.getMessage(), ex);\n             }\n             return code;\n         }\n     }\n\n     // 下面三个重写的方法是比较重要的\n     @Override\n     public void setResourceLoader(ResourceLoader resourceLoader) {\n         this.resourceLoader = (resourceLoader == null ? new DefaultResourceLoader() : resourceLoader);\n     }\n\n     @Override\n     protected MessageFormat resolveCode(String code, Locale locale) {\n         String msg = getSourceFromCache(code, locale);\n         MessageFormat messageFormat = new MessageFormat(msg, locale);\n         return messageFormat;\n     }\n\n     @Override\n     protected String resolveCodeWithoutArguments(String code, Locale locale) {\n         return getSourceFromCache(code, locale);\n     }\n }\n ```\n#### 最后\n 至此，自定义国际化配置读取数据库已经完成，只需要在更新数据库配置的时候调用一下reload重置一下缓存中的信息即可。\n > [参考博客：spring xml配置自定义读取数据库的messageSource](!https://blog.csdn.net/u014721131/article/details/79075802)\n","source":"_posts/使用springboot进行国际化时自定义读取数据库配置.md","raw":"---\ntitle: 使用springboot进行国际化时自定义读取数据库配置\ndate: 2019-03-20 19:27:02\ncategories: [springboot]\ntags: [springboot,国际化]\n---\n## 前言\nspringboot默认就支持国际化的，而且不需要你过多的做什么配置，只需要在`resources/`下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。 具体的关于springboot的国际化配置我这边就不再过多介绍(包括Locale的设置以及如何根据区域设置语言等)，关于页面上得使用可以参考：[springboot国际化](!https://www.baidu.com/s?word=springboot+%E5%9B%BD%E9%99%85%E5%8C%96)。在这篇博客中，我要介绍的是一个很有用的功能并且绝大部分人也会用得到，就是\n<strong><font color=#0099ff size=5 face=\"黑体\">不使用配置文件`messages.properties`储存国际化语言，而使用数据库进行动态配置，做到无需重启更改配置。</font></strong>\n<!-- more -->\n## 如何使用\n#### MessageSource介绍\nSpring提供了一个接口MessageSource用于获取国际化信息，ReloadableResourceBundleMessageSource和ResourceBundleMessageSource都是继承了该接口的一个抽象实现类AbstractMessageSource，在spring官网有一段这样介绍messageSource的话：\n![spring官网对于messageSource的介绍](https://img-blog.csdn.net/20180116154941287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDcyMTEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast \"spring官网对于messageSource的介绍\")\n图中红框画起来的意思就是，上下文加载的时候会查询messageSource的bean，如果没有就会创建一个名为`messageSource`放在上下文中... ...等等。\n#### 在springboot中注入自定义messageSource\n通过上面的介绍，我们就可以自己定义自己的messageSource进行配置的读取了。\n ** 我这边是把这个放在了业务层，大家用的时候也可以直接放在控制层(一般都放在控制层，要用到)，使用@Compnent(\"messageSource\")注解声明下bean名称即可 **\n ```\n // MyMessageSourceService是我自己的接口 你也可以不需要。使用@Compnent(\"messageSource\")注解就行\n @Service(\"messageSource\")\n public class MyMessageSource extends AbstractMessageSource implements ResourceLoaderAware, MyMessageSourceService {\n\n     ResourceLoader resourceLoader;\n\n     // 这个是用来缓存数据库中获取到的配置的 数据库配置更改的时候可以调用reload方法重新加载\n     // 当然 实际使用者也可以不使用这种缓存的方式\n     private static final Map<String, Map<String, String>> LOCAL_CACHE = new ConcurrentHashMap<>(256);\n\n     @Autowired\n     SysI18nService sysI18nService;\n\n     private final Logger logger = LoggerFactory.getLogger(MyMessageSource.class);\n\n     /**\n      * 初始化\n      */\n     @PostConstruct\n     public void init() {\n         this.reload();\n     }\n\n     /**\n      * 重新将数据库中的国际化配置加载\n      */\n     public void reload() {\n         LOCAL_CACHE.clear();\n         LOCAL_CACHE.putAll(loadAllMessageResourcesFromDB());\n     }\n\n     /**\n      * 从数据库中获取所有国际化配置 这边可以根据自己数据库表结构进行相应的业务实现\n      * 对应的语言能够取出来对应的值就行了 无需一定要按照这个方法来\n      */\n     public Map<String, Map<String, String>> loadAllMessageResourcesFromDB() {\n         List<SysI18nBO> list = sysI18nService.findList(new SysI18nAO());\n         if (CollectionUtils.isNotEmpty(list)) {\n             final Map<String, String> zhCnMessageResources = new HashMap<>(list.size());\n             final Map<String, String> enUsMessageResources = new HashMap<>(list.size());\n             final Map<String, String> idIdMessageResources = new HashMap<>(list.size());\n             for (SysI18nBO bo : list) {\n                 String name = bo.getModel() + \".\" + bo.getName();\n                 String zhText = bo.getZhCn();\n                 String enText = bo.getEnUs();\n                 String idText = bo.getInId();\n                 zhCnMessageResources.put(name, zhText);\n                 enUsMessageResources.put(name, enText);\n                 idIdMessageResources.put(name, idText);\n             }\n             LOCAL_CACHE.put(\"zh\", zhCnMessageResources);\n             LOCAL_CACHE.put(\"en\", enUsMessageResources);\n             LOCAL_CACHE.put(\"in\", idIdMessageResources);\n         }\n         return MapUtils.EMPTY_MAP;\n     }\n\n     /**\n      * 从缓存中取出国际化配置对应的数据 或者从父级获取\n      *\n      * @param code\n      * @param locale\n      * @return\n      */\n     public String getSourceFromCache(String code, Locale locale) {\n         String language = locale.getLanguage();\n         Map<String, String> props = LOCAL_CACHE.get(language);\n         if (null != props && props.containsKey(code)) {\n             return props.get(code);\n         } else {\n             try {\n                 if (null != this.getParentMessageSource()) {\n                     return this.getParentMessageSource().getMessage(code, null, locale);\n                 }\n             } catch (Exception ex) {\n                 logger.error(ex.getMessage(), ex);\n             }\n             return code;\n         }\n     }\n\n     // 下面三个重写的方法是比较重要的\n     @Override\n     public void setResourceLoader(ResourceLoader resourceLoader) {\n         this.resourceLoader = (resourceLoader == null ? new DefaultResourceLoader() : resourceLoader);\n     }\n\n     @Override\n     protected MessageFormat resolveCode(String code, Locale locale) {\n         String msg = getSourceFromCache(code, locale);\n         MessageFormat messageFormat = new MessageFormat(msg, locale);\n         return messageFormat;\n     }\n\n     @Override\n     protected String resolveCodeWithoutArguments(String code, Locale locale) {\n         return getSourceFromCache(code, locale);\n     }\n }\n ```\n#### 最后\n 至此，自定义国际化配置读取数据库已经完成，只需要在更新数据库配置的时候调用一下reload重置一下缓存中的信息即可。\n > [参考博客：spring xml配置自定义读取数据库的messageSource](!https://blog.csdn.net/u014721131/article/details/79075802)\n","slug":"使用springboot进行国际化时自定义读取数据库配置","published":1,"updated":"2019-05-07T09:48:29.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvh0019cwnkmz4n6ojt","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>springboot默认就支持国际化的，而且不需要你过多的做什么配置，只需要在<code>resources/</code>下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。 具体的关于springboot的国际化配置我这边就不再过多介绍(包括Locale的设置以及如何根据区域设置语言等)，关于页面上得使用可以参考：<a href=\"!https://www.baidu.com/s?word=springboot+%E5%9B%BD%E9%99%85%E5%8C%96\">springboot国际化</a>。在这篇博客中，我要介绍的是一个很有用的功能并且绝大部分人也会用得到，就是<br><strong><font color=\"#0099ff\" size=\"5\" face=\"黑体\">不使用配置文件<code>messages.properties</code>储存国际化语言，而使用数据库进行动态配置，做到无需重启更改配置。</font></strong><br><a id=\"more\"></a></p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><h4 id=\"MessageSource介绍\"><a href=\"#MessageSource介绍\" class=\"headerlink\" title=\"MessageSource介绍\"></a>MessageSource介绍</h4><p>Spring提供了一个接口MessageSource用于获取国际化信息，ReloadableResourceBundleMessageSource和ResourceBundleMessageSource都是继承了该接口的一个抽象实现类AbstractMessageSource，在spring官网有一段这样介绍messageSource的话：<br><img src=\"https://img-blog.csdn.net/20180116154941287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDcyMTEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"spring官网对于messageSource的介绍\" title=\"spring官网对于messageSource的介绍\"><br>图中红框画起来的意思就是，上下文加载的时候会查询messageSource的bean，如果没有就会创建一个名为<code>messageSource</code>放在上下文中… …等等。</p>\n<h4 id=\"在springboot中注入自定义messageSource\"><a href=\"#在springboot中注入自定义messageSource\" class=\"headerlink\" title=\"在springboot中注入自定义messageSource\"></a>在springboot中注入自定义messageSource</h4><p>通过上面的介绍，我们就可以自己定义自己的messageSource进行配置的读取了。<br> <strong> 我这边是把这个放在了业务层，大家用的时候也可以直接放在控制层(一般都放在控制层，要用到)，使用@Compnent(“messageSource”)注解声明下bean名称即可 </strong><br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// MyMessageSourceService是我自己的接口 你也可以不需要。使用@Compnent(&quot;messageSource&quot;)注解就行</span><br><span class=\"line\">@Service(&quot;messageSource&quot;)</span><br><span class=\"line\">public class MyMessageSource extends AbstractMessageSource implements ResourceLoaderAware, MyMessageSourceService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ResourceLoader resourceLoader;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这个是用来缓存数据库中获取到的配置的 数据库配置更改的时候可以调用reload方法重新加载</span><br><span class=\"line\">    // 当然 实际使用者也可以不使用这种缓存的方式</span><br><span class=\"line\">    private static final Map&lt;String, Map&lt;String, String&gt;&gt; LOCAL_CACHE = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    SysI18nService sysI18nService;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final Logger logger = LoggerFactory.getLogger(MyMessageSource.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 初始化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @PostConstruct</span><br><span class=\"line\">    public void init() &#123;</span><br><span class=\"line\">        this.reload();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 重新将数据库中的国际化配置加载</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void reload() &#123;</span><br><span class=\"line\">        LOCAL_CACHE.clear();</span><br><span class=\"line\">        LOCAL_CACHE.putAll(loadAllMessageResourcesFromDB());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 从数据库中获取所有国际化配置 这边可以根据自己数据库表结构进行相应的业务实现</span><br><span class=\"line\">     * 对应的语言能够取出来对应的值就行了 无需一定要按照这个方法来</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public Map&lt;String, Map&lt;String, String&gt;&gt; loadAllMessageResourcesFromDB() &#123;</span><br><span class=\"line\">        List&lt;SysI18nBO&gt; list = sysI18nService.findList(new SysI18nAO());</span><br><span class=\"line\">        if (CollectionUtils.isNotEmpty(list)) &#123;</span><br><span class=\"line\">            final Map&lt;String, String&gt; zhCnMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class=\"line\">            final Map&lt;String, String&gt; enUsMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class=\"line\">            final Map&lt;String, String&gt; idIdMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class=\"line\">            for (SysI18nBO bo : list) &#123;</span><br><span class=\"line\">                String name = bo.getModel() + &quot;.&quot; + bo.getName();</span><br><span class=\"line\">                String zhText = bo.getZhCn();</span><br><span class=\"line\">                String enText = bo.getEnUs();</span><br><span class=\"line\">                String idText = bo.getInId();</span><br><span class=\"line\">                zhCnMessageResources.put(name, zhText);</span><br><span class=\"line\">                enUsMessageResources.put(name, enText);</span><br><span class=\"line\">                idIdMessageResources.put(name, idText);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            LOCAL_CACHE.put(&quot;zh&quot;, zhCnMessageResources);</span><br><span class=\"line\">            LOCAL_CACHE.put(&quot;en&quot;, enUsMessageResources);</span><br><span class=\"line\">            LOCAL_CACHE.put(&quot;in&quot;, idIdMessageResources);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return MapUtils.EMPTY_MAP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 从缓存中取出国际化配置对应的数据 或者从父级获取</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param code</span><br><span class=\"line\">     * @param locale</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public String getSourceFromCache(String code, Locale locale) &#123;</span><br><span class=\"line\">        String language = locale.getLanguage();</span><br><span class=\"line\">        Map&lt;String, String&gt; props = LOCAL_CACHE.get(language);</span><br><span class=\"line\">        if (null != props &amp;&amp; props.containsKey(code)) &#123;</span><br><span class=\"line\">            return props.get(code);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if (null != this.getParentMessageSource()) &#123;</span><br><span class=\"line\">                    return this.getParentMessageSource().getMessage(code, null, locale);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">                logger.error(ex.getMessage(), ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return code;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 下面三个重写的方法是比较重要的</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setResourceLoader(ResourceLoader resourceLoader) &#123;</span><br><span class=\"line\">        this.resourceLoader = (resourceLoader == null ? new DefaultResourceLoader() : resourceLoader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected MessageFormat resolveCode(String code, Locale locale) &#123;</span><br><span class=\"line\">        String msg = getSourceFromCache(code, locale);</span><br><span class=\"line\">        MessageFormat messageFormat = new MessageFormat(msg, locale);</span><br><span class=\"line\">        return messageFormat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected String resolveCodeWithoutArguments(String code, Locale locale) &#123;</span><br><span class=\"line\">        return getSourceFromCache(code, locale);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h4><p> 至此，自定义国际化配置读取数据库已经完成，只需要在更新数据库配置的时候调用一下reload重置一下缓存中的信息即可。</p>\n<blockquote>\n<p><a href=\"!https://blog.csdn.net/u014721131/article/details/79075802\">参考博客：spring xml配置自定义读取数据库的messageSource</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>springboot默认就支持国际化的，而且不需要你过多的做什么配置，只需要在<code>resources/</code>下创建国际化配置文件即可，注意名称必须以messages开始。 messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。 具体的关于springboot的国际化配置我这边就不再过多介绍(包括Locale的设置以及如何根据区域设置语言等)，关于页面上得使用可以参考：<a href=\"!https://www.baidu.com/s?word=springboot+%E5%9B%BD%E9%99%85%E5%8C%96\">springboot国际化</a>。在这篇博客中，我要介绍的是一个很有用的功能并且绝大部分人也会用得到，就是<br><strong><font color=\"#0099ff\" size=\"5\" face=\"黑体\">不使用配置文件<code>messages.properties</code>储存国际化语言，而使用数据库进行动态配置，做到无需重启更改配置。</font></strong><br></p>","more":"<p></p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><h4 id=\"MessageSource介绍\"><a href=\"#MessageSource介绍\" class=\"headerlink\" title=\"MessageSource介绍\"></a>MessageSource介绍</h4><p>Spring提供了一个接口MessageSource用于获取国际化信息，ReloadableResourceBundleMessageSource和ResourceBundleMessageSource都是继承了该接口的一个抽象实现类AbstractMessageSource，在spring官网有一段这样介绍messageSource的话：<br><img src=\"https://img-blog.csdn.net/20180116154941287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDcyMTEzMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"spring官网对于messageSource的介绍\" title=\"spring官网对于messageSource的介绍\"><br>图中红框画起来的意思就是，上下文加载的时候会查询messageSource的bean，如果没有就会创建一个名为<code>messageSource</code>放在上下文中… …等等。</p>\n<h4 id=\"在springboot中注入自定义messageSource\"><a href=\"#在springboot中注入自定义messageSource\" class=\"headerlink\" title=\"在springboot中注入自定义messageSource\"></a>在springboot中注入自定义messageSource</h4><p>通过上面的介绍，我们就可以自己定义自己的messageSource进行配置的读取了。<br> <strong> 我这边是把这个放在了业务层，大家用的时候也可以直接放在控制层(一般都放在控制层，要用到)，使用@Compnent(“messageSource”)注解声明下bean名称即可 </strong><br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// MyMessageSourceService是我自己的接口 你也可以不需要。使用@Compnent(&quot;messageSource&quot;)注解就行</span><br><span class=\"line\">@Service(&quot;messageSource&quot;)</span><br><span class=\"line\">public class MyMessageSource extends AbstractMessageSource implements ResourceLoaderAware, MyMessageSourceService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ResourceLoader resourceLoader;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这个是用来缓存数据库中获取到的配置的 数据库配置更改的时候可以调用reload方法重新加载</span><br><span class=\"line\">    // 当然 实际使用者也可以不使用这种缓存的方式</span><br><span class=\"line\">    private static final Map&lt;String, Map&lt;String, String&gt;&gt; LOCAL_CACHE = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    SysI18nService sysI18nService;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final Logger logger = LoggerFactory.getLogger(MyMessageSource.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 初始化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @PostConstruct</span><br><span class=\"line\">    public void init() &#123;</span><br><span class=\"line\">        this.reload();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 重新将数据库中的国际化配置加载</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void reload() &#123;</span><br><span class=\"line\">        LOCAL_CACHE.clear();</span><br><span class=\"line\">        LOCAL_CACHE.putAll(loadAllMessageResourcesFromDB());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 从数据库中获取所有国际化配置 这边可以根据自己数据库表结构进行相应的业务实现</span><br><span class=\"line\">     * 对应的语言能够取出来对应的值就行了 无需一定要按照这个方法来</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public Map&lt;String, Map&lt;String, String&gt;&gt; loadAllMessageResourcesFromDB() &#123;</span><br><span class=\"line\">        List&lt;SysI18nBO&gt; list = sysI18nService.findList(new SysI18nAO());</span><br><span class=\"line\">        if (CollectionUtils.isNotEmpty(list)) &#123;</span><br><span class=\"line\">            final Map&lt;String, String&gt; zhCnMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class=\"line\">            final Map&lt;String, String&gt; enUsMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class=\"line\">            final Map&lt;String, String&gt; idIdMessageResources = new HashMap&lt;&gt;(list.size());</span><br><span class=\"line\">            for (SysI18nBO bo : list) &#123;</span><br><span class=\"line\">                String name = bo.getModel() + &quot;.&quot; + bo.getName();</span><br><span class=\"line\">                String zhText = bo.getZhCn();</span><br><span class=\"line\">                String enText = bo.getEnUs();</span><br><span class=\"line\">                String idText = bo.getInId();</span><br><span class=\"line\">                zhCnMessageResources.put(name, zhText);</span><br><span class=\"line\">                enUsMessageResources.put(name, enText);</span><br><span class=\"line\">                idIdMessageResources.put(name, idText);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            LOCAL_CACHE.put(&quot;zh&quot;, zhCnMessageResources);</span><br><span class=\"line\">            LOCAL_CACHE.put(&quot;en&quot;, enUsMessageResources);</span><br><span class=\"line\">            LOCAL_CACHE.put(&quot;in&quot;, idIdMessageResources);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return MapUtils.EMPTY_MAP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 从缓存中取出国际化配置对应的数据 或者从父级获取</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param code</span><br><span class=\"line\">     * @param locale</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public String getSourceFromCache(String code, Locale locale) &#123;</span><br><span class=\"line\">        String language = locale.getLanguage();</span><br><span class=\"line\">        Map&lt;String, String&gt; props = LOCAL_CACHE.get(language);</span><br><span class=\"line\">        if (null != props &amp;&amp; props.containsKey(code)) &#123;</span><br><span class=\"line\">            return props.get(code);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if (null != this.getParentMessageSource()) &#123;</span><br><span class=\"line\">                    return this.getParentMessageSource().getMessage(code, null, locale);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">                logger.error(ex.getMessage(), ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return code;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 下面三个重写的方法是比较重要的</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setResourceLoader(ResourceLoader resourceLoader) &#123;</span><br><span class=\"line\">        this.resourceLoader = (resourceLoader == null ? new DefaultResourceLoader() : resourceLoader);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected MessageFormat resolveCode(String code, Locale locale) &#123;</span><br><span class=\"line\">        String msg = getSourceFromCache(code, locale);</span><br><span class=\"line\">        MessageFormat messageFormat = new MessageFormat(msg, locale);</span><br><span class=\"line\">        return messageFormat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected String resolveCodeWithoutArguments(String code, Locale locale) &#123;</span><br><span class=\"line\">        return getSourceFromCache(code, locale);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h4><p> 至此，自定义国际化配置读取数据库已经完成，只需要在更新数据库配置的时候调用一下reload重置一下缓存中的信息即可。</p>\n<blockquote>\n<p><a href=\"!https://blog.csdn.net/u014721131/article/details/79075802\">参考博客：spring xml配置自定义读取数据库的messageSource</a></p>\n</blockquote>"},{"title":"并发编程学习(三)：CountDownLatch的实现原理及使用","date":"2019-06-02T13:36:53.000Z","_content":"![什么是CountDownLatch？](cdl.png)\n\n<!--more-->\n\n### 什么是`CountDownLatch`？\n\n  在本篇博客的封面，我放了一个截图，上面对于`CountDownLatch`的翻译是这样的：*闭锁，倒计时门闩*。其实顾名思义，`CountDownLatch`实际上就是一个计数器：**计数-计数完成后做一些事**。其实这个东西可以类比为一个水坝：当水还没有装满水库的时候水坝是关闭的，当水装满之后开闸放水，水库中的水\"一起\"涌出水库。\n\n  拥有同样功能的还有`CyclicBarrier`这个类，但是这个类相对较复杂，并且相对于`CountDownLatch`还可以重复使用，实际上前者一般被叫做线程计数器，后者被叫做循环屏障，还是有很大区别的。这个 **在后面再进行源码学习**。\n\n### `CountDownLatch`是如何实现的？\n\n  同`ReentrantLock`类似，内部也是有一个实现了`AbstractQueueSynchronizer`的内部类。内部类做了父类的共享式的显示锁的方法实现，维护一个初始为N的状态`state`，每次有线程调用之后阻塞，然后`state`减1，直到减为0之后所有阻塞的线程重新开始执行。\n\n#### 首先是内部类Sync的实现\n  构造器接收一个int参数初始化state的值。`tryAcquireShared()`方法不会对state做改变，当state不为0的时候返回-1即失败，当state等于0其返回1，表示计数器已经计数完成，`await()`方法不再阻塞。`tryReleaseShared()`方法会使用原子操作当`countDown()`被调用的时候释放一个state的占用，即state-1。\n\n```\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n      private static final long serialVersionUID = 4982264981922014374L;\n      Sync(int count) {\n          setState(count);\n      }\n      int getCount() {\n          return getState();\n      }\n      protected int tryAcquireShared(int acquires) {\n          return (getState() == 0) ? 1 : -1;\n      }\n      protected boolean tryReleaseShared(int releases) {\n          // Decrement count; signal when transition to zero\n          for (;;) {\n              int c = getState();\n              if (c == 0)\n                  return false;\n              int nextc = c-1;\n              if (compareAndSetState(c, nextc))\n                  return nextc == 0;\n          }\n      }\n}\n```\n\n#### CountDownLatch的countDown方法\n  countDown方法主要作用就是使state-1\n\n```\npublic void countDown() {\n    sync.releaseShared(1);\n}\n```\n\n  AQS中的`releaseShared()`方法的实现，如果释放成功执行`doReleaseShared();`\n\n```\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n```\n\n#### CountDownLatch的await方法\n  await方法会等待当前state值是否是0，如果不是的话就一直阻塞。直到state为0。\n\n```\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\npublic boolean await(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n}\n```\n\n  AQS中的`acquireSharedInterruptibly()`方法实现如下，在AQS的实现中，判断当前线程是否中断，是的话抛出中断异常，否则判断当前线程是否继续需要阻塞，即调用`tryAcquireShared()`。是的话进入`doAcquireSharedInterruptibly()`方法，不断的判断`int r = tryAcquireShared(arg);`，state如果一直不等于0，r就一直是负数，就会继续进入循环。\n```\npublic final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n/**\n * Acquires in shared interruptible mode.\n * @param arg the acquire argument\n */\nprivate void doAcquireSharedInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n其实以上代码的整体流程非常简单，即初始化`CountDownLatch`的state=N，每次调用countDown时state-1，减到0的时候停止阻塞，继续向下执行。\n\n### 我可以用`CountDownLatch`来做什么事情？\n#### 使用`CountDownLatch`模拟并发场景\n- 可以使用`CountDownLatch`，创建多个线程并等待线程全部就绪之后唤醒所有线程。可以用这种方式测试代码的可用性，或者测试单例类等；\n\n我在自己学习过程中也有写过类似的测试类 - [github](https://github.com/Fatezhang/Concurrent/tree/master/src/main/java/com/mime/concurrent/CountDownLatchStudy)\n\n#### 使用`CountDownLatch`等待依赖线程执行\n- `CountDownLatch`用来等待其他依赖服务都启动好之后在进行自身线程的任务处理\n\n### 总结\n  `CountDownLatch`是面试的时候多线程这块很容易被问到的点，实际上会考察这几个方面：\n  - 1、内部实现原理 **——** 使用内部类继承AQS实现；\n  - 2、需要注意的方面 **——** 计数器为0时，await后面的方法才会执行，否则一直阻塞，countDown方法尽量写在finally代码块中，避免出现异常导致死锁；\n  - 3、使用场景 **——** 监控一些依赖服务启动完成之后执行代码，或者造“水坝”，即模拟大量并发场景等。\n","source":"_posts/并发编程学习-三-：CountDownLatch的实现原理及使用.md","raw":"---\ntitle: 并发编程学习(三)：CountDownLatch的实现原理及使用\ndate: 2019-06-02 21:36:53\ncategories: [Java基础,并发编程]\ntags: [Java基础,并发编程,AQS,CountDownLatch]\n---\n![什么是CountDownLatch？](cdl.png)\n\n<!--more-->\n\n### 什么是`CountDownLatch`？\n\n  在本篇博客的封面，我放了一个截图，上面对于`CountDownLatch`的翻译是这样的：*闭锁，倒计时门闩*。其实顾名思义，`CountDownLatch`实际上就是一个计数器：**计数-计数完成后做一些事**。其实这个东西可以类比为一个水坝：当水还没有装满水库的时候水坝是关闭的，当水装满之后开闸放水，水库中的水\"一起\"涌出水库。\n\n  拥有同样功能的还有`CyclicBarrier`这个类，但是这个类相对较复杂，并且相对于`CountDownLatch`还可以重复使用，实际上前者一般被叫做线程计数器，后者被叫做循环屏障，还是有很大区别的。这个 **在后面再进行源码学习**。\n\n### `CountDownLatch`是如何实现的？\n\n  同`ReentrantLock`类似，内部也是有一个实现了`AbstractQueueSynchronizer`的内部类。内部类做了父类的共享式的显示锁的方法实现，维护一个初始为N的状态`state`，每次有线程调用之后阻塞，然后`state`减1，直到减为0之后所有阻塞的线程重新开始执行。\n\n#### 首先是内部类Sync的实现\n  构造器接收一个int参数初始化state的值。`tryAcquireShared()`方法不会对state做改变，当state不为0的时候返回-1即失败，当state等于0其返回1，表示计数器已经计数完成，`await()`方法不再阻塞。`tryReleaseShared()`方法会使用原子操作当`countDown()`被调用的时候释放一个state的占用，即state-1。\n\n```\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n      private static final long serialVersionUID = 4982264981922014374L;\n      Sync(int count) {\n          setState(count);\n      }\n      int getCount() {\n          return getState();\n      }\n      protected int tryAcquireShared(int acquires) {\n          return (getState() == 0) ? 1 : -1;\n      }\n      protected boolean tryReleaseShared(int releases) {\n          // Decrement count; signal when transition to zero\n          for (;;) {\n              int c = getState();\n              if (c == 0)\n                  return false;\n              int nextc = c-1;\n              if (compareAndSetState(c, nextc))\n                  return nextc == 0;\n          }\n      }\n}\n```\n\n#### CountDownLatch的countDown方法\n  countDown方法主要作用就是使state-1\n\n```\npublic void countDown() {\n    sync.releaseShared(1);\n}\n```\n\n  AQS中的`releaseShared()`方法的实现，如果释放成功执行`doReleaseShared();`\n\n```\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n```\n\n#### CountDownLatch的await方法\n  await方法会等待当前state值是否是0，如果不是的话就一直阻塞。直到state为0。\n\n```\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\npublic boolean await(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n}\n```\n\n  AQS中的`acquireSharedInterruptibly()`方法实现如下，在AQS的实现中，判断当前线程是否中断，是的话抛出中断异常，否则判断当前线程是否继续需要阻塞，即调用`tryAcquireShared()`。是的话进入`doAcquireSharedInterruptibly()`方法，不断的判断`int r = tryAcquireShared(arg);`，state如果一直不等于0，r就一直是负数，就会继续进入循环。\n```\npublic final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n/**\n * Acquires in shared interruptible mode.\n * @param arg the acquire argument\n */\nprivate void doAcquireSharedInterruptibly(int arg)\n    throws InterruptedException {\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n其实以上代码的整体流程非常简单，即初始化`CountDownLatch`的state=N，每次调用countDown时state-1，减到0的时候停止阻塞，继续向下执行。\n\n### 我可以用`CountDownLatch`来做什么事情？\n#### 使用`CountDownLatch`模拟并发场景\n- 可以使用`CountDownLatch`，创建多个线程并等待线程全部就绪之后唤醒所有线程。可以用这种方式测试代码的可用性，或者测试单例类等；\n\n我在自己学习过程中也有写过类似的测试类 - [github](https://github.com/Fatezhang/Concurrent/tree/master/src/main/java/com/mime/concurrent/CountDownLatchStudy)\n\n#### 使用`CountDownLatch`等待依赖线程执行\n- `CountDownLatch`用来等待其他依赖服务都启动好之后在进行自身线程的任务处理\n\n### 总结\n  `CountDownLatch`是面试的时候多线程这块很容易被问到的点，实际上会考察这几个方面：\n  - 1、内部实现原理 **——** 使用内部类继承AQS实现；\n  - 2、需要注意的方面 **——** 计数器为0时，await后面的方法才会执行，否则一直阻塞，countDown方法尽量写在finally代码块中，避免出现异常导致死锁；\n  - 3、使用场景 **——** 监控一些依赖服务启动完成之后执行代码，或者造“水坝”，即模拟大量并发场景等。\n","slug":"并发编程学习-三-：CountDownLatch的实现原理及使用","published":1,"updated":"2019-06-17T06:18:02.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvj001ccwnkew6hbvzl","content":"<p><img src=\"/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png\" alt=\"什么是CountDownLatch？\"></p>\n<a id=\"more\"></a>\n<h3 id=\"什么是CountDownLatch？\"><a href=\"#什么是CountDownLatch？\" class=\"headerlink\" title=\"什么是CountDownLatch？\"></a>什么是<code>CountDownLatch</code>？</h3><p>  在本篇博客的封面，我放了一个截图，上面对于<code>CountDownLatch</code>的翻译是这样的：<em>闭锁，倒计时门闩</em>。其实顾名思义，<code>CountDownLatch</code>实际上就是一个计数器：<strong>计数-计数完成后做一些事</strong>。其实这个东西可以类比为一个水坝：当水还没有装满水库的时候水坝是关闭的，当水装满之后开闸放水，水库中的水”一起”涌出水库。</p>\n<p>  拥有同样功能的还有<code>CyclicBarrier</code>这个类，但是这个类相对较复杂，并且相对于<code>CountDownLatch</code>还可以重复使用，实际上前者一般被叫做线程计数器，后者被叫做循环屏障，还是有很大区别的。这个 <strong>在后面再进行源码学习</strong>。</p>\n<h3 id=\"CountDownLatch是如何实现的？\"><a href=\"#CountDownLatch是如何实现的？\" class=\"headerlink\" title=\"CountDownLatch是如何实现的？\"></a><code>CountDownLatch</code>是如何实现的？</h3><p>  同<code>ReentrantLock</code>类似，内部也是有一个实现了<code>AbstractQueueSynchronizer</code>的内部类。内部类做了父类的共享式的显示锁的方法实现，维护一个初始为N的状态<code>state</code>，每次有线程调用之后阻塞，然后<code>state</code>减1，直到减为0之后所有阻塞的线程重新开始执行。</p>\n<h4 id=\"首先是内部类Sync的实现\"><a href=\"#首先是内部类Sync的实现\" class=\"headerlink\" title=\"首先是内部类Sync的实现\"></a>首先是内部类Sync的实现</h4><p>  构造器接收一个int参数初始化state的值。<code>tryAcquireShared()</code>方法不会对state做改变，当state不为0的时候返回-1即失败，当state等于0其返回1，表示计数器已经计数完成，<code>await()</code>方法不再阻塞。<code>tryReleaseShared()</code>方法会使用原子操作当<code>countDown()</code>被调用的时候释放一个state的占用，即state-1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class=\"line\">      private static final long serialVersionUID = 4982264981922014374L;</span><br><span class=\"line\">      Sync(int count) &#123;</span><br><span class=\"line\">          setState(count);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      int getCount() &#123;</span><br><span class=\"line\">          return getState();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      protected int tryAcquireShared(int acquires) &#123;</span><br><span class=\"line\">          return (getState() == 0) ? 1 : -1;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      protected boolean tryReleaseShared(int releases) &#123;</span><br><span class=\"line\">          // Decrement count; signal when transition to zero</span><br><span class=\"line\">          for (;;) &#123;</span><br><span class=\"line\">              int c = getState();</span><br><span class=\"line\">              if (c == 0)</span><br><span class=\"line\">                  return false;</span><br><span class=\"line\">              int nextc = c-1;</span><br><span class=\"line\">              if (compareAndSetState(c, nextc))</span><br><span class=\"line\">                  return nextc == 0;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CountDownLatch的countDown方法\"><a href=\"#CountDownLatch的countDown方法\" class=\"headerlink\" title=\"CountDownLatch的countDown方法\"></a>CountDownLatch的countDown方法</h4><p>  countDown方法主要作用就是使state-1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void countDown() &#123;</span><br><span class=\"line\">    sync.releaseShared(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  AQS中的<code>releaseShared()</code>方法的实现，如果释放成功执行<code>doReleaseShared();</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final boolean releaseShared(int arg) &#123;</span><br><span class=\"line\">    if (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CountDownLatch的await方法\"><a href=\"#CountDownLatch的await方法\" class=\"headerlink\" title=\"CountDownLatch的await方法\"></a>CountDownLatch的await方法</h4><p>  await方法会等待当前state值是否是0，如果不是的话就一直阻塞。直到state为0。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void await() throws InterruptedException &#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public boolean await(long timeout, TimeUnit unit)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  AQS中的<code>acquireSharedInterruptibly()</code>方法实现如下，在AQS的实现中，判断当前线程是否中断，是的话抛出中断异常，否则判断当前线程是否继续需要阻塞，即调用<code>tryAcquireShared()</code>。是的话进入<code>doAcquireSharedInterruptibly()</code>方法，不断的判断<code>int r = tryAcquireShared(arg);</code>，state如果一直不等于0，r就一直是负数，就会继续进入循环。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void acquireSharedInterruptibly(int arg)</span><br><span class=\"line\">        throws InterruptedException &#123;</span><br><span class=\"line\">    if (Thread.interrupted())</span><br><span class=\"line\">        throw new InterruptedException();</span><br><span class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Acquires in shared interruptible mode.</span><br><span class=\"line\"> * @param arg the acquire argument</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void doAcquireSharedInterruptibly(int arg)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    final Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    boolean failed = true;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            final Node p = node.predecessor();</span><br><span class=\"line\">            if (p == head) &#123;</span><br><span class=\"line\">                int r = tryAcquireShared(arg);</span><br><span class=\"line\">                if (r &gt;= 0) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    p.next = null; // help GC</span><br><span class=\"line\">                    failed = false;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                throw new InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实以上代码的整体流程非常简单，即初始化<code>CountDownLatch</code>的state=N，每次调用countDown时state-1，减到0的时候停止阻塞，继续向下执行。</p>\n<h3 id=\"我可以用CountDownLatch来做什么事情？\"><a href=\"#我可以用CountDownLatch来做什么事情？\" class=\"headerlink\" title=\"我可以用CountDownLatch来做什么事情？\"></a>我可以用<code>CountDownLatch</code>来做什么事情？</h3><h4 id=\"使用CountDownLatch模拟并发场景\"><a href=\"#使用CountDownLatch模拟并发场景\" class=\"headerlink\" title=\"使用CountDownLatch模拟并发场景\"></a>使用<code>CountDownLatch</code>模拟并发场景</h4><ul>\n<li>可以使用<code>CountDownLatch</code>，创建多个线程并等待线程全部就绪之后唤醒所有线程。可以用这种方式测试代码的可用性，或者测试单例类等；</li>\n</ul>\n<p>我在自己学习过程中也有写过类似的测试类 - <a href=\"https://github.com/Fatezhang/Concurrent/tree/master/src/main/java/com/mime/concurrent/CountDownLatchStudy\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<h4 id=\"使用CountDownLatch等待依赖线程执行\"><a href=\"#使用CountDownLatch等待依赖线程执行\" class=\"headerlink\" title=\"使用CountDownLatch等待依赖线程执行\"></a>使用<code>CountDownLatch</code>等待依赖线程执行</h4><ul>\n<li><code>CountDownLatch</code>用来等待其他依赖服务都启动好之后在进行自身线程的任务处理</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>  <code>CountDownLatch</code>是面试的时候多线程这块很容易被问到的点，实际上会考察这几个方面：</p>\n<ul>\n<li>1、内部实现原理 <strong>——</strong> 使用内部类继承AQS实现；</li>\n<li>2、需要注意的方面 <strong>——</strong> 计数器为0时，await后面的方法才会执行，否则一直阻塞，countDown方法尽量写在finally代码块中，避免出现异常导致死锁；</li>\n<li>3、使用场景 <strong>——</strong> 监控一些依赖服务启动完成之后执行代码，或者造“水坝”，即模拟大量并发场景等。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png\" alt=\"什么是CountDownLatch？\"></p>","more":"<h3 id=\"什么是CountDownLatch？\"><a href=\"#什么是CountDownLatch？\" class=\"headerlink\" title=\"什么是CountDownLatch？\"></a>什么是<code>CountDownLatch</code>？</h3><p>  在本篇博客的封面，我放了一个截图，上面对于<code>CountDownLatch</code>的翻译是这样的：<em>闭锁，倒计时门闩</em>。其实顾名思义，<code>CountDownLatch</code>实际上就是一个计数器：<strong>计数-计数完成后做一些事</strong>。其实这个东西可以类比为一个水坝：当水还没有装满水库的时候水坝是关闭的，当水装满之后开闸放水，水库中的水”一起”涌出水库。</p>\n<p>  拥有同样功能的还有<code>CyclicBarrier</code>这个类，但是这个类相对较复杂，并且相对于<code>CountDownLatch</code>还可以重复使用，实际上前者一般被叫做线程计数器，后者被叫做循环屏障，还是有很大区别的。这个 <strong>在后面再进行源码学习</strong>。</p>\n<h3 id=\"CountDownLatch是如何实现的？\"><a href=\"#CountDownLatch是如何实现的？\" class=\"headerlink\" title=\"CountDownLatch是如何实现的？\"></a><code>CountDownLatch</code>是如何实现的？</h3><p>  同<code>ReentrantLock</code>类似，内部也是有一个实现了<code>AbstractQueueSynchronizer</code>的内部类。内部类做了父类的共享式的显示锁的方法实现，维护一个初始为N的状态<code>state</code>，每次有线程调用之后阻塞，然后<code>state</code>减1，直到减为0之后所有阻塞的线程重新开始执行。</p>\n<h4 id=\"首先是内部类Sync的实现\"><a href=\"#首先是内部类Sync的实现\" class=\"headerlink\" title=\"首先是内部类Sync的实现\"></a>首先是内部类Sync的实现</h4><p>  构造器接收一个int参数初始化state的值。<code>tryAcquireShared()</code>方法不会对state做改变，当state不为0的时候返回-1即失败，当state等于0其返回1，表示计数器已经计数完成，<code>await()</code>方法不再阻塞。<code>tryReleaseShared()</code>方法会使用原子操作当<code>countDown()</code>被调用的时候释放一个state的占用，即state-1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class=\"line\">      private static final long serialVersionUID = 4982264981922014374L;</span><br><span class=\"line\">      Sync(int count) &#123;</span><br><span class=\"line\">          setState(count);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      int getCount() &#123;</span><br><span class=\"line\">          return getState();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      protected int tryAcquireShared(int acquires) &#123;</span><br><span class=\"line\">          return (getState() == 0) ? 1 : -1;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      protected boolean tryReleaseShared(int releases) &#123;</span><br><span class=\"line\">          // Decrement count; signal when transition to zero</span><br><span class=\"line\">          for (;;) &#123;</span><br><span class=\"line\">              int c = getState();</span><br><span class=\"line\">              if (c == 0)</span><br><span class=\"line\">                  return false;</span><br><span class=\"line\">              int nextc = c-1;</span><br><span class=\"line\">              if (compareAndSetState(c, nextc))</span><br><span class=\"line\">                  return nextc == 0;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CountDownLatch的countDown方法\"><a href=\"#CountDownLatch的countDown方法\" class=\"headerlink\" title=\"CountDownLatch的countDown方法\"></a>CountDownLatch的countDown方法</h4><p>  countDown方法主要作用就是使state-1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void countDown() &#123;</span><br><span class=\"line\">    sync.releaseShared(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  AQS中的<code>releaseShared()</code>方法的实现，如果释放成功执行<code>doReleaseShared();</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final boolean releaseShared(int arg) &#123;</span><br><span class=\"line\">    if (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"CountDownLatch的await方法\"><a href=\"#CountDownLatch的await方法\" class=\"headerlink\" title=\"CountDownLatch的await方法\"></a>CountDownLatch的await方法</h4><p>  await方法会等待当前state值是否是0，如果不是的话就一直阻塞。直到state为0。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void await() throws InterruptedException &#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public boolean await(long timeout, TimeUnit unit)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  AQS中的<code>acquireSharedInterruptibly()</code>方法实现如下，在AQS的实现中，判断当前线程是否中断，是的话抛出中断异常，否则判断当前线程是否继续需要阻塞，即调用<code>tryAcquireShared()</code>。是的话进入<code>doAcquireSharedInterruptibly()</code>方法，不断的判断<code>int r = tryAcquireShared(arg);</code>，state如果一直不等于0，r就一直是负数，就会继续进入循环。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void acquireSharedInterruptibly(int arg)</span><br><span class=\"line\">        throws InterruptedException &#123;</span><br><span class=\"line\">    if (Thread.interrupted())</span><br><span class=\"line\">        throw new InterruptedException();</span><br><span class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Acquires in shared interruptible mode.</span><br><span class=\"line\"> * @param arg the acquire argument</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void doAcquireSharedInterruptibly(int arg)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    final Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    boolean failed = true;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            final Node p = node.predecessor();</span><br><span class=\"line\">            if (p == head) &#123;</span><br><span class=\"line\">                int r = tryAcquireShared(arg);</span><br><span class=\"line\">                if (r &gt;= 0) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    p.next = null; // help GC</span><br><span class=\"line\">                    failed = false;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                throw new InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实以上代码的整体流程非常简单，即初始化<code>CountDownLatch</code>的state=N，每次调用countDown时state-1，减到0的时候停止阻塞，继续向下执行。</p>\n<h3 id=\"我可以用CountDownLatch来做什么事情？\"><a href=\"#我可以用CountDownLatch来做什么事情？\" class=\"headerlink\" title=\"我可以用CountDownLatch来做什么事情？\"></a>我可以用<code>CountDownLatch</code>来做什么事情？</h3><h4 id=\"使用CountDownLatch模拟并发场景\"><a href=\"#使用CountDownLatch模拟并发场景\" class=\"headerlink\" title=\"使用CountDownLatch模拟并发场景\"></a>使用<code>CountDownLatch</code>模拟并发场景</h4><ul>\n<li>可以使用<code>CountDownLatch</code>，创建多个线程并等待线程全部就绪之后唤醒所有线程。可以用这种方式测试代码的可用性，或者测试单例类等；</li>\n</ul>\n<p>我在自己学习过程中也有写过类似的测试类 - <a href=\"https://github.com/Fatezhang/Concurrent/tree/master/src/main/java/com/mime/concurrent/CountDownLatchStudy\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<h4 id=\"使用CountDownLatch等待依赖线程执行\"><a href=\"#使用CountDownLatch等待依赖线程执行\" class=\"headerlink\" title=\"使用CountDownLatch等待依赖线程执行\"></a>使用<code>CountDownLatch</code>等待依赖线程执行</h4><ul>\n<li><code>CountDownLatch</code>用来等待其他依赖服务都启动好之后在进行自身线程的任务处理</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>  <code>CountDownLatch</code>是面试的时候多线程这块很容易被问到的点，实际上会考察这几个方面：</p>\n<ul>\n<li>1、内部实现原理 <strong>——</strong> 使用内部类继承AQS实现；</li>\n<li>2、需要注意的方面 <strong>——</strong> 计数器为0时，await后面的方法才会执行，否则一直阻塞，countDown方法尽量写在finally代码块中，避免出现异常导致死锁；</li>\n<li>3、使用场景 <strong>——</strong> 监控一些依赖服务启动完成之后执行代码，或者造“水坝”，即模拟大量并发场景等。</li>\n</ul>"},{"title":"并发编程学习(二)：使用AQS编写可重入锁","date":"2019-05-25T06:07:35.000Z","_content":"![AQS中文文档介绍](aqs.png)\n<div style=\"width:100%;text-align: center;\"><a href=\"http://www.matools.com/api/java8\">AQS中文文档介绍</a></div>\n\n<!--more-->\n\n----------\n### 前言\n** [上一章](/blog/20190517/编写一个简易的可重入锁-一/) ** 我使用实现`Lock`接口的方式并结合`Synchronized`关键字实现了自己的可重入锁，学习并了解了可重入锁的原理机制。这一章我在学习了AQS之后结合AQS实现自己的显示可重入锁。\n\n### 什么是AQS\n如上所述，Java8中文文档中描述的，AQS即`AbstractQueuedSynchronizer`。它提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状态。 子类必须定义改变此状态的受保护方法，以及根据该对象被获取或释放来定义该状态的含义。 给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。**子类应定义为非公共内部助手类，用于实现其封闭类的同步属性。 AbstractQueuedSynchronizer类不实现任何同步接口。 相反，它定义了一些方法，如acquireInterruptibly(int) ，可以通过具体的锁和相关同步器来调用适当履行其公共方法。**\n\n其实AQS类是一个使用了模板方法模式的抽象框架类。它将核心实现封装在模板方法中，提供给程序员去实现具体的加锁和释放的机制，以便于实现一些特殊功能的锁，比如JDK提供的可重入锁和可重入读写锁等等。\n\n### 如何使用AQS\n**AQS在使用的时候主要需要重写以下方法**\n- `isHeldExclusively()`：该线程是否正在独占资源。只有用到condition才需要去实现它。\n- `tryAcquire(int)`：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n- `tryRelease(int)`：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n- `tryAcquireShared(int)`：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n- `tryReleaseShared(int)`：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n### 使用AQS实现自己的可重入独占非公平锁的伪代码如下\n\n#### 加锁步骤伪代码\n线程调用`lock`方法加锁，直接调用`sync.acquire(1);`，具体实现在`tryAcquire`\n- 首先线程进入想要获取锁\n- 拿到当前线程的引用\n- 判断加锁状态，如果是未加锁状态\n  - 使用`compareAndSetState`自旋原子操作加锁\n  - 设置当前线程\n  - 返回true加锁成功\n- 如果是加锁状态\n  - 判断是否是当前线程重入\n  - 如果是当前线程重入，state加1，并返回true加锁成功\n- 最后如果都不是就返回false加锁失败\n\n#### 释放锁步骤伪代码\n线程调用`unLock`方法加锁，直接调用`sync.release(1);`，具体实现在`tryRelease`\n- 首先线程进入方法想要释放锁\n- 判断如果不是当前线程，就抛出异常\n- 如果是当前线程，state就减1（arg一般为1），表示释放一次\n- 当state释放到0时，设置拥有锁的线程为null，然后返回true\n\n**具体的代码实现如下**\n\n```\n\n/**\n * @Author zhangjiaheng\n * @Description 使用AQS重写一个可重入锁\n **/\npublic class MyReentrantLockByAQS implements Lock {\n\n    private Sync sync = new Sync();\n\n    // 内部类Sync ReentrantLock使用的内部抽象类 并派生两个子类实现两种(公平/非公平)锁\n    private class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            Thread t = Thread.currentThread();\n            // 如果第一个线程进来 可以拿到锁 则返回true\n\n            // 如果第二个线程进来 如果不等于当前线程 返回false 否则更新当前线程值\n\n            int state = getState();\n            if (state == 0) {\n                while (compareAndSetState(0, 1)) {\n                    setExclusiveOwnerThread(t);\n                    return true;\n                }\n            } else if (t == getExclusiveOwnerThread()) {\n                // 当前线程再进来\n                setState(getState() + 1);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            // 锁的获取和释放时一一对应的\n            // 调用此方法的线程肯定是当前线程\n            if (Thread.currentThread() != getExclusiveOwnerThread()) {\n                throw new RuntimeException();\n            }\n            int c = getState() - arg;\n            boolean flag = false;\n            if (c == 0) {\n                setExclusiveOwnerThread(null);\n                flag = true;\n            }\n            setState(c);\n            return flag;\n        }\n\n        public Condition newCondition() {\n            return newCondition();\n        }\n    }\n\n    @Override\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    @Override\n    public void lockInterruptibly() throws InterruptedException {\n        sync.acquireInterruptibly(1);\n    }\n\n    @Override\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n\n    @Override\n    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {\n        return sync.tryAcquireNanos(1, unit.toNanos(time));\n    }\n\n    @Override\n    public void unlock() {\n        sync.release(1);\n    }\n\n    @Override\n    public Condition newCondition() {\n        return sync.newCondition();\n    }\n}\n```\n","source":"_posts/并发编程学习-二-：使用AQS编写可重入锁.md","raw":"---\ntitle: 并发编程学习(二)：使用AQS编写可重入锁\ndate: 2019-05-25 14:07:35\ncategories: [Java基础,并发编程]\ntags: [Java基础,并发编程,可重入锁,AQS]\n---\n![AQS中文文档介绍](aqs.png)\n<div style=\"width:100%;text-align: center;\"><a href=\"http://www.matools.com/api/java8\">AQS中文文档介绍</a></div>\n\n<!--more-->\n\n----------\n### 前言\n** [上一章](/blog/20190517/编写一个简易的可重入锁-一/) ** 我使用实现`Lock`接口的方式并结合`Synchronized`关键字实现了自己的可重入锁，学习并了解了可重入锁的原理机制。这一章我在学习了AQS之后结合AQS实现自己的显示可重入锁。\n\n### 什么是AQS\n如上所述，Java8中文文档中描述的，AQS即`AbstractQueuedSynchronizer`。它提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状态。 子类必须定义改变此状态的受保护方法，以及根据该对象被获取或释放来定义该状态的含义。 给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。**子类应定义为非公共内部助手类，用于实现其封闭类的同步属性。 AbstractQueuedSynchronizer类不实现任何同步接口。 相反，它定义了一些方法，如acquireInterruptibly(int) ，可以通过具体的锁和相关同步器来调用适当履行其公共方法。**\n\n其实AQS类是一个使用了模板方法模式的抽象框架类。它将核心实现封装在模板方法中，提供给程序员去实现具体的加锁和释放的机制，以便于实现一些特殊功能的锁，比如JDK提供的可重入锁和可重入读写锁等等。\n\n### 如何使用AQS\n**AQS在使用的时候主要需要重写以下方法**\n- `isHeldExclusively()`：该线程是否正在独占资源。只有用到condition才需要去实现它。\n- `tryAcquire(int)`：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n- `tryRelease(int)`：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n- `tryAcquireShared(int)`：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n- `tryReleaseShared(int)`：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n### 使用AQS实现自己的可重入独占非公平锁的伪代码如下\n\n#### 加锁步骤伪代码\n线程调用`lock`方法加锁，直接调用`sync.acquire(1);`，具体实现在`tryAcquire`\n- 首先线程进入想要获取锁\n- 拿到当前线程的引用\n- 判断加锁状态，如果是未加锁状态\n  - 使用`compareAndSetState`自旋原子操作加锁\n  - 设置当前线程\n  - 返回true加锁成功\n- 如果是加锁状态\n  - 判断是否是当前线程重入\n  - 如果是当前线程重入，state加1，并返回true加锁成功\n- 最后如果都不是就返回false加锁失败\n\n#### 释放锁步骤伪代码\n线程调用`unLock`方法加锁，直接调用`sync.release(1);`，具体实现在`tryRelease`\n- 首先线程进入方法想要释放锁\n- 判断如果不是当前线程，就抛出异常\n- 如果是当前线程，state就减1（arg一般为1），表示释放一次\n- 当state释放到0时，设置拥有锁的线程为null，然后返回true\n\n**具体的代码实现如下**\n\n```\n\n/**\n * @Author zhangjiaheng\n * @Description 使用AQS重写一个可重入锁\n **/\npublic class MyReentrantLockByAQS implements Lock {\n\n    private Sync sync = new Sync();\n\n    // 内部类Sync ReentrantLock使用的内部抽象类 并派生两个子类实现两种(公平/非公平)锁\n    private class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            Thread t = Thread.currentThread();\n            // 如果第一个线程进来 可以拿到锁 则返回true\n\n            // 如果第二个线程进来 如果不等于当前线程 返回false 否则更新当前线程值\n\n            int state = getState();\n            if (state == 0) {\n                while (compareAndSetState(0, 1)) {\n                    setExclusiveOwnerThread(t);\n                    return true;\n                }\n            } else if (t == getExclusiveOwnerThread()) {\n                // 当前线程再进来\n                setState(getState() + 1);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            // 锁的获取和释放时一一对应的\n            // 调用此方法的线程肯定是当前线程\n            if (Thread.currentThread() != getExclusiveOwnerThread()) {\n                throw new RuntimeException();\n            }\n            int c = getState() - arg;\n            boolean flag = false;\n            if (c == 0) {\n                setExclusiveOwnerThread(null);\n                flag = true;\n            }\n            setState(c);\n            return flag;\n        }\n\n        public Condition newCondition() {\n            return newCondition();\n        }\n    }\n\n    @Override\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    @Override\n    public void lockInterruptibly() throws InterruptedException {\n        sync.acquireInterruptibly(1);\n    }\n\n    @Override\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n\n    @Override\n    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {\n        return sync.tryAcquireNanos(1, unit.toNanos(time));\n    }\n\n    @Override\n    public void unlock() {\n        sync.release(1);\n    }\n\n    @Override\n    public Condition newCondition() {\n        return sync.newCondition();\n    }\n}\n```\n","slug":"并发编程学习-二-：使用AQS编写可重入锁","published":1,"updated":"2019-06-17T06:18:02.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvl001gcwnkq4f5bq1p","content":"<p><img src=\"/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/aqs.png\" alt=\"AQS中文文档介绍\"></p>\n<div style=\"width:100%;text-align: center;\"><a href=\"http://www.matools.com/api/java8\" target=\"_blank\" rel=\"noopener\">AQS中文文档介绍</a></div>\n\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><strong> <a href=\"/blog/20190517/编写一个简易的可重入锁-一/\">上一章</a> </strong> 我使用实现<code>Lock</code>接口的方式并结合<code>Synchronized</code>关键字实现了自己的可重入锁，学习并了解了可重入锁的原理机制。这一章我在学习了AQS之后结合AQS实现自己的显示可重入锁。</p>\n<h3 id=\"什么是AQS\"><a href=\"#什么是AQS\" class=\"headerlink\" title=\"什么是AQS\"></a>什么是AQS</h3><p>如上所述，Java8中文文档中描述的，AQS即<code>AbstractQueuedSynchronizer</code>。它提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状态。 子类必须定义改变此状态的受保护方法，以及根据该对象被获取或释放来定义该状态的含义。 给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。<strong>子类应定义为非公共内部助手类，用于实现其封闭类的同步属性。 AbstractQueuedSynchronizer类不实现任何同步接口。 相反，它定义了一些方法，如acquireInterruptibly(int) ，可以通过具体的锁和相关同步器来调用适当履行其公共方法。</strong></p>\n<p>其实AQS类是一个使用了模板方法模式的抽象框架类。它将核心实现封装在模板方法中，提供给程序员去实现具体的加锁和释放的机制，以便于实现一些特殊功能的锁，比如JDK提供的可重入锁和可重入读写锁等等。</p>\n<h3 id=\"如何使用AQS\"><a href=\"#如何使用AQS\" class=\"headerlink\" title=\"如何使用AQS\"></a>如何使用AQS</h3><p><strong>AQS在使用的时候主要需要重写以下方法</strong></p>\n<ul>\n<li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>\n<li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>\n<li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>\n<li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>\n<li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>\n</ul>\n<h3 id=\"使用AQS实现自己的可重入独占非公平锁的伪代码如下\"><a href=\"#使用AQS实现自己的可重入独占非公平锁的伪代码如下\" class=\"headerlink\" title=\"使用AQS实现自己的可重入独占非公平锁的伪代码如下\"></a>使用AQS实现自己的可重入独占非公平锁的伪代码如下</h3><h4 id=\"加锁步骤伪代码\"><a href=\"#加锁步骤伪代码\" class=\"headerlink\" title=\"加锁步骤伪代码\"></a>加锁步骤伪代码</h4><p>线程调用<code>lock</code>方法加锁，直接调用<code>sync.acquire(1);</code>，具体实现在<code>tryAcquire</code></p>\n<ul>\n<li>首先线程进入想要获取锁</li>\n<li>拿到当前线程的引用</li>\n<li>判断加锁状态，如果是未加锁状态<ul>\n<li>使用<code>compareAndSetState</code>自旋原子操作加锁</li>\n<li>设置当前线程</li>\n<li>返回true加锁成功</li>\n</ul>\n</li>\n<li>如果是加锁状态<ul>\n<li>判断是否是当前线程重入</li>\n<li>如果是当前线程重入，state加1，并返回true加锁成功</li>\n</ul>\n</li>\n<li>最后如果都不是就返回false加锁失败</li>\n</ul>\n<h4 id=\"释放锁步骤伪代码\"><a href=\"#释放锁步骤伪代码\" class=\"headerlink\" title=\"释放锁步骤伪代码\"></a>释放锁步骤伪代码</h4><p>线程调用<code>unLock</code>方法加锁，直接调用<code>sync.release(1);</code>，具体实现在<code>tryRelease</code></p>\n<ul>\n<li>首先线程进入方法想要释放锁</li>\n<li>判断如果不是当前线程，就抛出异常</li>\n<li>如果是当前线程，state就减1（arg一般为1），表示释放一次</li>\n<li>当state释放到0时，设置拥有锁的线程为null，然后返回true</li>\n</ul>\n<p><strong>具体的代码实现如下</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Author zhangjiaheng</span><br><span class=\"line\"> * @Description 使用AQS重写一个可重入锁</span><br><span class=\"line\"> **/</span><br><span class=\"line\">public class MyReentrantLockByAQS implements Lock &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Sync sync = new Sync();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 内部类Sync ReentrantLock使用的内部抽象类 并派生两个子类实现两种(公平/非公平)锁</span><br><span class=\"line\">    private class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryAcquire(int arg) &#123;</span><br><span class=\"line\">            Thread t = Thread.currentThread();</span><br><span class=\"line\">            // 如果第一个线程进来 可以拿到锁 则返回true</span><br><span class=\"line\"></span><br><span class=\"line\">            // 如果第二个线程进来 如果不等于当前线程 返回false 否则更新当前线程值</span><br><span class=\"line\"></span><br><span class=\"line\">            int state = getState();</span><br><span class=\"line\">            if (state == 0) &#123;</span><br><span class=\"line\">                while (compareAndSetState(0, 1)) &#123;</span><br><span class=\"line\">                    setExclusiveOwnerThread(t);</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else if (t == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">                // 当前线程再进来</span><br><span class=\"line\">                setState(getState() + 1);</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryRelease(int arg) &#123;</span><br><span class=\"line\">            // 锁的获取和释放时一一对应的</span><br><span class=\"line\">            // 调用此方法的线程肯定是当前线程</span><br><span class=\"line\">            if (Thread.currentThread() != getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">                throw new RuntimeException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            int c = getState() - arg;</span><br><span class=\"line\">            boolean flag = false;</span><br><span class=\"line\">            if (c == 0) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(null);</span><br><span class=\"line\">                flag = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            setState(c);</span><br><span class=\"line\">            return flag;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public Condition newCondition() &#123;</span><br><span class=\"line\">            return newCondition();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\">        sync.acquire(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class=\"line\">        sync.acquireInterruptibly(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean tryLock() &#123;</span><br><span class=\"line\">        return sync.tryAcquire(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class=\"line\">        return sync.tryAcquireNanos(1, unit.toNanos(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void unlock() &#123;</span><br><span class=\"line\">        sync.release(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Condition newCondition() &#123;</span><br><span class=\"line\">        return sync.newCondition();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><img src=\"/blog/20190525/并发编程学习-二-：使用AQS编写可重入锁/aqs.png\" alt=\"AQS中文文档介绍\"></p>\n<div style=\"width:100%;text-align: center;\"><a href=\"http://www.matools.com/api/java8\" target=\"_blank\" rel=\"noopener\">AQS中文文档介绍</a></div>","more":"<hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><strong> <a href=\"/blog/20190517/编写一个简易的可重入锁-一/\">上一章</a> </strong> 我使用实现<code>Lock</code>接口的方式并结合<code>Synchronized</code>关键字实现了自己的可重入锁，学习并了解了可重入锁的原理机制。这一章我在学习了AQS之后结合AQS实现自己的显示可重入锁。</p>\n<h3 id=\"什么是AQS\"><a href=\"#什么是AQS\" class=\"headerlink\" title=\"什么是AQS\"></a>什么是AQS</h3><p>如上所述，Java8中文文档中描述的，AQS即<code>AbstractQueuedSynchronizer</code>。它提供了一个框架，用于实现依赖先进先出（FIFO）等待队列的阻塞锁和相关同步器（信号量，事件等）。该类被设计为大多数类型的同步器的有用依据，这些同步器依赖于单个原子int值来表示状态。 子类必须定义改变此状态的受保护方法，以及根据该对象被获取或释放来定义该状态的含义。 给定这些，这个类中的其他方法执行所有排队和阻塞机制。 子类可以保持其他状态字段，但只以原子方式更新int使用方法操纵值getState() ， setState(int)和compareAndSetState(int, int)被跟踪相对于同步。<strong>子类应定义为非公共内部助手类，用于实现其封闭类的同步属性。 AbstractQueuedSynchronizer类不实现任何同步接口。 相反，它定义了一些方法，如acquireInterruptibly(int) ，可以通过具体的锁和相关同步器来调用适当履行其公共方法。</strong></p>\n<p>其实AQS类是一个使用了模板方法模式的抽象框架类。它将核心实现封装在模板方法中，提供给程序员去实现具体的加锁和释放的机制，以便于实现一些特殊功能的锁，比如JDK提供的可重入锁和可重入读写锁等等。</p>\n<h3 id=\"如何使用AQS\"><a href=\"#如何使用AQS\" class=\"headerlink\" title=\"如何使用AQS\"></a>如何使用AQS</h3><p><strong>AQS在使用的时候主要需要重写以下方法</strong></p>\n<ul>\n<li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>\n<li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>\n<li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>\n<li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>\n<li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>\n</ul>\n<h3 id=\"使用AQS实现自己的可重入独占非公平锁的伪代码如下\"><a href=\"#使用AQS实现自己的可重入独占非公平锁的伪代码如下\" class=\"headerlink\" title=\"使用AQS实现自己的可重入独占非公平锁的伪代码如下\"></a>使用AQS实现自己的可重入独占非公平锁的伪代码如下</h3><h4 id=\"加锁步骤伪代码\"><a href=\"#加锁步骤伪代码\" class=\"headerlink\" title=\"加锁步骤伪代码\"></a>加锁步骤伪代码</h4><p>线程调用<code>lock</code>方法加锁，直接调用<code>sync.acquire(1);</code>，具体实现在<code>tryAcquire</code></p>\n<ul>\n<li>首先线程进入想要获取锁</li>\n<li>拿到当前线程的引用</li>\n<li>判断加锁状态，如果是未加锁状态<ul>\n<li>使用<code>compareAndSetState</code>自旋原子操作加锁</li>\n<li>设置当前线程</li>\n<li>返回true加锁成功</li>\n</ul>\n</li>\n<li>如果是加锁状态<ul>\n<li>判断是否是当前线程重入</li>\n<li>如果是当前线程重入，state加1，并返回true加锁成功</li>\n</ul>\n</li>\n<li>最后如果都不是就返回false加锁失败</li>\n</ul>\n<h4 id=\"释放锁步骤伪代码\"><a href=\"#释放锁步骤伪代码\" class=\"headerlink\" title=\"释放锁步骤伪代码\"></a>释放锁步骤伪代码</h4><p>线程调用<code>unLock</code>方法加锁，直接调用<code>sync.release(1);</code>，具体实现在<code>tryRelease</code></p>\n<ul>\n<li>首先线程进入方法想要释放锁</li>\n<li>判断如果不是当前线程，就抛出异常</li>\n<li>如果是当前线程，state就减1（arg一般为1），表示释放一次</li>\n<li>当state释放到0时，设置拥有锁的线程为null，然后返回true</li>\n</ul>\n<p><strong>具体的代码实现如下</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Author zhangjiaheng</span><br><span class=\"line\"> * @Description 使用AQS重写一个可重入锁</span><br><span class=\"line\"> **/</span><br><span class=\"line\">public class MyReentrantLockByAQS implements Lock &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Sync sync = new Sync();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 内部类Sync ReentrantLock使用的内部抽象类 并派生两个子类实现两种(公平/非公平)锁</span><br><span class=\"line\">    private class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryAcquire(int arg) &#123;</span><br><span class=\"line\">            Thread t = Thread.currentThread();</span><br><span class=\"line\">            // 如果第一个线程进来 可以拿到锁 则返回true</span><br><span class=\"line\"></span><br><span class=\"line\">            // 如果第二个线程进来 如果不等于当前线程 返回false 否则更新当前线程值</span><br><span class=\"line\"></span><br><span class=\"line\">            int state = getState();</span><br><span class=\"line\">            if (state == 0) &#123;</span><br><span class=\"line\">                while (compareAndSetState(0, 1)) &#123;</span><br><span class=\"line\">                    setExclusiveOwnerThread(t);</span><br><span class=\"line\">                    return true;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else if (t == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">                // 当前线程再进来</span><br><span class=\"line\">                setState(getState() + 1);</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        protected boolean tryRelease(int arg) &#123;</span><br><span class=\"line\">            // 锁的获取和释放时一一对应的</span><br><span class=\"line\">            // 调用此方法的线程肯定是当前线程</span><br><span class=\"line\">            if (Thread.currentThread() != getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">                throw new RuntimeException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            int c = getState() - arg;</span><br><span class=\"line\">            boolean flag = false;</span><br><span class=\"line\">            if (c == 0) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(null);</span><br><span class=\"line\">                flag = true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            setState(c);</span><br><span class=\"line\">            return flag;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        public Condition newCondition() &#123;</span><br><span class=\"line\">            return newCondition();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void lock() &#123;</span><br><span class=\"line\">        sync.acquire(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class=\"line\">        sync.acquireInterruptibly(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean tryLock() &#123;</span><br><span class=\"line\">        return sync.tryAcquire(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class=\"line\">        return sync.tryAcquireNanos(1, unit.toNanos(time));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void unlock() &#123;</span><br><span class=\"line\">        sync.release(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Condition newCondition() &#123;</span><br><span class=\"line\">        return sync.newCondition();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"并发编程学习(四)：理解ThreadPoolExecutor线程池","date":"2019-06-17T06:19:07.000Z","_content":"![线程池](xcc.png)\n\n<!--more-->\n\n### 前言：关于ThreadPoolExecutor\n**ThreadPoolExecutor**即我们常说的线程池。《阿里巴巴Java手册》中对于线程池的使用规定如下：\n> **3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。**<br/>\n> **说明：使用线程池的好处是减少线程在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量的同类线程而导致消耗完内存或者“过度切换”的问题​**\n\n\n### 使用线程池的好处\n\n#### 使用线程池创建线程可以\n- 避免在应用中频繁的创建和销毁线程\n- 使用线程池创建线程可以复用CPU资源\n- 提高线程的可管理性\n\n### 使用线程池的风险 \n#### 线程饥饿死锁\n\n线程池为“死锁”这一概念带来了一种新的可能：线程饥饿死锁。在线程池中，如果一个任务将另一个任务提交到同一个Executor，那么通常会引发死锁。第二个线程停留在工作队列中等待第一个提交的任务执行完成，但是第一个任务又无法执行完成，因为它在等待第二个任务执行完成。如下代码所示。\n```aidl\npublic class MyThreadPoolDeadLock {\n    static ExecutorService singlePool = Executors.newSingleThreadExecutor();\n    static class MyTask implements Callable<String> {\n        String name;\n        public MyTask(String name) {\n            this.name = name;\n        }\n        @Override\n        public String call() throws Exception {\n            Future<String> inner = singlePool.submit(new MyTask(\"inner\"));\n            return inner.get();\n        }\n    }\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        Future<String> result = singlePool.submit(new MyTask(\"outer\"));\n        System.out.println(result.get());\n    }\n}\n```\n在更大的线程池中，如果所有线程都由于等待其他仍处于工作队列的任务而阻塞，那么会发生同样的问题，这种情况被称为线程饥饿死锁。\n\n#### 内存溢出\n除了Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。如果线程池的大小设置的不合理就会有可能导致内存溢出的风险。还有就是Java预置线程池FixedThreadPool 和 SingleThreadPool中的阻塞队列使用的无界队列，最多可以保存2147483647个任务，如果代码编写不严谨就会堆积大量请求导致内存溢出。\n\n#### 线程泄漏\n各种线程池都会导致一种问题就是线程泄漏。当从线程池取出一个线程去执行任务时，如果任务抛出RuntimeException 或一个Error而未捕获异常时，那么线程只会退出而线程池的大小将永远减少一个，当这种情况发生多次时，线程池最终就会为空并且因为没有可用的线程来处理任务。\n\n### 如果要自己实现线程池需要关注哪些点\n\n- 首先要有一个存放线程的容器并设置容量\n- 还需要一个存放用户提交的任务的容器，阻塞队列，有界还是无界\n- 线程池创建的时候需要将指定数量的线程启动\n- 用户提交任务的时候如果线程池没有空闲的线程如何创建线程并放入线程池\n- 线程数量远大于用户提交的任务数量需要有一个回收线程的机制\n- 线程全部在执行任务的时候存放的任务需要等待还是怎样或者再新加入任务时要提供一个饱和策略\n\n\n\n### ThreadPoolExecutor构造函数参数意义\n![构造函数](gzhs.png)\nThreadPoolExecutor提供了四种构造函数，总共有如下几种参数，意义为：\n- `int corePoolSize`: 核心线程数的大小，在线程池创建的时候就会创建这么多线程待命，用户提交任务之后立即开始执行任务\n- `int maximumPoolSize`: 最大线程数的大小，即最多会创建这么多线程，当超过这个数目的时候可能会在执行完任务之后回收多于核心线程数的线程\n- `long keepAliveTime`: 线程最大存活时间，是相对于核心线程数来讲的。没有超过核心线程数的会一直存活的。超过的才有存活时间的限制\n- `TimeUnit unit`: 时间单位\n- `BlockingQueue<Runnable> workQueue`: 阻塞队列，用于存放用户提交的任务。系统预置的线程池的阻塞队列一般都是无界的LinkBlockingQueue，但是建议使用有界队列，对于非常大或者无界的线程池，可以使用同步移交队列控制避免排队，直接将任务从生产者移交到工作者线程。\n- `ThreadFactory threadFactory`: 线程工厂接口。只有一个newThread方法。便于用户根据业务需要实现自己的线程创建机制。\n- `RejectedExecutionHandler handler`: 饱和策略。默认四种，在下面讲解。\n\n### 几种默认的饱和策略\n当有界队列被填满后，用户创建的任务无法再添加到线程池中保存，饱和策略开始发挥作用。如果某个任务被提交到已关闭的Executors时，饱和策略也会被执行。饱和策略的实现需要实现接口`RejectedExecutionHandler`。\n![四种默认的饱和策略](bhcl.png)\n如上，在ThreadPoolExecutor类中有四个内部类实现了`RejectedExecutionHandler`接口。分别是:\n```aidl\npublic static class AbortPolicy implements RejectedExecutionHandler {...}\npublic static class DiscardPolicy implements RejectedExecutionHandler {...}\npublic static class DiscardOldestPolicy implements RejectedExecutionHandler {...}\npublic static class CallerRunsPolicy implements RejectedExecutionHandler {...}\n```\n\n#### AbortPolicy\n“中止”策略是默认的饱和策略，该策略将会抛出一个异常`RejectedExecutionException`，调用者可以捕获这个异常然后编写自己的业务代码。\n\n#### DiscardPolicy\n“抛弃”策略会在新提交的任务无法保存在队列中等待执行时将其抛弃掉。\n\n#### DiscardOldestPolicy\n同“抛弃”策略，这种策略会将即将执行的那个任务抛弃掉，即抛弃最老的任务然后尝试提交新的任务。如果工作队列使用的是优先队列，那么会导致优先级最高的任务被抛弃，**慎用**！\n\n#### CallerRunsPolicy\n“调用者执行”策略即在队列满的时候由调用者去执行该任务。不会在线程池的某个线程中执行新的任务。\n\n>《阿里巴巴Java开发手册》中强调使用线程池的时候尽量使用ThreadPoolExecutor，目的在于让程序员更加明确线程池的工作机制，实际业务中不可能在任务满时将任务抛弃掉，所以实现自己的饱和策略是有必要的。\n\n### Java预置线程池及其使用场景\n如图是Executors类中的所有方法\n![预置线程池构造](yzxcgz.png)\n#### Executors.newCachedThreadPool()\n```aidl\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n    }\n```\n无限容量的线程池(最大为2147483647)，调用ThreadPoolExecutor构造传入的核心线程数为0。适合场景为创建执行时间短效快速的线程任务，线程在执行完成之后直接被回收。阻塞队列使用SynchronousQueue，这是一个不保存数据的队列，因为该线程池有任务提交就会创建线程去执行，所以不需要保存\n\n#### Executors.newFixedThreadPool(nThreads)\n```aidl\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n创建固定数量的线程池。调用ThreadPoolExecutor的构造函数传入的核心线程数等于最大线程数。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。\n\n#### Executors.newSingleThreadExecutor()：\n```aidl\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n每次都只有一个线程去执行任务，用户提交的任务都会排队阻塞在阻塞队列中等待上一个任务执行完之后执行下一个。适用场景为后面任务依赖前面任务的情况。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。使用这个线程池需要小心<a href=\"#线程饥饿死锁\">线程饥饿死锁</a>\n\n#### Executors.newWorkStealingPool()\n```aidl\n    public static ExecutorService newWorkStealingPool() {\n        return new ForkJoinPool\n            (Runtime.getRuntime().availableProcessors(),\n             ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n             null, true);\n    }\n```\n获取当前可用的线程数量进行创建作为并行级别，通过源码可以看出底层调用的是ForkJoinPool线程池，newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中。\n\n\n#### Executors.newScheduledThreadPool()\n```aidl\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n    ↑↑↑\n    ↓↓↓\n    ...\n    public class ScheduledThreadPoolExecutor\n            extends ThreadPoolExecutor\n            implements ScheduledExecutorService {\n        ...\n        public ScheduledThreadPoolExecutor(int corePoolSize) {\n            super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n                  new DelayedWorkQueue());\n        }\n        ...\n    }\n```\n设定延迟时间，定期执行。通过源码可以看出底层调用的是一个ScheduledThreadPoolExecutor，然后传入线程数量。同newWorkStealingPool一样也不是直接使用ThreadPoolExecutor进行扩展。可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。\n\n### 优雅的关闭线程池\n\n#### shutdown\n设置线程池状态为关闭，但是只会关闭已经执行完成的线程，对于还未执行完成的线程，会等待执行完成再关闭。\n\n当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。\n\n#### shutdownNow\n立马关闭线程池，线程池里的任务不再执行。\n\n如果我们调用shutdownNow方法时，线程处于从队列里读取任务而阻塞中，则会导致抛出InterruptedException异常\n\n","source":"_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池.md","raw":"---\ntitle: 并发编程学习(四)：理解ThreadPoolExecutor线程池\ndate: 2019-06-17 14:19:07\ncategories: [Java基础,并发编程]\ntags: [Java基础,并发编程,ThreadPoolExecutor,线程池]\n---\n![线程池](xcc.png)\n\n<!--more-->\n\n### 前言：关于ThreadPoolExecutor\n**ThreadPoolExecutor**即我们常说的线程池。《阿里巴巴Java手册》中对于线程池的使用规定如下：\n> **3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。**<br/>\n> **说明：使用线程池的好处是减少线程在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量的同类线程而导致消耗完内存或者“过度切换”的问题​**\n\n\n### 使用线程池的好处\n\n#### 使用线程池创建线程可以\n- 避免在应用中频繁的创建和销毁线程\n- 使用线程池创建线程可以复用CPU资源\n- 提高线程的可管理性\n\n### 使用线程池的风险 \n#### 线程饥饿死锁\n\n线程池为“死锁”这一概念带来了一种新的可能：线程饥饿死锁。在线程池中，如果一个任务将另一个任务提交到同一个Executor，那么通常会引发死锁。第二个线程停留在工作队列中等待第一个提交的任务执行完成，但是第一个任务又无法执行完成，因为它在等待第二个任务执行完成。如下代码所示。\n```aidl\npublic class MyThreadPoolDeadLock {\n    static ExecutorService singlePool = Executors.newSingleThreadExecutor();\n    static class MyTask implements Callable<String> {\n        String name;\n        public MyTask(String name) {\n            this.name = name;\n        }\n        @Override\n        public String call() throws Exception {\n            Future<String> inner = singlePool.submit(new MyTask(\"inner\"));\n            return inner.get();\n        }\n    }\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        Future<String> result = singlePool.submit(new MyTask(\"outer\"));\n        System.out.println(result.get());\n    }\n}\n```\n在更大的线程池中，如果所有线程都由于等待其他仍处于工作队列的任务而阻塞，那么会发生同样的问题，这种情况被称为线程饥饿死锁。\n\n#### 内存溢出\n除了Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。如果线程池的大小设置的不合理就会有可能导致内存溢出的风险。还有就是Java预置线程池FixedThreadPool 和 SingleThreadPool中的阻塞队列使用的无界队列，最多可以保存2147483647个任务，如果代码编写不严谨就会堆积大量请求导致内存溢出。\n\n#### 线程泄漏\n各种线程池都会导致一种问题就是线程泄漏。当从线程池取出一个线程去执行任务时，如果任务抛出RuntimeException 或一个Error而未捕获异常时，那么线程只会退出而线程池的大小将永远减少一个，当这种情况发生多次时，线程池最终就会为空并且因为没有可用的线程来处理任务。\n\n### 如果要自己实现线程池需要关注哪些点\n\n- 首先要有一个存放线程的容器并设置容量\n- 还需要一个存放用户提交的任务的容器，阻塞队列，有界还是无界\n- 线程池创建的时候需要将指定数量的线程启动\n- 用户提交任务的时候如果线程池没有空闲的线程如何创建线程并放入线程池\n- 线程数量远大于用户提交的任务数量需要有一个回收线程的机制\n- 线程全部在执行任务的时候存放的任务需要等待还是怎样或者再新加入任务时要提供一个饱和策略\n\n\n\n### ThreadPoolExecutor构造函数参数意义\n![构造函数](gzhs.png)\nThreadPoolExecutor提供了四种构造函数，总共有如下几种参数，意义为：\n- `int corePoolSize`: 核心线程数的大小，在线程池创建的时候就会创建这么多线程待命，用户提交任务之后立即开始执行任务\n- `int maximumPoolSize`: 最大线程数的大小，即最多会创建这么多线程，当超过这个数目的时候可能会在执行完任务之后回收多于核心线程数的线程\n- `long keepAliveTime`: 线程最大存活时间，是相对于核心线程数来讲的。没有超过核心线程数的会一直存活的。超过的才有存活时间的限制\n- `TimeUnit unit`: 时间单位\n- `BlockingQueue<Runnable> workQueue`: 阻塞队列，用于存放用户提交的任务。系统预置的线程池的阻塞队列一般都是无界的LinkBlockingQueue，但是建议使用有界队列，对于非常大或者无界的线程池，可以使用同步移交队列控制避免排队，直接将任务从生产者移交到工作者线程。\n- `ThreadFactory threadFactory`: 线程工厂接口。只有一个newThread方法。便于用户根据业务需要实现自己的线程创建机制。\n- `RejectedExecutionHandler handler`: 饱和策略。默认四种，在下面讲解。\n\n### 几种默认的饱和策略\n当有界队列被填满后，用户创建的任务无法再添加到线程池中保存，饱和策略开始发挥作用。如果某个任务被提交到已关闭的Executors时，饱和策略也会被执行。饱和策略的实现需要实现接口`RejectedExecutionHandler`。\n![四种默认的饱和策略](bhcl.png)\n如上，在ThreadPoolExecutor类中有四个内部类实现了`RejectedExecutionHandler`接口。分别是:\n```aidl\npublic static class AbortPolicy implements RejectedExecutionHandler {...}\npublic static class DiscardPolicy implements RejectedExecutionHandler {...}\npublic static class DiscardOldestPolicy implements RejectedExecutionHandler {...}\npublic static class CallerRunsPolicy implements RejectedExecutionHandler {...}\n```\n\n#### AbortPolicy\n“中止”策略是默认的饱和策略，该策略将会抛出一个异常`RejectedExecutionException`，调用者可以捕获这个异常然后编写自己的业务代码。\n\n#### DiscardPolicy\n“抛弃”策略会在新提交的任务无法保存在队列中等待执行时将其抛弃掉。\n\n#### DiscardOldestPolicy\n同“抛弃”策略，这种策略会将即将执行的那个任务抛弃掉，即抛弃最老的任务然后尝试提交新的任务。如果工作队列使用的是优先队列，那么会导致优先级最高的任务被抛弃，**慎用**！\n\n#### CallerRunsPolicy\n“调用者执行”策略即在队列满的时候由调用者去执行该任务。不会在线程池的某个线程中执行新的任务。\n\n>《阿里巴巴Java开发手册》中强调使用线程池的时候尽量使用ThreadPoolExecutor，目的在于让程序员更加明确线程池的工作机制，实际业务中不可能在任务满时将任务抛弃掉，所以实现自己的饱和策略是有必要的。\n\n### Java预置线程池及其使用场景\n如图是Executors类中的所有方法\n![预置线程池构造](yzxcgz.png)\n#### Executors.newCachedThreadPool()\n```aidl\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n    }\n```\n无限容量的线程池(最大为2147483647)，调用ThreadPoolExecutor构造传入的核心线程数为0。适合场景为创建执行时间短效快速的线程任务，线程在执行完成之后直接被回收。阻塞队列使用SynchronousQueue，这是一个不保存数据的队列，因为该线程池有任务提交就会创建线程去执行，所以不需要保存\n\n#### Executors.newFixedThreadPool(nThreads)\n```aidl\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n创建固定数量的线程池。调用ThreadPoolExecutor的构造函数传入的核心线程数等于最大线程数。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。\n\n#### Executors.newSingleThreadExecutor()：\n```aidl\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n每次都只有一个线程去执行任务，用户提交的任务都会排队阻塞在阻塞队列中等待上一个任务执行完之后执行下一个。适用场景为后面任务依赖前面任务的情况。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。使用这个线程池需要小心<a href=\"#线程饥饿死锁\">线程饥饿死锁</a>\n\n#### Executors.newWorkStealingPool()\n```aidl\n    public static ExecutorService newWorkStealingPool() {\n        return new ForkJoinPool\n            (Runtime.getRuntime().availableProcessors(),\n             ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n             null, true);\n    }\n```\n获取当前可用的线程数量进行创建作为并行级别，通过源码可以看出底层调用的是ForkJoinPool线程池，newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中。\n\n\n#### Executors.newScheduledThreadPool()\n```aidl\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n    ↑↑↑\n    ↓↓↓\n    ...\n    public class ScheduledThreadPoolExecutor\n            extends ThreadPoolExecutor\n            implements ScheduledExecutorService {\n        ...\n        public ScheduledThreadPoolExecutor(int corePoolSize) {\n            super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n                  new DelayedWorkQueue());\n        }\n        ...\n    }\n```\n设定延迟时间，定期执行。通过源码可以看出底层调用的是一个ScheduledThreadPoolExecutor，然后传入线程数量。同newWorkStealingPool一样也不是直接使用ThreadPoolExecutor进行扩展。可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。\n\n### 优雅的关闭线程池\n\n#### shutdown\n设置线程池状态为关闭，但是只会关闭已经执行完成的线程，对于还未执行完成的线程，会等待执行完成再关闭。\n\n当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。\n\n#### shutdownNow\n立马关闭线程池，线程池里的任务不再执行。\n\n如果我们调用shutdownNow方法时，线程处于从队列里读取任务而阻塞中，则会导致抛出InterruptedException异常\n\n","slug":"并发编程学习-四-：理解ThreadPoolExecutor线程池","published":1,"updated":"2019-06-17T10:16:20.628Z","_id":"cjwzzwvvm001jcwnk72t0nxt3","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png\" alt=\"线程池\"></p>\n<a id=\"more\"></a>\n<h3 id=\"前言：关于ThreadPoolExecutor\"><a href=\"#前言：关于ThreadPoolExecutor\" class=\"headerlink\" title=\"前言：关于ThreadPoolExecutor\"></a>前言：关于ThreadPoolExecutor</h3><p><strong>ThreadPoolExecutor</strong>即我们常说的线程池。《阿里巴巴Java手册》中对于线程池的使用规定如下：</p>\n<blockquote>\n<p><strong>3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong><br><br><strong>说明：使用线程池的好处是减少线程在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量的同类线程而导致消耗完内存或者“过度切换”的问题​</strong></p>\n</blockquote>\n<h3 id=\"使用线程池的好处\"><a href=\"#使用线程池的好处\" class=\"headerlink\" title=\"使用线程池的好处\"></a>使用线程池的好处</h3><h4 id=\"使用线程池创建线程可以\"><a href=\"#使用线程池创建线程可以\" class=\"headerlink\" title=\"使用线程池创建线程可以\"></a>使用线程池创建线程可以</h4><ul>\n<li>避免在应用中频繁的创建和销毁线程</li>\n<li>使用线程池创建线程可以复用CPU资源</li>\n<li>提高线程的可管理性</li>\n</ul>\n<h3 id=\"使用线程池的风险\"><a href=\"#使用线程池的风险\" class=\"headerlink\" title=\"使用线程池的风险\"></a>使用线程池的风险</h3><h4 id=\"线程饥饿死锁\"><a href=\"#线程饥饿死锁\" class=\"headerlink\" title=\"线程饥饿死锁\"></a>线程饥饿死锁</h4><p>线程池为“死锁”这一概念带来了一种新的可能：线程饥饿死锁。在线程池中，如果一个任务将另一个任务提交到同一个Executor，那么通常会引发死锁。第二个线程停留在工作队列中等待第一个提交的任务执行完成，但是第一个任务又无法执行完成，因为它在等待第二个任务执行完成。如下代码所示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyThreadPoolDeadLock &#123;</span><br><span class=\"line\">    static ExecutorService singlePool = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">    static class MyTask implements Callable&lt;String&gt; &#123;</span><br><span class=\"line\">        String name;</span><br><span class=\"line\">        public MyTask(String name) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String call() throws Exception &#123;</span><br><span class=\"line\">            Future&lt;String&gt; inner = singlePool.submit(new MyTask(&quot;inner&quot;));</span><br><span class=\"line\">            return inner.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        Future&lt;String&gt; result = singlePool.submit(new MyTask(&quot;outer&quot;));</span><br><span class=\"line\">        System.out.println(result.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在更大的线程池中，如果所有线程都由于等待其他仍处于工作队列的任务而阻塞，那么会发生同样的问题，这种情况被称为线程饥饿死锁。</p>\n<h4 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h4><p>除了Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。如果线程池的大小设置的不合理就会有可能导致内存溢出的风险。还有就是Java预置线程池FixedThreadPool 和 SingleThreadPool中的阻塞队列使用的无界队列，最多可以保存2147483647个任务，如果代码编写不严谨就会堆积大量请求导致内存溢出。</p>\n<h4 id=\"线程泄漏\"><a href=\"#线程泄漏\" class=\"headerlink\" title=\"线程泄漏\"></a>线程泄漏</h4><p>各种线程池都会导致一种问题就是线程泄漏。当从线程池取出一个线程去执行任务时，如果任务抛出RuntimeException 或一个Error而未捕获异常时，那么线程只会退出而线程池的大小将永远减少一个，当这种情况发生多次时，线程池最终就会为空并且因为没有可用的线程来处理任务。</p>\n<h3 id=\"如果要自己实现线程池需要关注哪些点\"><a href=\"#如果要自己实现线程池需要关注哪些点\" class=\"headerlink\" title=\"如果要自己实现线程池需要关注哪些点\"></a>如果要自己实现线程池需要关注哪些点</h3><ul>\n<li>首先要有一个存放线程的容器并设置容量</li>\n<li>还需要一个存放用户提交的任务的容器，阻塞队列，有界还是无界</li>\n<li>线程池创建的时候需要将指定数量的线程启动</li>\n<li>用户提交任务的时候如果线程池没有空闲的线程如何创建线程并放入线程池</li>\n<li>线程数量远大于用户提交的任务数量需要有一个回收线程的机制</li>\n<li>线程全部在执行任务的时候存放的任务需要等待还是怎样或者再新加入任务时要提供一个饱和策略</li>\n</ul>\n<h3 id=\"ThreadPoolExecutor构造函数参数意义\"><a href=\"#ThreadPoolExecutor构造函数参数意义\" class=\"headerlink\" title=\"ThreadPoolExecutor构造函数参数意义\"></a>ThreadPoolExecutor构造函数参数意义</h3><p><img src=\"/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/gzhs.png\" alt=\"构造函数\"><br>ThreadPoolExecutor提供了四种构造函数，总共有如下几种参数，意义为：</p>\n<ul>\n<li><code>int corePoolSize</code>: 核心线程数的大小，在线程池创建的时候就会创建这么多线程待命，用户提交任务之后立即开始执行任务</li>\n<li><code>int maximumPoolSize</code>: 最大线程数的大小，即最多会创建这么多线程，当超过这个数目的时候可能会在执行完任务之后回收多于核心线程数的线程</li>\n<li><code>long keepAliveTime</code>: 线程最大存活时间，是相对于核心线程数来讲的。没有超过核心线程数的会一直存活的。超过的才有存活时间的限制</li>\n<li><code>TimeUnit unit</code>: 时间单位</li>\n<li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 阻塞队列，用于存放用户提交的任务。系统预置的线程池的阻塞队列一般都是无界的LinkBlockingQueue，但是建议使用有界队列，对于非常大或者无界的线程池，可以使用同步移交队列控制避免排队，直接将任务从生产者移交到工作者线程。</li>\n<li><code>ThreadFactory threadFactory</code>: 线程工厂接口。只有一个newThread方法。便于用户根据业务需要实现自己的线程创建机制。</li>\n<li><code>RejectedExecutionHandler handler</code>: 饱和策略。默认四种，在下面讲解。</li>\n</ul>\n<h3 id=\"几种默认的饱和策略\"><a href=\"#几种默认的饱和策略\" class=\"headerlink\" title=\"几种默认的饱和策略\"></a>几种默认的饱和策略</h3><p>当有界队列被填满后，用户创建的任务无法再添加到线程池中保存，饱和策略开始发挥作用。如果某个任务被提交到已关闭的Executors时，饱和策略也会被执行。饱和策略的实现需要实现接口<code>RejectedExecutionHandler</code>。<br><img src=\"/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/bhcl.png\" alt=\"四种默认的饱和策略\"><br>如上，在ThreadPoolExecutor类中有四个内部类实现了<code>RejectedExecutionHandler</code>接口。分别是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static class AbortPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class=\"line\">public static class DiscardPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class=\"line\">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class=\"line\">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"AbortPolicy\"><a href=\"#AbortPolicy\" class=\"headerlink\" title=\"AbortPolicy\"></a>AbortPolicy</h4><p>“中止”策略是默认的饱和策略，该策略将会抛出一个异常<code>RejectedExecutionException</code>，调用者可以捕获这个异常然后编写自己的业务代码。</p>\n<h4 id=\"DiscardPolicy\"><a href=\"#DiscardPolicy\" class=\"headerlink\" title=\"DiscardPolicy\"></a>DiscardPolicy</h4><p>“抛弃”策略会在新提交的任务无法保存在队列中等待执行时将其抛弃掉。</p>\n<h4 id=\"DiscardOldestPolicy\"><a href=\"#DiscardOldestPolicy\" class=\"headerlink\" title=\"DiscardOldestPolicy\"></a>DiscardOldestPolicy</h4><p>同“抛弃”策略，这种策略会将即将执行的那个任务抛弃掉，即抛弃最老的任务然后尝试提交新的任务。如果工作队列使用的是优先队列，那么会导致优先级最高的任务被抛弃，<strong>慎用</strong>！</p>\n<h4 id=\"CallerRunsPolicy\"><a href=\"#CallerRunsPolicy\" class=\"headerlink\" title=\"CallerRunsPolicy\"></a>CallerRunsPolicy</h4><p>“调用者执行”策略即在队列满的时候由调用者去执行该任务。不会在线程池的某个线程中执行新的任务。</p>\n<blockquote>\n<p>《阿里巴巴Java开发手册》中强调使用线程池的时候尽量使用ThreadPoolExecutor，目的在于让程序员更加明确线程池的工作机制，实际业务中不可能在任务满时将任务抛弃掉，所以实现自己的饱和策略是有必要的。</p>\n</blockquote>\n<h3 id=\"Java预置线程池及其使用场景\"><a href=\"#Java预置线程池及其使用场景\" class=\"headerlink\" title=\"Java预置线程池及其使用场景\"></a>Java预置线程池及其使用场景</h3><p>如图是Executors类中的所有方法<br><img src=\"/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcgz.png\" alt=\"预置线程池构造\"></p>\n<h4 id=\"Executors-newCachedThreadPool\"><a href=\"#Executors-newCachedThreadPool\" class=\"headerlink\" title=\"Executors.newCachedThreadPool()\"></a>Executors.newCachedThreadPool()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class=\"line\">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class=\"line\">                              60L, TimeUnit.SECONDS,</span><br><span class=\"line\">                              new SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>无限容量的线程池(最大为2147483647)，调用ThreadPoolExecutor构造传入的核心线程数为0。适合场景为创建执行时间短效快速的线程任务，线程在执行完成之后直接被回收。阻塞队列使用SynchronousQueue，这是一个不保存数据的队列，因为该线程池有任务提交就会创建线程去执行，所以不需要保存</p>\n<h4 id=\"Executors-newFixedThreadPool-nThreads\"><a href=\"#Executors-newFixedThreadPool-nThreads\" class=\"headerlink\" title=\"Executors.newFixedThreadPool(nThreads)\"></a>Executors.newFixedThreadPool(nThreads)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class=\"line\">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建固定数量的线程池。调用ThreadPoolExecutor的构造函数传入的核心线程数等于最大线程数。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。</p>\n<h4 id=\"Executors-newSingleThreadExecutor-：\"><a href=\"#Executors-newSingleThreadExecutor-：\" class=\"headerlink\" title=\"Executors.newSingleThreadExecutor()：\"></a>Executors.newSingleThreadExecutor()：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class=\"line\">    return new FinalizableDelegatedExecutorService</span><br><span class=\"line\">        (new ThreadPoolExecutor(1, 1,</span><br><span class=\"line\">                                0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次都只有一个线程去执行任务，用户提交的任务都会排队阻塞在阻塞队列中等待上一个任务执行完之后执行下一个。适用场景为后面任务依赖前面任务的情况。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。使用这个线程池需要小心<a href=\"#线程饥饿死锁\">线程饥饿死锁</a></p>\n<h4 id=\"Executors-newWorkStealingPool\"><a href=\"#Executors-newWorkStealingPool\" class=\"headerlink\" title=\"Executors.newWorkStealingPool()\"></a>Executors.newWorkStealingPool()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newWorkStealingPool() &#123;</span><br><span class=\"line\">    return new ForkJoinPool</span><br><span class=\"line\">        (Runtime.getRuntime().availableProcessors(),</span><br><span class=\"line\">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class=\"line\">         null, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取当前可用的线程数量进行创建作为并行级别，通过源码可以看出底层调用的是ForkJoinPool线程池，newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中。</p>\n<h4 id=\"Executors-newScheduledThreadPool\"><a href=\"#Executors-newScheduledThreadPool\" class=\"headerlink\" title=\"Executors.newScheduledThreadPool()\"></a>Executors.newScheduledThreadPool()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class=\"line\">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">↑↑↑</span><br><span class=\"line\">↓↓↓</span><br><span class=\"line\">...</span><br><span class=\"line\">public class ScheduledThreadPoolExecutor</span><br><span class=\"line\">        extends ThreadPoolExecutor</span><br><span class=\"line\">        implements ScheduledExecutorService &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class=\"line\">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class=\"line\">              new DelayedWorkQueue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设定延迟时间，定期执行。通过源码可以看出底层调用的是一个ScheduledThreadPoolExecutor，然后传入线程数量。同newWorkStealingPool一样也不是直接使用ThreadPoolExecutor进行扩展。可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</p>\n<h3 id=\"优雅的关闭线程池\"><a href=\"#优雅的关闭线程池\" class=\"headerlink\" title=\"优雅的关闭线程池\"></a>优雅的关闭线程池</h3><h4 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h4><p>设置线程池状态为关闭，但是只会关闭已经执行完成的线程，对于还未执行完成的线程，会等待执行完成再关闭。</p>\n<p>当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。</p>\n<h4 id=\"shutdownNow\"><a href=\"#shutdownNow\" class=\"headerlink\" title=\"shutdownNow\"></a>shutdownNow</h4><p>立马关闭线程池，线程池里的任务不再执行。</p>\n<p>如果我们调用shutdownNow方法时，线程处于从队列里读取任务而阻塞中，则会导致抛出InterruptedException异常</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png\" alt=\"线程池\"></p>","more":"<h3 id=\"前言：关于ThreadPoolExecutor\"><a href=\"#前言：关于ThreadPoolExecutor\" class=\"headerlink\" title=\"前言：关于ThreadPoolExecutor\"></a>前言：关于ThreadPoolExecutor</h3><p><strong>ThreadPoolExecutor</strong>即我们常说的线程池。《阿里巴巴Java手册》中对于线程池的使用规定如下：</p>\n<blockquote>\n<p><strong>3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong><br><br><strong>说明：使用线程池的好处是减少线程在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量的同类线程而导致消耗完内存或者“过度切换”的问题​</strong></p>\n</blockquote>\n<h3 id=\"使用线程池的好处\"><a href=\"#使用线程池的好处\" class=\"headerlink\" title=\"使用线程池的好处\"></a>使用线程池的好处</h3><h4 id=\"使用线程池创建线程可以\"><a href=\"#使用线程池创建线程可以\" class=\"headerlink\" title=\"使用线程池创建线程可以\"></a>使用线程池创建线程可以</h4><ul>\n<li>避免在应用中频繁的创建和销毁线程</li>\n<li>使用线程池创建线程可以复用CPU资源</li>\n<li>提高线程的可管理性</li>\n</ul>\n<h3 id=\"使用线程池的风险\"><a href=\"#使用线程池的风险\" class=\"headerlink\" title=\"使用线程池的风险\"></a>使用线程池的风险</h3><h4 id=\"线程饥饿死锁\"><a href=\"#线程饥饿死锁\" class=\"headerlink\" title=\"线程饥饿死锁\"></a>线程饥饿死锁</h4><p>线程池为“死锁”这一概念带来了一种新的可能：线程饥饿死锁。在线程池中，如果一个任务将另一个任务提交到同一个Executor，那么通常会引发死锁。第二个线程停留在工作队列中等待第一个提交的任务执行完成，但是第一个任务又无法执行完成，因为它在等待第二个任务执行完成。如下代码所示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyThreadPoolDeadLock &#123;</span><br><span class=\"line\">    static ExecutorService singlePool = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">    static class MyTask implements Callable&lt;String&gt; &#123;</span><br><span class=\"line\">        String name;</span><br><span class=\"line\">        public MyTask(String name) &#123;</span><br><span class=\"line\">            this.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String call() throws Exception &#123;</span><br><span class=\"line\">            Future&lt;String&gt; inner = singlePool.submit(new MyTask(&quot;inner&quot;));</span><br><span class=\"line\">            return inner.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        Future&lt;String&gt; result = singlePool.submit(new MyTask(&quot;outer&quot;));</span><br><span class=\"line\">        System.out.println(result.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在更大的线程池中，如果所有线程都由于等待其他仍处于工作队列的任务而阻塞，那么会发生同样的问题，这种情况被称为线程饥饿死锁。</p>\n<h4 id=\"内存溢出\"><a href=\"#内存溢出\" class=\"headerlink\" title=\"内存溢出\"></a>内存溢出</h4><p>除了Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。如果线程池的大小设置的不合理就会有可能导致内存溢出的风险。还有就是Java预置线程池FixedThreadPool 和 SingleThreadPool中的阻塞队列使用的无界队列，最多可以保存2147483647个任务，如果代码编写不严谨就会堆积大量请求导致内存溢出。</p>\n<h4 id=\"线程泄漏\"><a href=\"#线程泄漏\" class=\"headerlink\" title=\"线程泄漏\"></a>线程泄漏</h4><p>各种线程池都会导致一种问题就是线程泄漏。当从线程池取出一个线程去执行任务时，如果任务抛出RuntimeException 或一个Error而未捕获异常时，那么线程只会退出而线程池的大小将永远减少一个，当这种情况发生多次时，线程池最终就会为空并且因为没有可用的线程来处理任务。</p>\n<h3 id=\"如果要自己实现线程池需要关注哪些点\"><a href=\"#如果要自己实现线程池需要关注哪些点\" class=\"headerlink\" title=\"如果要自己实现线程池需要关注哪些点\"></a>如果要自己实现线程池需要关注哪些点</h3><ul>\n<li>首先要有一个存放线程的容器并设置容量</li>\n<li>还需要一个存放用户提交的任务的容器，阻塞队列，有界还是无界</li>\n<li>线程池创建的时候需要将指定数量的线程启动</li>\n<li>用户提交任务的时候如果线程池没有空闲的线程如何创建线程并放入线程池</li>\n<li>线程数量远大于用户提交的任务数量需要有一个回收线程的机制</li>\n<li>线程全部在执行任务的时候存放的任务需要等待还是怎样或者再新加入任务时要提供一个饱和策略</li>\n</ul>\n<h3 id=\"ThreadPoolExecutor构造函数参数意义\"><a href=\"#ThreadPoolExecutor构造函数参数意义\" class=\"headerlink\" title=\"ThreadPoolExecutor构造函数参数意义\"></a>ThreadPoolExecutor构造函数参数意义</h3><p><img src=\"/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/gzhs.png\" alt=\"构造函数\"><br>ThreadPoolExecutor提供了四种构造函数，总共有如下几种参数，意义为：</p>\n<ul>\n<li><code>int corePoolSize</code>: 核心线程数的大小，在线程池创建的时候就会创建这么多线程待命，用户提交任务之后立即开始执行任务</li>\n<li><code>int maximumPoolSize</code>: 最大线程数的大小，即最多会创建这么多线程，当超过这个数目的时候可能会在执行完任务之后回收多于核心线程数的线程</li>\n<li><code>long keepAliveTime</code>: 线程最大存活时间，是相对于核心线程数来讲的。没有超过核心线程数的会一直存活的。超过的才有存活时间的限制</li>\n<li><code>TimeUnit unit</code>: 时间单位</li>\n<li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 阻塞队列，用于存放用户提交的任务。系统预置的线程池的阻塞队列一般都是无界的LinkBlockingQueue，但是建议使用有界队列，对于非常大或者无界的线程池，可以使用同步移交队列控制避免排队，直接将任务从生产者移交到工作者线程。</li>\n<li><code>ThreadFactory threadFactory</code>: 线程工厂接口。只有一个newThread方法。便于用户根据业务需要实现自己的线程创建机制。</li>\n<li><code>RejectedExecutionHandler handler</code>: 饱和策略。默认四种，在下面讲解。</li>\n</ul>\n<h3 id=\"几种默认的饱和策略\"><a href=\"#几种默认的饱和策略\" class=\"headerlink\" title=\"几种默认的饱和策略\"></a>几种默认的饱和策略</h3><p>当有界队列被填满后，用户创建的任务无法再添加到线程池中保存，饱和策略开始发挥作用。如果某个任务被提交到已关闭的Executors时，饱和策略也会被执行。饱和策略的实现需要实现接口<code>RejectedExecutionHandler</code>。<br><img src=\"/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/bhcl.png\" alt=\"四种默认的饱和策略\"><br>如上，在ThreadPoolExecutor类中有四个内部类实现了<code>RejectedExecutionHandler</code>接口。分别是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static class AbortPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class=\"line\">public static class DiscardPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class=\"line\">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class=\"line\">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"AbortPolicy\"><a href=\"#AbortPolicy\" class=\"headerlink\" title=\"AbortPolicy\"></a>AbortPolicy</h4><p>“中止”策略是默认的饱和策略，该策略将会抛出一个异常<code>RejectedExecutionException</code>，调用者可以捕获这个异常然后编写自己的业务代码。</p>\n<h4 id=\"DiscardPolicy\"><a href=\"#DiscardPolicy\" class=\"headerlink\" title=\"DiscardPolicy\"></a>DiscardPolicy</h4><p>“抛弃”策略会在新提交的任务无法保存在队列中等待执行时将其抛弃掉。</p>\n<h4 id=\"DiscardOldestPolicy\"><a href=\"#DiscardOldestPolicy\" class=\"headerlink\" title=\"DiscardOldestPolicy\"></a>DiscardOldestPolicy</h4><p>同“抛弃”策略，这种策略会将即将执行的那个任务抛弃掉，即抛弃最老的任务然后尝试提交新的任务。如果工作队列使用的是优先队列，那么会导致优先级最高的任务被抛弃，<strong>慎用</strong>！</p>\n<h4 id=\"CallerRunsPolicy\"><a href=\"#CallerRunsPolicy\" class=\"headerlink\" title=\"CallerRunsPolicy\"></a>CallerRunsPolicy</h4><p>“调用者执行”策略即在队列满的时候由调用者去执行该任务。不会在线程池的某个线程中执行新的任务。</p>\n<blockquote>\n<p>《阿里巴巴Java开发手册》中强调使用线程池的时候尽量使用ThreadPoolExecutor，目的在于让程序员更加明确线程池的工作机制，实际业务中不可能在任务满时将任务抛弃掉，所以实现自己的饱和策略是有必要的。</p>\n</blockquote>\n<h3 id=\"Java预置线程池及其使用场景\"><a href=\"#Java预置线程池及其使用场景\" class=\"headerlink\" title=\"Java预置线程池及其使用场景\"></a>Java预置线程池及其使用场景</h3><p>如图是Executors类中的所有方法<br><img src=\"/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcgz.png\" alt=\"预置线程池构造\"></p>\n<h4 id=\"Executors-newCachedThreadPool\"><a href=\"#Executors-newCachedThreadPool\" class=\"headerlink\" title=\"Executors.newCachedThreadPool()\"></a>Executors.newCachedThreadPool()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class=\"line\">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class=\"line\">                              60L, TimeUnit.SECONDS,</span><br><span class=\"line\">                              new SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>无限容量的线程池(最大为2147483647)，调用ThreadPoolExecutor构造传入的核心线程数为0。适合场景为创建执行时间短效快速的线程任务，线程在执行完成之后直接被回收。阻塞队列使用SynchronousQueue，这是一个不保存数据的队列，因为该线程池有任务提交就会创建线程去执行，所以不需要保存</p>\n<h4 id=\"Executors-newFixedThreadPool-nThreads\"><a href=\"#Executors-newFixedThreadPool-nThreads\" class=\"headerlink\" title=\"Executors.newFixedThreadPool(nThreads)\"></a>Executors.newFixedThreadPool(nThreads)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class=\"line\">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建固定数量的线程池。调用ThreadPoolExecutor的构造函数传入的核心线程数等于最大线程数。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。</p>\n<h4 id=\"Executors-newSingleThreadExecutor-：\"><a href=\"#Executors-newSingleThreadExecutor-：\" class=\"headerlink\" title=\"Executors.newSingleThreadExecutor()：\"></a>Executors.newSingleThreadExecutor()：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class=\"line\">    return new FinalizableDelegatedExecutorService</span><br><span class=\"line\">        (new ThreadPoolExecutor(1, 1,</span><br><span class=\"line\">                                0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次都只有一个线程去执行任务，用户提交的任务都会排队阻塞在阻塞队列中等待上一个任务执行完之后执行下一个。适用场景为后面任务依赖前面任务的情况。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。使用这个线程池需要小心<a href=\"#线程饥饿死锁\">线程饥饿死锁</a></p>\n<h4 id=\"Executors-newWorkStealingPool\"><a href=\"#Executors-newWorkStealingPool\" class=\"headerlink\" title=\"Executors.newWorkStealingPool()\"></a>Executors.newWorkStealingPool()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newWorkStealingPool() &#123;</span><br><span class=\"line\">    return new ForkJoinPool</span><br><span class=\"line\">        (Runtime.getRuntime().availableProcessors(),</span><br><span class=\"line\">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class=\"line\">         null, true);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取当前可用的线程数量进行创建作为并行级别，通过源码可以看出底层调用的是ForkJoinPool线程池，newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中。</p>\n<h4 id=\"Executors-newScheduledThreadPool\"><a href=\"#Executors-newScheduledThreadPool\" class=\"headerlink\" title=\"Executors.newScheduledThreadPool()\"></a>Executors.newScheduledThreadPool()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class=\"line\">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">↑↑↑</span><br><span class=\"line\">↓↓↓</span><br><span class=\"line\">...</span><br><span class=\"line\">public class ScheduledThreadPoolExecutor</span><br><span class=\"line\">        extends ThreadPoolExecutor</span><br><span class=\"line\">        implements ScheduledExecutorService &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class=\"line\">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class=\"line\">              new DelayedWorkQueue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>设定延迟时间，定期执行。通过源码可以看出底层调用的是一个ScheduledThreadPoolExecutor，然后传入线程数量。同newWorkStealingPool一样也不是直接使用ThreadPoolExecutor进行扩展。可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</p>\n<h3 id=\"优雅的关闭线程池\"><a href=\"#优雅的关闭线程池\" class=\"headerlink\" title=\"优雅的关闭线程池\"></a>优雅的关闭线程池</h3><h4 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h4><p>设置线程池状态为关闭，但是只会关闭已经执行完成的线程，对于还未执行完成的线程，会等待执行完成再关闭。</p>\n<p>当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。</p>\n<h4 id=\"shutdownNow\"><a href=\"#shutdownNow\" class=\"headerlink\" title=\"shutdownNow\"></a>shutdownNow</h4><p>立马关闭线程池，线程池里的任务不再执行。</p>\n<p>如果我们调用shutdownNow方法时，线程处于从队列里读取任务而阻塞中，则会导致抛出InterruptedException异常</p>"},{"title":"如何在Springboot服务启动之后执行一些代码(三种方式)","date":"2019-04-19T09:01:21.000Z","_content":"\n### 前言\n  通常的我们的项目开发中，经常会遇到那种在服务一启动就需要自动执行一些业务代码的情况。比如将数据库中的配置信息或者数据字典之类的缓存到redis，或者在服务启动的时候将一些配置化的定时任务开起来。关于spring mvc或者springboot如何在项目启动的时候就执行一些代码，方法其实有很多，我这边介绍一下我使用过的三种。\n\n  <!--more-->\n  \n#### 1、`@PostConstruct` 注解\n\n从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，`@PostConstruct`和`@PreDestroy`，这两个注解被用来修饰一个非静态的void（）方法。`@PostConstruct`会在所在类的构造函数执行之后执行，在init()方法执行之前执行。(`@PreDestroy`注解的方法会在这个类的destory()方法执行之后执行。)\n- 使用示例：在Spring容器加载之后，我需要启动定时任务去做任务的处理（我的定时任务采用的是读取数据库配置的方式）。在这里我使用`@PostConstruct` 指定了需要启动的方法。\n```\n@Component // 注意 这里必须有\npublic class StartAllJobInit {\n\n    protected Logger logger = LoggerFactory.getLogger(getClass().getName());\n    @Autowired\n    JobInfoService jobInfoService;\n\n    @Autowired\n    JobTaskUtil jobTaskUtil;\n\n    @PostConstruct // 构造函数之后执行\n    public void init(){\n        System.out.println(\"容器启动后执行\");\n        startJob();\n    }\n\n    public void startJob() {\n        List<JobInfoBO> list = jobInfoService.findList();\n        for (JobInfoBO jobinfo :list) {\n            try {\n                if(\"0\".equals(jobinfo.getStartWithrun())){\n                    logger.info(\"任务{}未设置自动启动。\", jobinfo.getJobName());\n                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);\n                }else{\n                    logger.info(\"任务{}设置了自动启动。\", jobinfo.getJobName());\n                    jobTaskUtil.addOrUpdateJob(jobinfo);\n                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);\n                }\n            } catch (SchedulerException e) {\n                logger.error(\"执行定时任务出错，任务名称 {} \", jobinfo.getJobName());\n            }\n        }\n    }\n}\n```\n\n#### 2、实现`CommandLineRunner`接口并重写run()方法\n`CommandLineRunner`接口文档描述如下：\n```\n/**\n * Interface used to indicate that a bean should <em>run</em> when it is contained within\n * a {@link SpringApplication}. Multiple {@link CommandLineRunner} beans can be defined\n * within the same application context and can be ordered using the {@link Ordered}\n * interface or {@link Order @Order} annotation.\n * <p>\n * If you need access to {@link ApplicationArguments} instead of the raw String array\n * consider using {@link ApplicationRunner}.\n *\n * @author Dave Syer\n * @see ApplicationRunner\n */\npublic interface CommandLineRunner {\n\n\t/**\n\t * Callback used to run the bean.\n\t * @param args incoming main method arguments\n\t * @throws Exception on error\n\t */\n\tvoid run(String... args) throws Exception;\n\n}\n```\n如上所说：接口被用作加入Spring容器中时执行run(String... args)方法，通过命令行传递参数。SpringBoot在项目启动后会遍历所有实现CommandLineRunner的实体类并执行run方法，多个实现类可以并存并且根据order注解排序顺序执行。这边还有个`ApplicationRunner`接口，但是接收参数是使用的`ApplicationArguments`。这边不再赘述。\n\n**同样是启动时执行定时任务，使用这种方式我的写法如下：**\n```\n@Component // 注意 这里必须有\n//@Order(2) 如果有多个类需要启动后执行 order注解中的值为启动的顺序\npublic class StartAllJobInit implements CommandLineRunner {\n\n    protected Logger logger = LoggerFactory.getLogger(getClass().getName());\n    @Autowired\n    JobInfoService jobInfoService;\n\n    @Autowired\n    JobTaskUtil jobTaskUtil;\n\n    @Override\n    public void run(String... args) {\n        List<JobInfoBO> list = jobInfoService.findList();\n        for (JobInfoBO jobinfo :list) {\n            try {\n                if(\"0\".equals(jobinfo.getStartWithrun())){\n                    logger.info(\"任务{}未设置自动启动。\", jobinfo.getJobName());\n                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);\n                }else{\n                    logger.info(\"任务{}设置了自动启动。\", jobinfo.getJobName());\n                    jobTaskUtil.addOrUpdateJob(jobinfo);\n                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);\n                }\n            } catch (SchedulerException e) {\n                logger.error(\"执行定时任务出错，任务名称 {} \", jobinfo.getJobName());\n            }\n        }\n    }\n}\n```\n#### 3、使用`ContextRefreshedEvent`事件(上下文件刷新事件)\n\n> ContextRefreshedEvent 官方在接口上的doc说明<br>\n> Event raised when an {@code ApplicationContext} gets initialized or refreshed.\n\nContextRefreshedEvent是Spring的ApplicationContextEvent一个实现，ContextRefreshedEvent 事件会在Spring容器初始化完成后以及刷新时触发。\n\n**在这里我需要在springboot程序启动之后加载配置信息和字典信息到Redis缓存中去，我可以这样写：**\n\n```\n@Component // 注意 这个也是必须有的注解 三种都需要 使spring扫描到这个类并交给它管理\npublic class InitRedisCache implements ApplicationListener<ContextRefreshedEvent> {\n    static final Logger logger = LoggerFactory\n            .getLogger(InitRedisCache.class);\n\n    @Autowired\n    private SysConfigService sysConfigService;\n\n    @Autowired\n    private SysDictService sysDictService;\n\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {\n        logger.info(\"-------加载配置信息 start-------\");\n        sysConfigService.loadConfigIntoRedis();\n        logger.info(\"-------加载配置信息 end-------\");\n\n        logger.info(\"-------加载字典信息 start-------\");\n        sysDictService.loadDictIntoRedis();\n        logger.info(\"-------加载字典信息 end-------\");\n    }\n}\n```\n**注意**：这种方式在springmvc-spring的项目中使用的时候会出现执行两次的情况。这种是因为在加载spring和springmvc的时候会创建两个容器，都会触发这个事件的执行。这时候只需要在`onApplicationEvent`方法中判断是否有父容器即可。\n```\n@Override  \n  public void onApplicationEvent(ContextRefreshedEvent event) {  \n      if(event.getApplicationContext().getParent() == null){//root application context 没有parent，他就是老大.  \n           //需要执行的逻辑代码，当spring容器初始化完成后就会执行该方法。  \n      }  \n  }  \n```\n#### 总结\n以上，就是我在实际开发中常用的三种，在项目启动时执行代码的方式，开发者可以根据不同的使用情况选择合适的方法去执行自己的业务逻辑。\n","source":"_posts/如何在springboot服务启动之后执行一些代码(三种方式).md","raw":"---\ntitle: 如何在springboot服务启动之后执行一些代码(三种方式)\ndate: 2019-04-19 17:01:21\ncategories: [springboot]\ntags: [spring,springboot]\n---\n\n### 前言\n  通常的我们的项目开发中，经常会遇到那种在服务一启动就需要自动执行一些业务代码的情况。比如将数据库中的配置信息或者数据字典之类的缓存到redis，或者在服务启动的时候将一些配置化的定时任务开起来。关于spring mvc或者springboot如何在项目启动的时候就执行一些代码，方法其实有很多，我这边介绍一下我使用过的三种。\n\n  <!--more-->\n  \n#### 1、`@PostConstruct` 注解\n\n从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，`@PostConstruct`和`@PreDestroy`，这两个注解被用来修饰一个非静态的void（）方法。`@PostConstruct`会在所在类的构造函数执行之后执行，在init()方法执行之前执行。(`@PreDestroy`注解的方法会在这个类的destory()方法执行之后执行。)\n- 使用示例：在Spring容器加载之后，我需要启动定时任务去做任务的处理（我的定时任务采用的是读取数据库配置的方式）。在这里我使用`@PostConstruct` 指定了需要启动的方法。\n```\n@Component // 注意 这里必须有\npublic class StartAllJobInit {\n\n    protected Logger logger = LoggerFactory.getLogger(getClass().getName());\n    @Autowired\n    JobInfoService jobInfoService;\n\n    @Autowired\n    JobTaskUtil jobTaskUtil;\n\n    @PostConstruct // 构造函数之后执行\n    public void init(){\n        System.out.println(\"容器启动后执行\");\n        startJob();\n    }\n\n    public void startJob() {\n        List<JobInfoBO> list = jobInfoService.findList();\n        for (JobInfoBO jobinfo :list) {\n            try {\n                if(\"0\".equals(jobinfo.getStartWithrun())){\n                    logger.info(\"任务{}未设置自动启动。\", jobinfo.getJobName());\n                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);\n                }else{\n                    logger.info(\"任务{}设置了自动启动。\", jobinfo.getJobName());\n                    jobTaskUtil.addOrUpdateJob(jobinfo);\n                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);\n                }\n            } catch (SchedulerException e) {\n                logger.error(\"执行定时任务出错，任务名称 {} \", jobinfo.getJobName());\n            }\n        }\n    }\n}\n```\n\n#### 2、实现`CommandLineRunner`接口并重写run()方法\n`CommandLineRunner`接口文档描述如下：\n```\n/**\n * Interface used to indicate that a bean should <em>run</em> when it is contained within\n * a {@link SpringApplication}. Multiple {@link CommandLineRunner} beans can be defined\n * within the same application context and can be ordered using the {@link Ordered}\n * interface or {@link Order @Order} annotation.\n * <p>\n * If you need access to {@link ApplicationArguments} instead of the raw String array\n * consider using {@link ApplicationRunner}.\n *\n * @author Dave Syer\n * @see ApplicationRunner\n */\npublic interface CommandLineRunner {\n\n\t/**\n\t * Callback used to run the bean.\n\t * @param args incoming main method arguments\n\t * @throws Exception on error\n\t */\n\tvoid run(String... args) throws Exception;\n\n}\n```\n如上所说：接口被用作加入Spring容器中时执行run(String... args)方法，通过命令行传递参数。SpringBoot在项目启动后会遍历所有实现CommandLineRunner的实体类并执行run方法，多个实现类可以并存并且根据order注解排序顺序执行。这边还有个`ApplicationRunner`接口，但是接收参数是使用的`ApplicationArguments`。这边不再赘述。\n\n**同样是启动时执行定时任务，使用这种方式我的写法如下：**\n```\n@Component // 注意 这里必须有\n//@Order(2) 如果有多个类需要启动后执行 order注解中的值为启动的顺序\npublic class StartAllJobInit implements CommandLineRunner {\n\n    protected Logger logger = LoggerFactory.getLogger(getClass().getName());\n    @Autowired\n    JobInfoService jobInfoService;\n\n    @Autowired\n    JobTaskUtil jobTaskUtil;\n\n    @Override\n    public void run(String... args) {\n        List<JobInfoBO> list = jobInfoService.findList();\n        for (JobInfoBO jobinfo :list) {\n            try {\n                if(\"0\".equals(jobinfo.getStartWithrun())){\n                    logger.info(\"任务{}未设置自动启动。\", jobinfo.getJobName());\n                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);\n                }else{\n                    logger.info(\"任务{}设置了自动启动。\", jobinfo.getJobName());\n                    jobTaskUtil.addOrUpdateJob(jobinfo);\n                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);\n                }\n            } catch (SchedulerException e) {\n                logger.error(\"执行定时任务出错，任务名称 {} \", jobinfo.getJobName());\n            }\n        }\n    }\n}\n```\n#### 3、使用`ContextRefreshedEvent`事件(上下文件刷新事件)\n\n> ContextRefreshedEvent 官方在接口上的doc说明<br>\n> Event raised when an {@code ApplicationContext} gets initialized or refreshed.\n\nContextRefreshedEvent是Spring的ApplicationContextEvent一个实现，ContextRefreshedEvent 事件会在Spring容器初始化完成后以及刷新时触发。\n\n**在这里我需要在springboot程序启动之后加载配置信息和字典信息到Redis缓存中去，我可以这样写：**\n\n```\n@Component // 注意 这个也是必须有的注解 三种都需要 使spring扫描到这个类并交给它管理\npublic class InitRedisCache implements ApplicationListener<ContextRefreshedEvent> {\n    static final Logger logger = LoggerFactory\n            .getLogger(InitRedisCache.class);\n\n    @Autowired\n    private SysConfigService sysConfigService;\n\n    @Autowired\n    private SysDictService sysDictService;\n\n\n    @Override\n    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {\n        logger.info(\"-------加载配置信息 start-------\");\n        sysConfigService.loadConfigIntoRedis();\n        logger.info(\"-------加载配置信息 end-------\");\n\n        logger.info(\"-------加载字典信息 start-------\");\n        sysDictService.loadDictIntoRedis();\n        logger.info(\"-------加载字典信息 end-------\");\n    }\n}\n```\n**注意**：这种方式在springmvc-spring的项目中使用的时候会出现执行两次的情况。这种是因为在加载spring和springmvc的时候会创建两个容器，都会触发这个事件的执行。这时候只需要在`onApplicationEvent`方法中判断是否有父容器即可。\n```\n@Override  \n  public void onApplicationEvent(ContextRefreshedEvent event) {  \n      if(event.getApplicationContext().getParent() == null){//root application context 没有parent，他就是老大.  \n           //需要执行的逻辑代码，当spring容器初始化完成后就会执行该方法。  \n      }  \n  }  \n```\n#### 总结\n以上，就是我在实际开发中常用的三种，在项目启动时执行代码的方式，开发者可以根据不同的使用情况选择合适的方法去执行自己的业务逻辑。\n","slug":"如何在springboot服务启动之后执行一些代码(三种方式)","published":1,"updated":"2019-05-07T09:48:29.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvo001ocwnk5a3qc6o0","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  通常的我们的项目开发中，经常会遇到那种在服务一启动就需要自动执行一些业务代码的情况。比如将数据库中的配置信息或者数据字典之类的缓存到redis，或者在服务启动的时候将一些配置化的定时任务开起来。关于spring mvc或者springboot如何在项目启动的时候就执行一些代码，方法其实有很多，我这边介绍一下我使用过的三种。</p>\n  <a id=\"more\"></a>\n<h4 id=\"1、-PostConstruct-注解\"><a href=\"#1、-PostConstruct-注解\" class=\"headerlink\" title=\"1、@PostConstruct 注解\"></a>1、<code>@PostConstruct</code> 注解</h4><p>从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，<code>@PostConstruct</code>和<code>@PreDestroy</code>，这两个注解被用来修饰一个非静态的void（）方法。<code>@PostConstruct</code>会在所在类的构造函数执行之后执行，在init()方法执行之前执行。(<code>@PreDestroy</code>注解的方法会在这个类的destory()方法执行之后执行。)</p>\n<ul>\n<li>使用示例：在Spring容器加载之后，我需要启动定时任务去做任务的处理（我的定时任务采用的是读取数据库配置的方式）。在这里我使用<code>@PostConstruct</code> 指定了需要启动的方法。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component // 注意 这里必须有</span><br><span class=\"line\">public class StartAllJobInit &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JobInfoService jobInfoService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JobTaskUtil jobTaskUtil;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostConstruct // 构造函数之后执行</span><br><span class=\"line\">    public void init()&#123;</span><br><span class=\"line\">        System.out.println(&quot;容器启动后执行&quot;);</span><br><span class=\"line\">        startJob();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void startJob() &#123;</span><br><span class=\"line\">        List&lt;JobInfoBO&gt; list = jobInfoService.findList();</span><br><span class=\"line\">        for (JobInfoBO jobinfo :list) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if(&quot;0&quot;.equals(jobinfo.getStartWithrun()))&#123;</span><br><span class=\"line\">                    logger.info(&quot;任务&#123;&#125;未设置自动启动。&quot;, jobinfo.getJobName());</span><br><span class=\"line\">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    logger.info(&quot;任务&#123;&#125;设置了自动启动。&quot;, jobinfo.getJobName());</span><br><span class=\"line\">                    jobTaskUtil.addOrUpdateJob(jobinfo);</span><br><span class=\"line\">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (SchedulerException e) &#123;</span><br><span class=\"line\">                logger.error(&quot;执行定时任务出错，任务名称 &#123;&#125; &quot;, jobinfo.getJobName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2、实现CommandLineRunner接口并重写run-方法\"><a href=\"#2、实现CommandLineRunner接口并重写run-方法\" class=\"headerlink\" title=\"2、实现CommandLineRunner接口并重写run()方法\"></a>2、实现<code>CommandLineRunner</code>接口并重写run()方法</h4><p><code>CommandLineRunner</code>接口文档描述如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within</span><br><span class=\"line\"> * a &#123;@link SpringApplication&#125;. Multiple &#123;@link CommandLineRunner&#125; beans can be defined</span><br><span class=\"line\"> * within the same application context and can be ordered using the &#123;@link Ordered&#125;</span><br><span class=\"line\"> * interface or &#123;@link Order @Order&#125; annotation.</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * If you need access to &#123;@link ApplicationArguments&#125; instead of the raw String array</span><br><span class=\"line\"> * consider using &#123;@link ApplicationRunner&#125;.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author Dave Syer</span><br><span class=\"line\"> * @see ApplicationRunner</span><br><span class=\"line\"> */</span><br><span class=\"line\">public interface CommandLineRunner &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Callback used to run the bean.</span><br><span class=\"line\">\t * @param args incoming main method arguments</span><br><span class=\"line\">\t * @throws Exception on error</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tvoid run(String... args) throws Exception;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上所说：接口被用作加入Spring容器中时执行run(String… args)方法，通过命令行传递参数。SpringBoot在项目启动后会遍历所有实现CommandLineRunner的实体类并执行run方法，多个实现类可以并存并且根据order注解排序顺序执行。这边还有个<code>ApplicationRunner</code>接口，但是接收参数是使用的<code>ApplicationArguments</code>。这边不再赘述。</p>\n<p><strong>同样是启动时执行定时任务，使用这种方式我的写法如下：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component // 注意 这里必须有</span><br><span class=\"line\">//@Order(2) 如果有多个类需要启动后执行 order注解中的值为启动的顺序</span><br><span class=\"line\">public class StartAllJobInit implements CommandLineRunner &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JobInfoService jobInfoService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JobTaskUtil jobTaskUtil;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run(String... args) &#123;</span><br><span class=\"line\">        List&lt;JobInfoBO&gt; list = jobInfoService.findList();</span><br><span class=\"line\">        for (JobInfoBO jobinfo :list) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if(&quot;0&quot;.equals(jobinfo.getStartWithrun()))&#123;</span><br><span class=\"line\">                    logger.info(&quot;任务&#123;&#125;未设置自动启动。&quot;, jobinfo.getJobName());</span><br><span class=\"line\">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    logger.info(&quot;任务&#123;&#125;设置了自动启动。&quot;, jobinfo.getJobName());</span><br><span class=\"line\">                    jobTaskUtil.addOrUpdateJob(jobinfo);</span><br><span class=\"line\">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (SchedulerException e) &#123;</span><br><span class=\"line\">                logger.error(&quot;执行定时任务出错，任务名称 &#123;&#125; &quot;, jobinfo.getJobName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、使用ContextRefreshedEvent事件-上下文件刷新事件\"><a href=\"#3、使用ContextRefreshedEvent事件-上下文件刷新事件\" class=\"headerlink\" title=\"3、使用ContextRefreshedEvent事件(上下文件刷新事件)\"></a>3、使用<code>ContextRefreshedEvent</code>事件(上下文件刷新事件)</h4><blockquote>\n<p>ContextRefreshedEvent 官方在接口上的doc说明<br><br>Event raised when an {@code ApplicationContext} gets initialized or refreshed.</p>\n</blockquote>\n<p>ContextRefreshedEvent是Spring的ApplicationContextEvent一个实现，ContextRefreshedEvent 事件会在Spring容器初始化完成后以及刷新时触发。</p>\n<p><strong>在这里我需要在springboot程序启动之后加载配置信息和字典信息到Redis缓存中去，我可以这样写：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component // 注意 这个也是必须有的注解 三种都需要 使spring扫描到这个类并交给它管理</span><br><span class=\"line\">public class InitRedisCache implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class=\"line\">    static final Logger logger = LoggerFactory</span><br><span class=\"line\">            .getLogger(InitRedisCache.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private SysConfigService sysConfigService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private SysDictService sysDictService;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) &#123;</span><br><span class=\"line\">        logger.info(&quot;-------加载配置信息 start-------&quot;);</span><br><span class=\"line\">        sysConfigService.loadConfigIntoRedis();</span><br><span class=\"line\">        logger.info(&quot;-------加载配置信息 end-------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        logger.info(&quot;-------加载字典信息 start-------&quot;);</span><br><span class=\"line\">        sysDictService.loadDictIntoRedis();</span><br><span class=\"line\">        logger.info(&quot;-------加载字典信息 end-------&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：这种方式在springmvc-spring的项目中使用的时候会出现执行两次的情况。这种是因为在加载spring和springmvc的时候会创建两个容器，都会触发这个事件的执行。这时候只需要在<code>onApplicationEvent</code>方法中判断是否有父容器即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override  </span><br><span class=\"line\">  public void onApplicationEvent(ContextRefreshedEvent event) &#123;  </span><br><span class=\"line\">      if(event.getApplicationContext().getParent() == null)&#123;//root application context 没有parent，他就是老大.  </span><br><span class=\"line\">           //需要执行的逻辑代码，当spring容器初始化完成后就会执行该方法。  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>以上，就是我在实际开发中常用的三种，在项目启动时执行代码的方式，开发者可以根据不同的使用情况选择合适的方法去执行自己的业务逻辑。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  通常的我们的项目开发中，经常会遇到那种在服务一启动就需要自动执行一些业务代码的情况。比如将数据库中的配置信息或者数据字典之类的缓存到redis，或者在服务启动的时候将一些配置化的定时任务开起来。关于spring mvc或者springboot如何在项目启动的时候就执行一些代码，方法其实有很多，我这边介绍一下我使用过的三种。</p>","more":"<h4 id=\"1、-PostConstruct-注解\"><a href=\"#1、-PostConstruct-注解\" class=\"headerlink\" title=\"1、@PostConstruct 注解\"></a>1、<code>@PostConstruct</code> 注解</h4><p>从Java EE5规范开始，Servlet中增加了两个影响Servlet生命周期的注解，<code>@PostConstruct</code>和<code>@PreDestroy</code>，这两个注解被用来修饰一个非静态的void（）方法。<code>@PostConstruct</code>会在所在类的构造函数执行之后执行，在init()方法执行之前执行。(<code>@PreDestroy</code>注解的方法会在这个类的destory()方法执行之后执行。)</p>\n<ul>\n<li>使用示例：在Spring容器加载之后，我需要启动定时任务去做任务的处理（我的定时任务采用的是读取数据库配置的方式）。在这里我使用<code>@PostConstruct</code> 指定了需要启动的方法。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component // 注意 这里必须有</span><br><span class=\"line\">public class StartAllJobInit &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JobInfoService jobInfoService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JobTaskUtil jobTaskUtil;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostConstruct // 构造函数之后执行</span><br><span class=\"line\">    public void init()&#123;</span><br><span class=\"line\">        System.out.println(&quot;容器启动后执行&quot;);</span><br><span class=\"line\">        startJob();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void startJob() &#123;</span><br><span class=\"line\">        List&lt;JobInfoBO&gt; list = jobInfoService.findList();</span><br><span class=\"line\">        for (JobInfoBO jobinfo :list) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if(&quot;0&quot;.equals(jobinfo.getStartWithrun()))&#123;</span><br><span class=\"line\">                    logger.info(&quot;任务&#123;&#125;未设置自动启动。&quot;, jobinfo.getJobName());</span><br><span class=\"line\">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    logger.info(&quot;任务&#123;&#125;设置了自动启动。&quot;, jobinfo.getJobName());</span><br><span class=\"line\">                    jobTaskUtil.addOrUpdateJob(jobinfo);</span><br><span class=\"line\">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (SchedulerException e) &#123;</span><br><span class=\"line\">                logger.error(&quot;执行定时任务出错，任务名称 &#123;&#125; &quot;, jobinfo.getJobName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2、实现CommandLineRunner接口并重写run-方法\"><a href=\"#2、实现CommandLineRunner接口并重写run-方法\" class=\"headerlink\" title=\"2、实现CommandLineRunner接口并重写run()方法\"></a>2、实现<code>CommandLineRunner</code>接口并重写run()方法</h4><p><code>CommandLineRunner</code>接口文档描述如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within</span><br><span class=\"line\"> * a &#123;@link SpringApplication&#125;. Multiple &#123;@link CommandLineRunner&#125; beans can be defined</span><br><span class=\"line\"> * within the same application context and can be ordered using the &#123;@link Ordered&#125;</span><br><span class=\"line\"> * interface or &#123;@link Order @Order&#125; annotation.</span><br><span class=\"line\"> * &lt;p&gt;</span><br><span class=\"line\"> * If you need access to &#123;@link ApplicationArguments&#125; instead of the raw String array</span><br><span class=\"line\"> * consider using &#123;@link ApplicationRunner&#125;.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author Dave Syer</span><br><span class=\"line\"> * @see ApplicationRunner</span><br><span class=\"line\"> */</span><br><span class=\"line\">public interface CommandLineRunner &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * Callback used to run the bean.</span><br><span class=\"line\">\t * @param args incoming main method arguments</span><br><span class=\"line\">\t * @throws Exception on error</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tvoid run(String... args) throws Exception;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上所说：接口被用作加入Spring容器中时执行run(String… args)方法，通过命令行传递参数。SpringBoot在项目启动后会遍历所有实现CommandLineRunner的实体类并执行run方法，多个实现类可以并存并且根据order注解排序顺序执行。这边还有个<code>ApplicationRunner</code>接口，但是接收参数是使用的<code>ApplicationArguments</code>。这边不再赘述。</p>\n<p><strong>同样是启动时执行定时任务，使用这种方式我的写法如下：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component // 注意 这里必须有</span><br><span class=\"line\">//@Order(2) 如果有多个类需要启动后执行 order注解中的值为启动的顺序</span><br><span class=\"line\">public class StartAllJobInit implements CommandLineRunner &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JobInfoService jobInfoService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JobTaskUtil jobTaskUtil;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run(String... args) &#123;</span><br><span class=\"line\">        List&lt;JobInfoBO&gt; list = jobInfoService.findList();</span><br><span class=\"line\">        for (JobInfoBO jobinfo :list) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if(&quot;0&quot;.equals(jobinfo.getStartWithrun()))&#123;</span><br><span class=\"line\">                    logger.info(&quot;任务&#123;&#125;未设置自动启动。&quot;, jobinfo.getJobName());</span><br><span class=\"line\">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STOP);</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    logger.info(&quot;任务&#123;&#125;设置了自动启动。&quot;, jobinfo.getJobName());</span><br><span class=\"line\">                    jobTaskUtil.addOrUpdateJob(jobinfo);</span><br><span class=\"line\">                    jobInfoService.updateJobStatus(jobinfo.getId(), BasicsConstantManual.BASICS_SYS_JOB_STATUS_STARTING);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (SchedulerException e) &#123;</span><br><span class=\"line\">                logger.error(&quot;执行定时任务出错，任务名称 &#123;&#125; &quot;, jobinfo.getJobName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3、使用ContextRefreshedEvent事件-上下文件刷新事件\"><a href=\"#3、使用ContextRefreshedEvent事件-上下文件刷新事件\" class=\"headerlink\" title=\"3、使用ContextRefreshedEvent事件(上下文件刷新事件)\"></a>3、使用<code>ContextRefreshedEvent</code>事件(上下文件刷新事件)</h4><blockquote>\n<p>ContextRefreshedEvent 官方在接口上的doc说明<br><br>Event raised when an {@code ApplicationContext} gets initialized or refreshed.</p>\n</blockquote>\n<p>ContextRefreshedEvent是Spring的ApplicationContextEvent一个实现，ContextRefreshedEvent 事件会在Spring容器初始化完成后以及刷新时触发。</p>\n<p><strong>在这里我需要在springboot程序启动之后加载配置信息和字典信息到Redis缓存中去，我可以这样写：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component // 注意 这个也是必须有的注解 三种都需要 使spring扫描到这个类并交给它管理</span><br><span class=\"line\">public class InitRedisCache implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class=\"line\">    static final Logger logger = LoggerFactory</span><br><span class=\"line\">            .getLogger(InitRedisCache.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private SysConfigService sysConfigService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private SysDictService sysDictService;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) &#123;</span><br><span class=\"line\">        logger.info(&quot;-------加载配置信息 start-------&quot;);</span><br><span class=\"line\">        sysConfigService.loadConfigIntoRedis();</span><br><span class=\"line\">        logger.info(&quot;-------加载配置信息 end-------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        logger.info(&quot;-------加载字典信息 start-------&quot;);</span><br><span class=\"line\">        sysDictService.loadDictIntoRedis();</span><br><span class=\"line\">        logger.info(&quot;-------加载字典信息 end-------&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：这种方式在springmvc-spring的项目中使用的时候会出现执行两次的情况。这种是因为在加载spring和springmvc的时候会创建两个容器，都会触发这个事件的执行。这时候只需要在<code>onApplicationEvent</code>方法中判断是否有父容器即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override  </span><br><span class=\"line\">  public void onApplicationEvent(ContextRefreshedEvent event) &#123;  </span><br><span class=\"line\">      if(event.getApplicationContext().getParent() == null)&#123;//root application context 没有parent，他就是老大.  </span><br><span class=\"line\">           //需要执行的逻辑代码，当spring容器初始化完成后就会执行该方法。  </span><br><span class=\"line\">      &#125;  </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>以上，就是我在实际开发中常用的三种，在项目启动时执行代码的方式，开发者可以根据不同的使用情况选择合适的方法去执行自己的业务逻辑。</p>"},{"title":"无重复字符的最长子串","date":"2019-05-12T06:36:15.000Z","_content":"\n![封面](bb.png)\n\n#### 算法题解：无重复字符的最长子串\nleetcode地址： [leetcode](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n> **题目：** 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n```aidl\n示例 1:\n\n输入: \"abcabcbb\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n<!--more-->\n#### 解法1：暴力求解\n - 思路：遍历字符串，以每一个字符作为子串的起始字符，向后查找直到遇到和该字符相同的字符，记录长度，依次执行直到找到最长长度。\n\n - 题解如下：\n ```\n public int maxIndexStrLength(String s) {\n   int maxLength = 0;\n   for (int index = 0; index < s.length(); index++) {\n\n       int length = 1;\n       int i = index + 1;\n       for (; ; ) {\n           if (i >= s.length()) {\n               break;\n           }\n           String ts = s.substring(index, i);\n           char c = s.charAt(i);\n           if (ts.contains(c + \"\")) {\n               break;\n           }\n           length++;\n           i++;\n       }\n       maxLength = maxLength > length ? maxLength : length;\n   }\n   return maxLength;\n}\n ```\n\n#### 解法2：滑动窗口法\n- 思路：在使用暴力解法时我们会发现实际上对于无重复子串来讲，我们产生了一些冗余的判断操作。例如对于串`sdabcabcbb`，判断了子串`sdabc`之后，当后面再出现字符`a`，那么重复字符之前的串直接舍弃就好。即直接从`bca`...开始判断即可。这样可以减少大量的不必要的判断与计算操作。\n- 题解如下：\n\n```\npublic int maxIndexStrLength(String s) {\n  HashMap<Character, Integer> map = new HashMap<>();\n  int start = 0, max = 0;\n\n  for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      //如果当前元素与滑动窗口中的元素重复：\n      if (map.containsKey(c) && map.get(c) >= start) {\n          max = Math.max(max, i - start);\n          start = map.get(c) + 1;\n          //如果当前元素与滑动窗口中的元素不重复，但已经遍历到了最后一个字符：\n      } else if (i == s.length() - 1) {\n          max = Math.max(max, i - start + 1);\n      }\n      map.put(c, i);\n  }\n  return max;\n}\n```\n\n#### 总结\n\n- 滑动窗口法的思路可以用来解决很多字符串相关的问题\n","source":"_posts/无重复字符的最长子串.md","raw":"---\ntitle: 无重复字符的最长子串\ndate: 2019-05-12 14:36:15\ncategories: [算法题解]\ntags: [leetcode,算法题解]\n---\n\n![封面](bb.png)\n\n#### 算法题解：无重复字符的最长子串\nleetcode地址： [leetcode](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n> **题目：** 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n```aidl\n示例 1:\n\n输入: \"abcabcbb\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n<!--more-->\n#### 解法1：暴力求解\n - 思路：遍历字符串，以每一个字符作为子串的起始字符，向后查找直到遇到和该字符相同的字符，记录长度，依次执行直到找到最长长度。\n\n - 题解如下：\n ```\n public int maxIndexStrLength(String s) {\n   int maxLength = 0;\n   for (int index = 0; index < s.length(); index++) {\n\n       int length = 1;\n       int i = index + 1;\n       for (; ; ) {\n           if (i >= s.length()) {\n               break;\n           }\n           String ts = s.substring(index, i);\n           char c = s.charAt(i);\n           if (ts.contains(c + \"\")) {\n               break;\n           }\n           length++;\n           i++;\n       }\n       maxLength = maxLength > length ? maxLength : length;\n   }\n   return maxLength;\n}\n ```\n\n#### 解法2：滑动窗口法\n- 思路：在使用暴力解法时我们会发现实际上对于无重复子串来讲，我们产生了一些冗余的判断操作。例如对于串`sdabcabcbb`，判断了子串`sdabc`之后，当后面再出现字符`a`，那么重复字符之前的串直接舍弃就好。即直接从`bca`...开始判断即可。这样可以减少大量的不必要的判断与计算操作。\n- 题解如下：\n\n```\npublic int maxIndexStrLength(String s) {\n  HashMap<Character, Integer> map = new HashMap<>();\n  int start = 0, max = 0;\n\n  for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      //如果当前元素与滑动窗口中的元素重复：\n      if (map.containsKey(c) && map.get(c) >= start) {\n          max = Math.max(max, i - start);\n          start = map.get(c) + 1;\n          //如果当前元素与滑动窗口中的元素不重复，但已经遍历到了最后一个字符：\n      } else if (i == s.length() - 1) {\n          max = Math.max(max, i - start + 1);\n      }\n      map.put(c, i);\n  }\n  return max;\n}\n```\n\n#### 总结\n\n- 滑动窗口法的思路可以用来解决很多字符串相关的问题\n","slug":"无重复字符的最长子串","published":1,"updated":"2019-05-23T06:59:28.435Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvp001rcwnkjadarep2","content":"<p><img src=\"/blog/20190512/无重复字符的最长子串/bb.png\" alt=\"封面\"></p>\n<h4 id=\"算法题解：无重复字符的最长子串\"><a href=\"#算法题解：无重复字符的最长子串\" class=\"headerlink\" title=\"算法题解：无重复字符的最长子串\"></a>算法题解：无重复字符的最长子串</h4><p>leetcode地址： <a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n<blockquote>\n<p><strong>题目：</strong> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h4 id=\"解法1：暴力求解\"><a href=\"#解法1：暴力求解\" class=\"headerlink\" title=\"解法1：暴力求解\"></a>解法1：暴力求解</h4><ul>\n<li><p>思路：遍历字符串，以每一个字符作为子串的起始字符，向后查找直到遇到和该字符相同的字符，记录长度，依次执行直到找到最长长度。</p>\n</li>\n<li><p>题解如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public int maxIndexStrLength(String s) &#123;</span><br><span class=\"line\">   int maxLength = 0;</span><br><span class=\"line\">   for (int index = 0; index &lt; s.length(); index++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       int length = 1;</span><br><span class=\"line\">       int i = index + 1;</span><br><span class=\"line\">       for (; ; ) &#123;</span><br><span class=\"line\">           if (i &gt;= s.length()) &#123;</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           String ts = s.substring(index, i);</span><br><span class=\"line\">           char c = s.charAt(i);</span><br><span class=\"line\">           if (ts.contains(c + &quot;&quot;)) &#123;</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           length++;</span><br><span class=\"line\">           i++;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       maxLength = maxLength &gt; length ? maxLength : length;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return maxLength;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"解法2：滑动窗口法\"><a href=\"#解法2：滑动窗口法\" class=\"headerlink\" title=\"解法2：滑动窗口法\"></a>解法2：滑动窗口法</h4><ul>\n<li>思路：在使用暴力解法时我们会发现实际上对于无重复子串来讲，我们产生了一些冗余的判断操作。例如对于串<code>sdabcabcbb</code>，判断了子串<code>sdabc</code>之后，当后面再出现字符<code>a</code>，那么重复字符之前的串直接舍弃就好。即直接从<code>bca</code>…开始判断即可。这样可以减少大量的不必要的判断与计算操作。</li>\n<li>题解如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int maxIndexStrLength(String s) &#123;</span><br><span class=\"line\">  HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">  int start = 0, max = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">      char c = s.charAt(i);</span><br><span class=\"line\">      //如果当前元素与滑动窗口中的元素重复：</span><br><span class=\"line\">      if (map.containsKey(c) &amp;&amp; map.get(c) &gt;= start) &#123;</span><br><span class=\"line\">          max = Math.max(max, i - start);</span><br><span class=\"line\">          start = map.get(c) + 1;</span><br><span class=\"line\">          //如果当前元素与滑动窗口中的元素不重复，但已经遍历到了最后一个字符：</span><br><span class=\"line\">      &#125; else if (i == s.length() - 1) &#123;</span><br><span class=\"line\">          max = Math.max(max, i - start + 1);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      map.put(c, i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return max;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>滑动窗口法的思路可以用来解决很多字符串相关的问题</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"/blog/20190512/无重复字符的最长子串/bb.png\" alt=\"封面\"></p>\n<h4 id=\"算法题解：无重复字符的最长子串\"><a href=\"#算法题解：无重复字符的最长子串\" class=\"headerlink\" title=\"算法题解：无重复字符的最长子串\"></a>算法题解：无重复字符的最长子串</h4><p>leetcode地址： <a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"noopener\">leetcode</a></p>\n<blockquote>\n<p><strong>题目：</strong> 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>","more":"<h4 id=\"解法1：暴力求解\"><a href=\"#解法1：暴力求解\" class=\"headerlink\" title=\"解法1：暴力求解\"></a>解法1：暴力求解</h4><ul>\n<li><p>思路：遍历字符串，以每一个字符作为子串的起始字符，向后查找直到遇到和该字符相同的字符，记录长度，依次执行直到找到最长长度。</p>\n</li>\n<li><p>题解如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public int maxIndexStrLength(String s) &#123;</span><br><span class=\"line\">   int maxLength = 0;</span><br><span class=\"line\">   for (int index = 0; index &lt; s.length(); index++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       int length = 1;</span><br><span class=\"line\">       int i = index + 1;</span><br><span class=\"line\">       for (; ; ) &#123;</span><br><span class=\"line\">           if (i &gt;= s.length()) &#123;</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           String ts = s.substring(index, i);</span><br><span class=\"line\">           char c = s.charAt(i);</span><br><span class=\"line\">           if (ts.contains(c + &quot;&quot;)) &#123;</span><br><span class=\"line\">               break;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           length++;</span><br><span class=\"line\">           i++;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       maxLength = maxLength &gt; length ? maxLength : length;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return maxLength;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"解法2：滑动窗口法\"><a href=\"#解法2：滑动窗口法\" class=\"headerlink\" title=\"解法2：滑动窗口法\"></a>解法2：滑动窗口法</h4><ul>\n<li>思路：在使用暴力解法时我们会发现实际上对于无重复子串来讲，我们产生了一些冗余的判断操作。例如对于串<code>sdabcabcbb</code>，判断了子串<code>sdabc</code>之后，当后面再出现字符<code>a</code>，那么重复字符之前的串直接舍弃就好。即直接从<code>bca</code>…开始判断即可。这样可以减少大量的不必要的判断与计算操作。</li>\n<li>题解如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int maxIndexStrLength(String s) &#123;</span><br><span class=\"line\">  HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">  int start = 0, max = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">      char c = s.charAt(i);</span><br><span class=\"line\">      //如果当前元素与滑动窗口中的元素重复：</span><br><span class=\"line\">      if (map.containsKey(c) &amp;&amp; map.get(c) &gt;= start) &#123;</span><br><span class=\"line\">          max = Math.max(max, i - start);</span><br><span class=\"line\">          start = map.get(c) + 1;</span><br><span class=\"line\">          //如果当前元素与滑动窗口中的元素不重复，但已经遍历到了最后一个字符：</span><br><span class=\"line\">      &#125; else if (i == s.length() - 1) &#123;</span><br><span class=\"line\">          max = Math.max(max, i - start + 1);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      map.put(c, i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return max;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>滑动窗口法的思路可以用来解决很多字符串相关的问题</li>\n</ul>"},{"title":"Dubbo获取注册中心的实例bean","date":"2018-07-18T18:07:56.000Z","_content":"\n## 开发日记 20180718\n### com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large\n\n```\ncom.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large: 11557050, max payload: 8388608 java.io.IOException: Data length too large: 11557050, max payload: 838860\n```\n\n在使用dubbo框架开发的时候，需要做一个导出csv文件的功能，查询大量的数据然后在提供者这边进行处理导出，其中数据达到过20万行以上，几十M的数据，抛出了这样一个异常。遇到服务提供者从数据库查询或者其他地方返回过大的对象，导致报错时，尽管有办法取消这个数据长度的限制，但是这并不符合程序开发的初衷。我们需要将对于数据的处理放在业务层，我在这里做了异步导出，给前端返回的仅仅是一个程序完成的状态，完美的解决了这个问题。\n\n<!-- more -->\n\n### 在dubbo消费者服务中写aop方法拦截工具类中的方法\n\n尽管服务的提供者和消费者都引入的工具类模块的依赖，但是拦截器的实际拦截的还是那个实际本身所在模块的方法。如果工具类是在消费者service层被使用的，那么在上层模块的拦截器是无法拦截到这个方法的。\n\n### 在dubbo服务中手动获取注册的提供者的bean\n\n在这里犯的错：以为通过SpringContextHolder.getBean()可以获取，是我傻逼了，dubbo中的服务怎么能用spring上下文获取呢。这里我使用dubbo的方式完成了这个功能。\n```\n    /**\n     * 获取服务的代理对象\n     *\n     * @return\n     */\n    public static <T> T getReferenceConfig(String appName,String address,Class<?> interfaceClass) {\n        String key  = interfaceClass.getName();\n        ReferenceConfig<T> referenceConfig =  (ReferenceConfig<T>)referenceCache.get(key);\n        if(referenceConfig == null){\n            referenceConfig = new ReferenceConfig<T>();\n\n            referenceConfig.setApplication(application);\n            referenceConfig.setRegistry(getRegistryConfig(appName,address));\n            referenceConfig.setInterface(interfaceClass);\n\n            referenceCache.put(key,referenceConfig);\n        }\n\n        return referenceConfig.get();\n    }\n```\n\n","source":"_posts/开发日记-20180718.md","raw":"---\ntitle: dubbo获取注册中心的实例bean\ndate: 2018-07-19 02:07:56\ncategories: [dubbo]\ntags: [dubbo,开发日记]\n---\n\n## 开发日记 20180718\n### com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large\n\n```\ncom.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large: 11557050, max payload: 8388608 java.io.IOException: Data length too large: 11557050, max payload: 838860\n```\n\n在使用dubbo框架开发的时候，需要做一个导出csv文件的功能，查询大量的数据然后在提供者这边进行处理导出，其中数据达到过20万行以上，几十M的数据，抛出了这样一个异常。遇到服务提供者从数据库查询或者其他地方返回过大的对象，导致报错时，尽管有办法取消这个数据长度的限制，但是这并不符合程序开发的初衷。我们需要将对于数据的处理放在业务层，我在这里做了异步导出，给前端返回的仅仅是一个程序完成的状态，完美的解决了这个问题。\n\n<!-- more -->\n\n### 在dubbo消费者服务中写aop方法拦截工具类中的方法\n\n尽管服务的提供者和消费者都引入的工具类模块的依赖，但是拦截器的实际拦截的还是那个实际本身所在模块的方法。如果工具类是在消费者service层被使用的，那么在上层模块的拦截器是无法拦截到这个方法的。\n\n### 在dubbo服务中手动获取注册的提供者的bean\n\n在这里犯的错：以为通过SpringContextHolder.getBean()可以获取，是我傻逼了，dubbo中的服务怎么能用spring上下文获取呢。这里我使用dubbo的方式完成了这个功能。\n```\n    /**\n     * 获取服务的代理对象\n     *\n     * @return\n     */\n    public static <T> T getReferenceConfig(String appName,String address,Class<?> interfaceClass) {\n        String key  = interfaceClass.getName();\n        ReferenceConfig<T> referenceConfig =  (ReferenceConfig<T>)referenceCache.get(key);\n        if(referenceConfig == null){\n            referenceConfig = new ReferenceConfig<T>();\n\n            referenceConfig.setApplication(application);\n            referenceConfig.setRegistry(getRegistryConfig(appName,address));\n            referenceConfig.setInterface(interfaceClass);\n\n            referenceCache.put(key,referenceConfig);\n        }\n\n        return referenceConfig.get();\n    }\n```\n\n","slug":"开发日记-20180718","published":1,"updated":"2019-05-07T09:48:29.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvr001wcwnk3nkikpyc","content":"<h2 id=\"开发日记-20180718\"><a href=\"#开发日记-20180718\" class=\"headerlink\" title=\"开发日记 20180718\"></a>开发日记 20180718</h2><h3 id=\"com-alibaba-dubbo-remoting-transport-AbstractCodec-checkPayload-ERROR-Data-length-too-large\"><a href=\"#com-alibaba-dubbo-remoting-transport-AbstractCodec-checkPayload-ERROR-Data-length-too-large\" class=\"headerlink\" title=\"com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large\"></a>com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large: 11557050, max payload: 8388608 java.io.IOException: Data length too large: 11557050, max payload: 838860</span><br></pre></td></tr></table></figure>\n<p>在使用dubbo框架开发的时候，需要做一个导出csv文件的功能，查询大量的数据然后在提供者这边进行处理导出，其中数据达到过20万行以上，几十M的数据，抛出了这样一个异常。遇到服务提供者从数据库查询或者其他地方返回过大的对象，导致报错时，尽管有办法取消这个数据长度的限制，但是这并不符合程序开发的初衷。我们需要将对于数据的处理放在业务层，我在这里做了异步导出，给前端返回的仅仅是一个程序完成的状态，完美的解决了这个问题。</p>\n<a id=\"more\"></a>\n<h3 id=\"在dubbo消费者服务中写aop方法拦截工具类中的方法\"><a href=\"#在dubbo消费者服务中写aop方法拦截工具类中的方法\" class=\"headerlink\" title=\"在dubbo消费者服务中写aop方法拦截工具类中的方法\"></a>在dubbo消费者服务中写aop方法拦截工具类中的方法</h3><p>尽管服务的提供者和消费者都引入的工具类模块的依赖，但是拦截器的实际拦截的还是那个实际本身所在模块的方法。如果工具类是在消费者service层被使用的，那么在上层模块的拦截器是无法拦截到这个方法的。</p>\n<h3 id=\"在dubbo服务中手动获取注册的提供者的bean\"><a href=\"#在dubbo服务中手动获取注册的提供者的bean\" class=\"headerlink\" title=\"在dubbo服务中手动获取注册的提供者的bean\"></a>在dubbo服务中手动获取注册的提供者的bean</h3><p>在这里犯的错：以为通过SpringContextHolder.getBean()可以获取，是我傻逼了，dubbo中的服务怎么能用spring上下文获取呢。这里我使用dubbo的方式完成了这个功能。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获取服务的代理对象</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static &lt;T&gt; T getReferenceConfig(String appName,String address,Class&lt;?&gt; interfaceClass) &#123;</span><br><span class=\"line\">    String key  = interfaceClass.getName();</span><br><span class=\"line\">    ReferenceConfig&lt;T&gt; referenceConfig =  (ReferenceConfig&lt;T&gt;)referenceCache.get(key);</span><br><span class=\"line\">    if(referenceConfig == null)&#123;</span><br><span class=\"line\">        referenceConfig = new ReferenceConfig&lt;T&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        referenceConfig.setApplication(application);</span><br><span class=\"line\">        referenceConfig.setRegistry(getRegistryConfig(appName,address));</span><br><span class=\"line\">        referenceConfig.setInterface(interfaceClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        referenceCache.put(key,referenceConfig);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return referenceConfig.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"开发日记-20180718\"><a href=\"#开发日记-20180718\" class=\"headerlink\" title=\"开发日记 20180718\"></a>开发日记 20180718</h2><h3 id=\"com-alibaba-dubbo-remoting-transport-AbstractCodec-checkPayload-ERROR-Data-length-too-large\"><a href=\"#com-alibaba-dubbo-remoting-transport-AbstractCodec-checkPayload-ERROR-Data-length-too-large\" class=\"headerlink\" title=\"com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large\"></a>com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR  Data length too large: 11557050, max payload: 8388608 java.io.IOException: Data length too large: 11557050, max payload: 838860</span><br></pre></td></tr></table></figure>\n<p>在使用dubbo框架开发的时候，需要做一个导出csv文件的功能，查询大量的数据然后在提供者这边进行处理导出，其中数据达到过20万行以上，几十M的数据，抛出了这样一个异常。遇到服务提供者从数据库查询或者其他地方返回过大的对象，导致报错时，尽管有办法取消这个数据长度的限制，但是这并不符合程序开发的初衷。我们需要将对于数据的处理放在业务层，我在这里做了异步导出，给前端返回的仅仅是一个程序完成的状态，完美的解决了这个问题。</p>","more":"<h3 id=\"在dubbo消费者服务中写aop方法拦截工具类中的方法\"><a href=\"#在dubbo消费者服务中写aop方法拦截工具类中的方法\" class=\"headerlink\" title=\"在dubbo消费者服务中写aop方法拦截工具类中的方法\"></a>在dubbo消费者服务中写aop方法拦截工具类中的方法</h3><p>尽管服务的提供者和消费者都引入的工具类模块的依赖，但是拦截器的实际拦截的还是那个实际本身所在模块的方法。如果工具类是在消费者service层被使用的，那么在上层模块的拦截器是无法拦截到这个方法的。</p>\n<h3 id=\"在dubbo服务中手动获取注册的提供者的bean\"><a href=\"#在dubbo服务中手动获取注册的提供者的bean\" class=\"headerlink\" title=\"在dubbo服务中手动获取注册的提供者的bean\"></a>在dubbo服务中手动获取注册的提供者的bean</h3><p>在这里犯的错：以为通过SpringContextHolder.getBean()可以获取，是我傻逼了，dubbo中的服务怎么能用spring上下文获取呢。这里我使用dubbo的方式完成了这个功能。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获取服务的代理对象</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static &lt;T&gt; T getReferenceConfig(String appName,String address,Class&lt;?&gt; interfaceClass) &#123;</span><br><span class=\"line\">    String key  = interfaceClass.getName();</span><br><span class=\"line\">    ReferenceConfig&lt;T&gt; referenceConfig =  (ReferenceConfig&lt;T&gt;)referenceCache.get(key);</span><br><span class=\"line\">    if(referenceConfig == null)&#123;</span><br><span class=\"line\">        referenceConfig = new ReferenceConfig&lt;T&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        referenceConfig.setApplication(application);</span><br><span class=\"line\">        referenceConfig.setRegistry(getRegistryConfig(appName,address));</span><br><span class=\"line\">        referenceConfig.setInterface(interfaceClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        referenceCache.put(key,referenceConfig);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return referenceConfig.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"并发编程学习(一)：编写一个简易的可重入锁","date":"2019-05-17T12:22:23.000Z","_content":"\n![封面](nullIsMistake.jpg)\n\n<!--more-->\n#### 什么是可重入锁\n在Java多线程编程中，锁是用来控制代码操作的原子性的重要机制，即对某线程共享的数据进行操作的时候，保证该操作同一时间段只有一个线程操作，整个过程是原子操作，其他线程再操作的时候只能等待锁的释放(排他锁)。一般我们的锁都是声明在方法上或者代码块中，那么在实际编程中我们经常会出现一个类的实例方法调用另一个实例方法的情况，我们不希望这个时候同一个线程进入另一实例方法时还要再去等待锁的释放，可重入锁就是为了解决这个问题，即 **线程可以进入任何一个它已经拥有的锁所同步着的代码块**。\n\n#### 如何实现一个简单的可重入锁\n- 首先加锁的时候需要记录当前是哪一个线程加锁，加锁之后加锁标志位标记锁已被占用\n- 维护一个加锁计数器，线程每次加锁计数器都要加1，每释放一次计数器减1\n- 当非占用锁的线程进来之后自旋等待锁的释放，如果锁还在被占用，就wait();\n- 所释放的时候只有当前获取锁的线程调用才有用，锁释放加锁计数器减1，当减到0的时候，加锁标志位置为false，然后唤醒其他等待的线程\n\n```\npublic class MyLock implements Lock {\n\n    private boolean locked = false;// 当前锁是否已经被线程使用\n\n    private int lockCount;// 保存当前线程加锁的次数\n\n    private Thread thread;// 保存当前线程是哪一个\n\n    public synchronized void lock() {\n        try {\n            // 自旋等待\n            // 可重入：如果获取锁的不是当前线程并且当前已经有线程加锁，则等待\n            while (locked && Thread.currentThread() != this.thread) {\n                System.out.println(\"我等会儿。。。\");\n                wait();\n            }\n            // 如果没有线程使用锁或者获取锁的是当前线程 加锁计数器+1 然后thread指向获取锁的线程\n            this.thread = Thread.currentThread();\n            lockCount++;\n            locked = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n\n        }\n    }\n\n    /**\n     * 释放锁的操作\n     */\n    public synchronized void unlock() {\n        try {\n            // 如果不是当前线程 不需要做任何操作\n            if(this.thread == Thread.currentThread()){\n                // 锁计数器减1 如果当前线程获取锁个数释放完成\n                lockCount--;\n                if(lockCount == 0 ){\n                    // 释放完成 加锁标志置为false 再唤醒等待锁的线程\n                    locked = false;\n                    notifyAll();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n\n        }\n    }\n}\n```\n\n#### 在Java中常用的可重入锁\n- synchronized 关键字加锁\n- java.util.concurrent.locks.ReentrantLock\n- java.util.concurrent.locks.ReentrantReadWriteLock\n> 上述ReentrantLock内部实际上还是使用AQS，关于AQS，后面还要进行学习与整理\n","source":"_posts/编写一个简易的可重入锁-一.md","raw":"---\ntitle: 并发编程学习(一)：编写一个简易的可重入锁\ndate: 2019-05-17 20:22:23\ncategories: [Java基础,并发编程]\ntags: [Java基础,并发编程,可重入锁]\n---\n\n![封面](nullIsMistake.jpg)\n\n<!--more-->\n#### 什么是可重入锁\n在Java多线程编程中，锁是用来控制代码操作的原子性的重要机制，即对某线程共享的数据进行操作的时候，保证该操作同一时间段只有一个线程操作，整个过程是原子操作，其他线程再操作的时候只能等待锁的释放(排他锁)。一般我们的锁都是声明在方法上或者代码块中，那么在实际编程中我们经常会出现一个类的实例方法调用另一个实例方法的情况，我们不希望这个时候同一个线程进入另一实例方法时还要再去等待锁的释放，可重入锁就是为了解决这个问题，即 **线程可以进入任何一个它已经拥有的锁所同步着的代码块**。\n\n#### 如何实现一个简单的可重入锁\n- 首先加锁的时候需要记录当前是哪一个线程加锁，加锁之后加锁标志位标记锁已被占用\n- 维护一个加锁计数器，线程每次加锁计数器都要加1，每释放一次计数器减1\n- 当非占用锁的线程进来之后自旋等待锁的释放，如果锁还在被占用，就wait();\n- 所释放的时候只有当前获取锁的线程调用才有用，锁释放加锁计数器减1，当减到0的时候，加锁标志位置为false，然后唤醒其他等待的线程\n\n```\npublic class MyLock implements Lock {\n\n    private boolean locked = false;// 当前锁是否已经被线程使用\n\n    private int lockCount;// 保存当前线程加锁的次数\n\n    private Thread thread;// 保存当前线程是哪一个\n\n    public synchronized void lock() {\n        try {\n            // 自旋等待\n            // 可重入：如果获取锁的不是当前线程并且当前已经有线程加锁，则等待\n            while (locked && Thread.currentThread() != this.thread) {\n                System.out.println(\"我等会儿。。。\");\n                wait();\n            }\n            // 如果没有线程使用锁或者获取锁的是当前线程 加锁计数器+1 然后thread指向获取锁的线程\n            this.thread = Thread.currentThread();\n            lockCount++;\n            locked = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n\n        }\n    }\n\n    /**\n     * 释放锁的操作\n     */\n    public synchronized void unlock() {\n        try {\n            // 如果不是当前线程 不需要做任何操作\n            if(this.thread == Thread.currentThread()){\n                // 锁计数器减1 如果当前线程获取锁个数释放完成\n                lockCount--;\n                if(lockCount == 0 ){\n                    // 释放完成 加锁标志置为false 再唤醒等待锁的线程\n                    locked = false;\n                    notifyAll();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n\n        }\n    }\n}\n```\n\n#### 在Java中常用的可重入锁\n- synchronized 关键字加锁\n- java.util.concurrent.locks.ReentrantLock\n- java.util.concurrent.locks.ReentrantReadWriteLock\n> 上述ReentrantLock内部实际上还是使用AQS，关于AQS，后面还要进行学习与整理\n","slug":"编写一个简易的可重入锁-一","published":1,"updated":"2019-06-17T06:18:02.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvs001xcwnkcr6rs8ej","content":"<p><img src=\"/blog/20190517/编写一个简易的可重入锁-一/nullIsMistake.jpg\" alt=\"封面\"></p>\n<a id=\"more\"></a>\n<h4 id=\"什么是可重入锁\"><a href=\"#什么是可重入锁\" class=\"headerlink\" title=\"什么是可重入锁\"></a>什么是可重入锁</h4><p>在Java多线程编程中，锁是用来控制代码操作的原子性的重要机制，即对某线程共享的数据进行操作的时候，保证该操作同一时间段只有一个线程操作，整个过程是原子操作，其他线程再操作的时候只能等待锁的释放(排他锁)。一般我们的锁都是声明在方法上或者代码块中，那么在实际编程中我们经常会出现一个类的实例方法调用另一个实例方法的情况，我们不希望这个时候同一个线程进入另一实例方法时还要再去等待锁的释放，可重入锁就是为了解决这个问题，即 <strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>。</p>\n<h4 id=\"如何实现一个简单的可重入锁\"><a href=\"#如何实现一个简单的可重入锁\" class=\"headerlink\" title=\"如何实现一个简单的可重入锁\"></a>如何实现一个简单的可重入锁</h4><ul>\n<li>首先加锁的时候需要记录当前是哪一个线程加锁，加锁之后加锁标志位标记锁已被占用</li>\n<li>维护一个加锁计数器，线程每次加锁计数器都要加1，每释放一次计数器减1</li>\n<li>当非占用锁的线程进来之后自旋等待锁的释放，如果锁还在被占用，就wait();</li>\n<li>所释放的时候只有当前获取锁的线程调用才有用，锁释放加锁计数器减1，当减到0的时候，加锁标志位置为false，然后唤醒其他等待的线程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyLock implements Lock &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private boolean locked = false;// 当前锁是否已经被线程使用</span><br><span class=\"line\"></span><br><span class=\"line\">    private int lockCount;// 保存当前线程加锁的次数</span><br><span class=\"line\"></span><br><span class=\"line\">    private Thread thread;// 保存当前线程是哪一个</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void lock() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 自旋等待</span><br><span class=\"line\">            // 可重入：如果获取锁的不是当前线程并且当前已经有线程加锁，则等待</span><br><span class=\"line\">            while (locked &amp;&amp; Thread.currentThread() != this.thread) &#123;</span><br><span class=\"line\">                System.out.println(&quot;我等会儿。。。&quot;);</span><br><span class=\"line\">                wait();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 如果没有线程使用锁或者获取锁的是当前线程 加锁计数器+1 然后thread指向获取锁的线程</span><br><span class=\"line\">            this.thread = Thread.currentThread();</span><br><span class=\"line\">            lockCount++;</span><br><span class=\"line\">            locked = true;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 释放锁的操作</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public synchronized void unlock() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 如果不是当前线程 不需要做任何操作</span><br><span class=\"line\">            if(this.thread == Thread.currentThread())&#123;</span><br><span class=\"line\">                // 锁计数器减1 如果当前线程获取锁个数释放完成</span><br><span class=\"line\">                lockCount--;</span><br><span class=\"line\">                if(lockCount == 0 )&#123;</span><br><span class=\"line\">                    // 释放完成 加锁标志置为false 再唤醒等待锁的线程</span><br><span class=\"line\">                    locked = false;</span><br><span class=\"line\">                    notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在Java中常用的可重入锁\"><a href=\"#在Java中常用的可重入锁\" class=\"headerlink\" title=\"在Java中常用的可重入锁\"></a>在Java中常用的可重入锁</h4><ul>\n<li>synchronized 关键字加锁</li>\n<li>java.util.concurrent.locks.ReentrantLock</li>\n<li>java.util.concurrent.locks.ReentrantReadWriteLock<blockquote>\n<p>上述ReentrantLock内部实际上还是使用AQS，关于AQS，后面还要进行学习与整理</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"/blog/20190517/编写一个简易的可重入锁-一/nullIsMistake.jpg\" alt=\"封面\"></p>","more":"<h4 id=\"什么是可重入锁\"><a href=\"#什么是可重入锁\" class=\"headerlink\" title=\"什么是可重入锁\"></a>什么是可重入锁</h4><p>在Java多线程编程中，锁是用来控制代码操作的原子性的重要机制，即对某线程共享的数据进行操作的时候，保证该操作同一时间段只有一个线程操作，整个过程是原子操作，其他线程再操作的时候只能等待锁的释放(排他锁)。一般我们的锁都是声明在方法上或者代码块中，那么在实际编程中我们经常会出现一个类的实例方法调用另一个实例方法的情况，我们不希望这个时候同一个线程进入另一实例方法时还要再去等待锁的释放，可重入锁就是为了解决这个问题，即 <strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>。</p>\n<h4 id=\"如何实现一个简单的可重入锁\"><a href=\"#如何实现一个简单的可重入锁\" class=\"headerlink\" title=\"如何实现一个简单的可重入锁\"></a>如何实现一个简单的可重入锁</h4><ul>\n<li>首先加锁的时候需要记录当前是哪一个线程加锁，加锁之后加锁标志位标记锁已被占用</li>\n<li>维护一个加锁计数器，线程每次加锁计数器都要加1，每释放一次计数器减1</li>\n<li>当非占用锁的线程进来之后自旋等待锁的释放，如果锁还在被占用，就wait();</li>\n<li>所释放的时候只有当前获取锁的线程调用才有用，锁释放加锁计数器减1，当减到0的时候，加锁标志位置为false，然后唤醒其他等待的线程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyLock implements Lock &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private boolean locked = false;// 当前锁是否已经被线程使用</span><br><span class=\"line\"></span><br><span class=\"line\">    private int lockCount;// 保存当前线程加锁的次数</span><br><span class=\"line\"></span><br><span class=\"line\">    private Thread thread;// 保存当前线程是哪一个</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void lock() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 自旋等待</span><br><span class=\"line\">            // 可重入：如果获取锁的不是当前线程并且当前已经有线程加锁，则等待</span><br><span class=\"line\">            while (locked &amp;&amp; Thread.currentThread() != this.thread) &#123;</span><br><span class=\"line\">                System.out.println(&quot;我等会儿。。。&quot;);</span><br><span class=\"line\">                wait();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 如果没有线程使用锁或者获取锁的是当前线程 加锁计数器+1 然后thread指向获取锁的线程</span><br><span class=\"line\">            this.thread = Thread.currentThread();</span><br><span class=\"line\">            lockCount++;</span><br><span class=\"line\">            locked = true;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 释放锁的操作</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public synchronized void unlock() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 如果不是当前线程 不需要做任何操作</span><br><span class=\"line\">            if(this.thread == Thread.currentThread())&#123;</span><br><span class=\"line\">                // 锁计数器减1 如果当前线程获取锁个数释放完成</span><br><span class=\"line\">                lockCount--;</span><br><span class=\"line\">                if(lockCount == 0 )&#123;</span><br><span class=\"line\">                    // 释放完成 加锁标志置为false 再唤醒等待锁的线程</span><br><span class=\"line\">                    locked = false;</span><br><span class=\"line\">                    notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在Java中常用的可重入锁\"><a href=\"#在Java中常用的可重入锁\" class=\"headerlink\" title=\"在Java中常用的可重入锁\"></a>在Java中常用的可重入锁</h4><ul>\n<li>synchronized 关键字加锁</li>\n<li>java.util.concurrent.locks.ReentrantLock</li>\n<li>java.util.concurrent.locks.ReentrantReadWriteLock<blockquote>\n<p>上述ReentrantLock内部实际上还是使用AQS，关于AQS，后面还要进行学习与整理</p>\n</blockquote>\n</li>\n</ul>"},{"title":"泰国7天6晚自由行攻略","date":"2018-09-04T11:38:45.000Z","_content":"\n> 人生不可能是一场说走就走的旅行，但心怀远方的人，一定要时刻做着说走就走的准备！\n\n<font face=\"STCAIYUN\">关于去泰国这件事情，可能发生的很突然，但是没关系，既然决定了，就把它安排在计划里。</font>\n\n### 一、出行前的准备\n#### 1、护照&签证\n我是在杭州工作，在杭州工作社保交满一年，就可以办护照了。拿着身份证在西湖区行政服务中心的出入境管理那儿就可以办理了。现在一楼自助打印下社保证明，然后去后面的楼，出入境办理区按照流程办理即可。大概一个多礼拜就能拿到护照，我也没想到有这么快。\n\n签证是在淘宝上买的，260￥。七个工作日到手。\n#### 2、泰铢&电话卡&出入境&去泰国的必备软件&其他\n\n泰国新规定，过境签、落地签-10000泰铢或等值外币现金（每人），20000泰铢（家庭）；\n旅游签-20000泰铢或等值外币现金（每人），40000泰铢（家庭），抽查到概率很低，一般落地签会查的吧。但是网上说好像都不查的，或者很少查，但还是换两千的吧。\n\n然后再淘宝买泰国7天happy卡，[我买的是这家的](https://traveldetail.fliggy.com/item.htm?spm=a230r.1.14.1.42f77cb9MwHKZ4&id=38255797452&ns=1&abbucket=7&smToken=ef69fda777d249bab6581b59d4cb9a82&smSign=twzGgFTirKEEIRtKkNLrYQ%3D%3D)，8天无限流量，4G。\n\n入境时需要填写出入境卡，然后和护照一起交给海关查看盖章。下面是入境卡中文说明图：\n![出入境卡](http://ol3d80aa0.bkt.clouddn.com/%E6%B3%B0%E5%9B%BD%E5%87%BA%E5%85%A5%E5%A2%83%E5%8D%A1%E4%B8%AD%E6%96%87.jpg)\n\n一般情况下，在乘坐航班时常会有工作人员在抵达目的地钱给乘客发放出入境卡，以便乘客提前填好出入境卡，方便出关。护照也很重要，可以在国内出发前复印几份护照一定要放行李箱，不要随身携带。\n\n\n\n\n\n\n<!--more-->\n\n### END - 其他一些实用信息\n> #### 大使馆/领事馆\n\n中国驻泰国大使馆\n地址：NO.57, Racgadapisek Road, Bangkok\n电话：+66-02-2450088\n领事保护电话：+66-854833327（24小时值班手机），+66-02-2457010（工作日9：00-17：00）\n\n中国驻清迈总领事馆\n地址：111 Changloh Road, Haiya District, Chiangmai\n电话：+66-53-280380，+66-53-276125，+66-53-276457\n\n中国驻宋卡总领事馆（近普吉岛、苏梅岛、甲米）\n地址：9 Sadao Road, Songkhla\n电话：+66-74-322034\n领事保护电话：+66-817665560\n\n中国驻宋卡总领馆驻普吉领事办公室\n电话：+66-76-304219\n领事保护电话：+66-945956168（中文、泰文），+66-945986859（中文）\n\n中国驻孔敬总领馆\n地址：142/44 Moo 2，Rob-Bueng Rd.，Nai-Muang， Muang， Khon Kaen\n电话：+66-43-226873\n\n> #### 紧急电话\n\n警察:123/191\n火警:199\n救护:2460199\n领事:022-457010\n大使馆:022-457044\n旅游投诉:1155\n","source":"_posts/泰国7天6晚自由行攻略.md","raw":"---\ntitle: 泰国7天6晚自由行攻略\ndate: 2018-09-04 19:38:45\ncategories: [个人随笔]\ntags: [个人随笔]\n---\n\n> 人生不可能是一场说走就走的旅行，但心怀远方的人，一定要时刻做着说走就走的准备！\n\n<font face=\"STCAIYUN\">关于去泰国这件事情，可能发生的很突然，但是没关系，既然决定了，就把它安排在计划里。</font>\n\n### 一、出行前的准备\n#### 1、护照&签证\n我是在杭州工作，在杭州工作社保交满一年，就可以办护照了。拿着身份证在西湖区行政服务中心的出入境管理那儿就可以办理了。现在一楼自助打印下社保证明，然后去后面的楼，出入境办理区按照流程办理即可。大概一个多礼拜就能拿到护照，我也没想到有这么快。\n\n签证是在淘宝上买的，260￥。七个工作日到手。\n#### 2、泰铢&电话卡&出入境&去泰国的必备软件&其他\n\n泰国新规定，过境签、落地签-10000泰铢或等值外币现金（每人），20000泰铢（家庭）；\n旅游签-20000泰铢或等值外币现金（每人），40000泰铢（家庭），抽查到概率很低，一般落地签会查的吧。但是网上说好像都不查的，或者很少查，但还是换两千的吧。\n\n然后再淘宝买泰国7天happy卡，[我买的是这家的](https://traveldetail.fliggy.com/item.htm?spm=a230r.1.14.1.42f77cb9MwHKZ4&id=38255797452&ns=1&abbucket=7&smToken=ef69fda777d249bab6581b59d4cb9a82&smSign=twzGgFTirKEEIRtKkNLrYQ%3D%3D)，8天无限流量，4G。\n\n入境时需要填写出入境卡，然后和护照一起交给海关查看盖章。下面是入境卡中文说明图：\n![出入境卡](http://ol3d80aa0.bkt.clouddn.com/%E6%B3%B0%E5%9B%BD%E5%87%BA%E5%85%A5%E5%A2%83%E5%8D%A1%E4%B8%AD%E6%96%87.jpg)\n\n一般情况下，在乘坐航班时常会有工作人员在抵达目的地钱给乘客发放出入境卡，以便乘客提前填好出入境卡，方便出关。护照也很重要，可以在国内出发前复印几份护照一定要放行李箱，不要随身携带。\n\n\n\n\n\n\n<!--more-->\n\n### END - 其他一些实用信息\n> #### 大使馆/领事馆\n\n中国驻泰国大使馆\n地址：NO.57, Racgadapisek Road, Bangkok\n电话：+66-02-2450088\n领事保护电话：+66-854833327（24小时值班手机），+66-02-2457010（工作日9：00-17：00）\n\n中国驻清迈总领事馆\n地址：111 Changloh Road, Haiya District, Chiangmai\n电话：+66-53-280380，+66-53-276125，+66-53-276457\n\n中国驻宋卡总领事馆（近普吉岛、苏梅岛、甲米）\n地址：9 Sadao Road, Songkhla\n电话：+66-74-322034\n领事保护电话：+66-817665560\n\n中国驻宋卡总领馆驻普吉领事办公室\n电话：+66-76-304219\n领事保护电话：+66-945956168（中文、泰文），+66-945986859（中文）\n\n中国驻孔敬总领馆\n地址：142/44 Moo 2，Rob-Bueng Rd.，Nai-Muang， Muang， Khon Kaen\n电话：+66-43-226873\n\n> #### 紧急电话\n\n警察:123/191\n火警:199\n救护:2460199\n领事:022-457010\n大使馆:022-457044\n旅游投诉:1155\n","slug":"泰国7天6晚自由行攻略","published":1,"updated":"2019-05-07T09:48:29.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvt0021cwnk9k1xn3q5","content":"<blockquote>\n<p>人生不可能是一场说走就走的旅行，但心怀远方的人，一定要时刻做着说走就走的准备！</p>\n</blockquote>\n<font face=\"STCAIYUN\">关于去泰国这件事情，可能发生的很突然，但是没关系，既然决定了，就把它安排在计划里。</font>\n\n<h3 id=\"一、出行前的准备\"><a href=\"#一、出行前的准备\" class=\"headerlink\" title=\"一、出行前的准备\"></a>一、出行前的准备</h3><h4 id=\"1、护照-amp-签证\"><a href=\"#1、护照-amp-签证\" class=\"headerlink\" title=\"1、护照&amp;签证\"></a>1、护照&amp;签证</h4><p>我是在杭州工作，在杭州工作社保交满一年，就可以办护照了。拿着身份证在西湖区行政服务中心的出入境管理那儿就可以办理了。现在一楼自助打印下社保证明，然后去后面的楼，出入境办理区按照流程办理即可。大概一个多礼拜就能拿到护照，我也没想到有这么快。</p>\n<p>签证是在淘宝上买的，260￥。七个工作日到手。</p>\n<h4 id=\"2、泰铢-amp-电话卡-amp-出入境-amp-去泰国的必备软件-amp-其他\"><a href=\"#2、泰铢-amp-电话卡-amp-出入境-amp-去泰国的必备软件-amp-其他\" class=\"headerlink\" title=\"2、泰铢&amp;电话卡&amp;出入境&amp;去泰国的必备软件&amp;其他\"></a>2、泰铢&amp;电话卡&amp;出入境&amp;去泰国的必备软件&amp;其他</h4><p>泰国新规定，过境签、落地签-10000泰铢或等值外币现金（每人），20000泰铢（家庭）；<br>旅游签-20000泰铢或等值外币现金（每人），40000泰铢（家庭），抽查到概率很低，一般落地签会查的吧。但是网上说好像都不查的，或者很少查，但还是换两千的吧。</p>\n<p>然后再淘宝买泰国7天happy卡，<a href=\"https://traveldetail.fliggy.com/item.htm?spm=a230r.1.14.1.42f77cb9MwHKZ4&amp;id=38255797452&amp;ns=1&amp;abbucket=7&amp;smToken=ef69fda777d249bab6581b59d4cb9a82&amp;smSign=twzGgFTirKEEIRtKkNLrYQ%3D%3D\" target=\"_blank\" rel=\"noopener\">我买的是这家的</a>，8天无限流量，4G。</p>\n<p>入境时需要填写出入境卡，然后和护照一起交给海关查看盖章。下面是入境卡中文说明图：<br><img src=\"http://ol3d80aa0.bkt.clouddn.com/%E6%B3%B0%E5%9B%BD%E5%87%BA%E5%85%A5%E5%A2%83%E5%8D%A1%E4%B8%AD%E6%96%87.jpg\" alt=\"出入境卡\"></p>\n<p>一般情况下，在乘坐航班时常会有工作人员在抵达目的地钱给乘客发放出入境卡，以便乘客提前填好出入境卡，方便出关。护照也很重要，可以在国内出发前复印几份护照一定要放行李箱，不要随身携带。</p>\n<a id=\"more\"></a>\n<h3 id=\"END-其他一些实用信息\"><a href=\"#END-其他一些实用信息\" class=\"headerlink\" title=\"END - 其他一些实用信息\"></a>END - 其他一些实用信息</h3><blockquote>\n<h4 id=\"大使馆-领事馆\"><a href=\"#大使馆-领事馆\" class=\"headerlink\" title=\"大使馆/领事馆\"></a>大使馆/领事馆</h4></blockquote>\n<p>中国驻泰国大使馆<br>地址：NO.57, Racgadapisek Road, Bangkok<br>电话：+66-02-2450088<br>领事保护电话：+66-854833327（24小时值班手机），+66-02-2457010（工作日9：00-17：00）</p>\n<p>中国驻清迈总领事馆<br>地址：111 Changloh Road, Haiya District, Chiangmai<br>电话：+66-53-280380，+66-53-276125，+66-53-276457</p>\n<p>中国驻宋卡总领事馆（近普吉岛、苏梅岛、甲米）<br>地址：9 Sadao Road, Songkhla<br>电话：+66-74-322034<br>领事保护电话：+66-817665560</p>\n<p>中国驻宋卡总领馆驻普吉领事办公室<br>电话：+66-76-304219<br>领事保护电话：+66-945956168（中文、泰文），+66-945986859（中文）</p>\n<p>中国驻孔敬总领馆<br>地址：142/44 Moo 2，Rob-Bueng Rd.，Nai-Muang， Muang， Khon Kaen<br>电话：+66-43-226873</p>\n<blockquote>\n<h4 id=\"紧急电话\"><a href=\"#紧急电话\" class=\"headerlink\" title=\"紧急电话\"></a>紧急电话</h4></blockquote>\n<p>警察:123/191<br>火警:199<br>救护:2460199<br>领事:022-457010<br>大使馆:022-457044<br>旅游投诉:1155</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>人生不可能是一场说走就走的旅行，但心怀远方的人，一定要时刻做着说走就走的准备！</p>\n</blockquote>\n<font face=\"STCAIYUN\">关于去泰国这件事情，可能发生的很突然，但是没关系，既然决定了，就把它安排在计划里。</font>\n\n<h3 id=\"一、出行前的准备\"><a href=\"#一、出行前的准备\" class=\"headerlink\" title=\"一、出行前的准备\"></a>一、出行前的准备</h3><h4 id=\"1、护照-amp-签证\"><a href=\"#1、护照-amp-签证\" class=\"headerlink\" title=\"1、护照&amp;签证\"></a>1、护照&amp;签证</h4><p>我是在杭州工作，在杭州工作社保交满一年，就可以办护照了。拿着身份证在西湖区行政服务中心的出入境管理那儿就可以办理了。现在一楼自助打印下社保证明，然后去后面的楼，出入境办理区按照流程办理即可。大概一个多礼拜就能拿到护照，我也没想到有这么快。</p>\n<p>签证是在淘宝上买的，260￥。七个工作日到手。</p>\n<h4 id=\"2、泰铢-amp-电话卡-amp-出入境-amp-去泰国的必备软件-amp-其他\"><a href=\"#2、泰铢-amp-电话卡-amp-出入境-amp-去泰国的必备软件-amp-其他\" class=\"headerlink\" title=\"2、泰铢&amp;电话卡&amp;出入境&amp;去泰国的必备软件&amp;其他\"></a>2、泰铢&amp;电话卡&amp;出入境&amp;去泰国的必备软件&amp;其他</h4><p>泰国新规定，过境签、落地签-10000泰铢或等值外币现金（每人），20000泰铢（家庭）；<br>旅游签-20000泰铢或等值外币现金（每人），40000泰铢（家庭），抽查到概率很低，一般落地签会查的吧。但是网上说好像都不查的，或者很少查，但还是换两千的吧。</p>\n<p>然后再淘宝买泰国7天happy卡，<a href=\"https://traveldetail.fliggy.com/item.htm?spm=a230r.1.14.1.42f77cb9MwHKZ4&amp;id=38255797452&amp;ns=1&amp;abbucket=7&amp;smToken=ef69fda777d249bab6581b59d4cb9a82&amp;smSign=twzGgFTirKEEIRtKkNLrYQ%3D%3D\" target=\"_blank\" rel=\"noopener\">我买的是这家的</a>，8天无限流量，4G。</p>\n<p>入境时需要填写出入境卡，然后和护照一起交给海关查看盖章。下面是入境卡中文说明图：<br><img src=\"http://ol3d80aa0.bkt.clouddn.com/%E6%B3%B0%E5%9B%BD%E5%87%BA%E5%85%A5%E5%A2%83%E5%8D%A1%E4%B8%AD%E6%96%87.jpg\" alt=\"出入境卡\"></p>\n<p>一般情况下，在乘坐航班时常会有工作人员在抵达目的地钱给乘客发放出入境卡，以便乘客提前填好出入境卡，方便出关。护照也很重要，可以在国内出发前复印几份护照一定要放行李箱，不要随身携带。</p>","more":"<h3 id=\"END-其他一些实用信息\"><a href=\"#END-其他一些实用信息\" class=\"headerlink\" title=\"END - 其他一些实用信息\"></a>END - 其他一些实用信息</h3><blockquote>\n<h4 id=\"大使馆-领事馆\"><a href=\"#大使馆-领事馆\" class=\"headerlink\" title=\"大使馆/领事馆\"></a>大使馆/领事馆</h4></blockquote>\n<p>中国驻泰国大使馆<br>地址：NO.57, Racgadapisek Road, Bangkok<br>电话：+66-02-2450088<br>领事保护电话：+66-854833327（24小时值班手机），+66-02-2457010（工作日9：00-17：00）</p>\n<p>中国驻清迈总领事馆<br>地址：111 Changloh Road, Haiya District, Chiangmai<br>电话：+66-53-280380，+66-53-276125，+66-53-276457</p>\n<p>中国驻宋卡总领事馆（近普吉岛、苏梅岛、甲米）<br>地址：9 Sadao Road, Songkhla<br>电话：+66-74-322034<br>领事保护电话：+66-817665560</p>\n<p>中国驻宋卡总领馆驻普吉领事办公室<br>电话：+66-76-304219<br>领事保护电话：+66-945956168（中文、泰文），+66-945986859（中文）</p>\n<p>中国驻孔敬总领馆<br>地址：142/44 Moo 2，Rob-Bueng Rd.，Nai-Muang， Muang， Khon Kaen<br>电话：+66-43-226873</p>\n<blockquote>\n<h4 id=\"紧急电话\"><a href=\"#紧急电话\" class=\"headerlink\" title=\"紧急电话\"></a>紧急电话</h4></blockquote>\n<p>警察:123/191<br>火警:199<br>救护:2460199<br>领事:022-457010<br>大使馆:022-457044<br>旅游投诉:1155</p>"},{"title":"校招面试【京东、顺丰科技、招银网络科技、去哪儿网】","date":"2016-09-27T11:38:45.000Z","_content":"\n\n* 2017校招过的太惨了，还一度把原因怪罪在实习上，认为自己实习了4个月非Java研发的东西导致自己对于Java没有进行更加深入的学习，其实呢，还是应该怪自己不努力，怪不得其他。*\n从三星离职之后就开始找一些公众号内推，我是来自非985、211院校的本科生，学的还是自动化专业，偏硬件，实习内容还不是Java开发之类的东西，不知道是由于这些公众号的原因（恶意吸引粉丝）还是自己的简历确实有问题，内推一直不顺利。烦得很。\n之后又从9月开始海投Java软件开发岗，各种在线笔试。博主的基础（计算机网络操作系统等）本身就不强，C/C++/Java/PHP等还有HTML/CSS/JS/jQuery这些乱七八糟都学，算法和数据结构也学得不是很精，应付不来笔试编程题，感觉面试过的公司好少，妈的工作要找到十月了。\n\n\n<!--more-->\n\n\n** 首先说下招银电面：** 9月23号晚上八点正在理发染发呢电话就来了，都不预约一下。\n1、在Java中进行数据库连接并操作数据的步骤？最后需要进行什么操作？\n2、项目中使用jquery，那么on、bind、live、delegate这几个函数有什么区别？\n3、一个http请求所包含的数据格式是什么？\n4、一次http请求的详细处理过程？\n5、一次struts处理请求从开始到看到页面数据之间都发生了什么，整个详细过程？\n6、项目中都用到了什么框架？（spring+struts+mybatis）\n7、在自己的项目中有没有用到并发？如果让你现在考虑给你的项目中考虑并发你会怎么做？你要控制（进行同步）的数据源是哪些？\n*还有几个吧，想不起来了，应该比较简单就没有印象。电面后预约28号下午再面试。*\n\n\n----------\n\n\n**招银现场面**===该来的就这样来了\n*9月28号下午，不知道哪里来的自信感觉自己能够在一个半小时之内从长安赶到永宁门，坐地铁还把安远门当成了永宁门，到了安远门叫个优步，打电话让司机快一点，妈的竟然给我取消了，害我最后坐公交去，迟到了半个小时。心态爆炸！！！╮(╯▽╰)╭*\n1、去了在房间里等着，过会儿从酒店房间出来一个，叫我进去面试。先问我要了成绩单和一些证书，感觉招银对于成绩和证书很看重。面试官是三个人，3V1，很紧张有木有。中间坐着老大，然后一个问技术的，一个HR。\n2、自我介绍\n3、介绍一下自己的项目\n4、项目中是使用servlet编写的后台代码，为什么不用开源框架？\n5、如果要给项目中添加日志，该如何做？\n6、一个struts请求从输入URL到显示在页面上都经过了哪些过程？\n7、中间老大看我写着struts1，就问为什么使用struts1而不是struts2，有研究过两者的区别吗？\n8、给一个string，问如何不使用任何库函数也不转化为数组，如何逆序？\n就这么多问题，心态爆炸！怀疑人生！阿弥陀佛！\n\n\n----------\n\n\n** 京东一面：** 9月24日一早6点就爬起来了，昨晚一晚上都没睡好。做梦都在想着一些多线程常考的东西，果然第二天就问了。\n1、了解哪些常用的集合（set、list、map）？说说他们各自的特点（ArrayList和LinkedList等）？\n2、HashMap、HashTable的区别？HashMap扩容为什么是2倍？如何实现的？\n3、说一说线程调度机制？对线程池有何理解？哪里会用到线程池？好处是？\n4、JVM中如果有一个线程挂起了，用什么工具去查找这个线程？\n5、Java在什么时候会内存溢出？持久代内存溢出是什么情况？\n6、动态代理的实现？（从动态代理答到了springAOP）\n7、装饰模式了解吗？它的特点是什么？\n8、I/O库中都用到了什么设计模式？\n9、struts的一次请求是如何处理的？\n10、网络编程？socket？\n11、数据库索引了解吗？一个表中什么情况适合建立索引？如何去建立数据库索引？\n12、快速排序的时间复杂度、原理？\n13、java多态的实现原理？动态绑定底层虚拟机是如何实现的？\n14、forward和redirect的区别？\n*同样。。。有很多问题没想起来，一面半个多小时，后天二面。。*\n\n\n----------\n\n\n** 京东二面： ** 感觉一面回答的不好，全程面试官问什么我答什么，一点互动都没有，狠狠狠紧张！二面抱着无所谓的心态去的，倒还没有一面紧张。\n1、了解那些算法和设计模式，说说你都用他们在什么地方？（贪心、回溯、分治、动态规划  ||  单例模式、工厂模式、动态代理、装饰模式、适配器模式等，说了说单例工厂动态代理等，再说到JDK动态代理和CGLIB代理的区别，一顿乱侃）\n2、你的项目中那些都用到了多服务器？分布式了解吗？还问到了跨域请求。在实习的时候开发的网站也是单机吗？（从这儿开始问分布式集群服务器，高并发，这方面没怎么深入学习哎）\n3、设计一个抢购商品的系统需要考虑到那些问题？\n4、对于线程池有什么理解？\n5、消息队列？\n6、知道红黑树吗？平衡树？有什么区别？\n*算了不写了，想不起来了，估计二面跪了。。。*\n\n\n----------\n\n\n** 顺丰技术面： ** 9月24日下午5点，就是京东一面的下午。。。（除了技术面就是HR）\n1、简单的自我介绍一下。。。\n2、介绍自己认为最能体现自己能力的项目，跟着项目引出很多题目，问了个透彻。。。\n3、觉得自己还有那些方面的能力没有体现出来，可以说一说？（在这里傻逼了，我他喵说我暂时想不起来。因为可能自己的项目有点简单了，面试官还想要看看自己其他的能力，醉醉哒）\n顺丰科技面试就这样，问了40多分钟，结果问完就让我走了，伤心，怪自己傻逼了。另一个西电的技术面玩就直接HR面了，让我回来等通知，4天了都没有通过不通过的通知，也是厉害。挂了也不让我安心挂！\n\n\n----------\n** 去哪儿网** 9月29号下午3点好像\n感觉自己真的是，干什么事情完全不做任何准备的，很多看过的问题，在面试的时候就只能说有印象，答不详细，想抽死自己！\n1、去哪儿在金沙国际酒店面试，一天内面完，对去哪儿抱了很大希望，因为听学长说这个面试不难，问的比较基础，妈的现在写这段话还是想扇自己。\n2、刚见到面试官，他拿到简历就说，你是本科生啊？我说哦。。。然后就是自我介绍。。。\n3、给我了一张纸，在纸上写出自己用过的所有的类名。。。然后他在一边电脑上敲着东西。突然让写自己用过的所有的类的类名，脑子有点儿蒙了。\n4、说说mysql的引擎吧，说了myisam和innodb以及其区别，这个看过。\n5、mysql的各种连接是怎么回事？\n6、说说B树和B+树的区别吧。\n7、哈希冲突的解决算法？\n8、说说HashMap的实现原理？\n9、有什么问题问我？\n10、还有一些忘记了。。。\n/(ㄒoㄒ)/~~。。。都是些很简单的问题，妈的就是答得不好不够详细。\n\n----------\n** 总结 ： ** 菜鸟的求职之路总是艰辛的，校招时间还长，十月份还有几家面试（觉得自己的脸火辣辣的疼。。。），看到人都拿到了很好的Offer，不服啊！哎，语言总是苍白的，只有安心敲代码！！！！！！！！！国庆七天奋发图强，多看看Java并发编程实战那书上的东西吧，问得太多了。","source":"_posts/校招面试经历.md","raw":"\n---\ntitle: 校招面试【京东、顺丰科技、招银网络科技、去哪儿网】\ndate: 2016-09-27 19:38:45\ncategories: [程序人生]\ntags: [面试经历, 个人随笔]\n---\n\n\n* 2017校招过的太惨了，还一度把原因怪罪在实习上，认为自己实习了4个月非Java研发的东西导致自己对于Java没有进行更加深入的学习，其实呢，还是应该怪自己不努力，怪不得其他。*\n从三星离职之后就开始找一些公众号内推，我是来自非985、211院校的本科生，学的还是自动化专业，偏硬件，实习内容还不是Java开发之类的东西，不知道是由于这些公众号的原因（恶意吸引粉丝）还是自己的简历确实有问题，内推一直不顺利。烦得很。\n之后又从9月开始海投Java软件开发岗，各种在线笔试。博主的基础（计算机网络操作系统等）本身就不强，C/C++/Java/PHP等还有HTML/CSS/JS/jQuery这些乱七八糟都学，算法和数据结构也学得不是很精，应付不来笔试编程题，感觉面试过的公司好少，妈的工作要找到十月了。\n\n\n<!--more-->\n\n\n** 首先说下招银电面：** 9月23号晚上八点正在理发染发呢电话就来了，都不预约一下。\n1、在Java中进行数据库连接并操作数据的步骤？最后需要进行什么操作？\n2、项目中使用jquery，那么on、bind、live、delegate这几个函数有什么区别？\n3、一个http请求所包含的数据格式是什么？\n4、一次http请求的详细处理过程？\n5、一次struts处理请求从开始到看到页面数据之间都发生了什么，整个详细过程？\n6、项目中都用到了什么框架？（spring+struts+mybatis）\n7、在自己的项目中有没有用到并发？如果让你现在考虑给你的项目中考虑并发你会怎么做？你要控制（进行同步）的数据源是哪些？\n*还有几个吧，想不起来了，应该比较简单就没有印象。电面后预约28号下午再面试。*\n\n\n----------\n\n\n**招银现场面**===该来的就这样来了\n*9月28号下午，不知道哪里来的自信感觉自己能够在一个半小时之内从长安赶到永宁门，坐地铁还把安远门当成了永宁门，到了安远门叫个优步，打电话让司机快一点，妈的竟然给我取消了，害我最后坐公交去，迟到了半个小时。心态爆炸！！！╮(╯▽╰)╭*\n1、去了在房间里等着，过会儿从酒店房间出来一个，叫我进去面试。先问我要了成绩单和一些证书，感觉招银对于成绩和证书很看重。面试官是三个人，3V1，很紧张有木有。中间坐着老大，然后一个问技术的，一个HR。\n2、自我介绍\n3、介绍一下自己的项目\n4、项目中是使用servlet编写的后台代码，为什么不用开源框架？\n5、如果要给项目中添加日志，该如何做？\n6、一个struts请求从输入URL到显示在页面上都经过了哪些过程？\n7、中间老大看我写着struts1，就问为什么使用struts1而不是struts2，有研究过两者的区别吗？\n8、给一个string，问如何不使用任何库函数也不转化为数组，如何逆序？\n就这么多问题，心态爆炸！怀疑人生！阿弥陀佛！\n\n\n----------\n\n\n** 京东一面：** 9月24日一早6点就爬起来了，昨晚一晚上都没睡好。做梦都在想着一些多线程常考的东西，果然第二天就问了。\n1、了解哪些常用的集合（set、list、map）？说说他们各自的特点（ArrayList和LinkedList等）？\n2、HashMap、HashTable的区别？HashMap扩容为什么是2倍？如何实现的？\n3、说一说线程调度机制？对线程池有何理解？哪里会用到线程池？好处是？\n4、JVM中如果有一个线程挂起了，用什么工具去查找这个线程？\n5、Java在什么时候会内存溢出？持久代内存溢出是什么情况？\n6、动态代理的实现？（从动态代理答到了springAOP）\n7、装饰模式了解吗？它的特点是什么？\n8、I/O库中都用到了什么设计模式？\n9、struts的一次请求是如何处理的？\n10、网络编程？socket？\n11、数据库索引了解吗？一个表中什么情况适合建立索引？如何去建立数据库索引？\n12、快速排序的时间复杂度、原理？\n13、java多态的实现原理？动态绑定底层虚拟机是如何实现的？\n14、forward和redirect的区别？\n*同样。。。有很多问题没想起来，一面半个多小时，后天二面。。*\n\n\n----------\n\n\n** 京东二面： ** 感觉一面回答的不好，全程面试官问什么我答什么，一点互动都没有，狠狠狠紧张！二面抱着无所谓的心态去的，倒还没有一面紧张。\n1、了解那些算法和设计模式，说说你都用他们在什么地方？（贪心、回溯、分治、动态规划  ||  单例模式、工厂模式、动态代理、装饰模式、适配器模式等，说了说单例工厂动态代理等，再说到JDK动态代理和CGLIB代理的区别，一顿乱侃）\n2、你的项目中那些都用到了多服务器？分布式了解吗？还问到了跨域请求。在实习的时候开发的网站也是单机吗？（从这儿开始问分布式集群服务器，高并发，这方面没怎么深入学习哎）\n3、设计一个抢购商品的系统需要考虑到那些问题？\n4、对于线程池有什么理解？\n5、消息队列？\n6、知道红黑树吗？平衡树？有什么区别？\n*算了不写了，想不起来了，估计二面跪了。。。*\n\n\n----------\n\n\n** 顺丰技术面： ** 9月24日下午5点，就是京东一面的下午。。。（除了技术面就是HR）\n1、简单的自我介绍一下。。。\n2、介绍自己认为最能体现自己能力的项目，跟着项目引出很多题目，问了个透彻。。。\n3、觉得自己还有那些方面的能力没有体现出来，可以说一说？（在这里傻逼了，我他喵说我暂时想不起来。因为可能自己的项目有点简单了，面试官还想要看看自己其他的能力，醉醉哒）\n顺丰科技面试就这样，问了40多分钟，结果问完就让我走了，伤心，怪自己傻逼了。另一个西电的技术面玩就直接HR面了，让我回来等通知，4天了都没有通过不通过的通知，也是厉害。挂了也不让我安心挂！\n\n\n----------\n** 去哪儿网** 9月29号下午3点好像\n感觉自己真的是，干什么事情完全不做任何准备的，很多看过的问题，在面试的时候就只能说有印象，答不详细，想抽死自己！\n1、去哪儿在金沙国际酒店面试，一天内面完，对去哪儿抱了很大希望，因为听学长说这个面试不难，问的比较基础，妈的现在写这段话还是想扇自己。\n2、刚见到面试官，他拿到简历就说，你是本科生啊？我说哦。。。然后就是自我介绍。。。\n3、给我了一张纸，在纸上写出自己用过的所有的类名。。。然后他在一边电脑上敲着东西。突然让写自己用过的所有的类的类名，脑子有点儿蒙了。\n4、说说mysql的引擎吧，说了myisam和innodb以及其区别，这个看过。\n5、mysql的各种连接是怎么回事？\n6、说说B树和B+树的区别吧。\n7、哈希冲突的解决算法？\n8、说说HashMap的实现原理？\n9、有什么问题问我？\n10、还有一些忘记了。。。\n/(ㄒoㄒ)/~~。。。都是些很简单的问题，妈的就是答得不好不够详细。\n\n----------\n** 总结 ： ** 菜鸟的求职之路总是艰辛的，校招时间还长，十月份还有几家面试（觉得自己的脸火辣辣的疼。。。），看到人都拿到了很好的Offer，不服啊！哎，语言总是苍白的，只有安心敲代码！！！！！！！！！国庆七天奋发图强，多看看Java并发编程实战那书上的东西吧，问得太多了。","slug":"校招面试经历","published":1,"updated":"2019-05-07T09:48:29.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvv0025cwnkykwa0weh","content":"<ul>\n<li>2017校招过的太惨了，还一度把原因怪罪在实习上，认为自己实习了4个月非Java研发的东西导致自己对于Java没有进行更加深入的学习，其实呢，还是应该怪自己不努力，怪不得其他。*<br>从三星离职之后就开始找一些公众号内推，我是来自非985、211院校的本科生，学的还是自动化专业，偏硬件，实习内容还不是Java开发之类的东西，不知道是由于这些公众号的原因（恶意吸引粉丝）还是自己的简历确实有问题，内推一直不顺利。烦得很。<br>之后又从9月开始海投Java软件开发岗，各种在线笔试。博主的基础（计算机网络操作系统等）本身就不强，C/C++/Java/PHP等还有HTML/CSS/JS/jQuery这些乱七八糟都学，算法和数据结构也学得不是很精，应付不来笔试编程题，感觉面试过的公司好少，妈的工作要找到十月了。</li>\n</ul>\n<a id=\"more\"></a>\n<p><strong> 首先说下招银电面：</strong> 9月23号晚上八点正在理发染发呢电话就来了，都不预约一下。<br>1、在Java中进行数据库连接并操作数据的步骤？最后需要进行什么操作？<br>2、项目中使用jquery，那么on、bind、live、delegate这几个函数有什么区别？<br>3、一个http请求所包含的数据格式是什么？<br>4、一次http请求的详细处理过程？<br>5、一次struts处理请求从开始到看到页面数据之间都发生了什么，整个详细过程？<br>6、项目中都用到了什么框架？（spring+struts+mybatis）<br>7、在自己的项目中有没有用到并发？如果让你现在考虑给你的项目中考虑并发你会怎么做？你要控制（进行同步）的数据源是哪些？<br><em>还有几个吧，想不起来了，应该比较简单就没有印象。电面后预约28号下午再面试。</em></p>\n<hr>\n<p><strong>招银现场面</strong>===该来的就这样来了<br><em>9月28号下午，不知道哪里来的自信感觉自己能够在一个半小时之内从长安赶到永宁门，坐地铁还把安远门当成了永宁门，到了安远门叫个优步，打电话让司机快一点，妈的竟然给我取消了，害我最后坐公交去，迟到了半个小时。心态爆炸！！！╮(╯▽╰)╭</em><br>1、去了在房间里等着，过会儿从酒店房间出来一个，叫我进去面试。先问我要了成绩单和一些证书，感觉招银对于成绩和证书很看重。面试官是三个人，3V1，很紧张有木有。中间坐着老大，然后一个问技术的，一个HR。<br>2、自我介绍<br>3、介绍一下自己的项目<br>4、项目中是使用servlet编写的后台代码，为什么不用开源框架？<br>5、如果要给项目中添加日志，该如何做？<br>6、一个struts请求从输入URL到显示在页面上都经过了哪些过程？<br>7、中间老大看我写着struts1，就问为什么使用struts1而不是struts2，有研究过两者的区别吗？<br>8、给一个string，问如何不使用任何库函数也不转化为数组，如何逆序？<br>就这么多问题，心态爆炸！怀疑人生！阿弥陀佛！</p>\n<hr>\n<p><strong> 京东一面：</strong> 9月24日一早6点就爬起来了，昨晚一晚上都没睡好。做梦都在想着一些多线程常考的东西，果然第二天就问了。<br>1、了解哪些常用的集合（set、list、map）？说说他们各自的特点（ArrayList和LinkedList等）？<br>2、HashMap、HashTable的区别？HashMap扩容为什么是2倍？如何实现的？<br>3、说一说线程调度机制？对线程池有何理解？哪里会用到线程池？好处是？<br>4、JVM中如果有一个线程挂起了，用什么工具去查找这个线程？<br>5、Java在什么时候会内存溢出？持久代内存溢出是什么情况？<br>6、动态代理的实现？（从动态代理答到了springAOP）<br>7、装饰模式了解吗？它的特点是什么？<br>8、I/O库中都用到了什么设计模式？<br>9、struts的一次请求是如何处理的？<br>10、网络编程？socket？<br>11、数据库索引了解吗？一个表中什么情况适合建立索引？如何去建立数据库索引？<br>12、快速排序的时间复杂度、原理？<br>13、java多态的实现原理？动态绑定底层虚拟机是如何实现的？<br>14、forward和redirect的区别？<br><em>同样。。。有很多问题没想起来，一面半个多小时，后天二面。。</em></p>\n<hr>\n<p><strong> 京东二面： </strong> 感觉一面回答的不好，全程面试官问什么我答什么，一点互动都没有，狠狠狠紧张！二面抱着无所谓的心态去的，倒还没有一面紧张。<br>1、了解那些算法和设计模式，说说你都用他们在什么地方？（贪心、回溯、分治、动态规划  ||  单例模式、工厂模式、动态代理、装饰模式、适配器模式等，说了说单例工厂动态代理等，再说到JDK动态代理和CGLIB代理的区别，一顿乱侃）<br>2、你的项目中那些都用到了多服务器？分布式了解吗？还问到了跨域请求。在实习的时候开发的网站也是单机吗？（从这儿开始问分布式集群服务器，高并发，这方面没怎么深入学习哎）<br>3、设计一个抢购商品的系统需要考虑到那些问题？<br>4、对于线程池有什么理解？<br>5、消息队列？<br>6、知道红黑树吗？平衡树？有什么区别？<br><em>算了不写了，想不起来了，估计二面跪了。。。</em></p>\n<hr>\n<p><strong> 顺丰技术面： </strong> 9月24日下午5点，就是京东一面的下午。。。（除了技术面就是HR）<br>1、简单的自我介绍一下。。。<br>2、介绍自己认为最能体现自己能力的项目，跟着项目引出很多题目，问了个透彻。。。<br>3、觉得自己还有那些方面的能力没有体现出来，可以说一说？（在这里傻逼了，我他喵说我暂时想不起来。因为可能自己的项目有点简单了，面试官还想要看看自己其他的能力，醉醉哒）<br>顺丰科技面试就这样，问了40多分钟，结果问完就让我走了，伤心，怪自己傻逼了。另一个西电的技术面玩就直接HR面了，让我回来等通知，4天了都没有通过不通过的通知，也是厉害。挂了也不让我安心挂！</p>\n<hr>\n<p><strong> 去哪儿网</strong> 9月29号下午3点好像<br>感觉自己真的是，干什么事情完全不做任何准备的，很多看过的问题，在面试的时候就只能说有印象，答不详细，想抽死自己！<br>1、去哪儿在金沙国际酒店面试，一天内面完，对去哪儿抱了很大希望，因为听学长说这个面试不难，问的比较基础，妈的现在写这段话还是想扇自己。<br>2、刚见到面试官，他拿到简历就说，你是本科生啊？我说哦。。。然后就是自我介绍。。。<br>3、给我了一张纸，在纸上写出自己用过的所有的类名。。。然后他在一边电脑上敲着东西。突然让写自己用过的所有的类的类名，脑子有点儿蒙了。<br>4、说说mysql的引擎吧，说了myisam和innodb以及其区别，这个看过。<br>5、mysql的各种连接是怎么回事？<br>6、说说B树和B+树的区别吧。<br>7、哈希冲突的解决算法？<br>8、说说HashMap的实现原理？<br>9、有什么问题问我？<br>10、还有一些忘记了。。。<br>/(ㄒoㄒ)/~~。。。都是些很简单的问题，妈的就是答得不好不够详细。</p>\n<hr>\n<p><strong> 总结 ： </strong> 菜鸟的求职之路总是艰辛的，校招时间还长，十月份还有几家面试（觉得自己的脸火辣辣的疼。。。），看到人都拿到了很好的Offer，不服啊！哎，语言总是苍白的，只有安心敲代码！！！！！！！！！国庆七天奋发图强，多看看Java并发编程实战那书上的东西吧，问得太多了。</p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>2017校招过的太惨了，还一度把原因怪罪在实习上，认为自己实习了4个月非Java研发的东西导致自己对于Java没有进行更加深入的学习，其实呢，还是应该怪自己不努力，怪不得其他。*<br>从三星离职之后就开始找一些公众号内推，我是来自非985、211院校的本科生，学的还是自动化专业，偏硬件，实习内容还不是Java开发之类的东西，不知道是由于这些公众号的原因（恶意吸引粉丝）还是自己的简历确实有问题，内推一直不顺利。烦得很。<br>之后又从9月开始海投Java软件开发岗，各种在线笔试。博主的基础（计算机网络操作系统等）本身就不强，C/C++/Java/PHP等还有HTML/CSS/JS/jQuery这些乱七八糟都学，算法和数据结构也学得不是很精，应付不来笔试编程题，感觉面试过的公司好少，妈的工作要找到十月了。</li>\n</ul>","more":"<p><strong> 首先说下招银电面：</strong> 9月23号晚上八点正在理发染发呢电话就来了，都不预约一下。<br>1、在Java中进行数据库连接并操作数据的步骤？最后需要进行什么操作？<br>2、项目中使用jquery，那么on、bind、live、delegate这几个函数有什么区别？<br>3、一个http请求所包含的数据格式是什么？<br>4、一次http请求的详细处理过程？<br>5、一次struts处理请求从开始到看到页面数据之间都发生了什么，整个详细过程？<br>6、项目中都用到了什么框架？（spring+struts+mybatis）<br>7、在自己的项目中有没有用到并发？如果让你现在考虑给你的项目中考虑并发你会怎么做？你要控制（进行同步）的数据源是哪些？<br><em>还有几个吧，想不起来了，应该比较简单就没有印象。电面后预约28号下午再面试。</em></p>\n<hr>\n<p><strong>招银现场面</strong>===该来的就这样来了<br><em>9月28号下午，不知道哪里来的自信感觉自己能够在一个半小时之内从长安赶到永宁门，坐地铁还把安远门当成了永宁门，到了安远门叫个优步，打电话让司机快一点，妈的竟然给我取消了，害我最后坐公交去，迟到了半个小时。心态爆炸！！！╮(╯▽╰)╭</em><br>1、去了在房间里等着，过会儿从酒店房间出来一个，叫我进去面试。先问我要了成绩单和一些证书，感觉招银对于成绩和证书很看重。面试官是三个人，3V1，很紧张有木有。中间坐着老大，然后一个问技术的，一个HR。<br>2、自我介绍<br>3、介绍一下自己的项目<br>4、项目中是使用servlet编写的后台代码，为什么不用开源框架？<br>5、如果要给项目中添加日志，该如何做？<br>6、一个struts请求从输入URL到显示在页面上都经过了哪些过程？<br>7、中间老大看我写着struts1，就问为什么使用struts1而不是struts2，有研究过两者的区别吗？<br>8、给一个string，问如何不使用任何库函数也不转化为数组，如何逆序？<br>就这么多问题，心态爆炸！怀疑人生！阿弥陀佛！</p>\n<hr>\n<p><strong> 京东一面：</strong> 9月24日一早6点就爬起来了，昨晚一晚上都没睡好。做梦都在想着一些多线程常考的东西，果然第二天就问了。<br>1、了解哪些常用的集合（set、list、map）？说说他们各自的特点（ArrayList和LinkedList等）？<br>2、HashMap、HashTable的区别？HashMap扩容为什么是2倍？如何实现的？<br>3、说一说线程调度机制？对线程池有何理解？哪里会用到线程池？好处是？<br>4、JVM中如果有一个线程挂起了，用什么工具去查找这个线程？<br>5、Java在什么时候会内存溢出？持久代内存溢出是什么情况？<br>6、动态代理的实现？（从动态代理答到了springAOP）<br>7、装饰模式了解吗？它的特点是什么？<br>8、I/O库中都用到了什么设计模式？<br>9、struts的一次请求是如何处理的？<br>10、网络编程？socket？<br>11、数据库索引了解吗？一个表中什么情况适合建立索引？如何去建立数据库索引？<br>12、快速排序的时间复杂度、原理？<br>13、java多态的实现原理？动态绑定底层虚拟机是如何实现的？<br>14、forward和redirect的区别？<br><em>同样。。。有很多问题没想起来，一面半个多小时，后天二面。。</em></p>\n<hr>\n<p><strong> 京东二面： </strong> 感觉一面回答的不好，全程面试官问什么我答什么，一点互动都没有，狠狠狠紧张！二面抱着无所谓的心态去的，倒还没有一面紧张。<br>1、了解那些算法和设计模式，说说你都用他们在什么地方？（贪心、回溯、分治、动态规划  ||  单例模式、工厂模式、动态代理、装饰模式、适配器模式等，说了说单例工厂动态代理等，再说到JDK动态代理和CGLIB代理的区别，一顿乱侃）<br>2、你的项目中那些都用到了多服务器？分布式了解吗？还问到了跨域请求。在实习的时候开发的网站也是单机吗？（从这儿开始问分布式集群服务器，高并发，这方面没怎么深入学习哎）<br>3、设计一个抢购商品的系统需要考虑到那些问题？<br>4、对于线程池有什么理解？<br>5、消息队列？<br>6、知道红黑树吗？平衡树？有什么区别？<br><em>算了不写了，想不起来了，估计二面跪了。。。</em></p>\n<hr>\n<p><strong> 顺丰技术面： </strong> 9月24日下午5点，就是京东一面的下午。。。（除了技术面就是HR）<br>1、简单的自我介绍一下。。。<br>2、介绍自己认为最能体现自己能力的项目，跟着项目引出很多题目，问了个透彻。。。<br>3、觉得自己还有那些方面的能力没有体现出来，可以说一说？（在这里傻逼了，我他喵说我暂时想不起来。因为可能自己的项目有点简单了，面试官还想要看看自己其他的能力，醉醉哒）<br>顺丰科技面试就这样，问了40多分钟，结果问完就让我走了，伤心，怪自己傻逼了。另一个西电的技术面玩就直接HR面了，让我回来等通知，4天了都没有通过不通过的通知，也是厉害。挂了也不让我安心挂！</p>\n<hr>\n<p><strong> 去哪儿网</strong> 9月29号下午3点好像<br>感觉自己真的是，干什么事情完全不做任何准备的，很多看过的问题，在面试的时候就只能说有印象，答不详细，想抽死自己！<br>1、去哪儿在金沙国际酒店面试，一天内面完，对去哪儿抱了很大希望，因为听学长说这个面试不难，问的比较基础，妈的现在写这段话还是想扇自己。<br>2、刚见到面试官，他拿到简历就说，你是本科生啊？我说哦。。。然后就是自我介绍。。。<br>3、给我了一张纸，在纸上写出自己用过的所有的类名。。。然后他在一边电脑上敲着东西。突然让写自己用过的所有的类的类名，脑子有点儿蒙了。<br>4、说说mysql的引擎吧，说了myisam和innodb以及其区别，这个看过。<br>5、mysql的各种连接是怎么回事？<br>6、说说B树和B+树的区别吧。<br>7、哈希冲突的解决算法？<br>8、说说HashMap的实现原理？<br>9、有什么问题问我？<br>10、还有一些忘记了。。。<br>/(ㄒoㄒ)/~~。。。都是些很简单的问题，妈的就是答得不好不够详细。</p>\n<hr>\n<p><strong> 总结 ： </strong> 菜鸟的求职之路总是艰辛的，校招时间还长，十月份还有几家面试（觉得自己的脸火辣辣的疼。。。），看到人都拿到了很好的Offer，不服啊！哎，语言总是苍白的，只有安心敲代码！！！！！！！！！国庆七天奋发图强，多看看Java并发编程实战那书上的东西吧，问得太多了。</p>"},{"title":"纪念即将结束的第一份工作","date":"2018-06-28T14:20:45.000Z","_content":"\n## 纪念*~~即将~~* 结束的第一份工作\n\n\n1. #### 我一直都不知道自己想要得到些什么东西\n  > - 记得高中的时候，身边不管是家人还是老师，总会时刻不停在耳边说着：你需要如何如何学习，考上一个怎样的大学，进入一个怎么样的专业，以后找一个怎样的工作。可是当我听到这些话时总是会很反感。也许是叛逆，也许是这些对于我当时都是些虚无缥缈，很遥远的东西，我没有办法理解自己得到这些东西有什么用。但是虽然忠言不入耳，我还是得按照他们说的做。还好，大学上了一个普通的理工科一本。\n  - 当上了大学之后，没有了老师家长在耳边“絮叨”，更不知道自己要干什么了。记得当时参加各种社团，觉得在社团里面干的风风火火很牛逼，甚至课程都不上几节，最严重的时候好几周都不上课。浑浑噩噩的度过了大学的第一年之后，突然因为一个给学校编程培训班试听课凑人数的机会，让自动化专业的我接触到了软件开发这个方向。依然记得当时上课的老师，老范！当他用C语言在电脑上输出一串笑脸字符的时候，我当时的眼睛都亮了，我对和自己一块去凑人数的舍友说，这个人一定以后对我有很大的帮助，我一定要报名他的课程。后来真的觉得我是幸运的，老范是一个很有人格魅力的中年程序员 :) 。也是他让我知道了程序员是做什么的，也是他让我非常期待自己能够成为一个真正的软件开发者。<!--more-->\n  - 就这样我跟着老范从计算机基础，学到数据结构与算法，学计算机网络，MySQL，学习设计模式，学C++，后来又在另一个班学Java。计算机硬件方向专业的我，学完了软件专业学生要学的所有课程。终于大三，我找到了西安三星电子研究所的一份实习，写了两个月shell脚本，学习了Linux相关的知识以及自动化测试的东西，后来又在组内用PHP写了个网站，提供给大家进行会议的预定与提醒。现在想想这一切经验都是我的宝贵的财富.\n  - 实习结束后，工作却找的不是很顺利，也许是自己的实习经历没有太多做Java开发的东西，导致自己没有什么实际的项目经验。后来，我来了同※※。\n\n\n2. #### 或许离开这里是我最正确的选择\n  > - 在拿到offer来到同※※之前，我觉得我来到了一个很好的大公司。事实上这里也没有很差，除了我所在的部门。同※※是国内最早做股票交易平台的软件公司，目前也有自己的大楼，装修的也很不错，很像一个一线的大型互联网公司。然而，只是很像而已。从一件很平常的事就看得出来：每天饭点，后勤部经理就站在食堂打饭窗口对打饭的员工喊，少打一点少打一点，他们吃不完！ ... ...\n  - 其实我刚来的时候觉得自己可以呆三年的，现在想想真的很抱歉，我得走了。并不是因为上面的“打饭”。我来到这里做的工作都是外包的，在B2B部门。我本来以为大公司的工作流程都很规范，没想到在这里刷新了我的三观哈哈。外包工作什么都得听客户的，乱改需求不说，自己公司的运维根本派不上用场，连tomcat的启动报错都不知道怎么解决，让我们作为开发的去同时做开发、测试、运维、项目经理、产品的活，想想就火大。项目经理把客户电话甩给你，自己沟通去，然后自己潇洒的下班。\n  - 唉ε=(′ο｀*)))，不想再说太多了，显得自己好像太小气，都要走了还要diss前公司。但是，我觉得我是真的得走了，而且我还算是忍得时间长的。我们组，比我来得晚，比我走的早的人，超过了10个。才一年啊。作为一个刚毕业一年的程序员，真的心好累。\n\n\n\n3. #### 接下来的路少交点儿朋友，否则离开时会难受\n  > - 要走了要走了，却又感觉很难受。在这里，我接触过不少傻逼，但是也真的交到很多有趣的朋友。甚至有那种就算离职了，之后也不会断了联系的。在这个城市，原本独自一人的生活由他们，真的不会无聊。\n  - 天涯途上谁是客，散席时怎么分？ 也许有些人分开就不会再见，有些人想不见却总会出现在生活里。罢了，以后换到新的公司，不要再走心了。况且，真正值得走心的，也不会很多！\n\n###### ✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。  ——《行歌》 · 陈鸿宇\n\n","source":"_posts/纪念即将结束的第一份工作.md","raw":"---\ntitle: 纪念即将结束的第一份工作\ndate: 2018-06-28 22:20:45\ncategories: [程序人生]\ntags: [程序人生]\n---\n\n## 纪念*~~即将~~* 结束的第一份工作\n\n\n1. #### 我一直都不知道自己想要得到些什么东西\n  > - 记得高中的时候，身边不管是家人还是老师，总会时刻不停在耳边说着：你需要如何如何学习，考上一个怎样的大学，进入一个怎么样的专业，以后找一个怎样的工作。可是当我听到这些话时总是会很反感。也许是叛逆，也许是这些对于我当时都是些虚无缥缈，很遥远的东西，我没有办法理解自己得到这些东西有什么用。但是虽然忠言不入耳，我还是得按照他们说的做。还好，大学上了一个普通的理工科一本。\n  - 当上了大学之后，没有了老师家长在耳边“絮叨”，更不知道自己要干什么了。记得当时参加各种社团，觉得在社团里面干的风风火火很牛逼，甚至课程都不上几节，最严重的时候好几周都不上课。浑浑噩噩的度过了大学的第一年之后，突然因为一个给学校编程培训班试听课凑人数的机会，让自动化专业的我接触到了软件开发这个方向。依然记得当时上课的老师，老范！当他用C语言在电脑上输出一串笑脸字符的时候，我当时的眼睛都亮了，我对和自己一块去凑人数的舍友说，这个人一定以后对我有很大的帮助，我一定要报名他的课程。后来真的觉得我是幸运的，老范是一个很有人格魅力的中年程序员 :) 。也是他让我知道了程序员是做什么的，也是他让我非常期待自己能够成为一个真正的软件开发者。<!--more-->\n  - 就这样我跟着老范从计算机基础，学到数据结构与算法，学计算机网络，MySQL，学习设计模式，学C++，后来又在另一个班学Java。计算机硬件方向专业的我，学完了软件专业学生要学的所有课程。终于大三，我找到了西安三星电子研究所的一份实习，写了两个月shell脚本，学习了Linux相关的知识以及自动化测试的东西，后来又在组内用PHP写了个网站，提供给大家进行会议的预定与提醒。现在想想这一切经验都是我的宝贵的财富.\n  - 实习结束后，工作却找的不是很顺利，也许是自己的实习经历没有太多做Java开发的东西，导致自己没有什么实际的项目经验。后来，我来了同※※。\n\n\n2. #### 或许离开这里是我最正确的选择\n  > - 在拿到offer来到同※※之前，我觉得我来到了一个很好的大公司。事实上这里也没有很差，除了我所在的部门。同※※是国内最早做股票交易平台的软件公司，目前也有自己的大楼，装修的也很不错，很像一个一线的大型互联网公司。然而，只是很像而已。从一件很平常的事就看得出来：每天饭点，后勤部经理就站在食堂打饭窗口对打饭的员工喊，少打一点少打一点，他们吃不完！ ... ...\n  - 其实我刚来的时候觉得自己可以呆三年的，现在想想真的很抱歉，我得走了。并不是因为上面的“打饭”。我来到这里做的工作都是外包的，在B2B部门。我本来以为大公司的工作流程都很规范，没想到在这里刷新了我的三观哈哈。外包工作什么都得听客户的，乱改需求不说，自己公司的运维根本派不上用场，连tomcat的启动报错都不知道怎么解决，让我们作为开发的去同时做开发、测试、运维、项目经理、产品的活，想想就火大。项目经理把客户电话甩给你，自己沟通去，然后自己潇洒的下班。\n  - 唉ε=(′ο｀*)))，不想再说太多了，显得自己好像太小气，都要走了还要diss前公司。但是，我觉得我是真的得走了，而且我还算是忍得时间长的。我们组，比我来得晚，比我走的早的人，超过了10个。才一年啊。作为一个刚毕业一年的程序员，真的心好累。\n\n\n\n3. #### 接下来的路少交点儿朋友，否则离开时会难受\n  > - 要走了要走了，却又感觉很难受。在这里，我接触过不少傻逼，但是也真的交到很多有趣的朋友。甚至有那种就算离职了，之后也不会断了联系的。在这个城市，原本独自一人的生活由他们，真的不会无聊。\n  - 天涯途上谁是客，散席时怎么分？ 也许有些人分开就不会再见，有些人想不见却总会出现在生活里。罢了，以后换到新的公司，不要再走心了。况且，真正值得走心的，也不会很多！\n\n###### ✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。  ——《行歌》 · 陈鸿宇\n\n","slug":"纪念即将结束的第一份工作","published":1,"updated":"2019-05-07T09:48:29.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvvw0029cwnkwgfygxyb","content":"<h2 id=\"纪念即将-结束的第一份工作\"><a href=\"#纪念即将-结束的第一份工作\" class=\"headerlink\" title=\"纪念即将 结束的第一份工作\"></a>纪念<em><del>即将</del></em> 结束的第一份工作</h2><ol>\n<li><h4 id=\"我一直都不知道自己想要得到些什么东西\"><a href=\"#我一直都不知道自己想要得到些什么东西\" class=\"headerlink\" title=\"我一直都不知道自己想要得到些什么东西\"></a>我一直都不知道自己想要得到些什么东西</h4><blockquote>\n<ul>\n<li>记得高中的时候，身边不管是家人还是老师，总会时刻不停在耳边说着：你需要如何如何学习，考上一个怎样的大学，进入一个怎么样的专业，以后找一个怎样的工作。可是当我听到这些话时总是会很反感。也许是叛逆，也许是这些对于我当时都是些虚无缥缈，很遥远的东西，我没有办法理解自己得到这些东西有什么用。但是虽然忠言不入耳，我还是得按照他们说的做。还好，大学上了一个普通的理工科一本。</li>\n<li>当上了大学之后，没有了老师家长在耳边“絮叨”，更不知道自己要干什么了。记得当时参加各种社团，觉得在社团里面干的风风火火很牛逼，甚至课程都不上几节，最严重的时候好几周都不上课。浑浑噩噩的度过了大学的第一年之后，突然因为一个给学校编程培训班试听课凑人数的机会，让自动化专业的我接触到了软件开发这个方向。依然记得当时上课的老师，老范！当他用C语言在电脑上输出一串笑脸字符的时候，我当时的眼睛都亮了，我对和自己一块去凑人数的舍友说，这个人一定以后对我有很大的帮助，我一定要报名他的课程。后来真的觉得我是幸运的，老范是一个很有人格魅力的中年程序员 :) 。也是他让我知道了程序员是做什么的，也是他让我非常期待自己能够成为一个真正的软件开发者。<a id=\"more\"></a></li>\n<li>就这样我跟着老范从计算机基础，学到数据结构与算法，学计算机网络，MySQL，学习设计模式，学C++，后来又在另一个班学Java。计算机硬件方向专业的我，学完了软件专业学生要学的所有课程。终于大三，我找到了西安三星电子研究所的一份实习，写了两个月shell脚本，学习了Linux相关的知识以及自动化测试的东西，后来又在组内用PHP写了个网站，提供给大家进行会议的预定与提醒。现在想想这一切经验都是我的宝贵的财富.</li>\n<li>实习结束后，工作却找的不是很顺利，也许是自己的实习经历没有太多做Java开发的东西，导致自己没有什么实际的项目经验。后来，我来了同※※。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<ol start=\"2\">\n<li><h4 id=\"或许离开这里是我最正确的选择\"><a href=\"#或许离开这里是我最正确的选择\" class=\"headerlink\" title=\"或许离开这里是我最正确的选择\"></a>或许离开这里是我最正确的选择</h4><blockquote>\n<ul>\n<li>在拿到offer来到同※※之前，我觉得我来到了一个很好的大公司。事实上这里也没有很差，除了我所在的部门。同※※是国内最早做股票交易平台的软件公司，目前也有自己的大楼，装修的也很不错，很像一个一线的大型互联网公司。然而，只是很像而已。从一件很平常的事就看得出来：每天饭点，后勤部经理就站在食堂打饭窗口对打饭的员工喊，少打一点少打一点，他们吃不完！ … …</li>\n<li>其实我刚来的时候觉得自己可以呆三年的，现在想想真的很抱歉，我得走了。并不是因为上面的“打饭”。我来到这里做的工作都是外包的，在B2B部门。我本来以为大公司的工作流程都很规范，没想到在这里刷新了我的三观哈哈。外包工作什么都得听客户的，乱改需求不说，自己公司的运维根本派不上用场，连tomcat的启动报错都不知道怎么解决，让我们作为开发的去同时做开发、测试、运维、项目经理、产品的活，想想就火大。项目经理把客户电话甩给你，自己沟通去，然后自己潇洒的下班。</li>\n<li>唉ε=(′ο｀*)))，不想再说太多了，显得自己好像太小气，都要走了还要diss前公司。但是，我觉得我是真的得走了，而且我还算是忍得时间长的。我们组，比我来得晚，比我走的早的人，超过了10个。才一年啊。作为一个刚毕业一年的程序员，真的心好累。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<ol start=\"3\">\n<li><h4 id=\"接下来的路少交点儿朋友，否则离开时会难受\"><a href=\"#接下来的路少交点儿朋友，否则离开时会难受\" class=\"headerlink\" title=\"接下来的路少交点儿朋友，否则离开时会难受\"></a>接下来的路少交点儿朋友，否则离开时会难受</h4><blockquote>\n<ul>\n<li>要走了要走了，却又感觉很难受。在这里，我接触过不少傻逼，但是也真的交到很多有趣的朋友。甚至有那种就算离职了，之后也不会断了联系的。在这个城市，原本独自一人的生活由他们，真的不会无聊。</li>\n<li>天涯途上谁是客，散席时怎么分？ 也许有些人分开就不会再见，有些人想不见却总会出现在生活里。罢了，以后换到新的公司，不要再走心了。况且，真正值得走心的，也不会很多！</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h6 id=\"✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。-——《行歌》-·-陈鸿宇\"><a href=\"#✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。-——《行歌》-·-陈鸿宇\" class=\"headerlink\" title=\"✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。  ——《行歌》 · 陈鸿宇\"></a>✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。  ——《行歌》 · 陈鸿宇</h6>","site":{"data":{}},"excerpt":"<h2 id=\"纪念即将-结束的第一份工作\"><a href=\"#纪念即将-结束的第一份工作\" class=\"headerlink\" title=\"纪念即将 结束的第一份工作\"></a>纪念<em><del>即将</del></em> 结束的第一份工作</h2><ol>\n<li><h4 id=\"我一直都不知道自己想要得到些什么东西\"><a href=\"#我一直都不知道自己想要得到些什么东西\" class=\"headerlink\" title=\"我一直都不知道自己想要得到些什么东西\"></a>我一直都不知道自己想要得到些什么东西</h4><blockquote>\n<ul>\n<li>记得高中的时候，身边不管是家人还是老师，总会时刻不停在耳边说着：你需要如何如何学习，考上一个怎样的大学，进入一个怎么样的专业，以后找一个怎样的工作。可是当我听到这些话时总是会很反感。也许是叛逆，也许是这些对于我当时都是些虚无缥缈，很遥远的东西，我没有办法理解自己得到这些东西有什么用。但是虽然忠言不入耳，我还是得按照他们说的做。还好，大学上了一个普通的理工科一本。</li>\n<li>当上了大学之后，没有了老师家长在耳边“絮叨”，更不知道自己要干什么了。记得当时参加各种社团，觉得在社团里面干的风风火火很牛逼，甚至课程都不上几节，最严重的时候好几周都不上课。浑浑噩噩的度过了大学的第一年之后，突然因为一个给学校编程培训班试听课凑人数的机会，让自动化专业的我接触到了软件开发这个方向。依然记得当时上课的老师，老范！当他用C语言在电脑上输出一串笑脸字符的时候，我当时的眼睛都亮了，我对和自己一块去凑人数的舍友说，这个人一定以后对我有很大的帮助，我一定要报名他的课程。后来真的觉得我是幸运的，老范是一个很有人格魅力的中年程序员 :) 。也是他让我知道了程序员是做什么的，也是他让我非常期待自己能够成为一个真正的软件开发者。</li></ul></blockquote></li></ol>","more":"\n<li>就这样我跟着老范从计算机基础，学到数据结构与算法，学计算机网络，MySQL，学习设计模式，学C++，后来又在另一个班学Java。计算机硬件方向专业的我，学完了软件专业学生要学的所有课程。终于大三，我找到了西安三星电子研究所的一份实习，写了两个月shell脚本，学习了Linux相关的知识以及自动化测试的东西，后来又在组内用PHP写了个网站，提供给大家进行会议的预定与提醒。现在想想这一切经验都是我的宝贵的财富.</li>\n<li>实习结束后，工作却找的不是很顺利，也许是自己的实习经历没有太多做Java开发的东西，导致自己没有什么实际的项目经验。后来，我来了同※※。</li>\n\n\n\n\n<ol start=\"2\">\n<li><h4 id=\"或许离开这里是我最正确的选择\"><a href=\"#或许离开这里是我最正确的选择\" class=\"headerlink\" title=\"或许离开这里是我最正确的选择\"></a>或许离开这里是我最正确的选择</h4><blockquote>\n<ul>\n<li>在拿到offer来到同※※之前，我觉得我来到了一个很好的大公司。事实上这里也没有很差，除了我所在的部门。同※※是国内最早做股票交易平台的软件公司，目前也有自己的大楼，装修的也很不错，很像一个一线的大型互联网公司。然而，只是很像而已。从一件很平常的事就看得出来：每天饭点，后勤部经理就站在食堂打饭窗口对打饭的员工喊，少打一点少打一点，他们吃不完！ … …</li>\n<li>其实我刚来的时候觉得自己可以呆三年的，现在想想真的很抱歉，我得走了。并不是因为上面的“打饭”。我来到这里做的工作都是外包的，在B2B部门。我本来以为大公司的工作流程都很规范，没想到在这里刷新了我的三观哈哈。外包工作什么都得听客户的，乱改需求不说，自己公司的运维根本派不上用场，连tomcat的启动报错都不知道怎么解决，让我们作为开发的去同时做开发、测试、运维、项目经理、产品的活，想想就火大。项目经理把客户电话甩给你，自己沟通去，然后自己潇洒的下班。</li>\n<li>唉ε=(′ο｀*)))，不想再说太多了，显得自己好像太小气，都要走了还要diss前公司。但是，我觉得我是真的得走了，而且我还算是忍得时间长的。我们组，比我来得晚，比我走的早的人，超过了10个。才一年啊。作为一个刚毕业一年的程序员，真的心好累。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<ol start=\"3\">\n<li><h4 id=\"接下来的路少交点儿朋友，否则离开时会难受\"><a href=\"#接下来的路少交点儿朋友，否则离开时会难受\" class=\"headerlink\" title=\"接下来的路少交点儿朋友，否则离开时会难受\"></a>接下来的路少交点儿朋友，否则离开时会难受</h4><blockquote>\n<ul>\n<li>要走了要走了，却又感觉很难受。在这里，我接触过不少傻逼，但是也真的交到很多有趣的朋友。甚至有那种就算离职了，之后也不会断了联系的。在这个城市，原本独自一人的生活由他们，真的不会无聊。</li>\n<li>天涯途上谁是客，散席时怎么分？ 也许有些人分开就不会再见，有些人想不见却总会出现在生活里。罢了，以后换到新的公司，不要再走心了。况且，真正值得走心的，也不会很多！</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h6 id=\"✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。-——《行歌》-·-陈鸿宇\"><a href=\"#✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。-——《行歌》-·-陈鸿宇\" class=\"headerlink\" title=\"✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。  ——《行歌》 · 陈鸿宇\"></a>✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。  ——《行歌》 · 陈鸿宇</h6>"},{"title":"编写自己的SpringMVC框架","date":"2019-05-31T07:25:00.000Z","_content":"\n![封面](aaa.jpeg)\n<!--more-->\n## Summer项目\n\n**[项目github地址](https://github.com/Fatezhang/Summer)**\n\n\n### 介绍\n\n- Summer项目是本人在学习Spring源码的时候按照SpringMVC的流程编写的一个简易的SpringMVC框架，主要完成以下功能：\n    - 读取配置文件进行包的扫描\n    - 对所有加入注解的bean进行装配\n    - 对加了注解的字段进行依赖自动注入\n    - URL与相应方法的映射\n    - 请求的分发处理\n\n项目通过实现以上流程完成SpringMVC框架工作的整体过程演示\n\n### 以下是框架流程的详细步骤说明\n#### 项目的结构\nSummer项目仅仅是一个单独的Servlet项目，没有引入Spring相关的任何依赖，仅仅使用了一些外部的工具类，我的pom.xml文件如下：\n```aidl\n  <dependencies>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>3.1.0</version>\n    </dependency>\n    <dependency>\n      <groupId>cn.hutool</groupId>\n      <artifactId>hutool-all</artifactId>\n      <version>4.5.10</version>\n    </dependency>\n    <dependency>\n      <groupId>org.eclipse.jetty</groupId>\n      <artifactId>jetty-maven-plugin</artifactId>\n      <version>9.3.12.v20160915</version>\n    </dependency>\n    <dependency>\n      <groupId>org.projectlombok</groupId>\n      <artifactId>lombok</artifactId>\n      <version>1.18.2</version>\n    </dependency>\n  </dependencies>\n```\n项目使用jetty启动，所以我还配置了jetty插件\n```aidl\n<build>\n    <plugins>\n      <!-- jetty插件 -->\n      <plugin>\n        <groupId>org.mortbay.jetty</groupId>\n        <artifactId>maven-jetty-plugin</artifactId>\n        <version>6.1.26</version>\n        <configuration>\n          <scanIntervalSeconds>0</scanIntervalSeconds>\n          <contextPath>/Summer</contextPath>\n          <connectors>\n            <connector implementation=\"org.mortbay.jetty.nio.SelectChannelConnector\">\n              <port>4000</port>\n            </connector>\n          </connectors>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n```\n#### 整体框架结构\n\n![注解](zj.png)\n除了自定义的这几个注解之外其他的就和平常编写Controller以及Service的流程一样，我的核心代码主要在MyServlet中\n\n#### MyServlet主要做了什么\n##### 加载配置文件，首先读取web.xml中配置的配置文件\n把扫描到的所有类全链路径名保存在list中\n> 以下是servlet的配置\n\n```aidl\n<servlet>\n    <!-- 声明Servlet对象 -->\n    <servlet-name>myServlet</servlet-name>\n    <!-- 上面一句指定Servlet对象的名称 -->\n    <servlet-class>com.zhang.summer.servlet.MyServlet</servlet-class>\n    <!-- 上面一句指定Servlet对象的完整位置，包含包名和类名 -->\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:config.properties</param-value>\n    </init-param>\n    <!-- 下面一句是在启动时加载servlet -->\n    <load-on-startup>0</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <!-- 映射Servlet -->\n    <servlet-name>myServlet</servlet-name>\n    <!--<servlet-name>与上面<Servlet>标签的<servlet-name>元素相对应，不可以随便起名  -->\n    <url-pattern>/</url-pattern>\n    <!-- 上面一句话用于映射访问URL -->\n</servlet-mapping>\n```\n##### 遍历所有类，使用反射创建对象`class.forName`\n创建对象，将所有我们声明了自己注解的类加入到一个Map中，即IOC-Map\n\n##### 遍历IOC-Map中的所有对象，进行依赖注入\n在这里我只判断是`@MyController`注解的类才进行依赖注入\n\n##### 处理URL和方法之间的映射\n将注解了`@MyRequestMapping`的类和方法路径拼接起来，对方法和拼接起来的url路径进行映射，并且对方法参数做特殊处理\n\n##### 请求分发\n在doGet或者doPost请求中通过映射好的url-method找到方法进行请求的分发处理\n","source":"_posts/编写自己的SpringMVC框架.md","raw":"---\ntitle: 编写自己的SpringMVC框架\ndate: 2019-05-31 15:25:00\ncategories: [SpringMVC框架]\ntags: [Java基础,Spring,SpringMVC,Servlet]\n---\n\n![封面](aaa.jpeg)\n<!--more-->\n## Summer项目\n\n**[项目github地址](https://github.com/Fatezhang/Summer)**\n\n\n### 介绍\n\n- Summer项目是本人在学习Spring源码的时候按照SpringMVC的流程编写的一个简易的SpringMVC框架，主要完成以下功能：\n    - 读取配置文件进行包的扫描\n    - 对所有加入注解的bean进行装配\n    - 对加了注解的字段进行依赖自动注入\n    - URL与相应方法的映射\n    - 请求的分发处理\n\n项目通过实现以上流程完成SpringMVC框架工作的整体过程演示\n\n### 以下是框架流程的详细步骤说明\n#### 项目的结构\nSummer项目仅仅是一个单独的Servlet项目，没有引入Spring相关的任何依赖，仅仅使用了一些外部的工具类，我的pom.xml文件如下：\n```aidl\n  <dependencies>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>3.1.0</version>\n    </dependency>\n    <dependency>\n      <groupId>cn.hutool</groupId>\n      <artifactId>hutool-all</artifactId>\n      <version>4.5.10</version>\n    </dependency>\n    <dependency>\n      <groupId>org.eclipse.jetty</groupId>\n      <artifactId>jetty-maven-plugin</artifactId>\n      <version>9.3.12.v20160915</version>\n    </dependency>\n    <dependency>\n      <groupId>org.projectlombok</groupId>\n      <artifactId>lombok</artifactId>\n      <version>1.18.2</version>\n    </dependency>\n  </dependencies>\n```\n项目使用jetty启动，所以我还配置了jetty插件\n```aidl\n<build>\n    <plugins>\n      <!-- jetty插件 -->\n      <plugin>\n        <groupId>org.mortbay.jetty</groupId>\n        <artifactId>maven-jetty-plugin</artifactId>\n        <version>6.1.26</version>\n        <configuration>\n          <scanIntervalSeconds>0</scanIntervalSeconds>\n          <contextPath>/Summer</contextPath>\n          <connectors>\n            <connector implementation=\"org.mortbay.jetty.nio.SelectChannelConnector\">\n              <port>4000</port>\n            </connector>\n          </connectors>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n```\n#### 整体框架结构\n\n![注解](zj.png)\n除了自定义的这几个注解之外其他的就和平常编写Controller以及Service的流程一样，我的核心代码主要在MyServlet中\n\n#### MyServlet主要做了什么\n##### 加载配置文件，首先读取web.xml中配置的配置文件\n把扫描到的所有类全链路径名保存在list中\n> 以下是servlet的配置\n\n```aidl\n<servlet>\n    <!-- 声明Servlet对象 -->\n    <servlet-name>myServlet</servlet-name>\n    <!-- 上面一句指定Servlet对象的名称 -->\n    <servlet-class>com.zhang.summer.servlet.MyServlet</servlet-class>\n    <!-- 上面一句指定Servlet对象的完整位置，包含包名和类名 -->\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:config.properties</param-value>\n    </init-param>\n    <!-- 下面一句是在启动时加载servlet -->\n    <load-on-startup>0</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <!-- 映射Servlet -->\n    <servlet-name>myServlet</servlet-name>\n    <!--<servlet-name>与上面<Servlet>标签的<servlet-name>元素相对应，不可以随便起名  -->\n    <url-pattern>/</url-pattern>\n    <!-- 上面一句话用于映射访问URL -->\n</servlet-mapping>\n```\n##### 遍历所有类，使用反射创建对象`class.forName`\n创建对象，将所有我们声明了自己注解的类加入到一个Map中，即IOC-Map\n\n##### 遍历IOC-Map中的所有对象，进行依赖注入\n在这里我只判断是`@MyController`注解的类才进行依赖注入\n\n##### 处理URL和方法之间的映射\n将注解了`@MyRequestMapping`的类和方法路径拼接起来，对方法和拼接起来的url路径进行映射，并且对方法参数做特殊处理\n\n##### 请求分发\n在doGet或者doPost请求中通过映射好的url-method找到方法进行请求的分发处理\n","slug":"编写自己的SpringMVC框架","published":1,"updated":"2019-06-05T07:45:43.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvw0002dcwnku39x1k21","content":"<p><img src=\"/blog/20190531/编写自己的SpringMVC框架/aaa.jpeg\" alt=\"封面\"><br><a id=\"more\"></a></p>\n<h2 id=\"Summer项目\"><a href=\"#Summer项目\" class=\"headerlink\" title=\"Summer项目\"></a>Summer项目</h2><p><strong><a href=\"https://github.com/Fatezhang/Summer\" target=\"_blank\" rel=\"noopener\">项目github地址</a></strong></p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><ul>\n<li>Summer项目是本人在学习Spring源码的时候按照SpringMVC的流程编写的一个简易的SpringMVC框架，主要完成以下功能：<ul>\n<li>读取配置文件进行包的扫描</li>\n<li>对所有加入注解的bean进行装配</li>\n<li>对加了注解的字段进行依赖自动注入</li>\n<li>URL与相应方法的映射</li>\n<li>请求的分发处理</li>\n</ul>\n</li>\n</ul>\n<p>项目通过实现以上流程完成SpringMVC框架工作的整体过程演示</p>\n<h3 id=\"以下是框架流程的详细步骤说明\"><a href=\"#以下是框架流程的详细步骤说明\" class=\"headerlink\" title=\"以下是框架流程的详细步骤说明\"></a>以下是框架流程的详细步骤说明</h3><h4 id=\"项目的结构\"><a href=\"#项目的结构\" class=\"headerlink\" title=\"项目的结构\"></a>项目的结构</h4><p>Summer项目仅仅是一个单独的Servlet项目，没有引入Spring相关的任何依赖，仅仅使用了一些外部的工具类，我的pom.xml文件如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.5.10&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;9.3.12.v20160915&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.18.2&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p>\n<p>项目使用jetty启动，所以我还配置了jetty插件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">      &lt;!-- jetty插件 --&gt;</span><br><span class=\"line\">      &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;6.1.26&lt;/version&gt;</span><br><span class=\"line\">        &lt;configuration&gt;</span><br><span class=\"line\">          &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt;</span><br><span class=\"line\">          &lt;contextPath&gt;/Summer&lt;/contextPath&gt;</span><br><span class=\"line\">          &lt;connectors&gt;</span><br><span class=\"line\">            &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt;</span><br><span class=\"line\">              &lt;port&gt;4000&lt;/port&gt;</span><br><span class=\"line\">            &lt;/connector&gt;</span><br><span class=\"line\">          &lt;/connectors&gt;</span><br><span class=\"line\">        &lt;/configuration&gt;</span><br><span class=\"line\">      &lt;/plugin&gt;</span><br><span class=\"line\">    &lt;/plugins&gt;</span><br><span class=\"line\">  &lt;/build&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"整体框架结构\"><a href=\"#整体框架结构\" class=\"headerlink\" title=\"整体框架结构\"></a>整体框架结构</h4><p><img src=\"/blog/20190531/编写自己的SpringMVC框架/zj.png\" alt=\"注解\"><br>除了自定义的这几个注解之外其他的就和平常编写Controller以及Service的流程一样，我的核心代码主要在MyServlet中</p>\n<h4 id=\"MyServlet主要做了什么\"><a href=\"#MyServlet主要做了什么\" class=\"headerlink\" title=\"MyServlet主要做了什么\"></a>MyServlet主要做了什么</h4><h5 id=\"加载配置文件，首先读取web-xml中配置的配置文件\"><a href=\"#加载配置文件，首先读取web-xml中配置的配置文件\" class=\"headerlink\" title=\"加载配置文件，首先读取web.xml中配置的配置文件\"></a>加载配置文件，首先读取web.xml中配置的配置文件</h5><p>把扫描到的所有类全链路径名保存在list中</p>\n<blockquote>\n<p>以下是servlet的配置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;servlet&gt;</span><br><span class=\"line\">    &lt;!-- 声明Servlet对象 --&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;</span><br><span class=\"line\">    &lt;!-- 上面一句指定Servlet对象的名称 --&gt;</span><br><span class=\"line\">    &lt;servlet-class&gt;com.zhang.summer.servlet.MyServlet&lt;/servlet-class&gt;</span><br><span class=\"line\">    &lt;!-- 上面一句指定Servlet对象的完整位置，包含包名和类名 --&gt;</span><br><span class=\"line\">    &lt;init-param&gt;</span><br><span class=\"line\">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class=\"line\">        &lt;param-value&gt;classpath:config.properties&lt;/param-value&gt;</span><br><span class=\"line\">    &lt;/init-param&gt;</span><br><span class=\"line\">    &lt;!-- 下面一句是在启动时加载servlet --&gt;</span><br><span class=\"line\">    &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;</span><br><span class=\"line\">&lt;/servlet&gt;</span><br><span class=\"line\">&lt;servlet-mapping&gt;</span><br><span class=\"line\">    &lt;!-- 映射Servlet --&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;</span><br><span class=\"line\">    &lt;!--&lt;servlet-name&gt;与上面&lt;Servlet&gt;标签的&lt;servlet-name&gt;元素相对应，不可以随便起名  --&gt;</span><br><span class=\"line\">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class=\"line\">    &lt;!-- 上面一句话用于映射访问URL --&gt;</span><br><span class=\"line\">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"遍历所有类，使用反射创建对象class-forName\"><a href=\"#遍历所有类，使用反射创建对象class-forName\" class=\"headerlink\" title=\"遍历所有类，使用反射创建对象class.forName\"></a>遍历所有类，使用反射创建对象<code>class.forName</code></h5><p>创建对象，将所有我们声明了自己注解的类加入到一个Map中，即IOC-Map</p>\n<h5 id=\"遍历IOC-Map中的所有对象，进行依赖注入\"><a href=\"#遍历IOC-Map中的所有对象，进行依赖注入\" class=\"headerlink\" title=\"遍历IOC-Map中的所有对象，进行依赖注入\"></a>遍历IOC-Map中的所有对象，进行依赖注入</h5><p>在这里我只判断是<code>@MyController</code>注解的类才进行依赖注入</p>\n<h5 id=\"处理URL和方法之间的映射\"><a href=\"#处理URL和方法之间的映射\" class=\"headerlink\" title=\"处理URL和方法之间的映射\"></a>处理URL和方法之间的映射</h5><p>将注解了<code>@MyRequestMapping</code>的类和方法路径拼接起来，对方法和拼接起来的url路径进行映射，并且对方法参数做特殊处理</p>\n<h5 id=\"请求分发\"><a href=\"#请求分发\" class=\"headerlink\" title=\"请求分发\"></a>请求分发</h5><p>在doGet或者doPost请求中通过映射好的url-method找到方法进行请求的分发处理</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/blog/20190531/编写自己的SpringMVC框架/aaa.jpeg\" alt=\"封面\"><br></p>","more":"<p></p>\n<h2 id=\"Summer项目\"><a href=\"#Summer项目\" class=\"headerlink\" title=\"Summer项目\"></a>Summer项目</h2><p><strong><a href=\"https://github.com/Fatezhang/Summer\" target=\"_blank\" rel=\"noopener\">项目github地址</a></strong></p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><ul>\n<li>Summer项目是本人在学习Spring源码的时候按照SpringMVC的流程编写的一个简易的SpringMVC框架，主要完成以下功能：<ul>\n<li>读取配置文件进行包的扫描</li>\n<li>对所有加入注解的bean进行装配</li>\n<li>对加了注解的字段进行依赖自动注入</li>\n<li>URL与相应方法的映射</li>\n<li>请求的分发处理</li>\n</ul>\n</li>\n</ul>\n<p>项目通过实现以上流程完成SpringMVC框架工作的整体过程演示</p>\n<h3 id=\"以下是框架流程的详细步骤说明\"><a href=\"#以下是框架流程的详细步骤说明\" class=\"headerlink\" title=\"以下是框架流程的详细步骤说明\"></a>以下是框架流程的详细步骤说明</h3><h4 id=\"项目的结构\"><a href=\"#项目的结构\" class=\"headerlink\" title=\"项目的结构\"></a>项目的结构</h4><p>Summer项目仅仅是一个单独的Servlet项目，没有引入Spring相关的任何依赖，仅仅使用了一些外部的工具类，我的pom.xml文件如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.5.10&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;9.3.12.v20160915&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">  &lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.18.2&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p>\n<p>项目使用jetty启动，所以我还配置了jetty插件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">      &lt;!-- jetty插件 --&gt;</span><br><span class=\"line\">      &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;6.1.26&lt;/version&gt;</span><br><span class=\"line\">        &lt;configuration&gt;</span><br><span class=\"line\">          &lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt;</span><br><span class=\"line\">          &lt;contextPath&gt;/Summer&lt;/contextPath&gt;</span><br><span class=\"line\">          &lt;connectors&gt;</span><br><span class=\"line\">            &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt;</span><br><span class=\"line\">              &lt;port&gt;4000&lt;/port&gt;</span><br><span class=\"line\">            &lt;/connector&gt;</span><br><span class=\"line\">          &lt;/connectors&gt;</span><br><span class=\"line\">        &lt;/configuration&gt;</span><br><span class=\"line\">      &lt;/plugin&gt;</span><br><span class=\"line\">    &lt;/plugins&gt;</span><br><span class=\"line\">  &lt;/build&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"整体框架结构\"><a href=\"#整体框架结构\" class=\"headerlink\" title=\"整体框架结构\"></a>整体框架结构</h4><p><img src=\"/blog/20190531/编写自己的SpringMVC框架/zj.png\" alt=\"注解\"><br>除了自定义的这几个注解之外其他的就和平常编写Controller以及Service的流程一样，我的核心代码主要在MyServlet中</p>\n<h4 id=\"MyServlet主要做了什么\"><a href=\"#MyServlet主要做了什么\" class=\"headerlink\" title=\"MyServlet主要做了什么\"></a>MyServlet主要做了什么</h4><h5 id=\"加载配置文件，首先读取web-xml中配置的配置文件\"><a href=\"#加载配置文件，首先读取web-xml中配置的配置文件\" class=\"headerlink\" title=\"加载配置文件，首先读取web.xml中配置的配置文件\"></a>加载配置文件，首先读取web.xml中配置的配置文件</h5><p>把扫描到的所有类全链路径名保存在list中</p>\n<blockquote>\n<p>以下是servlet的配置</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;servlet&gt;</span><br><span class=\"line\">    &lt;!-- 声明Servlet对象 --&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;</span><br><span class=\"line\">    &lt;!-- 上面一句指定Servlet对象的名称 --&gt;</span><br><span class=\"line\">    &lt;servlet-class&gt;com.zhang.summer.servlet.MyServlet&lt;/servlet-class&gt;</span><br><span class=\"line\">    &lt;!-- 上面一句指定Servlet对象的完整位置，包含包名和类名 --&gt;</span><br><span class=\"line\">    &lt;init-param&gt;</span><br><span class=\"line\">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class=\"line\">        &lt;param-value&gt;classpath:config.properties&lt;/param-value&gt;</span><br><span class=\"line\">    &lt;/init-param&gt;</span><br><span class=\"line\">    &lt;!-- 下面一句是在启动时加载servlet --&gt;</span><br><span class=\"line\">    &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;</span><br><span class=\"line\">&lt;/servlet&gt;</span><br><span class=\"line\">&lt;servlet-mapping&gt;</span><br><span class=\"line\">    &lt;!-- 映射Servlet --&gt;</span><br><span class=\"line\">    &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt;</span><br><span class=\"line\">    &lt;!--&lt;servlet-name&gt;与上面&lt;Servlet&gt;标签的&lt;servlet-name&gt;元素相对应，不可以随便起名  --&gt;</span><br><span class=\"line\">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class=\"line\">    &lt;!-- 上面一句话用于映射访问URL --&gt;</span><br><span class=\"line\">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"遍历所有类，使用反射创建对象class-forName\"><a href=\"#遍历所有类，使用反射创建对象class-forName\" class=\"headerlink\" title=\"遍历所有类，使用反射创建对象class.forName\"></a>遍历所有类，使用反射创建对象<code>class.forName</code></h5><p>创建对象，将所有我们声明了自己注解的类加入到一个Map中，即IOC-Map</p>\n<h5 id=\"遍历IOC-Map中的所有对象，进行依赖注入\"><a href=\"#遍历IOC-Map中的所有对象，进行依赖注入\" class=\"headerlink\" title=\"遍历IOC-Map中的所有对象，进行依赖注入\"></a>遍历IOC-Map中的所有对象，进行依赖注入</h5><p>在这里我只判断是<code>@MyController</code>注解的类才进行依赖注入</p>\n<h5 id=\"处理URL和方法之间的映射\"><a href=\"#处理URL和方法之间的映射\" class=\"headerlink\" title=\"处理URL和方法之间的映射\"></a>处理URL和方法之间的映射</h5><p>将注解了<code>@MyRequestMapping</code>的类和方法路径拼接起来，对方法和拼接起来的url路径进行映射，并且对方法参数做特殊处理</p>\n<h5 id=\"请求分发\"><a href=\"#请求分发\" class=\"headerlink\" title=\"请求分发\"></a>请求分发</h5><p>在doGet或者doPost请求中通过映射好的url-method找到方法进行请求的分发处理</p>"},{"title":"Java内存分配与垃圾回收的复习整理","date":"2019-04-14T13:18:36.000Z","_content":"![摘要](zy.png)\n### 摘要\n众所周知Java作为一个“一次编译，到处运行”的编译型语言，JVM虚拟机当之无愧的是Java语言世界的先锋将军。作为一个Java程序员，JVM虚拟机其相关知识是我们必须要了解以及深入掌握的重点。在本篇博客我将总结一下JVM虚拟机的内存结构、对象内存分配以及垃圾回收算法。这也是经常找工作求职必问的点。\n\n<!--more-->\n### Java内存分配与垃圾回收的复习整理\n\n#### Java内存区域划分\n\nJava虚拟机在执行Java程序的过程中会将它所管理的内存划分为若干个不同的区域。每个区域各司其职，其创建与销毁数据的规则也都各不相同。根据《Java虚拟机规范（Java SE 7版）》的规定，主要分为如下图几个区域。\n\n![Java内存划分](jvm.png)\n\n- **程序计数器**：当前线程执行字节码的行号指示器。[*线程私有*]\n- **虚拟机栈**：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。平常我们所说的Java虚拟机划分为堆和栈中的“栈”中的一部分就是虚拟机栈。其中局部变量表存放着编译期可知的所有基本数据类型、对象引用等。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法所需要的帧的大小是已经确定了的。[*线程私有*]\n- **本地方法栈**：与虚拟机栈发挥的作用相似，只不过这个区域执行的是native方法，即由c/c++或者其他语言编写的方法。[*线程私有*]\n- **Java堆**：用来存放对象实例，即我们最熟悉的一块区域。Java堆是垃圾收集器管理的主要区域，所以有时也叫“GC堆”。[*线程共享*]\n- **方法区**：用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 [*线程共享*]\n- **运行时常量池**：这是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。[*线程共享*]\n\n#### 常用的垃圾回收算法\n\n> 在Java代码中，我们程序员通常只关注广义上的“栈”和“堆”这两种区域。上述划分的Java内存区域告诉我们，栈是朝生夕死的一块区域，当线程进入的时候，栈空间被分配，线程结束之后，栈的内存空间即被回收用来去做其他的任务，栈中的栈帧随着线程的进入与退出有条不紊的执行着入栈和出栈的操作，每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的。而堆却不同，我们只有在程序运行期间才会知道创建那些对象，这部分内存分配和回收都是动态的。都由虚拟机的垃圾回收器进行“已死”对象的回收。\n\n##### 如何判断对象已死\n\n- **引用计数法**：给对象添加一个引用计数器，每当有引用指向它时计数器加1，引用失效后计数器减1。垃圾回收器回收对象计数器为0的对象昂即可。但是当出现对象之间循环引用，而对象却无实际作用的时候，这种方式就会出现内存泄漏。\n- **可达性分析**：通过一系列的称为“GC ROOTS”的对象作为起点，向下搜索，搜索走过的路径都称为引用链，当一个对象到“GC ROOTS”没有引用链的时候，证明这个对象不可达。此时会被判定为可回收对象。（此时并非一定死亡，在此之后还会进行两次标记处理，与finalize()方法有关，此处不再整理。注意一个知识点：任何对象的finalize()方法只会被系统调用一次，并且不建议使用）\n\n> 知道哪些对象是“垃圾”，接下来就是回收操作了\n\n##### 标记-清除法\n- 首先标记出所有需要回收的对象，然后统一回收。是最基础的回收算法。\n- 不足之处：1、效率低下，标记和清除的效率都不高；2、产生大量内存碎片，使得之后程序要分配大对象却没有空间，不得不除法GC。\n\n##### 复制\n- 首先将内存区域划分为两等分，每次只使用其中一块内存，当用完之后，将活着的对象复制到另一块内存，然后整个回收上一半。这种按顺序分配内存，实现简单，运行高效。\n- 不足之处：直接将内存缩小了一半，产生大量的空间浪费。然而很多垃圾收集器都是用这种方式，但是有过改进。因为堆中的对象90%都是朝生夕死的，只有10%是会长期存活下来的对象，那么对于这90%的对象，完全可以使用这种高效的复制收集算法。首先将内存区域划分三份，10%的对象存在其中较大的一分中，另外的两份等份分配，处理这90%的“死的快”的对象。这就是Form,To,Eden区域。即Eden:From:To=8:1:1\n\n##### 标记-整理法\n- 标记整理的方式实际上也是先将可回收对象标记起来，然后对于这些存活着的对象，并不直接回收，而是先向一端移动，最后直接回收端边界之外的对象。这种做法解决了处理存活率较高的大对象的回收，适合老年代堆对象回收。\n\n##### 分代收集\n- 当前商业虚拟机基本上都会采取分代收集算法。即根据对象存活周期的不同将内存划分为不同区域，分别使用不同的垃圾回收算法进行垃圾回收。比如在新生代使用复制算法，因为新生代大量对象都是朝生夕死需要很高的回收效率，而对于老年代则使用标记清除或者标记整理。\n\n\n#### Java虚拟机的对象内存分配\n\nJava对象内存分配实际上就指的是将对象分配在堆上的过程。不过实际上堆还被虚拟机划分成了不同的区域，并且每个区域的分配策略都不相同。上面我们说到虚拟机根据对象存活周期的不同将对内存分为几种不同的区域，即新生代Eden,From Survivor,To Survivor和老年代。那么这几种区域是如何进行内存分配的呢？\n\n- 对象优先再Eden区域分配：大多数情况下，对象会在Eden区域分配，在Eden区域空间不够的情况下，会先进行一次MinorGC（MinorGC是新生代垃圾回收，Full GC是老年代垃圾回收）。\n- 大对象直接进入老年代：大对象即指的是需要大量连续空间的对象，例如很长的字符串以及数组。虚拟机提供参数`-XX:PretenureSizeThreadhold`参数设置大于多少算是大对象，避免在新生代几个区域中发生大量的内存复制。\n- 长期存活的对象直接进入老年代：每经过一次MinorGC对象的年龄都会加1。当年龄加到`-XX:MaxTenuringThreadhold`（默认15）指定的值时，判断为长期存活，对象会被移动到老年代。\n- 动态对象年龄判断：为了适应多变的内存情况，一般虚拟机都会使用动态对象年龄判定。如果Survivor中相同年龄的所有对象大小总和大于该空间的一半，该年龄以上的对象就会直接进入老年代，无需等到年龄大于`-XX:MaxTenuringThreadhold`（默认15）指定的值。\n- 空间分配担保：在发生MinorGC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，是的话MinorGC可以被认定是安全的。如果不成立，虚拟机会先检查`HandlerPromotionFailure`参数是否允许担保失败，不允许的话会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于的话或者`HandlerPromotionFailure`设置不允许冒险，那么就会执行一次FullGC。\n\n----\n\n### 总结\n> 内存回收与垃圾收集很多时候都是影响系统性能和并发能力的主要因素之一，虚拟机提供了多种垃圾收集器以及大量的调节参数，方便开发人员根据实际应用调整以便程序可以获得最高的性能。这些垃圾收集器和虚拟机参数没有固定的标准的组合，需要开发人员对于内存分配与垃圾回收相当了解，才得以根据实际情况实际配置。\n","source":"_posts/Java内存分配与垃圾回收的复习整理.md","raw":"---\ntitle: Java内存分配与垃圾回收的复习整理\ndate: 2019-04-14 21:18:36\ncategories: [Java基础]\ntags: [Java基础,内存分配,垃圾回收]\n---\n![摘要](zy.png)\n### 摘要\n众所周知Java作为一个“一次编译，到处运行”的编译型语言，JVM虚拟机当之无愧的是Java语言世界的先锋将军。作为一个Java程序员，JVM虚拟机其相关知识是我们必须要了解以及深入掌握的重点。在本篇博客我将总结一下JVM虚拟机的内存结构、对象内存分配以及垃圾回收算法。这也是经常找工作求职必问的点。\n\n<!--more-->\n### Java内存分配与垃圾回收的复习整理\n\n#### Java内存区域划分\n\nJava虚拟机在执行Java程序的过程中会将它所管理的内存划分为若干个不同的区域。每个区域各司其职，其创建与销毁数据的规则也都各不相同。根据《Java虚拟机规范（Java SE 7版）》的规定，主要分为如下图几个区域。\n\n![Java内存划分](jvm.png)\n\n- **程序计数器**：当前线程执行字节码的行号指示器。[*线程私有*]\n- **虚拟机栈**：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。平常我们所说的Java虚拟机划分为堆和栈中的“栈”中的一部分就是虚拟机栈。其中局部变量表存放着编译期可知的所有基本数据类型、对象引用等。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法所需要的帧的大小是已经确定了的。[*线程私有*]\n- **本地方法栈**：与虚拟机栈发挥的作用相似，只不过这个区域执行的是native方法，即由c/c++或者其他语言编写的方法。[*线程私有*]\n- **Java堆**：用来存放对象实例，即我们最熟悉的一块区域。Java堆是垃圾收集器管理的主要区域，所以有时也叫“GC堆”。[*线程共享*]\n- **方法区**：用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 [*线程共享*]\n- **运行时常量池**：这是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。[*线程共享*]\n\n#### 常用的垃圾回收算法\n\n> 在Java代码中，我们程序员通常只关注广义上的“栈”和“堆”这两种区域。上述划分的Java内存区域告诉我们，栈是朝生夕死的一块区域，当线程进入的时候，栈空间被分配，线程结束之后，栈的内存空间即被回收用来去做其他的任务，栈中的栈帧随着线程的进入与退出有条不紊的执行着入栈和出栈的操作，每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的。而堆却不同，我们只有在程序运行期间才会知道创建那些对象，这部分内存分配和回收都是动态的。都由虚拟机的垃圾回收器进行“已死”对象的回收。\n\n##### 如何判断对象已死\n\n- **引用计数法**：给对象添加一个引用计数器，每当有引用指向它时计数器加1，引用失效后计数器减1。垃圾回收器回收对象计数器为0的对象昂即可。但是当出现对象之间循环引用，而对象却无实际作用的时候，这种方式就会出现内存泄漏。\n- **可达性分析**：通过一系列的称为“GC ROOTS”的对象作为起点，向下搜索，搜索走过的路径都称为引用链，当一个对象到“GC ROOTS”没有引用链的时候，证明这个对象不可达。此时会被判定为可回收对象。（此时并非一定死亡，在此之后还会进行两次标记处理，与finalize()方法有关，此处不再整理。注意一个知识点：任何对象的finalize()方法只会被系统调用一次，并且不建议使用）\n\n> 知道哪些对象是“垃圾”，接下来就是回收操作了\n\n##### 标记-清除法\n- 首先标记出所有需要回收的对象，然后统一回收。是最基础的回收算法。\n- 不足之处：1、效率低下，标记和清除的效率都不高；2、产生大量内存碎片，使得之后程序要分配大对象却没有空间，不得不除法GC。\n\n##### 复制\n- 首先将内存区域划分为两等分，每次只使用其中一块内存，当用完之后，将活着的对象复制到另一块内存，然后整个回收上一半。这种按顺序分配内存，实现简单，运行高效。\n- 不足之处：直接将内存缩小了一半，产生大量的空间浪费。然而很多垃圾收集器都是用这种方式，但是有过改进。因为堆中的对象90%都是朝生夕死的，只有10%是会长期存活下来的对象，那么对于这90%的对象，完全可以使用这种高效的复制收集算法。首先将内存区域划分三份，10%的对象存在其中较大的一分中，另外的两份等份分配，处理这90%的“死的快”的对象。这就是Form,To,Eden区域。即Eden:From:To=8:1:1\n\n##### 标记-整理法\n- 标记整理的方式实际上也是先将可回收对象标记起来，然后对于这些存活着的对象，并不直接回收，而是先向一端移动，最后直接回收端边界之外的对象。这种做法解决了处理存活率较高的大对象的回收，适合老年代堆对象回收。\n\n##### 分代收集\n- 当前商业虚拟机基本上都会采取分代收集算法。即根据对象存活周期的不同将内存划分为不同区域，分别使用不同的垃圾回收算法进行垃圾回收。比如在新生代使用复制算法，因为新生代大量对象都是朝生夕死需要很高的回收效率，而对于老年代则使用标记清除或者标记整理。\n\n\n#### Java虚拟机的对象内存分配\n\nJava对象内存分配实际上就指的是将对象分配在堆上的过程。不过实际上堆还被虚拟机划分成了不同的区域，并且每个区域的分配策略都不相同。上面我们说到虚拟机根据对象存活周期的不同将对内存分为几种不同的区域，即新生代Eden,From Survivor,To Survivor和老年代。那么这几种区域是如何进行内存分配的呢？\n\n- 对象优先再Eden区域分配：大多数情况下，对象会在Eden区域分配，在Eden区域空间不够的情况下，会先进行一次MinorGC（MinorGC是新生代垃圾回收，Full GC是老年代垃圾回收）。\n- 大对象直接进入老年代：大对象即指的是需要大量连续空间的对象，例如很长的字符串以及数组。虚拟机提供参数`-XX:PretenureSizeThreadhold`参数设置大于多少算是大对象，避免在新生代几个区域中发生大量的内存复制。\n- 长期存活的对象直接进入老年代：每经过一次MinorGC对象的年龄都会加1。当年龄加到`-XX:MaxTenuringThreadhold`（默认15）指定的值时，判断为长期存活，对象会被移动到老年代。\n- 动态对象年龄判断：为了适应多变的内存情况，一般虚拟机都会使用动态对象年龄判定。如果Survivor中相同年龄的所有对象大小总和大于该空间的一半，该年龄以上的对象就会直接进入老年代，无需等到年龄大于`-XX:MaxTenuringThreadhold`（默认15）指定的值。\n- 空间分配担保：在发生MinorGC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，是的话MinorGC可以被认定是安全的。如果不成立，虚拟机会先检查`HandlerPromotionFailure`参数是否允许担保失败，不允许的话会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于的话或者`HandlerPromotionFailure`设置不允许冒险，那么就会执行一次FullGC。\n\n----\n\n### 总结\n> 内存回收与垃圾收集很多时候都是影响系统性能和并发能力的主要因素之一，虚拟机提供了多种垃圾收集器以及大量的调节参数，方便开发人员根据实际应用调整以便程序可以获得最高的性能。这些垃圾收集器和虚拟机参数没有固定的标准的组合，需要开发人员对于内存分配与垃圾回收相当了解，才得以根据实际情况实际配置。\n","slug":"Java内存分配与垃圾回收的复习整理","published":1,"updated":"2019-05-22T12:36:48.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvxr005ocwnkrvaq9tfr","content":"<p><img src=\"/blog/20190414/Java内存分配与垃圾回收的复习整理/zy.png\" alt=\"摘要\"></p>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>众所周知Java作为一个“一次编译，到处运行”的编译型语言，JVM虚拟机当之无愧的是Java语言世界的先锋将军。作为一个Java程序员，JVM虚拟机其相关知识是我们必须要了解以及深入掌握的重点。在本篇博客我将总结一下JVM虚拟机的内存结构、对象内存分配以及垃圾回收算法。这也是经常找工作求职必问的点。</p>\n<a id=\"more\"></a>\n<h3 id=\"Java内存分配与垃圾回收的复习整理\"><a href=\"#Java内存分配与垃圾回收的复习整理\" class=\"headerlink\" title=\"Java内存分配与垃圾回收的复习整理\"></a>Java内存分配与垃圾回收的复习整理</h3><h4 id=\"Java内存区域划分\"><a href=\"#Java内存区域划分\" class=\"headerlink\" title=\"Java内存区域划分\"></a>Java内存区域划分</h4><p>Java虚拟机在执行Java程序的过程中会将它所管理的内存划分为若干个不同的区域。每个区域各司其职，其创建与销毁数据的规则也都各不相同。根据《Java虚拟机规范（Java SE 7版）》的规定，主要分为如下图几个区域。</p>\n<p><img src=\"/blog/20190414/Java内存分配与垃圾回收的复习整理/jvm.png\" alt=\"Java内存划分\"></p>\n<ul>\n<li><strong>程序计数器</strong>：当前线程执行字节码的行号指示器。[<em>线程私有</em>]</li>\n<li><strong>虚拟机栈</strong>：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。平常我们所说的Java虚拟机划分为堆和栈中的“栈”中的一部分就是虚拟机栈。其中局部变量表存放着编译期可知的所有基本数据类型、对象引用等。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法所需要的帧的大小是已经确定了的。[<em>线程私有</em>]</li>\n<li><strong>本地方法栈</strong>：与虚拟机栈发挥的作用相似，只不过这个区域执行的是native方法，即由c/c++或者其他语言编写的方法。[<em>线程私有</em>]</li>\n<li><strong>Java堆</strong>：用来存放对象实例，即我们最熟悉的一块区域。Java堆是垃圾收集器管理的主要区域，所以有时也叫“GC堆”。[<em>线程共享</em>]</li>\n<li><strong>方法区</strong>：用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 [<em>线程共享</em>]</li>\n<li><strong>运行时常量池</strong>：这是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。[<em>线程共享</em>]</li>\n</ul>\n<h4 id=\"常用的垃圾回收算法\"><a href=\"#常用的垃圾回收算法\" class=\"headerlink\" title=\"常用的垃圾回收算法\"></a>常用的垃圾回收算法</h4><blockquote>\n<p>在Java代码中，我们程序员通常只关注广义上的“栈”和“堆”这两种区域。上述划分的Java内存区域告诉我们，栈是朝生夕死的一块区域，当线程进入的时候，栈空间被分配，线程结束之后，栈的内存空间即被回收用来去做其他的任务，栈中的栈帧随着线程的进入与退出有条不紊的执行着入栈和出栈的操作，每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的。而堆却不同，我们只有在程序运行期间才会知道创建那些对象，这部分内存分配和回收都是动态的。都由虚拟机的垃圾回收器进行“已死”对象的回收。</p>\n</blockquote>\n<h5 id=\"如何判断对象已死\"><a href=\"#如何判断对象已死\" class=\"headerlink\" title=\"如何判断对象已死\"></a>如何判断对象已死</h5><ul>\n<li><strong>引用计数法</strong>：给对象添加一个引用计数器，每当有引用指向它时计数器加1，引用失效后计数器减1。垃圾回收器回收对象计数器为0的对象昂即可。但是当出现对象之间循环引用，而对象却无实际作用的时候，这种方式就会出现内存泄漏。</li>\n<li><strong>可达性分析</strong>：通过一系列的称为“GC ROOTS”的对象作为起点，向下搜索，搜索走过的路径都称为引用链，当一个对象到“GC ROOTS”没有引用链的时候，证明这个对象不可达。此时会被判定为可回收对象。（此时并非一定死亡，在此之后还会进行两次标记处理，与finalize()方法有关，此处不再整理。注意一个知识点：任何对象的finalize()方法只会被系统调用一次，并且不建议使用）</li>\n</ul>\n<blockquote>\n<p>知道哪些对象是“垃圾”，接下来就是回收操作了</p>\n</blockquote>\n<h5 id=\"标记-清除法\"><a href=\"#标记-清除法\" class=\"headerlink\" title=\"标记-清除法\"></a>标记-清除法</h5><ul>\n<li>首先标记出所有需要回收的对象，然后统一回收。是最基础的回收算法。</li>\n<li>不足之处：1、效率低下，标记和清除的效率都不高；2、产生大量内存碎片，使得之后程序要分配大对象却没有空间，不得不除法GC。</li>\n</ul>\n<h5 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h5><ul>\n<li>首先将内存区域划分为两等分，每次只使用其中一块内存，当用完之后，将活着的对象复制到另一块内存，然后整个回收上一半。这种按顺序分配内存，实现简单，运行高效。</li>\n<li>不足之处：直接将内存缩小了一半，产生大量的空间浪费。然而很多垃圾收集器都是用这种方式，但是有过改进。因为堆中的对象90%都是朝生夕死的，只有10%是会长期存活下来的对象，那么对于这90%的对象，完全可以使用这种高效的复制收集算法。首先将内存区域划分三份，10%的对象存在其中较大的一分中，另外的两份等份分配，处理这90%的“死的快”的对象。这就是Form,To,Eden区域。即Eden:From:To=8:1:1</li>\n</ul>\n<h5 id=\"标记-整理法\"><a href=\"#标记-整理法\" class=\"headerlink\" title=\"标记-整理法\"></a>标记-整理法</h5><ul>\n<li>标记整理的方式实际上也是先将可回收对象标记起来，然后对于这些存活着的对象，并不直接回收，而是先向一端移动，最后直接回收端边界之外的对象。这种做法解决了处理存活率较高的大对象的回收，适合老年代堆对象回收。</li>\n</ul>\n<h5 id=\"分代收集\"><a href=\"#分代收集\" class=\"headerlink\" title=\"分代收集\"></a>分代收集</h5><ul>\n<li>当前商业虚拟机基本上都会采取分代收集算法。即根据对象存活周期的不同将内存划分为不同区域，分别使用不同的垃圾回收算法进行垃圾回收。比如在新生代使用复制算法，因为新生代大量对象都是朝生夕死需要很高的回收效率，而对于老年代则使用标记清除或者标记整理。</li>\n</ul>\n<h4 id=\"Java虚拟机的对象内存分配\"><a href=\"#Java虚拟机的对象内存分配\" class=\"headerlink\" title=\"Java虚拟机的对象内存分配\"></a>Java虚拟机的对象内存分配</h4><p>Java对象内存分配实际上就指的是将对象分配在堆上的过程。不过实际上堆还被虚拟机划分成了不同的区域，并且每个区域的分配策略都不相同。上面我们说到虚拟机根据对象存活周期的不同将对内存分为几种不同的区域，即新生代Eden,From Survivor,To Survivor和老年代。那么这几种区域是如何进行内存分配的呢？</p>\n<ul>\n<li>对象优先再Eden区域分配：大多数情况下，对象会在Eden区域分配，在Eden区域空间不够的情况下，会先进行一次MinorGC（MinorGC是新生代垃圾回收，Full GC是老年代垃圾回收）。</li>\n<li>大对象直接进入老年代：大对象即指的是需要大量连续空间的对象，例如很长的字符串以及数组。虚拟机提供参数<code>-XX:PretenureSizeThreadhold</code>参数设置大于多少算是大对象，避免在新生代几个区域中发生大量的内存复制。</li>\n<li>长期存活的对象直接进入老年代：每经过一次MinorGC对象的年龄都会加1。当年龄加到<code>-XX:MaxTenuringThreadhold</code>（默认15）指定的值时，判断为长期存活，对象会被移动到老年代。</li>\n<li>动态对象年龄判断：为了适应多变的内存情况，一般虚拟机都会使用动态对象年龄判定。如果Survivor中相同年龄的所有对象大小总和大于该空间的一半，该年龄以上的对象就会直接进入老年代，无需等到年龄大于<code>-XX:MaxTenuringThreadhold</code>（默认15）指定的值。</li>\n<li>空间分配担保：在发生MinorGC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，是的话MinorGC可以被认定是安全的。如果不成立，虚拟机会先检查<code>HandlerPromotionFailure</code>参数是否允许担保失败，不允许的话会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于的话或者<code>HandlerPromotionFailure</code>设置不允许冒险，那么就会执行一次FullGC。</li>\n</ul>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>内存回收与垃圾收集很多时候都是影响系统性能和并发能力的主要因素之一，虚拟机提供了多种垃圾收集器以及大量的调节参数，方便开发人员根据实际应用调整以便程序可以获得最高的性能。这些垃圾收集器和虚拟机参数没有固定的标准的组合，需要开发人员对于内存分配与垃圾回收相当了解，才得以根据实际情况实际配置。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p><img src=\"/blog/20190414/Java内存分配与垃圾回收的复习整理/zy.png\" alt=\"摘要\"></p>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>众所周知Java作为一个“一次编译，到处运行”的编译型语言，JVM虚拟机当之无愧的是Java语言世界的先锋将军。作为一个Java程序员，JVM虚拟机其相关知识是我们必须要了解以及深入掌握的重点。在本篇博客我将总结一下JVM虚拟机的内存结构、对象内存分配以及垃圾回收算法。这也是经常找工作求职必问的点。</p>","more":"<h3 id=\"Java内存分配与垃圾回收的复习整理\"><a href=\"#Java内存分配与垃圾回收的复习整理\" class=\"headerlink\" title=\"Java内存分配与垃圾回收的复习整理\"></a>Java内存分配与垃圾回收的复习整理</h3><h4 id=\"Java内存区域划分\"><a href=\"#Java内存区域划分\" class=\"headerlink\" title=\"Java内存区域划分\"></a>Java内存区域划分</h4><p>Java虚拟机在执行Java程序的过程中会将它所管理的内存划分为若干个不同的区域。每个区域各司其职，其创建与销毁数据的规则也都各不相同。根据《Java虚拟机规范（Java SE 7版）》的规定，主要分为如下图几个区域。</p>\n<p><img src=\"/blog/20190414/Java内存分配与垃圾回收的复习整理/jvm.png\" alt=\"Java内存划分\"></p>\n<ul>\n<li><strong>程序计数器</strong>：当前线程执行字节码的行号指示器。[<em>线程私有</em>]</li>\n<li><strong>虚拟机栈</strong>：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。平常我们所说的Java虚拟机划分为堆和栈中的“栈”中的一部分就是虚拟机栈。其中局部变量表存放着编译期可知的所有基本数据类型、对象引用等。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法所需要的帧的大小是已经确定了的。[<em>线程私有</em>]</li>\n<li><strong>本地方法栈</strong>：与虚拟机栈发挥的作用相似，只不过这个区域执行的是native方法，即由c/c++或者其他语言编写的方法。[<em>线程私有</em>]</li>\n<li><strong>Java堆</strong>：用来存放对象实例，即我们最熟悉的一块区域。Java堆是垃圾收集器管理的主要区域，所以有时也叫“GC堆”。[<em>线程共享</em>]</li>\n<li><strong>方法区</strong>：用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 [<em>线程共享</em>]</li>\n<li><strong>运行时常量池</strong>：这是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息之外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。[<em>线程共享</em>]</li>\n</ul>\n<h4 id=\"常用的垃圾回收算法\"><a href=\"#常用的垃圾回收算法\" class=\"headerlink\" title=\"常用的垃圾回收算法\"></a>常用的垃圾回收算法</h4><blockquote>\n<p>在Java代码中，我们程序员通常只关注广义上的“栈”和“堆”这两种区域。上述划分的Java内存区域告诉我们，栈是朝生夕死的一块区域，当线程进入的时候，栈空间被分配，线程结束之后，栈的内存空间即被回收用来去做其他的任务，栈中的栈帧随着线程的进入与退出有条不紊的执行着入栈和出栈的操作，每一个栈帧中分配多少内存基本上是在类结构确定下来就已知的。而堆却不同，我们只有在程序运行期间才会知道创建那些对象，这部分内存分配和回收都是动态的。都由虚拟机的垃圾回收器进行“已死”对象的回收。</p>\n</blockquote>\n<h5 id=\"如何判断对象已死\"><a href=\"#如何判断对象已死\" class=\"headerlink\" title=\"如何判断对象已死\"></a>如何判断对象已死</h5><ul>\n<li><strong>引用计数法</strong>：给对象添加一个引用计数器，每当有引用指向它时计数器加1，引用失效后计数器减1。垃圾回收器回收对象计数器为0的对象昂即可。但是当出现对象之间循环引用，而对象却无实际作用的时候，这种方式就会出现内存泄漏。</li>\n<li><strong>可达性分析</strong>：通过一系列的称为“GC ROOTS”的对象作为起点，向下搜索，搜索走过的路径都称为引用链，当一个对象到“GC ROOTS”没有引用链的时候，证明这个对象不可达。此时会被判定为可回收对象。（此时并非一定死亡，在此之后还会进行两次标记处理，与finalize()方法有关，此处不再整理。注意一个知识点：任何对象的finalize()方法只会被系统调用一次，并且不建议使用）</li>\n</ul>\n<blockquote>\n<p>知道哪些对象是“垃圾”，接下来就是回收操作了</p>\n</blockquote>\n<h5 id=\"标记-清除法\"><a href=\"#标记-清除法\" class=\"headerlink\" title=\"标记-清除法\"></a>标记-清除法</h5><ul>\n<li>首先标记出所有需要回收的对象，然后统一回收。是最基础的回收算法。</li>\n<li>不足之处：1、效率低下，标记和清除的效率都不高；2、产生大量内存碎片，使得之后程序要分配大对象却没有空间，不得不除法GC。</li>\n</ul>\n<h5 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h5><ul>\n<li>首先将内存区域划分为两等分，每次只使用其中一块内存，当用完之后，将活着的对象复制到另一块内存，然后整个回收上一半。这种按顺序分配内存，实现简单，运行高效。</li>\n<li>不足之处：直接将内存缩小了一半，产生大量的空间浪费。然而很多垃圾收集器都是用这种方式，但是有过改进。因为堆中的对象90%都是朝生夕死的，只有10%是会长期存活下来的对象，那么对于这90%的对象，完全可以使用这种高效的复制收集算法。首先将内存区域划分三份，10%的对象存在其中较大的一分中，另外的两份等份分配，处理这90%的“死的快”的对象。这就是Form,To,Eden区域。即Eden:From:To=8:1:1</li>\n</ul>\n<h5 id=\"标记-整理法\"><a href=\"#标记-整理法\" class=\"headerlink\" title=\"标记-整理法\"></a>标记-整理法</h5><ul>\n<li>标记整理的方式实际上也是先将可回收对象标记起来，然后对于这些存活着的对象，并不直接回收，而是先向一端移动，最后直接回收端边界之外的对象。这种做法解决了处理存活率较高的大对象的回收，适合老年代堆对象回收。</li>\n</ul>\n<h5 id=\"分代收集\"><a href=\"#分代收集\" class=\"headerlink\" title=\"分代收集\"></a>分代收集</h5><ul>\n<li>当前商业虚拟机基本上都会采取分代收集算法。即根据对象存活周期的不同将内存划分为不同区域，分别使用不同的垃圾回收算法进行垃圾回收。比如在新生代使用复制算法，因为新生代大量对象都是朝生夕死需要很高的回收效率，而对于老年代则使用标记清除或者标记整理。</li>\n</ul>\n<h4 id=\"Java虚拟机的对象内存分配\"><a href=\"#Java虚拟机的对象内存分配\" class=\"headerlink\" title=\"Java虚拟机的对象内存分配\"></a>Java虚拟机的对象内存分配</h4><p>Java对象内存分配实际上就指的是将对象分配在堆上的过程。不过实际上堆还被虚拟机划分成了不同的区域，并且每个区域的分配策略都不相同。上面我们说到虚拟机根据对象存活周期的不同将对内存分为几种不同的区域，即新生代Eden,From Survivor,To Survivor和老年代。那么这几种区域是如何进行内存分配的呢？</p>\n<ul>\n<li>对象优先再Eden区域分配：大多数情况下，对象会在Eden区域分配，在Eden区域空间不够的情况下，会先进行一次MinorGC（MinorGC是新生代垃圾回收，Full GC是老年代垃圾回收）。</li>\n<li>大对象直接进入老年代：大对象即指的是需要大量连续空间的对象，例如很长的字符串以及数组。虚拟机提供参数<code>-XX:PretenureSizeThreadhold</code>参数设置大于多少算是大对象，避免在新生代几个区域中发生大量的内存复制。</li>\n<li>长期存活的对象直接进入老年代：每经过一次MinorGC对象的年龄都会加1。当年龄加到<code>-XX:MaxTenuringThreadhold</code>（默认15）指定的值时，判断为长期存活，对象会被移动到老年代。</li>\n<li>动态对象年龄判断：为了适应多变的内存情况，一般虚拟机都会使用动态对象年龄判定。如果Survivor中相同年龄的所有对象大小总和大于该空间的一半，该年龄以上的对象就会直接进入老年代，无需等到年龄大于<code>-XX:MaxTenuringThreadhold</code>（默认15）指定的值。</li>\n<li>空间分配担保：在发生MinorGC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，是的话MinorGC可以被认定是安全的。如果不成立，虚拟机会先检查<code>HandlerPromotionFailure</code>参数是否允许担保失败，不允许的话会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于的话或者<code>HandlerPromotionFailure</code>设置不允许冒险，那么就会执行一次FullGC。</li>\n</ul>\n<hr>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>内存回收与垃圾收集很多时候都是影响系统性能和并发能力的主要因素之一，虚拟机提供了多种垃圾收集器以及大量的调节参数，方便开发人员根据实际应用调整以便程序可以获得最高的性能。这些垃圾收集器和虚拟机参数没有固定的标准的组合，需要开发人员对于内存分配与垃圾回收相当了解，才得以根据实际情况实际配置。</p>\n</blockquote>"},{"title":"Java序列化和transient关键字的理解与学习","date":"2019-05-11T12:44:31.000Z","_content":"\n#### Java序列化\n\n![Java序列化过程](xuliehua.png)\n\n> 在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。\n\n<!--more-->\n\n##### Java中如何进行序列化与反序列化\n\n  - 在Java中，对象一般是无法进行序列化与反序列化的。而使得对象能够被序列化的方式也很简单，即实现接口 `Serializable` 。如下代码即将对象序列化以及反序列化的过程。\n\n  ```\n    public class TestSerializable implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private Integer age;\n        private String name;\n        TestSerializable() {\n            age = 20;\n            name = \"aachuanpu\";\n        }\n        public static void main(String[] args) throws IOException, ClassNotFoundException {\n            TestSerializable test = new TestSerializable();\n            File file = new File(\"e:/test.txt\");\n            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));\n            out.writeObject(test);\n            ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));\n            TestSerializable newTest = (TestSerializable) in.readObject();\n            System.out.println(newTest.name);\n        }\n    }\n  ```\n\n##### serialVersionUID的作用\n\n  - serialVersionUID作为实现序列化接口的一个非必须非必须声明的静态常量经常不被开发者所重视，忘记声明。其实serialVersionUID的作用是为了保证序列化之前和之后的对象是同一对象。我们知道JVM判断对象是否相同是根据对象的类路径全限定名确定的，而虚拟机决定一个对象是否允许序列化和反序列化成这个类还取决于其serialVersionUID是否一致。不一致的话会导致`java.io.InvalidClassException的异常`，也可以不指定serialVersionUID，如果不指定的话java会根据class计算serialVersionUID。\n  - 对于两个相同的类及拥有相同的serialVersionUID，如果两个类字段不一致也会序列化和反序列化成功。这时Java会在反序列化的时候忽略掉不一致的字段。\n\n##### 静态变量的序列化\n\n  - 在序列化的时候，静态变量能够被序列化成功吗？\n  ```\n  public class TestSerializable implements Serializable {\n      private static final long serialVersionUID = 1L;\n      public static String staticName;\n      private Integer age;\n      private String name;\n      TestSerializable() {\n          age = 20;\n          name = \"aachuanpu\";\n      }\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n          TestSerializable test = new TestSerializable();\n          TestSerializable.staticName = \"name11111\";\n          File file = new File(\"e:/test.txt\");\n          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));\n          out.writeObject(test);\n          TestSerializable.staticName = \"name222\";\n          ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));\n          TestSerializable newTest = (TestSerializable) in.readObject();\n          System.out.println(newTest.name);\n          System.out.println(TestSerializable.staticName);\n      }\n  }\n  ```\n\n  - 以上代码会输出什么？\n\n  ```\n  aachuanpu\n  name222\n\n  Process finished with exit code 0\n  ```\n\n  - 如上所见：将对象序列化之后，修改静态变量的值，再将对象反序列化，输出的静态变量的值是修改之后的。即序列化保存的是对象的状态，静态变量属于类，因此序列化并不保存静态变量。\n\n##### transient关键字与自定义序列化\n\n  - 对象的序列化是将对象中的数据写入本地文件或者用于网络传输的过程，但是很多时候会有一些数据无需进行序列化保存起来或者传输出去。我们可以使用`transient`关键字修饰成员变量。那么在Java序列化的时候就**不会使用Java本身的序列化方式对其进行序列化**。但是我们依然可以自定义自己的序列化行为对其进行序列化！\n\n  **自定义序列化：** 定义自己的`writeObject`和`readObject`方法\n\n  - 对于使用transient修饰的成员变量，可以编写`writeObject`和`readObject`方法实现对于该成员变量(不仅仅只是针对该成员变量)的自定义序列化。在编写`writeObject`和`readObject`方法的时候需要注意的地方在于：这俩方法没有在Object中定义，也没有在`Serializable`接口中声明，JVM是如何调用到这俩方法的呢？答案是通过反射，去根据方法名和参数寻找到相应的方法，找到之后会被ObjectOutputStream调用，没有这俩方法就调用默认的序列化呗。还有就是因为ObjectOutputStream使用getPrivateMethod，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。\n\n  - 通过这种方法，我们实现自己的序列化与反序列化可以实现很多场景下的需求。比如网络传输的时候对于特殊字段进行加密等等。\n\n  - 如下，你会发现我在这俩方法中调用了defaultWriteObject()和defaultReadObject()用于处理未被transient修饰的成员变量。\n\n  ```\n  public class TestSerializable implements Serializable {\n      private static final long serialVersionUID = 1L;\n      public static String staticName;\n      private Integer age;\n      private transient String name;\n      TestSerializable() {\n          age = 20;\n          name = \"aachuanpu\";\n      }\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n          TestSerializable test = new TestSerializable();\n          TestSerializable.staticName = \"name11111\";\n          File file = new File(\"e:/test.txt\");\n          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));\n          out.writeObject(test);\n          TestSerializable.staticName = \"name222\";\n          ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));\n          TestSerializable newTest = (TestSerializable) in.readObject();\n          System.out.println(newTest.name);\n          System.out.println(TestSerializable.staticName);\n      }\n      private void writeObject(ObjectOutputStream oos) throws IOException {\n          oos.defaultWriteObject();\n          name = \"自定义名称\";\n          oos.writeObject(name);\n          System.out.println(\"调用writeObject\");\n      }\n      private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n          ois.defaultReadObject();\n          String name = (String) ois.readObject();\n          this.name = name;\n          System.out.println(\"读出的name=\" + name);\n          System.out.println(\"调用readObject\");\n      }\n  }\n  ```\n  输出如下：\n  ```\n  调用writeObject\n  读出的name=自定义名称\n  调用readObject\n  自定义名称\n  name222\n\n  Process finished with exit code 0\n  ```\n\n##### 父类的序列化\n\n  - 一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取 父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都 是默认声明的值。\n\n##### 常问：ArrayList中数组使用transient修饰为何还能被序列化\n\n  **ArrayList源码：**\n  ```\n  /**\n   * The array buffer into which the elements of the ArrayList are stored.\n   * The capacity of the ArrayList is the length of this array buffer. Any\n   * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n   * will be expanded to DEFAULT_CAPACITY when the first element is added.\n   */\n  transient Object[] elementData; // non-private to simplify nested class access\n  ```\n  transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。但是ArrayList又是可序行化的类，elementData是ArrayList具体存放元素的成员，用transient来修饰elementData，需要实现自己的序列化方式去处理。即对于数组中多余的空间不去进行序列化。如下：\n  ```\n  /**\n   * Save the state of the <tt>ArrayList</tt> instance to a stream (that\n   * is, serialize it).\n   *\n   * @serialData The length of the array backing the <tt>ArrayList</tt>\n   *             instance is emitted (int), followed by all of its elements\n   *             (each an <tt>Object</tt>) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException{\n      // Write out element count, and any hidden stuff\n      int expectedModCount = modCount;\n      s.defaultWriteObject();\n\n      // Write out size as capacity for behavioural compatibility with clone()\n      s.writeInt(size);\n\n      // Write out all elements in the proper order.\n      for (int i=0; i<size; i++) {\n          s.writeObject(elementData[i]);\n      }\n\n      if (modCount != expectedModCount) {\n          throw new ConcurrentModificationException();\n      }\n  }\n\n  /**\n   * Reconstitute the <tt>ArrayList</tt> instance from a stream (that is,\n   * deserialize it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n      elementData = EMPTY_ELEMENTDATA;\n\n      // Read in size, and any hidden stuff\n      s.defaultReadObject();\n\n      // Read in capacity\n      s.readInt(); // ignored\n\n      if (size > 0) {\n          // be like clone(), allocate array based upon size not capacity\n          ensureCapacityInternal(size);\n\n          Object[] a = elementData;\n          // Read in all elements in the proper order.\n          for (int i=0; i<size; i++) {\n              a[i] = s.readObject();\n          }\n      }\n  }\n  ```\n  **elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。**\n\n\n##### 其余补充\n\n[来自文章](https://bluepopopo.iteye.com/blog/486548) ← 点击链接查看参考博客\n\n> 1.Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值;\n\n> 2.Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。Serializable是内建支持的也就是直接implement即可，但Externalizable的实现类必须提供readExternal和writeExternal实现。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。\n\n> 3.正如Effectvie Java中提到的，序列化就如同另外一个构造函数，只不过是有由stream进行创建的。如果字段有一些条件限制的，特别是非可变的类定义了可变的字段会反序列化可能会有问题。可以在readObject方法中添加条件限制，也可以在readResolve中做。参考56条“保护性的编写readObject”和“提供一个readResolve方法”。\n\n> 4.当有非常复杂的对象需要提供deep clone时，可以考虑将其声明为可序列化，不过缺点也显而易见，性能开销。\n","source":"_posts/Java序列化和transient关键字的理解与学习.md","raw":"---\ntitle: Java序列化和transient关键字的理解与学习\ndate: 2019-05-11 20:44:31\ncategories: [Java基础]\ntags: [序列化,Java基础,transient关键字]\n---\n\n#### Java序列化\n\n![Java序列化过程](xuliehua.png)\n\n> 在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。\n\n<!--more-->\n\n##### Java中如何进行序列化与反序列化\n\n  - 在Java中，对象一般是无法进行序列化与反序列化的。而使得对象能够被序列化的方式也很简单，即实现接口 `Serializable` 。如下代码即将对象序列化以及反序列化的过程。\n\n  ```\n    public class TestSerializable implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private Integer age;\n        private String name;\n        TestSerializable() {\n            age = 20;\n            name = \"aachuanpu\";\n        }\n        public static void main(String[] args) throws IOException, ClassNotFoundException {\n            TestSerializable test = new TestSerializable();\n            File file = new File(\"e:/test.txt\");\n            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));\n            out.writeObject(test);\n            ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));\n            TestSerializable newTest = (TestSerializable) in.readObject();\n            System.out.println(newTest.name);\n        }\n    }\n  ```\n\n##### serialVersionUID的作用\n\n  - serialVersionUID作为实现序列化接口的一个非必须非必须声明的静态常量经常不被开发者所重视，忘记声明。其实serialVersionUID的作用是为了保证序列化之前和之后的对象是同一对象。我们知道JVM判断对象是否相同是根据对象的类路径全限定名确定的，而虚拟机决定一个对象是否允许序列化和反序列化成这个类还取决于其serialVersionUID是否一致。不一致的话会导致`java.io.InvalidClassException的异常`，也可以不指定serialVersionUID，如果不指定的话java会根据class计算serialVersionUID。\n  - 对于两个相同的类及拥有相同的serialVersionUID，如果两个类字段不一致也会序列化和反序列化成功。这时Java会在反序列化的时候忽略掉不一致的字段。\n\n##### 静态变量的序列化\n\n  - 在序列化的时候，静态变量能够被序列化成功吗？\n  ```\n  public class TestSerializable implements Serializable {\n      private static final long serialVersionUID = 1L;\n      public static String staticName;\n      private Integer age;\n      private String name;\n      TestSerializable() {\n          age = 20;\n          name = \"aachuanpu\";\n      }\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n          TestSerializable test = new TestSerializable();\n          TestSerializable.staticName = \"name11111\";\n          File file = new File(\"e:/test.txt\");\n          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));\n          out.writeObject(test);\n          TestSerializable.staticName = \"name222\";\n          ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));\n          TestSerializable newTest = (TestSerializable) in.readObject();\n          System.out.println(newTest.name);\n          System.out.println(TestSerializable.staticName);\n      }\n  }\n  ```\n\n  - 以上代码会输出什么？\n\n  ```\n  aachuanpu\n  name222\n\n  Process finished with exit code 0\n  ```\n\n  - 如上所见：将对象序列化之后，修改静态变量的值，再将对象反序列化，输出的静态变量的值是修改之后的。即序列化保存的是对象的状态，静态变量属于类，因此序列化并不保存静态变量。\n\n##### transient关键字与自定义序列化\n\n  - 对象的序列化是将对象中的数据写入本地文件或者用于网络传输的过程，但是很多时候会有一些数据无需进行序列化保存起来或者传输出去。我们可以使用`transient`关键字修饰成员变量。那么在Java序列化的时候就**不会使用Java本身的序列化方式对其进行序列化**。但是我们依然可以自定义自己的序列化行为对其进行序列化！\n\n  **自定义序列化：** 定义自己的`writeObject`和`readObject`方法\n\n  - 对于使用transient修饰的成员变量，可以编写`writeObject`和`readObject`方法实现对于该成员变量(不仅仅只是针对该成员变量)的自定义序列化。在编写`writeObject`和`readObject`方法的时候需要注意的地方在于：这俩方法没有在Object中定义，也没有在`Serializable`接口中声明，JVM是如何调用到这俩方法的呢？答案是通过反射，去根据方法名和参数寻找到相应的方法，找到之后会被ObjectOutputStream调用，没有这俩方法就调用默认的序列化呗。还有就是因为ObjectOutputStream使用getPrivateMethod，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。\n\n  - 通过这种方法，我们实现自己的序列化与反序列化可以实现很多场景下的需求。比如网络传输的时候对于特殊字段进行加密等等。\n\n  - 如下，你会发现我在这俩方法中调用了defaultWriteObject()和defaultReadObject()用于处理未被transient修饰的成员变量。\n\n  ```\n  public class TestSerializable implements Serializable {\n      private static final long serialVersionUID = 1L;\n      public static String staticName;\n      private Integer age;\n      private transient String name;\n      TestSerializable() {\n          age = 20;\n          name = \"aachuanpu\";\n      }\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n          TestSerializable test = new TestSerializable();\n          TestSerializable.staticName = \"name11111\";\n          File file = new File(\"e:/test.txt\");\n          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));\n          out.writeObject(test);\n          TestSerializable.staticName = \"name222\";\n          ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));\n          TestSerializable newTest = (TestSerializable) in.readObject();\n          System.out.println(newTest.name);\n          System.out.println(TestSerializable.staticName);\n      }\n      private void writeObject(ObjectOutputStream oos) throws IOException {\n          oos.defaultWriteObject();\n          name = \"自定义名称\";\n          oos.writeObject(name);\n          System.out.println(\"调用writeObject\");\n      }\n      private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n          ois.defaultReadObject();\n          String name = (String) ois.readObject();\n          this.name = name;\n          System.out.println(\"读出的name=\" + name);\n          System.out.println(\"调用readObject\");\n      }\n  }\n  ```\n  输出如下：\n  ```\n  调用writeObject\n  读出的name=自定义名称\n  调用readObject\n  自定义名称\n  name222\n\n  Process finished with exit code 0\n  ```\n\n##### 父类的序列化\n\n  - 一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取 父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都 是默认声明的值。\n\n##### 常问：ArrayList中数组使用transient修饰为何还能被序列化\n\n  **ArrayList源码：**\n  ```\n  /**\n   * The array buffer into which the elements of the ArrayList are stored.\n   * The capacity of the ArrayList is the length of this array buffer. Any\n   * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n   * will be expanded to DEFAULT_CAPACITY when the first element is added.\n   */\n  transient Object[] elementData; // non-private to simplify nested class access\n  ```\n  transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。但是ArrayList又是可序行化的类，elementData是ArrayList具体存放元素的成员，用transient来修饰elementData，需要实现自己的序列化方式去处理。即对于数组中多余的空间不去进行序列化。如下：\n  ```\n  /**\n   * Save the state of the <tt>ArrayList</tt> instance to a stream (that\n   * is, serialize it).\n   *\n   * @serialData The length of the array backing the <tt>ArrayList</tt>\n   *             instance is emitted (int), followed by all of its elements\n   *             (each an <tt>Object</tt>) in the proper order.\n   */\n  private void writeObject(java.io.ObjectOutputStream s)\n      throws java.io.IOException{\n      // Write out element count, and any hidden stuff\n      int expectedModCount = modCount;\n      s.defaultWriteObject();\n\n      // Write out size as capacity for behavioural compatibility with clone()\n      s.writeInt(size);\n\n      // Write out all elements in the proper order.\n      for (int i=0; i<size; i++) {\n          s.writeObject(elementData[i]);\n      }\n\n      if (modCount != expectedModCount) {\n          throw new ConcurrentModificationException();\n      }\n  }\n\n  /**\n   * Reconstitute the <tt>ArrayList</tt> instance from a stream (that is,\n   * deserialize it).\n   */\n  private void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n      elementData = EMPTY_ELEMENTDATA;\n\n      // Read in size, and any hidden stuff\n      s.defaultReadObject();\n\n      // Read in capacity\n      s.readInt(); // ignored\n\n      if (size > 0) {\n          // be like clone(), allocate array based upon size not capacity\n          ensureCapacityInternal(size);\n\n          Object[] a = elementData;\n          // Read in all elements in the proper order.\n          for (int i=0; i<size; i++) {\n              a[i] = s.readObject();\n          }\n      }\n  }\n  ```\n  **elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。**\n\n\n##### 其余补充\n\n[来自文章](https://bluepopopo.iteye.com/blog/486548) ← 点击链接查看参考博客\n\n> 1.Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值;\n\n> 2.Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。Serializable是内建支持的也就是直接implement即可，但Externalizable的实现类必须提供readExternal和writeExternal实现。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。\n\n> 3.正如Effectvie Java中提到的，序列化就如同另外一个构造函数，只不过是有由stream进行创建的。如果字段有一些条件限制的，特别是非可变的类定义了可变的字段会反序列化可能会有问题。可以在readObject方法中添加条件限制，也可以在readResolve中做。参考56条“保护性的编写readObject”和“提供一个readResolve方法”。\n\n> 4.当有非常复杂的对象需要提供deep clone时，可以考虑将其声明为可序列化，不过缺点也显而易见，性能开销。\n","slug":"Java序列化和transient关键字的理解与学习","published":1,"updated":"2019-05-14T08:19:57.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvxs005pcwnkiexx7q04","content":"<h4 id=\"Java序列化\"><a href=\"#Java序列化\" class=\"headerlink\" title=\"Java序列化\"></a>Java序列化</h4><p><img src=\"/blog/20190511/Java序列化和transient关键字的理解与学习/xuliehua.png\" alt=\"Java序列化过程\"></p>\n<blockquote>\n<p>在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h5 id=\"Java中如何进行序列化与反序列化\"><a href=\"#Java中如何进行序列化与反序列化\" class=\"headerlink\" title=\"Java中如何进行序列化与反序列化\"></a>Java中如何进行序列化与反序列化</h5><ul>\n<li><p>在Java中，对象一般是无法进行序列化与反序列化的。而使得对象能够被序列化的方式也很简单，即实现接口 <code>Serializable</code> 。如下代码即将对象序列化以及反序列化的过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestSerializable implements Serializable &#123;</span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\">    private Integer age;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    TestSerializable() &#123;</span><br><span class=\"line\">        age = 20;</span><br><span class=\"line\">        name = &quot;aachuanpu&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        TestSerializable test = new TestSerializable();</span><br><span class=\"line\">        File file = new File(&quot;e:/test.txt&quot;);</span><br><span class=\"line\">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class=\"line\">        out.writeObject(test);</span><br><span class=\"line\">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));</span><br><span class=\"line\">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class=\"line\">        System.out.println(newTest.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"serialVersionUID的作用\"><a href=\"#serialVersionUID的作用\" class=\"headerlink\" title=\"serialVersionUID的作用\"></a>serialVersionUID的作用</h5><ul>\n<li>serialVersionUID作为实现序列化接口的一个非必须非必须声明的静态常量经常不被开发者所重视，忘记声明。其实serialVersionUID的作用是为了保证序列化之前和之后的对象是同一对象。我们知道JVM判断对象是否相同是根据对象的类路径全限定名确定的，而虚拟机决定一个对象是否允许序列化和反序列化成这个类还取决于其serialVersionUID是否一致。不一致的话会导致<code>java.io.InvalidClassException的异常</code>，也可以不指定serialVersionUID，如果不指定的话java会根据class计算serialVersionUID。</li>\n<li>对于两个相同的类及拥有相同的serialVersionUID，如果两个类字段不一致也会序列化和反序列化成功。这时Java会在反序列化的时候忽略掉不一致的字段。</li>\n</ul>\n<h5 id=\"静态变量的序列化\"><a href=\"#静态变量的序列化\" class=\"headerlink\" title=\"静态变量的序列化\"></a>静态变量的序列化</h5><ul>\n<li><p>在序列化的时候，静态变量能够被序列化成功吗？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestSerializable implements Serializable &#123;</span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\">    public static String staticName;</span><br><span class=\"line\">    private Integer age;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    TestSerializable() &#123;</span><br><span class=\"line\">        age = 20;</span><br><span class=\"line\">        name = &quot;aachuanpu&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        TestSerializable test = new TestSerializable();</span><br><span class=\"line\">        TestSerializable.staticName = &quot;name11111&quot;;</span><br><span class=\"line\">        File file = new File(&quot;e:/test.txt&quot;);</span><br><span class=\"line\">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class=\"line\">        out.writeObject(test);</span><br><span class=\"line\">        TestSerializable.staticName = &quot;name222&quot;;</span><br><span class=\"line\">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));</span><br><span class=\"line\">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class=\"line\">        System.out.println(newTest.name);</span><br><span class=\"line\">        System.out.println(TestSerializable.staticName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以上代码会输出什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aachuanpu</span><br><span class=\"line\">name222</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如上所见：将对象序列化之后，修改静态变量的值，再将对象反序列化，输出的静态变量的值是修改之后的。即序列化保存的是对象的状态，静态变量属于类，因此序列化并不保存静态变量。</p>\n</li>\n</ul>\n<h5 id=\"transient关键字与自定义序列化\"><a href=\"#transient关键字与自定义序列化\" class=\"headerlink\" title=\"transient关键字与自定义序列化\"></a>transient关键字与自定义序列化</h5><ul>\n<li><p>对象的序列化是将对象中的数据写入本地文件或者用于网络传输的过程，但是很多时候会有一些数据无需进行序列化保存起来或者传输出去。我们可以使用<code>transient</code>关键字修饰成员变量。那么在Java序列化的时候就<strong>不会使用Java本身的序列化方式对其进行序列化</strong>。但是我们依然可以自定义自己的序列化行为对其进行序列化！</p>\n<p><strong>自定义序列化：</strong> 定义自己的<code>writeObject</code>和<code>readObject</code>方法</p>\n</li>\n<li><p>对于使用transient修饰的成员变量，可以编写<code>writeObject</code>和<code>readObject</code>方法实现对于该成员变量(不仅仅只是针对该成员变量)的自定义序列化。在编写<code>writeObject</code>和<code>readObject</code>方法的时候需要注意的地方在于：这俩方法没有在Object中定义，也没有在<code>Serializable</code>接口中声明，JVM是如何调用到这俩方法的呢？答案是通过反射，去根据方法名和参数寻找到相应的方法，找到之后会被ObjectOutputStream调用，没有这俩方法就调用默认的序列化呗。还有就是因为ObjectOutputStream使用getPrivateMethod，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。</p>\n</li>\n<li><p>通过这种方法，我们实现自己的序列化与反序列化可以实现很多场景下的需求。比如网络传输的时候对于特殊字段进行加密等等。</p>\n</li>\n<li><p>如下，你会发现我在这俩方法中调用了defaultWriteObject()和defaultReadObject()用于处理未被transient修饰的成员变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestSerializable implements Serializable &#123;</span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\">    public static String staticName;</span><br><span class=\"line\">    private Integer age;</span><br><span class=\"line\">    private transient String name;</span><br><span class=\"line\">    TestSerializable() &#123;</span><br><span class=\"line\">        age = 20;</span><br><span class=\"line\">        name = &quot;aachuanpu&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        TestSerializable test = new TestSerializable();</span><br><span class=\"line\">        TestSerializable.staticName = &quot;name11111&quot;;</span><br><span class=\"line\">        File file = new File(&quot;e:/test.txt&quot;);</span><br><span class=\"line\">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class=\"line\">        out.writeObject(test);</span><br><span class=\"line\">        TestSerializable.staticName = &quot;name222&quot;;</span><br><span class=\"line\">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));</span><br><span class=\"line\">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class=\"line\">        System.out.println(newTest.name);</span><br><span class=\"line\">        System.out.println(TestSerializable.staticName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void writeObject(ObjectOutputStream oos) throws IOException &#123;</span><br><span class=\"line\">        oos.defaultWriteObject();</span><br><span class=\"line\">        name = &quot;自定义名称&quot;;</span><br><span class=\"line\">        oos.writeObject(name);</span><br><span class=\"line\">        System.out.println(&quot;调用writeObject&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        ois.defaultReadObject();</span><br><span class=\"line\">        String name = (String) ois.readObject();</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        System.out.println(&quot;读出的name=&quot; + name);</span><br><span class=\"line\">        System.out.println(&quot;调用readObject&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">调用writeObject</span><br><span class=\"line\">读出的name=自定义名称</span><br><span class=\"line\">调用readObject</span><br><span class=\"line\">自定义名称</span><br><span class=\"line\">name222</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"父类的序列化\"><a href=\"#父类的序列化\" class=\"headerlink\" title=\"父类的序列化\"></a>父类的序列化</h5><ul>\n<li>一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取 父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都 是默认声明的值。</li>\n</ul>\n<h5 id=\"常问：ArrayList中数组使用transient修饰为何还能被序列化\"><a href=\"#常问：ArrayList中数组使用transient修饰为何还能被序列化\" class=\"headerlink\" title=\"常问：ArrayList中数组使用transient修饰为何还能被序列化\"></a>常问：ArrayList中数组使用transient修饰为何还能被序列化</h5><p>  <strong>ArrayList源码：</strong><br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class=\"line\"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class=\"line\"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class=\"line\"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class=\"line\"> */</span><br><span class=\"line\">transient Object[] elementData; // non-private to simplify nested class access</span><br></pre></td></tr></table></figure></p>\n<p>  transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。但是ArrayList又是可序行化的类，elementData是ArrayList具体存放元素的成员，用transient来修饰elementData，需要实现自己的序列化方式去处理。即对于数组中多余的空间不去进行序列化。如下：<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span><br><span class=\"line\"> * is, serialize it).</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span><br><span class=\"line\"> *             instance is emitted (int), followed by all of its elements</span><br><span class=\"line\"> *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class=\"line\">    throws java.io.IOException&#123;</span><br><span class=\"line\">    // Write out element count, and any hidden stuff</span><br><span class=\"line\">    int expectedModCount = modCount;</span><br><span class=\"line\">    s.defaultWriteObject();</span><br><span class=\"line\"></span><br><span class=\"line\">    // Write out size as capacity for behavioural compatibility with clone()</span><br><span class=\"line\">    s.writeInt(size);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Write out all elements in the proper order.</span><br><span class=\"line\">    for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">        s.writeObject(elementData[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (modCount != expectedModCount) &#123;</span><br><span class=\"line\">        throw new ConcurrentModificationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span><br><span class=\"line\"> * deserialize it).</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void readObject(java.io.ObjectInputStream s)</span><br><span class=\"line\">    throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">    elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Read in size, and any hidden stuff</span><br><span class=\"line\">    s.defaultReadObject();</span><br><span class=\"line\"></span><br><span class=\"line\">    // Read in capacity</span><br><span class=\"line\">    s.readInt(); // ignored</span><br><span class=\"line\"></span><br><span class=\"line\">    if (size &gt; 0) &#123;</span><br><span class=\"line\">        // be like clone(), allocate array based upon size not capacity</span><br><span class=\"line\">        ensureCapacityInternal(size);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = elementData;</span><br><span class=\"line\">        // Read in all elements in the proper order.</span><br><span class=\"line\">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">            a[i] = s.readObject();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。</strong></p>\n<h5 id=\"其余补充\"><a href=\"#其余补充\" class=\"headerlink\" title=\"其余补充\"></a>其余补充</h5><p><a href=\"https://bluepopopo.iteye.com/blog/486548\" target=\"_blank\" rel=\"noopener\">来自文章</a> ← 点击链接查看参考博客</p>\n<blockquote>\n<p>1.Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值;</p>\n</blockquote>\n<blockquote>\n<p>2.Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。Serializable是内建支持的也就是直接implement即可，但Externalizable的实现类必须提供readExternal和writeExternal实现。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。</p>\n</blockquote>\n<blockquote>\n<p>3.正如Effectvie Java中提到的，序列化就如同另外一个构造函数，只不过是有由stream进行创建的。如果字段有一些条件限制的，特别是非可变的类定义了可变的字段会反序列化可能会有问题。可以在readObject方法中添加条件限制，也可以在readResolve中做。参考56条“保护性的编写readObject”和“提供一个readResolve方法”。</p>\n</blockquote>\n<blockquote>\n<p>4.当有非常复杂的对象需要提供deep clone时，可以考虑将其声明为可序列化，不过缺点也显而易见，性能开销。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h4 id=\"Java序列化\"><a href=\"#Java序列化\" class=\"headerlink\" title=\"Java序列化\"></a>Java序列化</h4><p><img src=\"/blog/20190511/Java序列化和transient关键字的理解与学习/xuliehua.png\" alt=\"Java序列化过程\"></p>\n<blockquote>\n<p>在我们平时开发中，经常会遇到将对象转成可传输的字节流或者保存在某些文件中去使用的场景。这种将对象转成字节序列的过程称之为序列化。反之，将字节序列转成对象的过程我们称之为反序列化。序列化是保存与传输对象相关数据的一种方式，并不是保存类信息的一种方式。</p>\n</blockquote>","more":"<h5 id=\"Java中如何进行序列化与反序列化\"><a href=\"#Java中如何进行序列化与反序列化\" class=\"headerlink\" title=\"Java中如何进行序列化与反序列化\"></a>Java中如何进行序列化与反序列化</h5><ul>\n<li><p>在Java中，对象一般是无法进行序列化与反序列化的。而使得对象能够被序列化的方式也很简单，即实现接口 <code>Serializable</code> 。如下代码即将对象序列化以及反序列化的过程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestSerializable implements Serializable &#123;</span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\">    private Integer age;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    TestSerializable() &#123;</span><br><span class=\"line\">        age = 20;</span><br><span class=\"line\">        name = &quot;aachuanpu&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        TestSerializable test = new TestSerializable();</span><br><span class=\"line\">        File file = new File(&quot;e:/test.txt&quot;);</span><br><span class=\"line\">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class=\"line\">        out.writeObject(test);</span><br><span class=\"line\">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));</span><br><span class=\"line\">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class=\"line\">        System.out.println(newTest.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"serialVersionUID的作用\"><a href=\"#serialVersionUID的作用\" class=\"headerlink\" title=\"serialVersionUID的作用\"></a>serialVersionUID的作用</h5><ul>\n<li>serialVersionUID作为实现序列化接口的一个非必须非必须声明的静态常量经常不被开发者所重视，忘记声明。其实serialVersionUID的作用是为了保证序列化之前和之后的对象是同一对象。我们知道JVM判断对象是否相同是根据对象的类路径全限定名确定的，而虚拟机决定一个对象是否允许序列化和反序列化成这个类还取决于其serialVersionUID是否一致。不一致的话会导致<code>java.io.InvalidClassException的异常</code>，也可以不指定serialVersionUID，如果不指定的话java会根据class计算serialVersionUID。</li>\n<li>对于两个相同的类及拥有相同的serialVersionUID，如果两个类字段不一致也会序列化和反序列化成功。这时Java会在反序列化的时候忽略掉不一致的字段。</li>\n</ul>\n<h5 id=\"静态变量的序列化\"><a href=\"#静态变量的序列化\" class=\"headerlink\" title=\"静态变量的序列化\"></a>静态变量的序列化</h5><ul>\n<li><p>在序列化的时候，静态变量能够被序列化成功吗？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestSerializable implements Serializable &#123;</span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\">    public static String staticName;</span><br><span class=\"line\">    private Integer age;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    TestSerializable() &#123;</span><br><span class=\"line\">        age = 20;</span><br><span class=\"line\">        name = &quot;aachuanpu&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        TestSerializable test = new TestSerializable();</span><br><span class=\"line\">        TestSerializable.staticName = &quot;name11111&quot;;</span><br><span class=\"line\">        File file = new File(&quot;e:/test.txt&quot;);</span><br><span class=\"line\">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class=\"line\">        out.writeObject(test);</span><br><span class=\"line\">        TestSerializable.staticName = &quot;name222&quot;;</span><br><span class=\"line\">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));</span><br><span class=\"line\">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class=\"line\">        System.out.println(newTest.name);</span><br><span class=\"line\">        System.out.println(TestSerializable.staticName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以上代码会输出什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aachuanpu</span><br><span class=\"line\">name222</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如上所见：将对象序列化之后，修改静态变量的值，再将对象反序列化，输出的静态变量的值是修改之后的。即序列化保存的是对象的状态，静态变量属于类，因此序列化并不保存静态变量。</p>\n</li>\n</ul>\n<h5 id=\"transient关键字与自定义序列化\"><a href=\"#transient关键字与自定义序列化\" class=\"headerlink\" title=\"transient关键字与自定义序列化\"></a>transient关键字与自定义序列化</h5><ul>\n<li><p>对象的序列化是将对象中的数据写入本地文件或者用于网络传输的过程，但是很多时候会有一些数据无需进行序列化保存起来或者传输出去。我们可以使用<code>transient</code>关键字修饰成员变量。那么在Java序列化的时候就<strong>不会使用Java本身的序列化方式对其进行序列化</strong>。但是我们依然可以自定义自己的序列化行为对其进行序列化！</p>\n<p><strong>自定义序列化：</strong> 定义自己的<code>writeObject</code>和<code>readObject</code>方法</p>\n</li>\n<li><p>对于使用transient修饰的成员变量，可以编写<code>writeObject</code>和<code>readObject</code>方法实现对于该成员变量(不仅仅只是针对该成员变量)的自定义序列化。在编写<code>writeObject</code>和<code>readObject</code>方法的时候需要注意的地方在于：这俩方法没有在Object中定义，也没有在<code>Serializable</code>接口中声明，JVM是如何调用到这俩方法的呢？答案是通过反射，去根据方法名和参数寻找到相应的方法，找到之后会被ObjectOutputStream调用，没有这俩方法就调用默认的序列化呗。还有就是因为ObjectOutputStream使用getPrivateMethod，所以这些方法不得不被声明为priate以至于供ObjectOutputStream来使用。</p>\n</li>\n<li><p>通过这种方法，我们实现自己的序列化与反序列化可以实现很多场景下的需求。比如网络传输的时候对于特殊字段进行加密等等。</p>\n</li>\n<li><p>如下，你会发现我在这俩方法中调用了defaultWriteObject()和defaultReadObject()用于处理未被transient修饰的成员变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestSerializable implements Serializable &#123;</span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\">    public static String staticName;</span><br><span class=\"line\">    private Integer age;</span><br><span class=\"line\">    private transient String name;</span><br><span class=\"line\">    TestSerializable() &#123;</span><br><span class=\"line\">        age = 20;</span><br><span class=\"line\">        name = &quot;aachuanpu&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        TestSerializable test = new TestSerializable();</span><br><span class=\"line\">        TestSerializable.staticName = &quot;name11111&quot;;</span><br><span class=\"line\">        File file = new File(&quot;e:/test.txt&quot;);</span><br><span class=\"line\">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class=\"line\">        out.writeObject(test);</span><br><span class=\"line\">        TestSerializable.staticName = &quot;name222&quot;;</span><br><span class=\"line\">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));</span><br><span class=\"line\">        TestSerializable newTest = (TestSerializable) in.readObject();</span><br><span class=\"line\">        System.out.println(newTest.name);</span><br><span class=\"line\">        System.out.println(TestSerializable.staticName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void writeObject(ObjectOutputStream oos) throws IOException &#123;</span><br><span class=\"line\">        oos.defaultWriteObject();</span><br><span class=\"line\">        name = &quot;自定义名称&quot;;</span><br><span class=\"line\">        oos.writeObject(name);</span><br><span class=\"line\">        System.out.println(&quot;调用writeObject&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">        ois.defaultReadObject();</span><br><span class=\"line\">        String name = (String) ois.readObject();</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        System.out.println(&quot;读出的name=&quot; + name);</span><br><span class=\"line\">        System.out.println(&quot;调用readObject&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">调用writeObject</span><br><span class=\"line\">读出的name=自定义名称</span><br><span class=\"line\">调用readObject</span><br><span class=\"line\">自定义名称</span><br><span class=\"line\">name222</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"父类的序列化\"><a href=\"#父类的序列化\" class=\"headerlink\" title=\"父类的序列化\"></a>父类的序列化</h5><ul>\n<li>一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。 在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取 父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都 是默认声明的值。</li>\n</ul>\n<h5 id=\"常问：ArrayList中数组使用transient修饰为何还能被序列化\"><a href=\"#常问：ArrayList中数组使用transient修饰为何还能被序列化\" class=\"headerlink\" title=\"常问：ArrayList中数组使用transient修饰为何还能被序列化\"></a>常问：ArrayList中数组使用transient修饰为何还能被序列化</h5><p>  <strong>ArrayList源码：</strong><br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class=\"line\"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class=\"line\"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class=\"line\"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class=\"line\"> */</span><br><span class=\"line\">transient Object[] elementData; // non-private to simplify nested class access</span><br></pre></td></tr></table></figure></p>\n<p>  transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。但是ArrayList又是可序行化的类，elementData是ArrayList具体存放元素的成员，用transient来修饰elementData，需要实现自己的序列化方式去处理。即对于数组中多余的空间不去进行序列化。如下：<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span><br><span class=\"line\"> * is, serialize it).</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span><br><span class=\"line\"> *             instance is emitted (int), followed by all of its elements</span><br><span class=\"line\"> *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class=\"line\">    throws java.io.IOException&#123;</span><br><span class=\"line\">    // Write out element count, and any hidden stuff</span><br><span class=\"line\">    int expectedModCount = modCount;</span><br><span class=\"line\">    s.defaultWriteObject();</span><br><span class=\"line\"></span><br><span class=\"line\">    // Write out size as capacity for behavioural compatibility with clone()</span><br><span class=\"line\">    s.writeInt(size);</span><br><span class=\"line\"></span><br><span class=\"line\">    // Write out all elements in the proper order.</span><br><span class=\"line\">    for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">        s.writeObject(elementData[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (modCount != expectedModCount) &#123;</span><br><span class=\"line\">        throw new ConcurrentModificationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span><br><span class=\"line\"> * deserialize it).</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void readObject(java.io.ObjectInputStream s)</span><br><span class=\"line\">    throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class=\"line\">    elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Read in size, and any hidden stuff</span><br><span class=\"line\">    s.defaultReadObject();</span><br><span class=\"line\"></span><br><span class=\"line\">    // Read in capacity</span><br><span class=\"line\">    s.readInt(); // ignored</span><br><span class=\"line\"></span><br><span class=\"line\">    if (size &gt; 0) &#123;</span><br><span class=\"line\">        // be like clone(), allocate array based upon size not capacity</span><br><span class=\"line\">        ensureCapacityInternal(size);</span><br><span class=\"line\"></span><br><span class=\"line\">        Object[] a = elementData;</span><br><span class=\"line\">        // Read in all elements in the proper order.</span><br><span class=\"line\">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class=\"line\">            a[i] = s.readObject();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  <strong>elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。</strong></p>\n<h5 id=\"其余补充\"><a href=\"#其余补充\" class=\"headerlink\" title=\"其余补充\"></a>其余补充</h5><p><a href=\"https://bluepopopo.iteye.com/blog/486548\" target=\"_blank\" rel=\"noopener\">来自文章</a> ← 点击链接查看参考博客</p>\n<blockquote>\n<p>1.Write的顺序和read的顺序需要对应，譬如有多个字段都用wirteInt一一写入流中，那么readInt需要按照顺序将其赋值;</p>\n</blockquote>\n<blockquote>\n<p>2.Externalizable,该接口是继承于Serializable ,所以实现序列化有两种方式。区别在于Externalizable多声明了两个方法readExternal和writeExternal，子类必须实现二者。Serializable是内建支持的也就是直接implement即可，但Externalizable的实现类必须提供readExternal和writeExternal实现。对于Serializable来说，Java自己建立对象图和字段进行对象序列化，可能会占用更多空间。而Externalizable则完全需要程序员自己控制如何写/读，麻烦但可以有效控制序列化的存储的内容。</p>\n</blockquote>\n<blockquote>\n<p>3.正如Effectvie Java中提到的，序列化就如同另外一个构造函数，只不过是有由stream进行创建的。如果字段有一些条件限制的，特别是非可变的类定义了可变的字段会反序列化可能会有问题。可以在readObject方法中添加条件限制，也可以在readResolve中做。参考56条“保护性的编写readObject”和“提供一个readResolve方法”。</p>\n</blockquote>\n<blockquote>\n<p>4.当有非常复杂的对象需要提供deep clone时，可以考虑将其声明为可序列化，不过缺点也显而易见，性能开销。</p>\n</blockquote>"},{"title":"Layui结合freemarker+springboot进行前端数据表格字典转义","date":"2019-03-16T11:51:53.000Z","_content":"\n### 前言\n在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。\n那么在layui的数据表格中，我们要展示这样的数据，写法可以是：\n```\ntemplet: function (d) {\n  if(d.status === 1){\n      return \"启用\";\n  } else if(d.status === 0){\n      return \"停用\";\n  }\n}\n```\n但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。\n在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。\n最后我们的写法就会简化成：`<@th type=\"template\" nid=\"basics_sys_status\" objName=\"status\"></@th>`，接下来看看如何在springboot中配置使用吧。\n<!-- more -->\n### freemarker自定义标签介绍及使用\n`TemplateDirectiveModel`接口是freemarker自定标签或者自定义指令的核心处理接口。当模板页面遇到用户自定义的标签指令时，`execute()`方法会被执行。`execute()`方法如下。\n```\npublic void execute(\n  Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body\n) throws TemplateException, IOException;\n```\n我们在使用freemarker自定义标签的时候需要实现该接口并且重写execute方法。\n#### `execute()`方法参数解释\n- *Environment env*：系统环境变量，通常用它来输出相关内容，如`Writer out = env.getOut();`\n- *Map params*：自定义标签传过来的对象，就是从页面上获取的参数，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等。\n  在本例使用时，我们会将map转成我们自己的对象进行数据保存。\n- *TemplateModel[] loopVars*：循环替代变量\n- *TemplateDirectiveBody body*：标签中嵌套的内容，如`<@tag>body</@tag>`，就是这个body\n\n#### 开始使用\n\n###### 定义接收页面参数的对象\n```\n@Getter\n@Setter\npublic class TableThTag {\n    /**\n     * 对象属性名【需要进行对象属性获取】\n     */\n    private String objName;\n    /**\n     * 字典标识\n     */\n    private String nid;\n\n    /**\n     * 类型\n     */\n    private String type;\n}\n```\n###### 实现`TemplateDirectiveModel`接口并重写`execute`方法\n```\n@Component\n@org.springframework.context.annotation.Configuration\npublic class TableThDirective implements TemplateDirectiveModel {\n\n    Logger logger = LoggerFactory.getLogger(getClass().getName());\n\n    /**\n     * FreeMarker自定义指令\n     */\n    @Override\n    public void execute(Environment environment, Map map, TemplateModel[] templateModels,\n                        TemplateDirectiveBody templateDirectiveBody) throws TemplateException, IOException {\n        TableThTag tableThTag = new TableThTag();\n        //校验参数\n        try {\n            //  用来将一些 key-value 的值（例如 hashmap）映射到 bean 中的属性\n            BeanUtils.populate(tableThTag, map);\n            if (StringUtils.isEmpty(tableThTag.getNid()) || StringUtils.isEmpty(tableThTag.getType())) {\n                throw new IllegalArgumentException(\"nid,type不能为空\");\n            }\n        } catch (Exception e) {\n            logger.error(\"数据转化异常\", e);\n        }\n        StringBuilder html = new StringBuilder();\n        // 根据类型创建不同的HTML生成器\n        ThFormatterInterface thFormatterInterface = ThFormatterFactory.createThFormatter(tableThTag.getType());\n        if (thFormatterInterface != null) {\n            String dictHtml = thFormatterInterface.buildFormatterHtml(tableThTag.getNid(), tableThTag.getFieldName());\n            html.append(dictHtml);\n        }\n        // 执行真正指令的执行部分:\n        Writer out = environment.getOut();\n        out.write(html.toString());\n        if (templateDirectiveBody != null) {\n            templateDirectiveBody.render(environment.getOut());\n        }\n\n    }\n\n    public static BeansWrapper getBeansWrapper() {\n        BeansWrapper beansWrapper =\n                new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build();\n        return beansWrapper;\n    }\n\n}\n```\n大家可以看到，在这个方法中，我将页面上的参数转为`TableThTag `对象。然后再根据前端页面不同的type类型对应\n实现了`ThFormatterInterface `的工厂对象，创建不同的html生成器。（这里考虑到扩展性，可能以后不光创建数据表格会用的到，比如下拉框什么的，也可以使用这种方式创建，所以在这里使用抽象工厂依据类型动态创建。）\n下面就是创建html的具体工厂以及实现方法。\n###### `ThFormatterInterface `抽象工厂创建html生成器\n接口\n```\npublic interface ThFormatterInterface {\n    /**\n     * 构造生成枚举html\n     * @param nid\n     * @return\n     */\n    String buildFormatterHtml(String nid, String fieldName);\n}\n```\n工厂\n```\npublic class ThFormatterFactory {\n\n    private static Logger logger = LoggerFactory.getLogger(ThFormatterFactory.class);\n\n    public static ThFormatterInterface createThFormatter(String type){\n        if(StringUtils.isEmpty(type)){\n            return  new ThFormatterTemplate();\n        }\n        // 文件名 如果type传template 就需要有一个名为ThFormatterTemplate的文件\n        // 并且实现了ThFormatterInterface以及重写生成html的方法\n        String fileName = \"ThFormatter\" + StringUtil.firstCharUpperCase(type);\n        //类路径 通过反射去创建实现类\n        String className = \"com.module.freemarker.impl.\"+fileName;\n        //生成表头格式实现类\n        ThFormatterInterface thFormatterInterface = null;\n        try {\n            thFormatterInterface =(ThFormatterInterface) Class.forName(className).newInstance();\n        } catch (Exception e) {\n            logger.error(e.getMessage(),e);\n        }\n        return thFormatterInterface;\n    }\n}\n```\n实现类\n```\npublic class ThFormatterTemplate implements ThFormatterInterface {\n\n    @Override\n    public String buildFormatterHtml(String nid, String fieldName) {\n        Assert.notEMPTY(nid, \"nid不能为空\");\n        Assert.notEMPTY(fieldName, \"objName不能为空\");\n        SysDictService sysDictService = SpringContextHolder.getBean(SysDictService.class);\n        // 通过nid查询字典类 这里不需要进行照抄 每个人都会有自己的实现方法\n        List<SysDictBO> sysDictModelList = sysDictService.findByPartnerNid(nid);\n        StringBuilder dictHtml = new StringBuilder();\n        // 反正目的就是根据字典类生成对应的html就行了 需要生成的格式对照template原本应该有的写法就行了\n        dictHtml.append(\"templet: function(d){ \");\n        for (SysDictBO sysDict : sysDictModelList) {\n            dictHtml.append(\"if(d.\" + fieldName + \" == '\" + sysDict.getValue() + \"'){ return '\" + sysDict.getName() + \"';}\");\n        }\n        dictHtml.append(\"}\");\n\n        return dictHtml.toString();\n    }\n}\n```\n###### 最后将自定义标签注入到freemarker标签中去\n```\n@org.springframework.context.annotation.Configuration\npublic class FreemarkerConfig {\n\n    @Resource\n    private Configuration configuration;\n    @Resource\n    private TableThDirective tableThDirective;\n\n    @PostConstruct\n    public void setSharedVariable(){\n        configuration.setSharedVariable(\"th\",tableThDirective);\n        configuration.setSharedVariable(\"shiro\",new ShiroTags());\n    }\n\n}\n```\n---\n这样就大功告成了。\n\n在页面上进行使用吧：`<@th type=\"template\" nid=\"basics_sys_status\" objName=\"status\"></@th>`\n\n以后进行扩展什么的也方便，比如生成下拉框：`<@th type=\"select\" nid=\"basics_sys_status\" objName=\"status\"></@th>`这样然后自动生成html的时候查出来所有的字典，根据类型生成多个<option>出来就行了。\n","source":"_posts/layui开发中结合freemarker展示字典数据.md","raw":"---\ntitle: layui结合freemarker+springboot进行前端数据表格字典转义\ndate: 2019-03-16 19:51:53\ncategories: [springboot]\ntags: [开发日记,springboot,freemarker,工厂模式,layui]\n---\n\n### 前言\n在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。\n那么在layui的数据表格中，我们要展示这样的数据，写法可以是：\n```\ntemplet: function (d) {\n  if(d.status === 1){\n      return \"启用\";\n  } else if(d.status === 0){\n      return \"停用\";\n  }\n}\n```\n但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。\n在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。\n最后我们的写法就会简化成：`<@th type=\"template\" nid=\"basics_sys_status\" objName=\"status\"></@th>`，接下来看看如何在springboot中配置使用吧。\n<!-- more -->\n### freemarker自定义标签介绍及使用\n`TemplateDirectiveModel`接口是freemarker自定标签或者自定义指令的核心处理接口。当模板页面遇到用户自定义的标签指令时，`execute()`方法会被执行。`execute()`方法如下。\n```\npublic void execute(\n  Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body\n) throws TemplateException, IOException;\n```\n我们在使用freemarker自定义标签的时候需要实现该接口并且重写execute方法。\n#### `execute()`方法参数解释\n- *Environment env*：系统环境变量，通常用它来输出相关内容，如`Writer out = env.getOut();`\n- *Map params*：自定义标签传过来的对象，就是从页面上获取的参数，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等。\n  在本例使用时，我们会将map转成我们自己的对象进行数据保存。\n- *TemplateModel[] loopVars*：循环替代变量\n- *TemplateDirectiveBody body*：标签中嵌套的内容，如`<@tag>body</@tag>`，就是这个body\n\n#### 开始使用\n\n###### 定义接收页面参数的对象\n```\n@Getter\n@Setter\npublic class TableThTag {\n    /**\n     * 对象属性名【需要进行对象属性获取】\n     */\n    private String objName;\n    /**\n     * 字典标识\n     */\n    private String nid;\n\n    /**\n     * 类型\n     */\n    private String type;\n}\n```\n###### 实现`TemplateDirectiveModel`接口并重写`execute`方法\n```\n@Component\n@org.springframework.context.annotation.Configuration\npublic class TableThDirective implements TemplateDirectiveModel {\n\n    Logger logger = LoggerFactory.getLogger(getClass().getName());\n\n    /**\n     * FreeMarker自定义指令\n     */\n    @Override\n    public void execute(Environment environment, Map map, TemplateModel[] templateModels,\n                        TemplateDirectiveBody templateDirectiveBody) throws TemplateException, IOException {\n        TableThTag tableThTag = new TableThTag();\n        //校验参数\n        try {\n            //  用来将一些 key-value 的值（例如 hashmap）映射到 bean 中的属性\n            BeanUtils.populate(tableThTag, map);\n            if (StringUtils.isEmpty(tableThTag.getNid()) || StringUtils.isEmpty(tableThTag.getType())) {\n                throw new IllegalArgumentException(\"nid,type不能为空\");\n            }\n        } catch (Exception e) {\n            logger.error(\"数据转化异常\", e);\n        }\n        StringBuilder html = new StringBuilder();\n        // 根据类型创建不同的HTML生成器\n        ThFormatterInterface thFormatterInterface = ThFormatterFactory.createThFormatter(tableThTag.getType());\n        if (thFormatterInterface != null) {\n            String dictHtml = thFormatterInterface.buildFormatterHtml(tableThTag.getNid(), tableThTag.getFieldName());\n            html.append(dictHtml);\n        }\n        // 执行真正指令的执行部分:\n        Writer out = environment.getOut();\n        out.write(html.toString());\n        if (templateDirectiveBody != null) {\n            templateDirectiveBody.render(environment.getOut());\n        }\n\n    }\n\n    public static BeansWrapper getBeansWrapper() {\n        BeansWrapper beansWrapper =\n                new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build();\n        return beansWrapper;\n    }\n\n}\n```\n大家可以看到，在这个方法中，我将页面上的参数转为`TableThTag `对象。然后再根据前端页面不同的type类型对应\n实现了`ThFormatterInterface `的工厂对象，创建不同的html生成器。（这里考虑到扩展性，可能以后不光创建数据表格会用的到，比如下拉框什么的，也可以使用这种方式创建，所以在这里使用抽象工厂依据类型动态创建。）\n下面就是创建html的具体工厂以及实现方法。\n###### `ThFormatterInterface `抽象工厂创建html生成器\n接口\n```\npublic interface ThFormatterInterface {\n    /**\n     * 构造生成枚举html\n     * @param nid\n     * @return\n     */\n    String buildFormatterHtml(String nid, String fieldName);\n}\n```\n工厂\n```\npublic class ThFormatterFactory {\n\n    private static Logger logger = LoggerFactory.getLogger(ThFormatterFactory.class);\n\n    public static ThFormatterInterface createThFormatter(String type){\n        if(StringUtils.isEmpty(type)){\n            return  new ThFormatterTemplate();\n        }\n        // 文件名 如果type传template 就需要有一个名为ThFormatterTemplate的文件\n        // 并且实现了ThFormatterInterface以及重写生成html的方法\n        String fileName = \"ThFormatter\" + StringUtil.firstCharUpperCase(type);\n        //类路径 通过反射去创建实现类\n        String className = \"com.module.freemarker.impl.\"+fileName;\n        //生成表头格式实现类\n        ThFormatterInterface thFormatterInterface = null;\n        try {\n            thFormatterInterface =(ThFormatterInterface) Class.forName(className).newInstance();\n        } catch (Exception e) {\n            logger.error(e.getMessage(),e);\n        }\n        return thFormatterInterface;\n    }\n}\n```\n实现类\n```\npublic class ThFormatterTemplate implements ThFormatterInterface {\n\n    @Override\n    public String buildFormatterHtml(String nid, String fieldName) {\n        Assert.notEMPTY(nid, \"nid不能为空\");\n        Assert.notEMPTY(fieldName, \"objName不能为空\");\n        SysDictService sysDictService = SpringContextHolder.getBean(SysDictService.class);\n        // 通过nid查询字典类 这里不需要进行照抄 每个人都会有自己的实现方法\n        List<SysDictBO> sysDictModelList = sysDictService.findByPartnerNid(nid);\n        StringBuilder dictHtml = new StringBuilder();\n        // 反正目的就是根据字典类生成对应的html就行了 需要生成的格式对照template原本应该有的写法就行了\n        dictHtml.append(\"templet: function(d){ \");\n        for (SysDictBO sysDict : sysDictModelList) {\n            dictHtml.append(\"if(d.\" + fieldName + \" == '\" + sysDict.getValue() + \"'){ return '\" + sysDict.getName() + \"';}\");\n        }\n        dictHtml.append(\"}\");\n\n        return dictHtml.toString();\n    }\n}\n```\n###### 最后将自定义标签注入到freemarker标签中去\n```\n@org.springframework.context.annotation.Configuration\npublic class FreemarkerConfig {\n\n    @Resource\n    private Configuration configuration;\n    @Resource\n    private TableThDirective tableThDirective;\n\n    @PostConstruct\n    public void setSharedVariable(){\n        configuration.setSharedVariable(\"th\",tableThDirective);\n        configuration.setSharedVariable(\"shiro\",new ShiroTags());\n    }\n\n}\n```\n---\n这样就大功告成了。\n\n在页面上进行使用吧：`<@th type=\"template\" nid=\"basics_sys_status\" objName=\"status\"></@th>`\n\n以后进行扩展什么的也方便，比如生成下拉框：`<@th type=\"select\" nid=\"basics_sys_status\" objName=\"status\"></@th>`这样然后自动生成html的时候查出来所有的字典，根据类型生成多个<option>出来就行了。\n","slug":"layui开发中结合freemarker展示字典数据","published":1,"updated":"2019-05-07T09:48:29.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvxt005rcwnk03kete0s","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。<br>那么在layui的数据表格中，我们要展示这样的数据，写法可以是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">templet: function (d) &#123;</span><br><span class=\"line\">  if(d.status === 1)&#123;</span><br><span class=\"line\">      return &quot;启用&quot;;</span><br><span class=\"line\">  &#125; else if(d.status === 0)&#123;</span><br><span class=\"line\">      return &quot;停用&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。<br>在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。<br>最后我们的写法就会简化成：<code>&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code>，接下来看看如何在springboot中配置使用吧。<br><a id=\"more\"></a></p>\n<h3 id=\"freemarker自定义标签介绍及使用\"><a href=\"#freemarker自定义标签介绍及使用\" class=\"headerlink\" title=\"freemarker自定义标签介绍及使用\"></a>freemarker自定义标签介绍及使用</h3><p><code>TemplateDirectiveModel</code>接口是freemarker自定标签或者自定义指令的核心处理接口。当模板页面遇到用户自定义的标签指令时，<code>execute()</code>方法会被执行。<code>execute()</code>方法如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void execute(</span><br><span class=\"line\">  Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body</span><br><span class=\"line\">) throws TemplateException, IOException;</span><br></pre></td></tr></table></figure></p>\n<p>我们在使用freemarker自定义标签的时候需要实现该接口并且重写execute方法。</p>\n<h4 id=\"execute-方法参数解释\"><a href=\"#execute-方法参数解释\" class=\"headerlink\" title=\"execute()方法参数解释\"></a><code>execute()</code>方法参数解释</h4><ul>\n<li><em>Environment env</em>：系统环境变量，通常用它来输出相关内容，如<code>Writer out = env.getOut();</code></li>\n<li><em>Map params</em>：自定义标签传过来的对象，就是从页面上获取的参数，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等。<br>在本例使用时，我们会将map转成我们自己的对象进行数据保存。</li>\n<li><em>TemplateModel[] loopVars</em>：循环替代变量</li>\n<li><em>TemplateDirectiveBody body</em>：标签中嵌套的内容，如<code>&lt;@tag&gt;body&lt;/@tag&gt;</code>，就是这个body</li>\n</ul>\n<h4 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h4><h6 id=\"定义接收页面参数的对象\"><a href=\"#定义接收页面参数的对象\" class=\"headerlink\" title=\"定义接收页面参数的对象\"></a>定义接收页面参数的对象</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Getter</span><br><span class=\"line\">@Setter</span><br><span class=\"line\">public class TableThTag &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 对象属性名【需要进行对象属性获取】</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String objName;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 字典标识</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String nid;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 类型</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String type;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"实现TemplateDirectiveModel接口并重写execute方法\"><a href=\"#实现TemplateDirectiveModel接口并重写execute方法\" class=\"headerlink\" title=\"实现TemplateDirectiveModel接口并重写execute方法\"></a>实现<code>TemplateDirectiveModel</code>接口并重写<code>execute</code>方法</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@org.springframework.context.annotation.Configuration</span><br><span class=\"line\">public class TableThDirective implements TemplateDirectiveModel &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * FreeMarker自定义指令</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void execute(Environment environment, Map map, TemplateModel[] templateModels,</span><br><span class=\"line\">                        TemplateDirectiveBody templateDirectiveBody) throws TemplateException, IOException &#123;</span><br><span class=\"line\">        TableThTag tableThTag = new TableThTag();</span><br><span class=\"line\">        //校验参数</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //  用来将一些 key-value 的值（例如 hashmap）映射到 bean 中的属性</span><br><span class=\"line\">            BeanUtils.populate(tableThTag, map);</span><br><span class=\"line\">            if (StringUtils.isEmpty(tableThTag.getNid()) || StringUtils.isEmpty(tableThTag.getType())) &#123;</span><br><span class=\"line\">                throw new IllegalArgumentException(&quot;nid,type不能为空&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            logger.error(&quot;数据转化异常&quot;, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder html = new StringBuilder();</span><br><span class=\"line\">        // 根据类型创建不同的HTML生成器</span><br><span class=\"line\">        ThFormatterInterface thFormatterInterface = ThFormatterFactory.createThFormatter(tableThTag.getType());</span><br><span class=\"line\">        if (thFormatterInterface != null) &#123;</span><br><span class=\"line\">            String dictHtml = thFormatterInterface.buildFormatterHtml(tableThTag.getNid(), tableThTag.getFieldName());</span><br><span class=\"line\">            html.append(dictHtml);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 执行真正指令的执行部分:</span><br><span class=\"line\">        Writer out = environment.getOut();</span><br><span class=\"line\">        out.write(html.toString());</span><br><span class=\"line\">        if (templateDirectiveBody != null) &#123;</span><br><span class=\"line\">            templateDirectiveBody.render(environment.getOut());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static BeansWrapper getBeansWrapper() &#123;</span><br><span class=\"line\">        BeansWrapper beansWrapper =</span><br><span class=\"line\">                new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build();</span><br><span class=\"line\">        return beansWrapper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家可以看到，在这个方法中，我将页面上的参数转为<code>TableThTag</code>对象。然后再根据前端页面不同的type类型对应<br>实现了<code>ThFormatterInterface</code>的工厂对象，创建不同的html生成器。（这里考虑到扩展性，可能以后不光创建数据表格会用的到，比如下拉框什么的，也可以使用这种方式创建，所以在这里使用抽象工厂依据类型动态创建。）<br>下面就是创建html的具体工厂以及实现方法。</p>\n<h6 id=\"ThFormatterInterface抽象工厂创建html生成器\"><a href=\"#ThFormatterInterface抽象工厂创建html生成器\" class=\"headerlink\" title=\"ThFormatterInterface抽象工厂创建html生成器\"></a><code>ThFormatterInterface</code>抽象工厂创建html生成器</h6><p>接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ThFormatterInterface &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 构造生成枚举html</span><br><span class=\"line\">     * @param nid</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    String buildFormatterHtml(String nid, String fieldName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工厂<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThFormatterFactory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Logger logger = LoggerFactory.getLogger(ThFormatterFactory.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static ThFormatterInterface createThFormatter(String type)&#123;</span><br><span class=\"line\">        if(StringUtils.isEmpty(type))&#123;</span><br><span class=\"line\">            return  new ThFormatterTemplate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 文件名 如果type传template 就需要有一个名为ThFormatterTemplate的文件</span><br><span class=\"line\">        // 并且实现了ThFormatterInterface以及重写生成html的方法</span><br><span class=\"line\">        String fileName = &quot;ThFormatter&quot; + StringUtil.firstCharUpperCase(type);</span><br><span class=\"line\">        //类路径 通过反射去创建实现类</span><br><span class=\"line\">        String className = &quot;com.module.freemarker.impl.&quot;+fileName;</span><br><span class=\"line\">        //生成表头格式实现类</span><br><span class=\"line\">        ThFormatterInterface thFormatterInterface = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            thFormatterInterface =(ThFormatterInterface) Class.forName(className).newInstance();</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            logger.error(e.getMessage(),e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return thFormatterInterface;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThFormatterTemplate implements ThFormatterInterface &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String buildFormatterHtml(String nid, String fieldName) &#123;</span><br><span class=\"line\">        Assert.notEMPTY(nid, &quot;nid不能为空&quot;);</span><br><span class=\"line\">        Assert.notEMPTY(fieldName, &quot;objName不能为空&quot;);</span><br><span class=\"line\">        SysDictService sysDictService = SpringContextHolder.getBean(SysDictService.class);</span><br><span class=\"line\">        // 通过nid查询字典类 这里不需要进行照抄 每个人都会有自己的实现方法</span><br><span class=\"line\">        List&lt;SysDictBO&gt; sysDictModelList = sysDictService.findByPartnerNid(nid);</span><br><span class=\"line\">        StringBuilder dictHtml = new StringBuilder();</span><br><span class=\"line\">        // 反正目的就是根据字典类生成对应的html就行了 需要生成的格式对照template原本应该有的写法就行了</span><br><span class=\"line\">        dictHtml.append(&quot;templet: function(d)&#123; &quot;);</span><br><span class=\"line\">        for (SysDictBO sysDict : sysDictModelList) &#123;</span><br><span class=\"line\">            dictHtml.append(&quot;if(d.&quot; + fieldName + &quot; == &apos;&quot; + sysDict.getValue() + &quot;&apos;)&#123; return &apos;&quot; + sysDict.getName() + &quot;&apos;;&#125;&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dictHtml.append(&quot;&#125;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        return dictHtml.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"最后将自定义标签注入到freemarker标签中去\"><a href=\"#最后将自定义标签注入到freemarker标签中去\" class=\"headerlink\" title=\"最后将自定义标签注入到freemarker标签中去\"></a>最后将自定义标签注入到freemarker标签中去</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@org.springframework.context.annotation.Configuration</span><br><span class=\"line\">public class FreemarkerConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private Configuration configuration;</span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private TableThDirective tableThDirective;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostConstruct</span><br><span class=\"line\">    public void setSharedVariable()&#123;</span><br><span class=\"line\">        configuration.setSharedVariable(&quot;th&quot;,tableThDirective);</span><br><span class=\"line\">        configuration.setSharedVariable(&quot;shiro&quot;,new ShiroTags());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>这样就大功告成了。</p>\n<p>在页面上进行使用吧：<code>&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code></p>\n<p>以后进行扩展什么的也方便，比如生成下拉框：<code>&lt;@th type=&quot;select&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code>这样然后自动生成html的时候查出来所有的字典，根据类型生成多个<option>出来就行了。</option></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。<br>那么在layui的数据表格中，我们要展示这样的数据，写法可以是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">templet: function (d) &#123;</span><br><span class=\"line\">  if(d.status === 1)&#123;</span><br><span class=\"line\">      return &quot;启用&quot;;</span><br><span class=\"line\">  &#125; else if(d.status === 0)&#123;</span><br><span class=\"line\">      return &quot;停用&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。<br>在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。<br>最后我们的写法就会简化成：<code>&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code>，接下来看看如何在springboot中配置使用吧。<br></p>","more":"<p></p>\n<h3 id=\"freemarker自定义标签介绍及使用\"><a href=\"#freemarker自定义标签介绍及使用\" class=\"headerlink\" title=\"freemarker自定义标签介绍及使用\"></a>freemarker自定义标签介绍及使用</h3><p><code>TemplateDirectiveModel</code>接口是freemarker自定标签或者自定义指令的核心处理接口。当模板页面遇到用户自定义的标签指令时，<code>execute()</code>方法会被执行。<code>execute()</code>方法如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void execute(</span><br><span class=\"line\">  Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body</span><br><span class=\"line\">) throws TemplateException, IOException;</span><br></pre></td></tr></table></figure></p>\n<p>我们在使用freemarker自定义标签的时候需要实现该接口并且重写execute方法。</p>\n<h4 id=\"execute-方法参数解释\"><a href=\"#execute-方法参数解释\" class=\"headerlink\" title=\"execute()方法参数解释\"></a><code>execute()</code>方法参数解释</h4><ul>\n<li><em>Environment env</em>：系统环境变量，通常用它来输出相关内容，如<code>Writer out = env.getOut();</code></li>\n<li><em>Map params</em>：自定义标签传过来的对象，就是从页面上获取的参数，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等。<br>在本例使用时，我们会将map转成我们自己的对象进行数据保存。</li>\n<li><em>TemplateModel[] loopVars</em>：循环替代变量</li>\n<li><em>TemplateDirectiveBody body</em>：标签中嵌套的内容，如<code>&lt;@tag&gt;body&lt;/@tag&gt;</code>，就是这个body</li>\n</ul>\n<h4 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h4><h6 id=\"定义接收页面参数的对象\"><a href=\"#定义接收页面参数的对象\" class=\"headerlink\" title=\"定义接收页面参数的对象\"></a>定义接收页面参数的对象</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Getter</span><br><span class=\"line\">@Setter</span><br><span class=\"line\">public class TableThTag &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 对象属性名【需要进行对象属性获取】</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String objName;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 字典标识</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String nid;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 类型</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String type;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"实现TemplateDirectiveModel接口并重写execute方法\"><a href=\"#实现TemplateDirectiveModel接口并重写execute方法\" class=\"headerlink\" title=\"实现TemplateDirectiveModel接口并重写execute方法\"></a>实现<code>TemplateDirectiveModel</code>接口并重写<code>execute</code>方法</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@org.springframework.context.annotation.Configuration</span><br><span class=\"line\">public class TableThDirective implements TemplateDirectiveModel &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Logger logger = LoggerFactory.getLogger(getClass().getName());</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * FreeMarker自定义指令</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void execute(Environment environment, Map map, TemplateModel[] templateModels,</span><br><span class=\"line\">                        TemplateDirectiveBody templateDirectiveBody) throws TemplateException, IOException &#123;</span><br><span class=\"line\">        TableThTag tableThTag = new TableThTag();</span><br><span class=\"line\">        //校验参数</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //  用来将一些 key-value 的值（例如 hashmap）映射到 bean 中的属性</span><br><span class=\"line\">            BeanUtils.populate(tableThTag, map);</span><br><span class=\"line\">            if (StringUtils.isEmpty(tableThTag.getNid()) || StringUtils.isEmpty(tableThTag.getType())) &#123;</span><br><span class=\"line\">                throw new IllegalArgumentException(&quot;nid,type不能为空&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            logger.error(&quot;数据转化异常&quot;, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuilder html = new StringBuilder();</span><br><span class=\"line\">        // 根据类型创建不同的HTML生成器</span><br><span class=\"line\">        ThFormatterInterface thFormatterInterface = ThFormatterFactory.createThFormatter(tableThTag.getType());</span><br><span class=\"line\">        if (thFormatterInterface != null) &#123;</span><br><span class=\"line\">            String dictHtml = thFormatterInterface.buildFormatterHtml(tableThTag.getNid(), tableThTag.getFieldName());</span><br><span class=\"line\">            html.append(dictHtml);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 执行真正指令的执行部分:</span><br><span class=\"line\">        Writer out = environment.getOut();</span><br><span class=\"line\">        out.write(html.toString());</span><br><span class=\"line\">        if (templateDirectiveBody != null) &#123;</span><br><span class=\"line\">            templateDirectiveBody.render(environment.getOut());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static BeansWrapper getBeansWrapper() &#123;</span><br><span class=\"line\">        BeansWrapper beansWrapper =</span><br><span class=\"line\">                new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build();</span><br><span class=\"line\">        return beansWrapper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大家可以看到，在这个方法中，我将页面上的参数转为<code>TableThTag</code>对象。然后再根据前端页面不同的type类型对应<br>实现了<code>ThFormatterInterface</code>的工厂对象，创建不同的html生成器。（这里考虑到扩展性，可能以后不光创建数据表格会用的到，比如下拉框什么的，也可以使用这种方式创建，所以在这里使用抽象工厂依据类型动态创建。）<br>下面就是创建html的具体工厂以及实现方法。</p>\n<h6 id=\"ThFormatterInterface抽象工厂创建html生成器\"><a href=\"#ThFormatterInterface抽象工厂创建html生成器\" class=\"headerlink\" title=\"ThFormatterInterface抽象工厂创建html生成器\"></a><code>ThFormatterInterface</code>抽象工厂创建html生成器</h6><p>接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface ThFormatterInterface &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 构造生成枚举html</span><br><span class=\"line\">     * @param nid</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    String buildFormatterHtml(String nid, String fieldName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>工厂<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThFormatterFactory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static Logger logger = LoggerFactory.getLogger(ThFormatterFactory.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static ThFormatterInterface createThFormatter(String type)&#123;</span><br><span class=\"line\">        if(StringUtils.isEmpty(type))&#123;</span><br><span class=\"line\">            return  new ThFormatterTemplate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 文件名 如果type传template 就需要有一个名为ThFormatterTemplate的文件</span><br><span class=\"line\">        // 并且实现了ThFormatterInterface以及重写生成html的方法</span><br><span class=\"line\">        String fileName = &quot;ThFormatter&quot; + StringUtil.firstCharUpperCase(type);</span><br><span class=\"line\">        //类路径 通过反射去创建实现类</span><br><span class=\"line\">        String className = &quot;com.module.freemarker.impl.&quot;+fileName;</span><br><span class=\"line\">        //生成表头格式实现类</span><br><span class=\"line\">        ThFormatterInterface thFormatterInterface = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            thFormatterInterface =(ThFormatterInterface) Class.forName(className).newInstance();</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            logger.error(e.getMessage(),e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return thFormatterInterface;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThFormatterTemplate implements ThFormatterInterface &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String buildFormatterHtml(String nid, String fieldName) &#123;</span><br><span class=\"line\">        Assert.notEMPTY(nid, &quot;nid不能为空&quot;);</span><br><span class=\"line\">        Assert.notEMPTY(fieldName, &quot;objName不能为空&quot;);</span><br><span class=\"line\">        SysDictService sysDictService = SpringContextHolder.getBean(SysDictService.class);</span><br><span class=\"line\">        // 通过nid查询字典类 这里不需要进行照抄 每个人都会有自己的实现方法</span><br><span class=\"line\">        List&lt;SysDictBO&gt; sysDictModelList = sysDictService.findByPartnerNid(nid);</span><br><span class=\"line\">        StringBuilder dictHtml = new StringBuilder();</span><br><span class=\"line\">        // 反正目的就是根据字典类生成对应的html就行了 需要生成的格式对照template原本应该有的写法就行了</span><br><span class=\"line\">        dictHtml.append(&quot;templet: function(d)&#123; &quot;);</span><br><span class=\"line\">        for (SysDictBO sysDict : sysDictModelList) &#123;</span><br><span class=\"line\">            dictHtml.append(&quot;if(d.&quot; + fieldName + &quot; == &apos;&quot; + sysDict.getValue() + &quot;&apos;)&#123; return &apos;&quot; + sysDict.getName() + &quot;&apos;;&#125;&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dictHtml.append(&quot;&#125;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        return dictHtml.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"最后将自定义标签注入到freemarker标签中去\"><a href=\"#最后将自定义标签注入到freemarker标签中去\" class=\"headerlink\" title=\"最后将自定义标签注入到freemarker标签中去\"></a>最后将自定义标签注入到freemarker标签中去</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@org.springframework.context.annotation.Configuration</span><br><span class=\"line\">public class FreemarkerConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private Configuration configuration;</span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private TableThDirective tableThDirective;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostConstruct</span><br><span class=\"line\">    public void setSharedVariable()&#123;</span><br><span class=\"line\">        configuration.setSharedVariable(&quot;th&quot;,tableThDirective);</span><br><span class=\"line\">        configuration.setSharedVariable(&quot;shiro&quot;,new ShiroTags());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>这样就大功告成了。</p>\n<p>在页面上进行使用吧：<code>&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code></p>\n<p>以后进行扩展什么的也方便，比如生成下拉框：<code>&lt;@th type=&quot;select&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;</code>这样然后自动生成html的时候查出来所有的字典，根据类型生成多个<option>出来就行了。</option></p>"},{"title":"深度分析如何写出一个线程安全的单例","date":"2019-06-07T12:51:33.000Z","_content":"![封面](fm.png)\n\n<!--more-->\n\n### 什么是单例模式？\n\n单例模式是在Java编程中除了工厂模式之外最常用的创建型设计模式之一。单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。\n\n**单例模式在创建时的注意事项：**\n- 因为每个类只能创建一个实例，所以需要将其构造方法封闭起来不能被外部调用，即私有化；\n- 需要提供一个获取类实例的公有方法，所有使用该类实例的人都通过这个方法拿到单例对象；\n- 在多线程环境下需要注意线程安全问题，避免多个线程同时创建出多个不同的实例，违背了单例的原则。\n\n### 创建单例模式的方法及其优缺点\n\n#### 饿汉型\n\n```\npublic class HungrySingleton {\n\tprivate static final HungrySingleton INSTANCE = new HungrySingleton();\n\n    /**\n     * 私有构造\n     */\n    private HungrySingleton() {}\n\n    /**\n     * 获取类在加载的时候就创建好的实例\n     */\n    public static HungrySingleton getInstance() {\n        return INSTANCE;\n    }\n}\n```\n\n- 分析：饿汉型单例是最简单的单例创建方法，在类中维护一个该类私有不可变的实例，然后提供一个获取该实例的静态方法即可。\n- 优点：代码编写简单，线程安全（使用类加载机制保证线程安全，classloader在加载类的时候使用synchronized同步）\n- 缺点：无法实现懒加载，在使用较少的时候浪费资源，无法防止反射破坏以及反序列化破坏单例唯一性\n\n#### 普通懒汉型\n\n```\npublic class LazySingleton {\n\n    private static LazySingleton INSTANCE ;\n\n    private LazySingleton(){}\n\n    public static LazySingleton getInstance(){\n        if(null == INSTANCE){\n            INSTANCE = new LazySingleton();\n        }\n        return INSTANCE;\n    }\n}\n\n```\n\n- 分析：这种懒汉型单例也是一种比较简单的单例实现方式，与第一种不同在于这种实例是在调用获取实例的静态方法的时候才创建\n- 优点：代码简单，可以实现懒加载\n- 缺点：多线程环境下会有线程安全问题，多个线程同时走到第8行代码，判断实例未创建，则会创建出多个实例;无法防止反射破坏以及反序列化破坏\n\n*那么为了实现线程安全我们可以在方法上加上同步关键字，但是这种方式的缺点就是多线程环境调用该方法都会阻塞，导致性能存在不必要的浪费*\n```\npublic synchronized static LazySingleton getInstance(){\n\tif(null == INSTANCE){\n\t\tINSTANCE = new LazySingleton();\n\t}\n\treturn INSTANCE;\n}\n```\n\n#### 双重检测锁实现懒加载单例\n\n上述懒汉型同步机制可以改进如下\n\n```\npublic class DoubleLockSingleton {\n\n    private DoubleLockSingleton() {\n    }\n    \n    private static DoubleLockSingleton INSTANCE;\n\t\n    public static DoubleLockSingleton getInstance() {\n\t// 进入方法后先判断一次 大幅减少多线程环境同步阻塞问题 \n\t// 但是这种方式在多线程第一次调用创建实例的时候会出现线程安全问题\n        if (null == INSTANCE) {\n            synchronized (DoubleLockSingleton.class) {\n                if (null == INSTANCE) {\n\t\t// 问题的根源所在\n\t\t// 此处可能会出现指令重排序 \n\t\t// new对象并不是原子操作\n\t\tINSTANCE = new DoubleLockSingleton();\n                }\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n- 分析：双重检测锁机制在进入`getInstance()`方法的时候会判断实例是否被创建，如果被创建，那么直接返回，如果没有，进入同步代码块，创建实例。这个方法貌似没有问题，而且还大大减少线程进入同步代码块阻塞的情况（因为只有第一次判断对象还没有创建的时候才会有线程进入同步代码块）。但是这种方法仍然存在线程安全性问题。<font color=\"#db1414\">问题出在第17行：`INSTANCE = new DoubleLockSingleton();`由于JVM虚拟机内部会对代码进行优化，在使用new创建对象的时候并不是一个原子操作且会被虚拟机进行指令重排序。这个步骤会被分成三步：**1、在堆上为对象分配空间；2、对象进行初始化；3、将引用指向该堆上的地址。 **由于在虚拟机中，指令重排序优化导致第2步和第3步的执行顺序可以被打乱，那么在代码执行到第11行的时候发现，INSTANCE不为null，直接返回一个未初始化完成的对象，导致程序崩溃。</font>**注意：synchronzed关键字没有屏蔽指令重排序的功能**，那么如何优化呢？答案是使用`volatile`关键字修饰实例变量引用，即`private volatile static TripleLockSingleton INSTANCE;`。`volatile`关键字才有屏蔽指令重排序的语义。\n- 优点：多线程环境下大部分时间线程安全\n- 缺点：有可能会出现线程安全问题；不能避免反射和反序列化破坏\n- 优化：`private volatile static TripleLockSingleton INSTANCE;`\n\n\n#### 静态内部类单例\n\n```\npublic class StaticInnerClassSingleton {\n    private StaticInnerClassSingleton() {\n    }\n\n    private static class SingletonHolder {\n        public static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();\n    }\n\n    public static StaticInnerClassSingleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n\n```\n\n- 分析：静态内部类实现单例也是借助了类加载的线程安全机制，并同时基于内部类的使用时再创建的懒加载机制实现线程安全的懒加载模式的单例\n- 优点：线程安全，可以实现懒加载\n- 缺点：无法防止被反射以及反序列化破坏单例的唯一性\n\n#### 枚举类单例\n\n```\npublic enum EnumSingleton {\n\n    INSTANCE;\n\n    public static EnumSingleton getInstance() {\n        return INSTANCE;\n    }\n}\n```\n\n- 分析：**Joshua Bloch**大神说过：“单元素的枚举类型已经成为实现Singleton的最佳方法”。足以见证枚举类在创建单例中的优势。\n- 优点：代码简单，线程安全，可以防止反射和反序列化破坏\n- 缺点：暂无\n\n#### CAS创建单例\n```\npublic class CASSingleton {\n\n    private static final AtomicReference<CASSingleton> INSTANCE = new AtomicReference<>();\n\n    private CASSingleton() {}\n\n    /**\n     * 使用原子操作 实现获取唯一实例\n     * 理论上在大量竞争的环境中 原子操作自旋等待消耗大量性能 但是实际上当一个线程创建好实例之后其余线程不会出现死循环\n     * 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度\n     */\n    public static CASSingleton getInstance() {\n        for (; ; ) {\n            CASSingleton instance = INSTANCE.get();\n            if (null != instance) {\n                return instance;\n            }\n            instance = new CASSingleton();\n            if (INSTANCE.compareAndSet(null, instance)) {\n                return instance;\n            }\n        }\n    }\n}\n```\n\n- 分析：使用原子操作`AtomicReference`进行单例的创建，事实上目前相对于双重检查锁性能上差的也不是也别大\n- 优点：线程安全，懒加载，相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度\n- 缺点：代码编写相对复杂，不能防止被反射和反序列化破坏\n\n### 防止反射和反序列化破坏单例的方式\n\n上述几个创建单例的方式中，除了使用枚举类创建单例，都会产生被反射和反序列化破坏的情况，避免该问题的方式如下，大家需要深究的话可以打开搜索引擎... 这里不再展开了~\n\n#### 枚举类防止反射和反序列化破坏\n> ** 参考文章：https://www.cnblogs.com/chiclee/p/9097772.html **\n\n#### 防止反射破坏\n因为反射是通过class对象来调用类的构造方法创建对象的，我们只需要在构造方法中进行判断，如果实例已经存在，就抛出异常。\n```\n/**\n * 私有构造\n */\nprivate Singleton() {\n\tif(INSTANCE != null){\n\t\tthrow new RuntimeException();\n\t}\n}\n```\n\n\n\n#### 防止反序列化破坏\n\n在反序列化的时候`ObjectInputStream.readObject()`中会去判断是否存在`readResolve()`方法，如果存在的话会调用该方法返回一个实例，所以在单例类中编写`readResolve()`方法返回`INSTANCE`即可。\n\n```\n// 在反序列化时，直接调用这个方法，返回指定的对象，无需再新建一个对象\nprivate Object readResolve() {\n\treturn INSTANCE;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/深度分析如何写出一个线程安全的单例.md","raw":"---\ntitle: 深度分析如何写出一个线程安全的单例\ndate: 2019-06-07 20:51:33\ncategories: [Java基础,并发编程]\ntags: [Java基础,并发编程,单例模式,设计模式]\n---\n![封面](fm.png)\n\n<!--more-->\n\n### 什么是单例模式？\n\n单例模式是在Java编程中除了工厂模式之外最常用的创建型设计模式之一。单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。\n\n**单例模式在创建时的注意事项：**\n- 因为每个类只能创建一个实例，所以需要将其构造方法封闭起来不能被外部调用，即私有化；\n- 需要提供一个获取类实例的公有方法，所有使用该类实例的人都通过这个方法拿到单例对象；\n- 在多线程环境下需要注意线程安全问题，避免多个线程同时创建出多个不同的实例，违背了单例的原则。\n\n### 创建单例模式的方法及其优缺点\n\n#### 饿汉型\n\n```\npublic class HungrySingleton {\n\tprivate static final HungrySingleton INSTANCE = new HungrySingleton();\n\n    /**\n     * 私有构造\n     */\n    private HungrySingleton() {}\n\n    /**\n     * 获取类在加载的时候就创建好的实例\n     */\n    public static HungrySingleton getInstance() {\n        return INSTANCE;\n    }\n}\n```\n\n- 分析：饿汉型单例是最简单的单例创建方法，在类中维护一个该类私有不可变的实例，然后提供一个获取该实例的静态方法即可。\n- 优点：代码编写简单，线程安全（使用类加载机制保证线程安全，classloader在加载类的时候使用synchronized同步）\n- 缺点：无法实现懒加载，在使用较少的时候浪费资源，无法防止反射破坏以及反序列化破坏单例唯一性\n\n#### 普通懒汉型\n\n```\npublic class LazySingleton {\n\n    private static LazySingleton INSTANCE ;\n\n    private LazySingleton(){}\n\n    public static LazySingleton getInstance(){\n        if(null == INSTANCE){\n            INSTANCE = new LazySingleton();\n        }\n        return INSTANCE;\n    }\n}\n\n```\n\n- 分析：这种懒汉型单例也是一种比较简单的单例实现方式，与第一种不同在于这种实例是在调用获取实例的静态方法的时候才创建\n- 优点：代码简单，可以实现懒加载\n- 缺点：多线程环境下会有线程安全问题，多个线程同时走到第8行代码，判断实例未创建，则会创建出多个实例;无法防止反射破坏以及反序列化破坏\n\n*那么为了实现线程安全我们可以在方法上加上同步关键字，但是这种方式的缺点就是多线程环境调用该方法都会阻塞，导致性能存在不必要的浪费*\n```\npublic synchronized static LazySingleton getInstance(){\n\tif(null == INSTANCE){\n\t\tINSTANCE = new LazySingleton();\n\t}\n\treturn INSTANCE;\n}\n```\n\n#### 双重检测锁实现懒加载单例\n\n上述懒汉型同步机制可以改进如下\n\n```\npublic class DoubleLockSingleton {\n\n    private DoubleLockSingleton() {\n    }\n    \n    private static DoubleLockSingleton INSTANCE;\n\t\n    public static DoubleLockSingleton getInstance() {\n\t// 进入方法后先判断一次 大幅减少多线程环境同步阻塞问题 \n\t// 但是这种方式在多线程第一次调用创建实例的时候会出现线程安全问题\n        if (null == INSTANCE) {\n            synchronized (DoubleLockSingleton.class) {\n                if (null == INSTANCE) {\n\t\t// 问题的根源所在\n\t\t// 此处可能会出现指令重排序 \n\t\t// new对象并不是原子操作\n\t\tINSTANCE = new DoubleLockSingleton();\n                }\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n- 分析：双重检测锁机制在进入`getInstance()`方法的时候会判断实例是否被创建，如果被创建，那么直接返回，如果没有，进入同步代码块，创建实例。这个方法貌似没有问题，而且还大大减少线程进入同步代码块阻塞的情况（因为只有第一次判断对象还没有创建的时候才会有线程进入同步代码块）。但是这种方法仍然存在线程安全性问题。<font color=\"#db1414\">问题出在第17行：`INSTANCE = new DoubleLockSingleton();`由于JVM虚拟机内部会对代码进行优化，在使用new创建对象的时候并不是一个原子操作且会被虚拟机进行指令重排序。这个步骤会被分成三步：**1、在堆上为对象分配空间；2、对象进行初始化；3、将引用指向该堆上的地址。 **由于在虚拟机中，指令重排序优化导致第2步和第3步的执行顺序可以被打乱，那么在代码执行到第11行的时候发现，INSTANCE不为null，直接返回一个未初始化完成的对象，导致程序崩溃。</font>**注意：synchronzed关键字没有屏蔽指令重排序的功能**，那么如何优化呢？答案是使用`volatile`关键字修饰实例变量引用，即`private volatile static TripleLockSingleton INSTANCE;`。`volatile`关键字才有屏蔽指令重排序的语义。\n- 优点：多线程环境下大部分时间线程安全\n- 缺点：有可能会出现线程安全问题；不能避免反射和反序列化破坏\n- 优化：`private volatile static TripleLockSingleton INSTANCE;`\n\n\n#### 静态内部类单例\n\n```\npublic class StaticInnerClassSingleton {\n    private StaticInnerClassSingleton() {\n    }\n\n    private static class SingletonHolder {\n        public static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();\n    }\n\n    public static StaticInnerClassSingleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n}\n\n```\n\n- 分析：静态内部类实现单例也是借助了类加载的线程安全机制，并同时基于内部类的使用时再创建的懒加载机制实现线程安全的懒加载模式的单例\n- 优点：线程安全，可以实现懒加载\n- 缺点：无法防止被反射以及反序列化破坏单例的唯一性\n\n#### 枚举类单例\n\n```\npublic enum EnumSingleton {\n\n    INSTANCE;\n\n    public static EnumSingleton getInstance() {\n        return INSTANCE;\n    }\n}\n```\n\n- 分析：**Joshua Bloch**大神说过：“单元素的枚举类型已经成为实现Singleton的最佳方法”。足以见证枚举类在创建单例中的优势。\n- 优点：代码简单，线程安全，可以防止反射和反序列化破坏\n- 缺点：暂无\n\n#### CAS创建单例\n```\npublic class CASSingleton {\n\n    private static final AtomicReference<CASSingleton> INSTANCE = new AtomicReference<>();\n\n    private CASSingleton() {}\n\n    /**\n     * 使用原子操作 实现获取唯一实例\n     * 理论上在大量竞争的环境中 原子操作自旋等待消耗大量性能 但是实际上当一个线程创建好实例之后其余线程不会出现死循环\n     * 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度\n     */\n    public static CASSingleton getInstance() {\n        for (; ; ) {\n            CASSingleton instance = INSTANCE.get();\n            if (null != instance) {\n                return instance;\n            }\n            instance = new CASSingleton();\n            if (INSTANCE.compareAndSet(null, instance)) {\n                return instance;\n            }\n        }\n    }\n}\n```\n\n- 分析：使用原子操作`AtomicReference`进行单例的创建，事实上目前相对于双重检查锁性能上差的也不是也别大\n- 优点：线程安全，懒加载，相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度\n- 缺点：代码编写相对复杂，不能防止被反射和反序列化破坏\n\n### 防止反射和反序列化破坏单例的方式\n\n上述几个创建单例的方式中，除了使用枚举类创建单例，都会产生被反射和反序列化破坏的情况，避免该问题的方式如下，大家需要深究的话可以打开搜索引擎... 这里不再展开了~\n\n#### 枚举类防止反射和反序列化破坏\n> ** 参考文章：https://www.cnblogs.com/chiclee/p/9097772.html **\n\n#### 防止反射破坏\n因为反射是通过class对象来调用类的构造方法创建对象的，我们只需要在构造方法中进行判断，如果实例已经存在，就抛出异常。\n```\n/**\n * 私有构造\n */\nprivate Singleton() {\n\tif(INSTANCE != null){\n\t\tthrow new RuntimeException();\n\t}\n}\n```\n\n\n\n#### 防止反序列化破坏\n\n在反序列化的时候`ObjectInputStream.readObject()`中会去判断是否存在`readResolve()`方法，如果存在的话会调用该方法返回一个实例，所以在单例类中编写`readResolve()`方法返回`INSTANCE`即可。\n\n```\n// 在反序列化时，直接调用这个方法，返回指定的对象，无需再新建一个对象\nprivate Object readResolve() {\n\treturn INSTANCE;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"深度分析如何写出一个线程安全的单例","published":1,"updated":"2019-06-17T06:18:02.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwzzwvxu005scwnkq84jl0rq","content":"<p><img src=\"/blog/20190607/深度分析如何写出一个线程安全的单例/fm.png\" alt=\"封面\"></p>\n<a id=\"more\"></a>\n<h3 id=\"什么是单例模式？\"><a href=\"#什么是单例模式？\" class=\"headerlink\" title=\"什么是单例模式？\"></a>什么是单例模式？</h3><p>单例模式是在Java编程中除了工厂模式之外最常用的创建型设计模式之一。单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。</p>\n<p><strong>单例模式在创建时的注意事项：</strong></p>\n<ul>\n<li>因为每个类只能创建一个实例，所以需要将其构造方法封闭起来不能被外部调用，即私有化；</li>\n<li>需要提供一个获取类实例的公有方法，所有使用该类实例的人都通过这个方法拿到单例对象；</li>\n<li>在多线程环境下需要注意线程安全问题，避免多个线程同时创建出多个不同的实例，违背了单例的原则。</li>\n</ul>\n<h3 id=\"创建单例模式的方法及其优缺点\"><a href=\"#创建单例模式的方法及其优缺点\" class=\"headerlink\" title=\"创建单例模式的方法及其优缺点\"></a>创建单例模式的方法及其优缺点</h3><h4 id=\"饿汉型\"><a href=\"#饿汉型\" class=\"headerlink\" title=\"饿汉型\"></a>饿汉型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HungrySingleton &#123;</span><br><span class=\"line\">\tprivate static final HungrySingleton INSTANCE = new HungrySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 私有构造</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private HungrySingleton() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取类在加载的时候就创建好的实例</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static HungrySingleton getInstance() &#123;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：饿汉型单例是最简单的单例创建方法，在类中维护一个该类私有不可变的实例，然后提供一个获取该实例的静态方法即可。</li>\n<li>优点：代码编写简单，线程安全（使用类加载机制保证线程安全，classloader在加载类的时候使用synchronized同步）</li>\n<li>缺点：无法实现懒加载，在使用较少的时候浪费资源，无法防止反射破坏以及反序列化破坏单例唯一性</li>\n</ul>\n<h4 id=\"普通懒汉型\"><a href=\"#普通懒汉型\" class=\"headerlink\" title=\"普通懒汉型\"></a>普通懒汉型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LazySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static LazySingleton INSTANCE ;</span><br><span class=\"line\"></span><br><span class=\"line\">    private LazySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static LazySingleton getInstance()&#123;</span><br><span class=\"line\">        if(null == INSTANCE)&#123;</span><br><span class=\"line\">            INSTANCE = new LazySingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：这种懒汉型单例也是一种比较简单的单例实现方式，与第一种不同在于这种实例是在调用获取实例的静态方法的时候才创建</li>\n<li>优点：代码简单，可以实现懒加载</li>\n<li>缺点：多线程环境下会有线程安全问题，多个线程同时走到第8行代码，判断实例未创建，则会创建出多个实例;无法防止反射破坏以及反序列化破坏</li>\n</ul>\n<p><em>那么为了实现线程安全我们可以在方法上加上同步关键字，但是这种方式的缺点就是多线程环境调用该方法都会阻塞，导致性能存在不必要的浪费</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized static LazySingleton getInstance()&#123;</span><br><span class=\"line\">\tif(null == INSTANCE)&#123;</span><br><span class=\"line\">\t\tINSTANCE = new LazySingleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"双重检测锁实现懒加载单例\"><a href=\"#双重检测锁实现懒加载单例\" class=\"headerlink\" title=\"双重检测锁实现懒加载单例\"></a>双重检测锁实现懒加载单例</h4><p>上述懒汉型同步机制可以改进如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoubleLockSingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private DoubleLockSingleton() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private static DoubleLockSingleton INSTANCE;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    public static DoubleLockSingleton getInstance() &#123;</span><br><span class=\"line\">\t// 进入方法后先判断一次 大幅减少多线程环境同步阻塞问题 </span><br><span class=\"line\">\t// 但是这种方式在多线程第一次调用创建实例的时候会出现线程安全问题</span><br><span class=\"line\">        if (null == INSTANCE) &#123;</span><br><span class=\"line\">            synchronized (DoubleLockSingleton.class) &#123;</span><br><span class=\"line\">                if (null == INSTANCE) &#123;</span><br><span class=\"line\">\t\t// 问题的根源所在</span><br><span class=\"line\">\t\t// 此处可能会出现指令重排序 </span><br><span class=\"line\">\t\t// new对象并不是原子操作</span><br><span class=\"line\">\t\tINSTANCE = new DoubleLockSingleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：双重检测锁机制在进入<code>getInstance()</code>方法的时候会判断实例是否被创建，如果被创建，那么直接返回，如果没有，进入同步代码块，创建实例。这个方法貌似没有问题，而且还大大减少线程进入同步代码块阻塞的情况（因为只有第一次判断对象还没有创建的时候才会有线程进入同步代码块）。但是这种方法仍然存在线程安全性问题。<font color=\"#db1414\">问题出在第17行：<code>INSTANCE = new DoubleLockSingleton();</code>由于JVM虚拟机内部会对代码进行优化，在使用new创建对象的时候并不是一个原子操作且会被虚拟机进行指令重排序。这个步骤会被分成三步：<strong>1、在堆上为对象分配空间；2、对象进行初始化；3、将引用指向该堆上的地址。 </strong>由于在虚拟机中，指令重排序优化导致第2步和第3步的执行顺序可以被打乱，那么在代码执行到第11行的时候发现，INSTANCE不为null，直接返回一个未初始化完成的对象，导致程序崩溃。</font><strong>注意：synchronzed关键字没有屏蔽指令重排序的功能</strong>，那么如何优化呢？答案是使用<code>volatile</code>关键字修饰实例变量引用，即<code>private volatile static TripleLockSingleton INSTANCE;</code>。<code>volatile</code>关键字才有屏蔽指令重排序的语义。</li>\n<li>优点：多线程环境下大部分时间线程安全</li>\n<li>缺点：有可能会出现线程安全问题；不能避免反射和反序列化破坏</li>\n<li>优化：<code>private volatile static TripleLockSingleton INSTANCE;</code></li>\n</ul>\n<h4 id=\"静态内部类单例\"><a href=\"#静态内部类单例\" class=\"headerlink\" title=\"静态内部类单例\"></a>静态内部类单例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StaticInnerClassSingleton &#123;</span><br><span class=\"line\">    private StaticInnerClassSingleton() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class SingletonHolder &#123;</span><br><span class=\"line\">        public static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static StaticInnerClassSingleton getInstance() &#123;</span><br><span class=\"line\">        return SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：静态内部类实现单例也是借助了类加载的线程安全机制，并同时基于内部类的使用时再创建的懒加载机制实现线程安全的懒加载模式的单例</li>\n<li>优点：线程安全，可以实现懒加载</li>\n<li>缺点：无法防止被反射以及反序列化破坏单例的唯一性</li>\n</ul>\n<h4 id=\"枚举类单例\"><a href=\"#枚举类单例\" class=\"headerlink\" title=\"枚举类单例\"></a>枚举类单例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum EnumSingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static EnumSingleton getInstance() &#123;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：<strong>Joshua Bloch</strong>大神说过：“单元素的枚举类型已经成为实现Singleton的最佳方法”。足以见证枚举类在创建单例中的优势。</li>\n<li>优点：代码简单，线程安全，可以防止反射和反序列化破坏</li>\n<li>缺点：暂无</li>\n</ul>\n<h4 id=\"CAS创建单例\"><a href=\"#CAS创建单例\" class=\"headerlink\" title=\"CAS创建单例\"></a>CAS创建单例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CASSingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final AtomicReference&lt;CASSingleton&gt; INSTANCE = new AtomicReference&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    private CASSingleton() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 使用原子操作 实现获取唯一实例</span><br><span class=\"line\">     * 理论上在大量竞争的环境中 原子操作自旋等待消耗大量性能 但是实际上当一个线程创建好实例之后其余线程不会出现死循环</span><br><span class=\"line\">     * 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static CASSingleton getInstance() &#123;</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            CASSingleton instance = INSTANCE.get();</span><br><span class=\"line\">            if (null != instance) &#123;</span><br><span class=\"line\">                return instance;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            instance = new CASSingleton();</span><br><span class=\"line\">            if (INSTANCE.compareAndSet(null, instance)) &#123;</span><br><span class=\"line\">                return instance;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：使用原子操作<code>AtomicReference</code>进行单例的创建，事实上目前相对于双重检查锁性能上差的也不是也别大</li>\n<li>优点：线程安全，懒加载，相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</li>\n<li>缺点：代码编写相对复杂，不能防止被反射和反序列化破坏</li>\n</ul>\n<h3 id=\"防止反射和反序列化破坏单例的方式\"><a href=\"#防止反射和反序列化破坏单例的方式\" class=\"headerlink\" title=\"防止反射和反序列化破坏单例的方式\"></a>防止反射和反序列化破坏单例的方式</h3><p>上述几个创建单例的方式中，除了使用枚举类创建单例，都会产生被反射和反序列化破坏的情况，避免该问题的方式如下，大家需要深究的话可以打开搜索引擎… 这里不再展开了~</p>\n<h4 id=\"枚举类防止反射和反序列化破坏\"><a href=\"#枚举类防止反射和反序列化破坏\" class=\"headerlink\" title=\"枚举类防止反射和反序列化破坏\"></a>枚举类防止反射和反序列化破坏</h4><blockquote>\n<p><strong> 参考文章：<a href=\"https://www.cnblogs.com/chiclee/p/9097772.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chiclee/p/9097772.html</a> </strong></p>\n</blockquote>\n<h4 id=\"防止反射破坏\"><a href=\"#防止反射破坏\" class=\"headerlink\" title=\"防止反射破坏\"></a>防止反射破坏</h4><p>因为反射是通过class对象来调用类的构造方法创建对象的，我们只需要在构造方法中进行判断，如果实例已经存在，就抛出异常。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 私有构造</span><br><span class=\"line\"> */</span><br><span class=\"line\">private Singleton() &#123;</span><br><span class=\"line\">\tif(INSTANCE != null)&#123;</span><br><span class=\"line\">\t\tthrow new RuntimeException();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"防止反序列化破坏\"><a href=\"#防止反序列化破坏\" class=\"headerlink\" title=\"防止反序列化破坏\"></a>防止反序列化破坏</h4><p>在反序列化的时候<code>ObjectInputStream.readObject()</code>中会去判断是否存在<code>readResolve()</code>方法，如果存在的话会调用该方法返回一个实例，所以在单例类中编写<code>readResolve()</code>方法返回<code>INSTANCE</code>即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在反序列化时，直接调用这个方法，返回指定的对象，无需再新建一个对象</span><br><span class=\"line\">private Object readResolve() &#123;</span><br><span class=\"line\">\treturn INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><img src=\"/blog/20190607/深度分析如何写出一个线程安全的单例/fm.png\" alt=\"封面\"></p>","more":"<h3 id=\"什么是单例模式？\"><a href=\"#什么是单例模式？\" class=\"headerlink\" title=\"什么是单例模式？\"></a>什么是单例模式？</h3><p>单例模式是在Java编程中除了工厂模式之外最常用的创建型设计模式之一。单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。</p>\n<p><strong>单例模式在创建时的注意事项：</strong></p>\n<ul>\n<li>因为每个类只能创建一个实例，所以需要将其构造方法封闭起来不能被外部调用，即私有化；</li>\n<li>需要提供一个获取类实例的公有方法，所有使用该类实例的人都通过这个方法拿到单例对象；</li>\n<li>在多线程环境下需要注意线程安全问题，避免多个线程同时创建出多个不同的实例，违背了单例的原则。</li>\n</ul>\n<h3 id=\"创建单例模式的方法及其优缺点\"><a href=\"#创建单例模式的方法及其优缺点\" class=\"headerlink\" title=\"创建单例模式的方法及其优缺点\"></a>创建单例模式的方法及其优缺点</h3><h4 id=\"饿汉型\"><a href=\"#饿汉型\" class=\"headerlink\" title=\"饿汉型\"></a>饿汉型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HungrySingleton &#123;</span><br><span class=\"line\">\tprivate static final HungrySingleton INSTANCE = new HungrySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 私有构造</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private HungrySingleton() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取类在加载的时候就创建好的实例</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static HungrySingleton getInstance() &#123;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：饿汉型单例是最简单的单例创建方法，在类中维护一个该类私有不可变的实例，然后提供一个获取该实例的静态方法即可。</li>\n<li>优点：代码编写简单，线程安全（使用类加载机制保证线程安全，classloader在加载类的时候使用synchronized同步）</li>\n<li>缺点：无法实现懒加载，在使用较少的时候浪费资源，无法防止反射破坏以及反序列化破坏单例唯一性</li>\n</ul>\n<h4 id=\"普通懒汉型\"><a href=\"#普通懒汉型\" class=\"headerlink\" title=\"普通懒汉型\"></a>普通懒汉型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LazySingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static LazySingleton INSTANCE ;</span><br><span class=\"line\"></span><br><span class=\"line\">    private LazySingleton()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static LazySingleton getInstance()&#123;</span><br><span class=\"line\">        if(null == INSTANCE)&#123;</span><br><span class=\"line\">            INSTANCE = new LazySingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：这种懒汉型单例也是一种比较简单的单例实现方式，与第一种不同在于这种实例是在调用获取实例的静态方法的时候才创建</li>\n<li>优点：代码简单，可以实现懒加载</li>\n<li>缺点：多线程环境下会有线程安全问题，多个线程同时走到第8行代码，判断实例未创建，则会创建出多个实例;无法防止反射破坏以及反序列化破坏</li>\n</ul>\n<p><em>那么为了实现线程安全我们可以在方法上加上同步关键字，但是这种方式的缺点就是多线程环境调用该方法都会阻塞，导致性能存在不必要的浪费</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized static LazySingleton getInstance()&#123;</span><br><span class=\"line\">\tif(null == INSTANCE)&#123;</span><br><span class=\"line\">\t\tINSTANCE = new LazySingleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"双重检测锁实现懒加载单例\"><a href=\"#双重检测锁实现懒加载单例\" class=\"headerlink\" title=\"双重检测锁实现懒加载单例\"></a>双重检测锁实现懒加载单例</h4><p>上述懒汉型同步机制可以改进如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DoubleLockSingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private DoubleLockSingleton() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private static DoubleLockSingleton INSTANCE;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    public static DoubleLockSingleton getInstance() &#123;</span><br><span class=\"line\">\t// 进入方法后先判断一次 大幅减少多线程环境同步阻塞问题 </span><br><span class=\"line\">\t// 但是这种方式在多线程第一次调用创建实例的时候会出现线程安全问题</span><br><span class=\"line\">        if (null == INSTANCE) &#123;</span><br><span class=\"line\">            synchronized (DoubleLockSingleton.class) &#123;</span><br><span class=\"line\">                if (null == INSTANCE) &#123;</span><br><span class=\"line\">\t\t// 问题的根源所在</span><br><span class=\"line\">\t\t// 此处可能会出现指令重排序 </span><br><span class=\"line\">\t\t// new对象并不是原子操作</span><br><span class=\"line\">\t\tINSTANCE = new DoubleLockSingleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：双重检测锁机制在进入<code>getInstance()</code>方法的时候会判断实例是否被创建，如果被创建，那么直接返回，如果没有，进入同步代码块，创建实例。这个方法貌似没有问题，而且还大大减少线程进入同步代码块阻塞的情况（因为只有第一次判断对象还没有创建的时候才会有线程进入同步代码块）。但是这种方法仍然存在线程安全性问题。<font color=\"#db1414\">问题出在第17行：<code>INSTANCE = new DoubleLockSingleton();</code>由于JVM虚拟机内部会对代码进行优化，在使用new创建对象的时候并不是一个原子操作且会被虚拟机进行指令重排序。这个步骤会被分成三步：<strong>1、在堆上为对象分配空间；2、对象进行初始化；3、将引用指向该堆上的地址。 </strong>由于在虚拟机中，指令重排序优化导致第2步和第3步的执行顺序可以被打乱，那么在代码执行到第11行的时候发现，INSTANCE不为null，直接返回一个未初始化完成的对象，导致程序崩溃。</font><strong>注意：synchronzed关键字没有屏蔽指令重排序的功能</strong>，那么如何优化呢？答案是使用<code>volatile</code>关键字修饰实例变量引用，即<code>private volatile static TripleLockSingleton INSTANCE;</code>。<code>volatile</code>关键字才有屏蔽指令重排序的语义。</li>\n<li>优点：多线程环境下大部分时间线程安全</li>\n<li>缺点：有可能会出现线程安全问题；不能避免反射和反序列化破坏</li>\n<li>优化：<code>private volatile static TripleLockSingleton INSTANCE;</code></li>\n</ul>\n<h4 id=\"静态内部类单例\"><a href=\"#静态内部类单例\" class=\"headerlink\" title=\"静态内部类单例\"></a>静态内部类单例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StaticInnerClassSingleton &#123;</span><br><span class=\"line\">    private StaticInnerClassSingleton() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class SingletonHolder &#123;</span><br><span class=\"line\">        public static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static StaticInnerClassSingleton getInstance() &#123;</span><br><span class=\"line\">        return SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：静态内部类实现单例也是借助了类加载的线程安全机制，并同时基于内部类的使用时再创建的懒加载机制实现线程安全的懒加载模式的单例</li>\n<li>优点：线程安全，可以实现懒加载</li>\n<li>缺点：无法防止被反射以及反序列化破坏单例的唯一性</li>\n</ul>\n<h4 id=\"枚举类单例\"><a href=\"#枚举类单例\" class=\"headerlink\" title=\"枚举类单例\"></a>枚举类单例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum EnumSingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static EnumSingleton getInstance() &#123;</span><br><span class=\"line\">        return INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：<strong>Joshua Bloch</strong>大神说过：“单元素的枚举类型已经成为实现Singleton的最佳方法”。足以见证枚举类在创建单例中的优势。</li>\n<li>优点：代码简单，线程安全，可以防止反射和反序列化破坏</li>\n<li>缺点：暂无</li>\n</ul>\n<h4 id=\"CAS创建单例\"><a href=\"#CAS创建单例\" class=\"headerlink\" title=\"CAS创建单例\"></a>CAS创建单例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CASSingleton &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final AtomicReference&lt;CASSingleton&gt; INSTANCE = new AtomicReference&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    private CASSingleton() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 使用原子操作 实现获取唯一实例</span><br><span class=\"line\">     * 理论上在大量竞争的环境中 原子操作自旋等待消耗大量性能 但是实际上当一个线程创建好实例之后其余线程不会出现死循环</span><br><span class=\"line\">     * 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static CASSingleton getInstance() &#123;</span><br><span class=\"line\">        for (; ; ) &#123;</span><br><span class=\"line\">            CASSingleton instance = INSTANCE.get();</span><br><span class=\"line\">            if (null != instance) &#123;</span><br><span class=\"line\">                return instance;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            instance = new CASSingleton();</span><br><span class=\"line\">            if (INSTANCE.compareAndSet(null, instance)) &#123;</span><br><span class=\"line\">                return instance;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>分析：使用原子操作<code>AtomicReference</code>进行单例的创建，事实上目前相对于双重检查锁性能上差的也不是也别大</li>\n<li>优点：线程安全，懒加载，相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</li>\n<li>缺点：代码编写相对复杂，不能防止被反射和反序列化破坏</li>\n</ul>\n<h3 id=\"防止反射和反序列化破坏单例的方式\"><a href=\"#防止反射和反序列化破坏单例的方式\" class=\"headerlink\" title=\"防止反射和反序列化破坏单例的方式\"></a>防止反射和反序列化破坏单例的方式</h3><p>上述几个创建单例的方式中，除了使用枚举类创建单例，都会产生被反射和反序列化破坏的情况，避免该问题的方式如下，大家需要深究的话可以打开搜索引擎… 这里不再展开了~</p>\n<h4 id=\"枚举类防止反射和反序列化破坏\"><a href=\"#枚举类防止反射和反序列化破坏\" class=\"headerlink\" title=\"枚举类防止反射和反序列化破坏\"></a>枚举类防止反射和反序列化破坏</h4><blockquote>\n<p><strong> 参考文章：<a href=\"https://www.cnblogs.com/chiclee/p/9097772.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chiclee/p/9097772.html</a> </strong></p>\n</blockquote>\n<h4 id=\"防止反射破坏\"><a href=\"#防止反射破坏\" class=\"headerlink\" title=\"防止反射破坏\"></a>防止反射破坏</h4><p>因为反射是通过class对象来调用类的构造方法创建对象的，我们只需要在构造方法中进行判断，如果实例已经存在，就抛出异常。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 私有构造</span><br><span class=\"line\"> */</span><br><span class=\"line\">private Singleton() &#123;</span><br><span class=\"line\">\tif(INSTANCE != null)&#123;</span><br><span class=\"line\">\t\tthrow new RuntimeException();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"防止反序列化破坏\"><a href=\"#防止反序列化破坏\" class=\"headerlink\" title=\"防止反序列化破坏\"></a>防止反序列化破坏</h4><p>在反序列化的时候<code>ObjectInputStream.readObject()</code>中会去判断是否存在<code>readResolve()</code>方法，如果存在的话会调用该方法返回一个实例，所以在单例类中编写<code>readResolve()</code>方法返回<code>INSTANCE</code>即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在反序列化时，直接调用这个方法，返回指定的对象，无需再新建一个对象</span><br><span class=\"line\">private Object readResolve() &#123;</span><br><span class=\"line\">\treturn INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/二叉树的几种非递归遍历/fm.jpg","slug":"fm.jpg","post":"cjwzzwvvb000vcwnkqmj4tx7m","modified":0,"renderable":0},{"_id":"source/_posts/你的内心比拳头更强大/xx.png","slug":"xx.png","post":"cjwzzwvvc000xcwnk2tt3m3cu","modified":0,"renderable":0},{"_id":"source/_posts/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png","slug":"cdl.png","post":"cjwzzwvvj001ccwnkew6hbvzl","modified":0,"renderable":0},{"_id":"source/_posts/并发编程学习-二-：使用AQS编写可重入锁/aqs.png","slug":"aqs.png","post":"cjwzzwvvl001gcwnkq4f5bq1p","modified":0,"renderable":0},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png","slug":"xcc.png","post":"cjwzzwvvm001jcwnk72t0nxt3","modified":0,"renderable":0},{"_id":"source/_posts/无重复字符的最长子串/bb.png","slug":"bb.png","post":"cjwzzwvvp001rcwnkjadarep2","modified":0,"renderable":0},{"_id":"source/_posts/编写一个简易的可重入锁-一/nullIsMistake.jpg","slug":"nullIsMistake.jpg","post":"cjwzzwvvs001xcwnkcr6rs8ej","modified":0,"renderable":0},{"_id":"source/_posts/使用-幕布-创建Java知识体系思维导图/java_core.png","slug":"java_core.png","post":"cjwzzwvvd0011cwnkv5q3ziqo","modified":0,"renderable":0},{"_id":"source/_posts/使用-幕布-创建Java知识体系思维导图/mb.png","slug":"mb.png","post":"cjwzzwvvd0011cwnkv5q3ziqo","modified":0,"renderable":0},{"_id":"source/_posts/编写自己的SpringMVC框架/aaa.jpeg","slug":"aaa.jpeg","post":"cjwzzwvw0002dcwnku39x1k21","modified":0,"renderable":0},{"_id":"source/_posts/编写自己的SpringMVC框架/zj.png","slug":"zj.png","post":"cjwzzwvw0002dcwnku39x1k21","modified":0,"renderable":0},{"_id":"source/_posts/二叉搜索树与完全二叉树/ecs.png","slug":"ecs.png","post":"cjwzzwvva000rcwnky3aoxc2o","modified":0,"renderable":0},{"_id":"source/_posts/二叉搜索树与完全二叉树/mecs.png","slug":"mecs.png","post":"cjwzzwvva000rcwnky3aoxc2o","modified":0,"renderable":0},{"_id":"source/_posts/二叉搜索树与完全二叉树/wqecs.png","slug":"wqecs.png","post":"cjwzzwvva000rcwnky3aoxc2o","modified":0,"renderable":0},{"_id":"source/_posts/深度分析如何写出一个线程安全的单例/fm.png","slug":"fm.png","post":"cjwzzwvxu005scwnkq84jl0rq","modified":0,"renderable":0},{"_id":"source/_posts/Java内存分配与垃圾回收的复习整理/jvm.png","slug":"jvm.png","post":"cjwzzwvxr005ocwnkrvaq9tfr","modified":0,"renderable":0},{"_id":"source/_posts/Java内存分配与垃圾回收的复习整理/zy.png","slug":"zy.png","post":"cjwzzwvxr005ocwnkrvaq9tfr","modified":0,"renderable":0},{"_id":"source/_posts/Java序列化和transient关键字的理解与学习/xuliehua.png","slug":"xuliehua.png","post":"cjwzzwvxs005pcwnkiexx7q04","modified":0,"renderable":0},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池/gzhs.png","slug":"gzhs.png","post":"cjwzzwvvm001jcwnk72t0nxt3","modified":0,"renderable":0},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池/bhcl.png","slug":"bhcl.png","post":"cjwzzwvvm001jcwnk72t0nxt3","modified":0,"renderable":0},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcc.png","slug":"yzxcc.png","post":"cjwzzwvvm001jcwnk72t0nxt3","modified":0,"renderable":0},{"_id":"source/_posts/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcgz.png","slug":"yzxcgz.png","post":"cjwzzwvvm001jcwnk72t0nxt3","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjwzzwvug0000cwnkkkn3c44s","category_id":"cjwzzwvuq0004cwnki3jkhofy","_id":"cjwzzwvv3000gcwnkyqy2vfq6"},{"post_id":"cjwzzwvum0002cwnk2xsedldr","category_id":"cjwzzwvuz000bcwnkmpec2649","_id":"cjwzzwvv8000ncwnkteb04w7e"},{"post_id":"cjwzzwvus0006cwnk074ktnpn","category_id":"cjwzzwvv3000hcwnkdfg0snou","_id":"cjwzzwvva000scwnkbrhl1f0h"},{"post_id":"cjwzzwvv9000qcwnk2iprmxes","category_id":"cjwzzwvuq0004cwnki3jkhofy","_id":"cjwzzwvvd000ycwnkexte8fph"},{"post_id":"cjwzzwvuv0008cwnk5k1pohqt","category_id":"cjwzzwvv8000pcwnkw2rl15k8","_id":"cjwzzwvve0012cwnk6lacvkq9"},{"post_id":"cjwzzwvuy000acwnkplx0e4d9","category_id":"cjwzzwvvb000ucwnkqisizy1q","_id":"cjwzzwvvg0016cwnkxcc44euo"},{"post_id":"cjwzzwvvd0011cwnkv5q3ziqo","category_id":"cjwzzwvvb000ucwnkqisizy1q","_id":"cjwzzwvvi001acwnknewvw7c8"},{"post_id":"cjwzzwvvf0014cwnkadkjkop1","category_id":"cjwzzwvvb000ucwnkqisizy1q","_id":"cjwzzwvvj001dcwnkmath4ifq"},{"post_id":"cjwzzwvv1000ecwnkkrg74ufm","category_id":"cjwzzwvve0013cwnk0pstrdgm","_id":"cjwzzwvvm001hcwnkafmbp1ib"},{"post_id":"cjwzzwvvh0019cwnkmz4n6ojt","category_id":"cjwzzwvvh0018cwnku8d62424","_id":"cjwzzwvvn001kcwnkun890pgx"},{"post_id":"cjwzzwvv2000fcwnk7v01pz8s","category_id":"cjwzzwvvh0018cwnku8d62424","_id":"cjwzzwvvp001pcwnk68eo9ke5"},{"post_id":"cjwzzwvv5000jcwnkchnbiv6f","category_id":"cjwzzwvv8000pcwnkw2rl15k8","_id":"cjwzzwvvr001ucwnky7kbw3tf"},{"post_id":"cjwzzwvvo001ocwnk5a3qc6o0","category_id":"cjwzzwvvh0018cwnku8d62424","_id":"cjwzzwvvt001ycwnk4iv1k5r0"},{"post_id":"cjwzzwvv7000lcwnklz02nogp","category_id":"cjwzzwvvh0018cwnku8d62424","_id":"cjwzzwvvu0022cwnktjy0vq2j"},{"post_id":"cjwzzwvvp001rcwnkjadarep2","category_id":"cjwzzwvve0013cwnk0pstrdgm","_id":"cjwzzwvvw0026cwnkrftv2xpp"},{"post_id":"cjwzzwvvr001wcwnk3nkikpyc","category_id":"cjwzzwvv3000hcwnkdfg0snou","_id":"cjwzzwvvz002acwnklniqnxoh"},{"post_id":"cjwzzwvvv0025cwnkykwa0weh","category_id":"cjwzzwvv8000pcwnkw2rl15k8","_id":"cjwzzwvw1002fcwnkhp6daqf1"},{"post_id":"cjwzzwvvw0029cwnkwgfygxyb","category_id":"cjwzzwvv8000pcwnkw2rl15k8","_id":"cjwzzwvw2002jcwnkrvbfkejd"},{"post_id":"cjwzzwvvc000xcwnk2tt3m3cu","category_id":"cjwzzwvvw0028cwnkx5kcl3o4","_id":"cjwzzwvw2002lcwnk9g083fum"},{"post_id":"cjwzzwvvg0015cwnkjvgxevjz","category_id":"cjwzzwvw1002gcwnk5k6sq7r7","_id":"cjwzzwvw4002qcwnk8zu20qy9"},{"post_id":"cjwzzwvvj001ccwnkew6hbvzl","category_id":"cjwzzwvuq0004cwnki3jkhofy","_id":"cjwzzwvw5002ucwnkn6ewwxre"},{"post_id":"cjwzzwvvj001ccwnkew6hbvzl","category_id":"cjwzzwvw2002mcwnk5e1w0r77","_id":"cjwzzwvw6002wcwnkqfxetu36"},{"post_id":"cjwzzwvvl001gcwnkq4f5bq1p","category_id":"cjwzzwvuq0004cwnki3jkhofy","_id":"cjwzzwvw6002ycwnkeg7d6nh4"},{"post_id":"cjwzzwvvl001gcwnkq4f5bq1p","category_id":"cjwzzwvw2002mcwnk5e1w0r77","_id":"cjwzzwvw70030cwnkwmm0a3j9"},{"post_id":"cjwzzwvvm001jcwnk72t0nxt3","category_id":"cjwzzwvuq0004cwnki3jkhofy","_id":"cjwzzwvw70031cwnkjfe9fhgd"},{"post_id":"cjwzzwvvm001jcwnk72t0nxt3","category_id":"cjwzzwvw2002mcwnk5e1w0r77","_id":"cjwzzwvw80034cwnkpqsdta4t"},{"post_id":"cjwzzwvva000rcwnky3aoxc2o","category_id":"cjwzzwvvq001tcwnka4xm0vhy","_id":"cjwzzwvw90037cwnknis7j7qa"},{"post_id":"cjwzzwvva000rcwnky3aoxc2o","category_id":"cjwzzwvw6002xcwnk2g8c7gj4","_id":"cjwzzwvw9003acwnkg9jckfev"},{"post_id":"cjwzzwvvs001xcwnkcr6rs8ej","category_id":"cjwzzwvuq0004cwnki3jkhofy","_id":"cjwzzwvwa003dcwnktdi41fbn"},{"post_id":"cjwzzwvvs001xcwnkcr6rs8ej","category_id":"cjwzzwvw2002mcwnk5e1w0r77","_id":"cjwzzwvwb003gcwnkqox4j6ec"},{"post_id":"cjwzzwvvt0021cwnk9k1xn3q5","category_id":"cjwzzwvvw0028cwnkx5kcl3o4","_id":"cjwzzwvwb003icwnk6kdx8ia0"},{"post_id":"cjwzzwvvb000vcwnkqmj4tx7m","category_id":"cjwzzwvvq001tcwnka4xm0vhy","_id":"cjwzzwvwc003lcwnk8f5gw666"},{"post_id":"cjwzzwvvb000vcwnkqmj4tx7m","category_id":"cjwzzwvw6002xcwnk2g8c7gj4","_id":"cjwzzwvwc003ncwnkg2o6bd62"},{"post_id":"cjwzzwvw0002dcwnku39x1k21","category_id":"cjwzzwvwb003hcwnkdx5axlt3","_id":"cjwzzwvwd003qcwnkek4zskc6"},{"post_id":"cjwzzwvxr005ocwnkrvaq9tfr","category_id":"cjwzzwvuq0004cwnki3jkhofy","_id":"cjwzzwvxv005tcwnkunj2n63c"},{"post_id":"cjwzzwvxs005pcwnkiexx7q04","category_id":"cjwzzwvuq0004cwnki3jkhofy","_id":"cjwzzwvxv005ucwnk51tnn875"},{"post_id":"cjwzzwvxt005rcwnk03kete0s","category_id":"cjwzzwvvh0018cwnku8d62424","_id":"cjwzzwvxw005wcwnkp086pp9i"},{"post_id":"cjwzzwvxu005scwnkq84jl0rq","category_id":"cjwzzwvuq0004cwnki3jkhofy","_id":"cjwzzwvxw005xcwnkf9dgq922"},{"post_id":"cjwzzwvxu005scwnkq84jl0rq","category_id":"cjwzzwvw2002mcwnk5e1w0r77","_id":"cjwzzwvxx0060cwnke78j1vqf"}],"PostTag":[{"post_id":"cjwzzwvug0000cwnkkkn3c44s","tag_id":"cjwzzwvur0005cwnkdqe15xjl","_id":"cjwzzwvv6000kcwnkzdygeunq"},{"post_id":"cjwzzwvug0000cwnkkkn3c44s","tag_id":"cjwzzwvuz000ccwnkpvsspasy","_id":"cjwzzwvv7000mcwnklmawovrf"},{"post_id":"cjwzzwvum0002cwnk2xsedldr","tag_id":"cjwzzwvur0005cwnkdqe15xjl","_id":"cjwzzwvvc000wcwnkh9ftc9os"},{"post_id":"cjwzzwvum0002cwnk2xsedldr","tag_id":"cjwzzwvv8000ocwnk6xnpteow","_id":"cjwzzwvvd000zcwnktbq3aqe9"},{"post_id":"cjwzzwvvg0015cwnkjvgxevjz","tag_id":"cjwzzwvur0005cwnkdqe15xjl","_id":"cjwzzwvvi001bcwnk777qg565"},{"post_id":"cjwzzwvus0006cwnk074ktnpn","tag_id":"cjwzzwvvb000tcwnko0bvbwdk","_id":"cjwzzwvvm001icwnkvs1ijfzc"},{"post_id":"cjwzzwvus0006cwnk074ktnpn","tag_id":"cjwzzwvvd0010cwnkew9nobfn","_id":"cjwzzwvvn001lcwnkoysfb9vm"},{"post_id":"cjwzzwvus0006cwnk074ktnpn","tag_id":"cjwzzwvvh0017cwnkmrhrejll","_id":"cjwzzwvvp001qcwnkc3b0o2vn"},{"post_id":"cjwzzwvuv0008cwnk5k1pohqt","tag_id":"cjwzzwvvk001ecwnkrq7be8vj","_id":"cjwzzwvvq001scwnkchfsjgtw"},{"post_id":"cjwzzwvvr001wcwnk3nkikpyc","tag_id":"cjwzzwvvd0010cwnkew9nobfn","_id":"cjwzzwvvt001zcwnkl718o5zt"},{"post_id":"cjwzzwvvr001wcwnk3nkikpyc","tag_id":"cjwzzwvur0005cwnkdqe15xjl","_id":"cjwzzwvvv0024cwnkri4v6d3w"},{"post_id":"cjwzzwvuy000acwnkplx0e4d9","tag_id":"cjwzzwvur0005cwnkdqe15xjl","_id":"cjwzzwvvw0027cwnkrhyhon5d"},{"post_id":"cjwzzwvuy000acwnkplx0e4d9","tag_id":"cjwzzwvvo001ncwnknda7blcv","_id":"cjwzzwvvz002ccwnkq100qh9d"},{"post_id":"cjwzzwvuy000acwnkplx0e4d9","tag_id":"cjwzzwvvr001vcwnkn898u1xy","_id":"cjwzzwvw1002ecwnkyxc61csb"},{"post_id":"cjwzzwvvw0029cwnkwgfygxyb","tag_id":"cjwzzwvvk001ecwnkrq7be8vj","_id":"cjwzzwvw1002icwnkw4w3ca31"},{"post_id":"cjwzzwvv1000ecwnkkrg74ufm","tag_id":"cjwzzwvvu0023cwnkqu4qwt16","_id":"cjwzzwvw2002kcwnkeb9fkk3w"},{"post_id":"cjwzzwvv1000ecwnkkrg74ufm","tag_id":"cjwzzwvvz002bcwnksz9c0n5d","_id":"cjwzzwvw3002ocwnkhiwds6jo"},{"post_id":"cjwzzwvv2000fcwnk7v01pz8s","tag_id":"cjwzzwvvb000tcwnko0bvbwdk","_id":"cjwzzwvw3002pcwnksptvzo0j"},{"post_id":"cjwzzwvv5000jcwnkchnbiv6f","tag_id":"cjwzzwvvk001ecwnkrq7be8vj","_id":"cjwzzwvw80035cwnk5wknhhpg"},{"post_id":"cjwzzwvv5000jcwnkchnbiv6f","tag_id":"cjwzzwvw4002scwnk2alruhsk","_id":"cjwzzwvw90038cwnkorw15tgl"},{"post_id":"cjwzzwvv5000jcwnkchnbiv6f","tag_id":"cjwzzwvw5002vcwnkr8x48ug6","_id":"cjwzzwvw9003bcwnk0xoy2a1r"},{"post_id":"cjwzzwvv5000jcwnkchnbiv6f","tag_id":"cjwzzwvw6002zcwnkrpvscowg","_id":"cjwzzwvwa003ecwnkj4xscvty"},{"post_id":"cjwzzwvv7000lcwnklz02nogp","tag_id":"cjwzzwvvb000tcwnko0bvbwdk","_id":"cjwzzwvwc003kcwnk73kl99mu"},{"post_id":"cjwzzwvv7000lcwnklz02nogp","tag_id":"cjwzzwvw90039cwnkz8kudts3","_id":"cjwzzwvwc003mcwnkiaaxhnnt"},{"post_id":"cjwzzwvv7000lcwnklz02nogp","tag_id":"cjwzzwvwa003fcwnk3sqtg59a","_id":"cjwzzwvwd003pcwnkmgxhazee"},{"post_id":"cjwzzwvv9000qcwnk2iprmxes","tag_id":"cjwzzwvuz000ccwnkpvsspasy","_id":"cjwzzwvwd003scwnkr9hkzjil"},{"post_id":"cjwzzwvv9000qcwnk2iprmxes","tag_id":"cjwzzwvwb003jcwnkr3jzeblc","_id":"cjwzzwvwe003tcwnk3qv4wa4a"},{"post_id":"cjwzzwvv9000qcwnk2iprmxes","tag_id":"cjwzzwvwc003ocwnkvn5ksa6e","_id":"cjwzzwvwe003vcwnkk7uvnkh0"},{"post_id":"cjwzzwvva000rcwnky3aoxc2o","tag_id":"cjwzzwvwd003rcwnk0wnpxorx","_id":"cjwzzwvwf003xcwnkkmv94azp"},{"post_id":"cjwzzwvva000rcwnky3aoxc2o","tag_id":"cjwzzwvwe003ucwnklqesrq8d","_id":"cjwzzwvwf003ycwnkqyb4oiag"},{"post_id":"cjwzzwvvb000vcwnkqmj4tx7m","tag_id":"cjwzzwvwd003rcwnk0wnpxorx","_id":"cjwzzwvwh0041cwnkmpvg4tt4"},{"post_id":"cjwzzwvvb000vcwnkqmj4tx7m","tag_id":"cjwzzwvwe003ucwnklqesrq8d","_id":"cjwzzwvwh0042cwnkpmi4eugk"},{"post_id":"cjwzzwvvc000xcwnk2tt3m3cu","tag_id":"cjwzzwvwg0040cwnk8izmieng","_id":"cjwzzwvwi0044cwnk7zmwyxlr"},{"post_id":"cjwzzwvvd0011cwnkv5q3ziqo","tag_id":"cjwzzwvwh0043cwnkhkgjfvxf","_id":"cjwzzwvwi0046cwnk0w1mx8gg"},{"post_id":"cjwzzwvvf0014cwnkadkjkop1","tag_id":"cjwzzwvwi0045cwnkoxerayvk","_id":"cjwzzwvwj0049cwnk0w7msh6a"},{"post_id":"cjwzzwvvf0014cwnkadkjkop1","tag_id":"cjwzzwvur0005cwnkdqe15xjl","_id":"cjwzzwvwk004acwnkrc5qnjaf"},{"post_id":"cjwzzwvvf0014cwnkadkjkop1","tag_id":"cjwzzwvwj0047cwnkec2ydxqm","_id":"cjwzzwvwl004ccwnknpdmamff"},{"post_id":"cjwzzwvvh0019cwnkmz4n6ojt","tag_id":"cjwzzwvvb000tcwnko0bvbwdk","_id":"cjwzzwvwl004dcwnkt2wdk6xi"},{"post_id":"cjwzzwvvh0019cwnkmz4n6ojt","tag_id":"cjwzzwvwj0048cwnkianuzdws","_id":"cjwzzwvwm004fcwnkv3c9ytjb"},{"post_id":"cjwzzwvvj001ccwnkew6hbvzl","tag_id":"cjwzzwvuz000ccwnkpvsspasy","_id":"cjwzzwvwn004icwnkmudxg1mm"},{"post_id":"cjwzzwvvj001ccwnkew6hbvzl","tag_id":"cjwzzwvwk004bcwnkysyr0kux","_id":"cjwzzwvwo004jcwnk6a5ifb8j"},{"post_id":"cjwzzwvvj001ccwnkew6hbvzl","tag_id":"cjwzzwvwl004ecwnkpq4swg1l","_id":"cjwzzwvwo004lcwnkjndzifbq"},{"post_id":"cjwzzwvvj001ccwnkew6hbvzl","tag_id":"cjwzzwvwm004gcwnkpk3i7fjr","_id":"cjwzzwvwo004mcwnkkxugacbp"},{"post_id":"cjwzzwvvl001gcwnkq4f5bq1p","tag_id":"cjwzzwvuz000ccwnkpvsspasy","_id":"cjwzzwvwq004pcwnks2mpmmy7"},{"post_id":"cjwzzwvvl001gcwnkq4f5bq1p","tag_id":"cjwzzwvwk004bcwnkysyr0kux","_id":"cjwzzwvwq004qcwnk2hv7vem2"},{"post_id":"cjwzzwvvl001gcwnkq4f5bq1p","tag_id":"cjwzzwvwo004kcwnkzyruyydd","_id":"cjwzzwvwr004scwnke76oshiu"},{"post_id":"cjwzzwvvl001gcwnkq4f5bq1p","tag_id":"cjwzzwvwl004ecwnkpq4swg1l","_id":"cjwzzwvwr004tcwnkq8pu1hfz"},{"post_id":"cjwzzwvvm001jcwnk72t0nxt3","tag_id":"cjwzzwvuz000ccwnkpvsspasy","_id":"cjwzzwvwt004wcwnk065uce1w"},{"post_id":"cjwzzwvvm001jcwnk72t0nxt3","tag_id":"cjwzzwvwk004bcwnkysyr0kux","_id":"cjwzzwvwt004xcwnk92k9eb4f"},{"post_id":"cjwzzwvvm001jcwnk72t0nxt3","tag_id":"cjwzzwvwq004rcwnkxmfihyqy","_id":"cjwzzwvwv004zcwnkjpwldcu1"},{"post_id":"cjwzzwvvm001jcwnk72t0nxt3","tag_id":"cjwzzwvwr004ucwnkftrscorr","_id":"cjwzzwvwv0050cwnkticv2g27"},{"post_id":"cjwzzwvvo001ocwnk5a3qc6o0","tag_id":"cjwzzwvws004vcwnkb94ti0ij","_id":"cjwzzwvww0052cwnkq5g3kura"},{"post_id":"cjwzzwvvo001ocwnk5a3qc6o0","tag_id":"cjwzzwvvb000tcwnko0bvbwdk","_id":"cjwzzwvwy0053cwnken87osyx"},{"post_id":"cjwzzwvvp001rcwnkjadarep2","tag_id":"cjwzzwvvu0023cwnkqu4qwt16","_id":"cjwzzwvx00055cwnkbiqq9576"},{"post_id":"cjwzzwvvp001rcwnkjadarep2","tag_id":"cjwzzwvvz002bcwnksz9c0n5d","_id":"cjwzzwvx10056cwnkmsul0lp8"},{"post_id":"cjwzzwvvs001xcwnkcr6rs8ej","tag_id":"cjwzzwvuz000ccwnkpvsspasy","_id":"cjwzzwvx30059cwnkfq0xojnu"},{"post_id":"cjwzzwvvs001xcwnkcr6rs8ej","tag_id":"cjwzzwvwk004bcwnkysyr0kux","_id":"cjwzzwvx3005acwnkx2cszuja"},{"post_id":"cjwzzwvvs001xcwnkcr6rs8ej","tag_id":"cjwzzwvwo004kcwnkzyruyydd","_id":"cjwzzwvx4005ccwnkzstsezmm"},{"post_id":"cjwzzwvvt0021cwnk9k1xn3q5","tag_id":"cjwzzwvwg0040cwnk8izmieng","_id":"cjwzzwvx4005dcwnk82tx1seb"},{"post_id":"cjwzzwvvv0025cwnkykwa0weh","tag_id":"cjwzzwvx3005bcwnksndjv9qq","_id":"cjwzzwvx5005gcwnk4jdg4ahg"},{"post_id":"cjwzzwvvv0025cwnkykwa0weh","tag_id":"cjwzzwvwg0040cwnk8izmieng","_id":"cjwzzwvx6005hcwnklk2mrqcc"},{"post_id":"cjwzzwvw0002dcwnku39x1k21","tag_id":"cjwzzwvuz000ccwnkpvsspasy","_id":"cjwzzwvx7005kcwnkrt06rx8u"},{"post_id":"cjwzzwvw0002dcwnku39x1k21","tag_id":"cjwzzwvx5005fcwnkkphacr2f","_id":"cjwzzwvx7005lcwnkv3n8n9mc"},{"post_id":"cjwzzwvw0002dcwnku39x1k21","tag_id":"cjwzzwvx6005icwnk22u11tfe","_id":"cjwzzwvx7005mcwnkfdo8f18i"},{"post_id":"cjwzzwvw0002dcwnku39x1k21","tag_id":"cjwzzwvx6005jcwnk4tgyakvv","_id":"cjwzzwvx7005ncwnkfyb63erj"},{"post_id":"cjwzzwvxr005ocwnkrvaq9tfr","tag_id":"cjwzzwvuz000ccwnkpvsspasy","_id":"cjwzzwvxw005zcwnkbf1v4owr"},{"post_id":"cjwzzwvxr005ocwnkrvaq9tfr","tag_id":"cjwzzwvxt005qcwnkrov81c63","_id":"cjwzzwvxx0061cwnkyzhuucj7"},{"post_id":"cjwzzwvxr005ocwnkrvaq9tfr","tag_id":"cjwzzwvxw005vcwnk70wau3pn","_id":"cjwzzwvxx0063cwnkn3c7lf49"},{"post_id":"cjwzzwvxs005pcwnkiexx7q04","tag_id":"cjwzzwvxw005ycwnkvttb9bmr","_id":"cjwzzwvxx0065cwnku8wn3s8y"},{"post_id":"cjwzzwvxs005pcwnkiexx7q04","tag_id":"cjwzzwvuz000ccwnkpvsspasy","_id":"cjwzzwvxx0066cwnk6kfvc77y"},{"post_id":"cjwzzwvxs005pcwnkiexx7q04","tag_id":"cjwzzwvxx0062cwnkf1g7vhwt","_id":"cjwzzwvxy0068cwnktf4bzsxi"},{"post_id":"cjwzzwvxt005rcwnk03kete0s","tag_id":"cjwzzwvur0005cwnkdqe15xjl","_id":"cjwzzwvxy006bcwnk5xdxpyll"},{"post_id":"cjwzzwvxt005rcwnk03kete0s","tag_id":"cjwzzwvvb000tcwnko0bvbwdk","_id":"cjwzzwvxy006ccwnk9cjp9ujz"},{"post_id":"cjwzzwvxt005rcwnk03kete0s","tag_id":"cjwzzwvxx0064cwnk7o1db557","_id":"cjwzzwvxz006ecwnktk6unmjp"},{"post_id":"cjwzzwvxt005rcwnk03kete0s","tag_id":"cjwzzwvxy0067cwnk4gsb2c3c","_id":"cjwzzwvxz006fcwnkndghxdpx"},{"post_id":"cjwzzwvxt005rcwnk03kete0s","tag_id":"cjwzzwvxy0069cwnkea4rb3vg","_id":"cjwzzwvxz006gcwnkfn0vsz0z"},{"post_id":"cjwzzwvxu005scwnkq84jl0rq","tag_id":"cjwzzwvuz000ccwnkpvsspasy","_id":"cjwzzwvxz006hcwnk06cxuwjo"},{"post_id":"cjwzzwvxu005scwnkq84jl0rq","tag_id":"cjwzzwvwk004bcwnkysyr0kux","_id":"cjwzzwvxz006icwnkv0dzluuo"},{"post_id":"cjwzzwvxu005scwnkq84jl0rq","tag_id":"cjwzzwvxy006acwnkaplei1vp","_id":"cjwzzwvxz006jcwnky9a3ubn1"},{"post_id":"cjwzzwvxu005scwnkq84jl0rq","tag_id":"cjwzzwvxy006dcwnkp25auww3","_id":"cjwzzwvxz006kcwnk3mduf1zd"}],"Tag":[{"name":"开发日记","_id":"cjwzzwvur0005cwnkdqe15xjl"},{"name":"Java基础","_id":"cjwzzwvuz000ccwnkpvsspasy"},{"name":"hexo","_id":"cjwzzwvv8000ocwnk6xnpteow"},{"name":"springboot","_id":"cjwzzwvvb000tcwnko0bvbwdk"},{"name":"dubbo","_id":"cjwzzwvvd0010cwnkew9nobfn"},{"name":"分布式服务降级","_id":"cjwzzwvvh0017cwnkmrhrejll"},{"name":"程序人生","_id":"cjwzzwvvk001ecwnkrq7be8vj"},{"name":"工作技巧","_id":"cjwzzwvvo001ncwnknda7blcv"},{"name":"nodepad++","_id":"cjwzzwvvr001vcwnkn898u1xy"},{"name":"leetcode","_id":"cjwzzwvvu0023cwnkqu4qwt16"},{"name":"算法题解","_id":"cjwzzwvvz002bcwnksz9c0n5d"},{"name":"实习","_id":"cjwzzwvw4002scwnk2alruhsk"},{"name":"三星","_id":"cjwzzwvw5002vcwnkr8x48ug6"},{"name":"shell自动化测试","_id":"cjwzzwvw6002zcwnkrpvscowg"},{"name":"shiro","_id":"cjwzzwvw90039cwnkz8kudts3"},{"name":"session污染","_id":"cjwzzwvwa003fcwnk3sqtg59a"},{"name":"事务","_id":"cjwzzwvwb003jcwnkr3jzeblc"},{"name":"数据库","_id":"cjwzzwvwc003ocwnkvn5ksa6e"},{"name":"数据结构与算法","_id":"cjwzzwvwd003rcwnk0wnpxorx"},{"name":"二叉树","_id":"cjwzzwvwe003ucwnklqesrq8d"},{"name":"个人随笔","_id":"cjwzzwvwg0040cwnk8izmieng"},{"name":"开发工具","_id":"cjwzzwvwh0043cwnkhkgjfvxf"},{"name":"IDEA","_id":"cjwzzwvwi0045cwnkoxerayvk"},{"name":"git","_id":"cjwzzwvwj0047cwnkec2ydxqm"},{"name":"国际化","_id":"cjwzzwvwj0048cwnkianuzdws"},{"name":"并发编程","_id":"cjwzzwvwk004bcwnkysyr0kux"},{"name":"AQS","_id":"cjwzzwvwl004ecwnkpq4swg1l"},{"name":"CountDownLatch","_id":"cjwzzwvwm004gcwnkpk3i7fjr"},{"name":"可重入锁","_id":"cjwzzwvwo004kcwnkzyruyydd"},{"name":"ThreadPoolExecutor","_id":"cjwzzwvwq004rcwnkxmfihyqy"},{"name":"线程池","_id":"cjwzzwvwr004ucwnkftrscorr"},{"name":"spring","_id":"cjwzzwvws004vcwnkb94ti0ij"},{"name":"面试经历","_id":"cjwzzwvx3005bcwnksndjv9qq"},{"name":"Spring","_id":"cjwzzwvx5005fcwnkkphacr2f"},{"name":"SpringMVC","_id":"cjwzzwvx6005icwnk22u11tfe"},{"name":"Servlet","_id":"cjwzzwvx6005jcwnk4tgyakvv"},{"name":"内存分配","_id":"cjwzzwvxt005qcwnkrov81c63"},{"name":"垃圾回收","_id":"cjwzzwvxw005vcwnk70wau3pn"},{"name":"序列化","_id":"cjwzzwvxw005ycwnkvttb9bmr"},{"name":"transient关键字","_id":"cjwzzwvxx0062cwnkf1g7vhwt"},{"name":"freemarker","_id":"cjwzzwvxx0064cwnk7o1db557"},{"name":"工厂模式","_id":"cjwzzwvxy0067cwnk4gsb2c3c"},{"name":"layui","_id":"cjwzzwvxy0069cwnkea4rb3vg"},{"name":"单例模式","_id":"cjwzzwvxy006acwnkaplei1vp"},{"name":"设计模式","_id":"cjwzzwvxy006dcwnkp25auww3"}]}}