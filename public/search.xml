<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[layui结合freemarker+springboot进行前端数据表格字典转义]]></title>
    <url>%2Fblog%2F20190316%2Flayui%E5%BC%80%E5%8F%91%E4%B8%AD%E7%BB%93%E5%90%88freemarker%E5%B1%95%E7%A4%BA%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言在layui的开发中，我们经常会用到表格数据展示。但是在数据库中我们通常保存的一些状态等数据，都是枚举值，而我们在前端展示的时候就不能使用这些枚举值了，而要展示枚举值对应的意义数据。比如状态status，1=启用，0=停用。那么在layui的数据表格中，我们要展示这样的数据，写法可以是：1234567templet: function (d) &#123; if(d.status === 1)&#123; return &quot;启用&quot;; &#125; else if(d.status === 0)&#123; return &quot;停用&quot;; &#125;&#125; 但是这样的写法很low啊，我们在数据库中定义多少枚举值在这里就要写多少代码，一旦有重复使用的情况，这种写法会让我们痛不欲生。在考虑到后台使用freemarker的情况下，配置freemarker自定义标签就能很好地解决这个问题。最后我们的写法就会简化成：&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;，接下来看看如何在springboot中配置使用吧。 freemarker自定义标签介绍及使用TemplateDirectiveModel接口是freemarker自定标签或者自定义指令的核心处理接口。当模板页面遇到用户自定义的标签指令时，execute()方法会被执行。execute()方法如下。123public void execute( Environment env, Map params, TemplateModel[] loopVars, TemplateDirectiveBody body) throws TemplateException, IOException; 我们在使用freemarker自定义标签的时候需要实现该接口并且重写execute方法。 execute()方法参数解释 Environment env：系统环境变量，通常用它来输出相关内容，如Writer out = env.getOut(); Map params：自定义标签传过来的对象，就是从页面上获取的参数，其key=自定义标签的参数名，value值是TemplateModel类型，而TemplateModel是一个接口类型，通常我们都使用TemplateScalarModel接口来替代它获取一个String 值，如TemplateScalarModel.getAsString();当然还有其它常用的替代接口，如TemplateNumberModel获取number，TemplateHashModel等。在本例使用时，我们会将map转成我们自己的对象进行数据保存。 TemplateModel[] loopVars：循环替代变量 TemplateDirectiveBody body：标签中嵌套的内容，如&lt;@tag&gt;body&lt;/@tag&gt;，就是这个body 开始使用定义接收页面参数的对象1234567891011121314151617@Getter@Setterpublic class TableThTag &#123; /** * 对象属性名【需要进行对象属性获取】 */ private String objName; /** * 字典标识 */ private String nid; /** * 类型 */ private String type;&#125; 实现TemplateDirectiveModel接口并重写execute方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component@org.springframework.context.annotation.Configurationpublic class TableThDirective implements TemplateDirectiveModel &#123; Logger logger = LoggerFactory.getLogger(getClass().getName()); /** * FreeMarker自定义指令 */ @Override public void execute(Environment environment, Map map, TemplateModel[] templateModels, TemplateDirectiveBody templateDirectiveBody) throws TemplateException, IOException &#123; TableThTag tableThTag = new TableThTag(); //校验参数 try &#123; // 用来将一些 key-value 的值（例如 hashmap）映射到 bean 中的属性 BeanUtils.populate(tableThTag, map); if (StringUtils.isEmpty(tableThTag.getNid()) || StringUtils.isEmpty(tableThTag.getType())) &#123; throw new IllegalArgumentException(&quot;nid,type不能为空&quot;); &#125; &#125; catch (Exception e) &#123; logger.error(&quot;数据转化异常&quot;, e); &#125; StringBuilder html = new StringBuilder(); // 根据类型创建不同的HTML生成器 ThFormatterInterface thFormatterInterface = ThFormatterFactory.createThFormatter(tableThTag.getType()); if (thFormatterInterface != null) &#123; String dictHtml = thFormatterInterface.buildFormatterHtml(tableThTag.getNid(), tableThTag.getFieldName()); html.append(dictHtml); &#125; // 执行真正指令的执行部分: Writer out = environment.getOut(); out.write(html.toString()); if (templateDirectiveBody != null) &#123; templateDirectiveBody.render(environment.getOut()); &#125; &#125; public static BeansWrapper getBeansWrapper() &#123; BeansWrapper beansWrapper = new BeansWrapperBuilder(Configuration.VERSION_2_3_21).build(); return beansWrapper; &#125;&#125; 大家可以看到，在这个方法中，我将页面上的参数转为TableThTag对象。然后再根据前端页面不同的type类型对应实现了ThFormatterInterface的工厂对象，创建不同的html生成器。（这里考虑到扩展性，可能以后不光创建数据表格会用的到，比如下拉框什么的，也可以使用这种方式创建，所以在这里使用抽象工厂依据类型动态创建。）下面就是创建html的具体工厂以及实现方法。 ThFormatterInterface抽象工厂创建html生成器接口12345678public interface ThFormatterInterface &#123; /** * 构造生成枚举html * @param nid * @return */ String buildFormatterHtml(String nid, String fieldName);&#125; 工厂1234567891011121314151617181920212223public class ThFormatterFactory &#123; private static Logger logger = LoggerFactory.getLogger(ThFormatterFactory.class); public static ThFormatterInterface createThFormatter(String type)&#123; if(StringUtils.isEmpty(type))&#123; return new ThFormatterTemplate(); &#125; // 文件名 如果type传template 就需要有一个名为ThFormatterTemplate的文件 // 并且实现了ThFormatterInterface以及重写生成html的方法 String fileName = &quot;ThFormatter&quot; + StringUtil.firstCharUpperCase(type); //类路径 通过反射去创建实现类 String className = &quot;com.module.freemarker.impl.&quot;+fileName; //生成表头格式实现类 ThFormatterInterface thFormatterInterface = null; try &#123; thFormatterInterface =(ThFormatterInterface) Class.forName(className).newInstance(); &#125; catch (Exception e) &#123; logger.error(e.getMessage(),e); &#125; return thFormatterInterface; &#125;&#125; 实现类1234567891011121314151617181920public class ThFormatterTemplate implements ThFormatterInterface &#123; @Override public String buildFormatterHtml(String nid, String fieldName) &#123; Assert.notEMPTY(nid, &quot;nid不能为空&quot;); Assert.notEMPTY(fieldName, &quot;objName不能为空&quot;); SysDictService sysDictService = SpringContextHolder.getBean(SysDictService.class); // 通过nid查询字典类 这里不需要进行照抄 每个人都会有自己的实现方法 List&lt;SysDictBO&gt; sysDictModelList = sysDictService.findByPartnerNid(nid); StringBuilder dictHtml = new StringBuilder(); // 反正目的就是根据字典类生成对应的html就行了 需要生成的格式对照template原本应该有的写法就行了 dictHtml.append(&quot;templet: function(d)&#123; &quot;); for (SysDictBO sysDict : sysDictModelList) &#123; dictHtml.append(&quot;if(d.&quot; + fieldName + &quot; == &apos;&quot; + sysDict.getValue() + &quot;&apos;)&#123; return &apos;&quot; + sysDict.getName() + &quot;&apos;;&#125;&quot;); &#125; dictHtml.append(&quot;&#125;&quot;); return dictHtml.toString(); &#125;&#125; 最后将自定义标签注入到freemarker标签中去123456789101112131415@org.springframework.context.annotation.Configurationpublic class FreemarkerConfig &#123; @Resource private Configuration configuration; @Resource private TableThDirective tableThDirective; @PostConstruct public void setSharedVariable()&#123; configuration.setSharedVariable(&quot;th&quot;,tableThDirective); configuration.setSharedVariable(&quot;shiro&quot;,new ShiroTags()); &#125;&#125; 这样就大功告成了。 在页面上进行使用吧：&lt;@th type=&quot;template&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt; 以后进行扩展什么的也方便，比如生成下拉框：&lt;@th type=&quot;select&quot; nid=&quot;basics_sys_status&quot; objName=&quot;status&quot;&gt;&lt;/@th&gt;这样然后自动生成html的时候查出来所有的字典，根据类型生成多个出来就行了。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>freemarker</tag>
        <tag>工厂模式</tag>
        <tag>layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中map新的骚操作]]></title>
    <url>%2Fblog%2F20181209%2FJava%E4%B8%ADmap%E6%96%B0%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在Java8中对于Map的操作新增的compute之类的方法，对于开发中很有帮助，在此处整理一下其用法，以及方法之间的异同，具体的先总结一下如下： 总结computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回nullcomputeIfAbsent 就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值compute 就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package test;import java.util.HashMap;public class MapTest &#123; public static void main(String[] args) &#123; HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1,&quot;zhang&quot;); // computeIfPresent 根据之前的key/value 如果oldValue 不为null 则根据提供的方法返回一个新的值 并进行新值对旧值的替换 System.out.println(&quot; 1 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123; return key + value;//原值不为null新值不为null 新值替换旧值 &#125;)); // 否则删除键值对 System.out.println(&quot; 2 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123; return null;//原值不为null新值为null 删除键值对 &#125;)); map.put(1,null); System.out.println(&quot; 3 ---&gt; &quot; + map.computeIfPresent(1,(key,value)-&gt;&#123; return &quot;jiaheng&quot;;//原值为null 不做更改 &#125;)); // computeIfAbsent 根据之前的key 如果旧值为空或者key不存在 就按照方法用新值替换旧值 新值为null不做替换 map.put(1,&quot;zhang&quot;); System.out.println(&quot; 4 ---&gt; &quot; + map.computeIfAbsent(1,k-&gt;&#123; return null;// 不会被替换旧值 返回原值 &#125;)); System.out.println(&quot; 5 ---&gt; &quot; + map.computeIfAbsent(2,k-&gt;&#123; k = k*k; return k.toString();// key=2不存在 直接新建并存入新值 &#125;)); // compute类似于computeIfAbsent和computeIfPresent的合体 map.put(1,null); System.out.println(&quot; 6 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123; return &quot;张&quot;;// 原值为null新值不为null 新值替换旧值 此处与computeIfPresent不同 &#125;)); System.out.println(&quot; 7 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123; v = (k*10) + v; return v;// 新值不为null 替换旧值 &#125;)); System.out.println(&quot; 8 ---&gt; &quot; + map.compute(1,(k,v)-&gt;&#123; return null;// 新值为null 删除键值对 &#125;)); // 总结 // computeIfPresent 就是根据方法来，返回方法中的值对原值进行替换，新的为null就删除键值对，但是原值为null新值不为null依然返回null // computeIfAbsent 就是根据旧值来，旧的没有再根据方法返回的来，旧值存在就返回旧值 // compute 就是两者结合，新值为null，就删除键值对；新值不为null就进行替换。 &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodepad++不用插件去重的方法]]></title>
    <url>%2Fblog%2F20181112%2Fnodepad-%E4%B8%8D%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在工作中，当我们需要对一个文本中的行进行去重统计的时候，会发现对于文本的去重并不是那么好处理。而nodepad++的去重插件一般人又懒得去安装，不巧在网上找到这样一个去重的小技巧，即使用正则表达式进行去重，简直方便快捷。在这里分享出来，希望大家能够用的上。1^(.*?)$\s+?^(?=.*^\1$) 点击全部替换，就可以将重复行全部去掉喽]]></content>
      <categories>
        <category>hexo博客配置</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>工作技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客文章置顶方式]]></title>
    <url>%2Fblog%2F20180904%2Fhexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[博文置顶目前已经有修改后支持置顶的仓库，可以直接用以下命令安装12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：123456---title: hexo博客置顶date: 2017-09-08 12:00:25categories: 博客搭建系列top: true--- 到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，紧接着下一行插入如下代码：12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 至此，博客置顶的方式就全部完成了]]></content>
      <categories>
        <category>hexo博客配置</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰国7天6晚自由行攻略]]></title>
    <url>%2Fblog%2F20180904%2F%E6%B3%B0%E5%9B%BD7%E5%A4%A96%E6%99%9A%E8%87%AA%E7%94%B1%E8%A1%8C%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[人生不可能是一场说走就走的旅行，但心怀远方的人，一定要时刻做着说走就走的准备！ 关于去泰国这件事情，可能发生的很突然，但是没关系，既然决定了，就把它安排在计划里。 一、出行前的准备1、护照&amp;签证我是在杭州工作，在杭州工作社保交满一年，就可以办护照了。拿着身份证在西湖区行政服务中心的出入境管理那儿就可以办理了。现在一楼自助打印下社保证明，然后去后面的楼，出入境办理区按照流程办理即可。大概一个多礼拜就能拿到护照，我也没想到有这么快。 签证是在淘宝上买的，260￥。七个工作日到手。 2、泰铢&amp;电话卡&amp;出入境&amp;去泰国的必备软件&amp;其他泰国新规定，过境签、落地签-10000泰铢或等值外币现金（每人），20000泰铢（家庭）；旅游签-20000泰铢或等值外币现金（每人），40000泰铢（家庭），抽查到概率很低，一般落地签会查的吧。但是网上说好像都不查的，或者很少查，但还是换两千的吧。 然后再淘宝买泰国7天happy卡，我买的是这家的，8天无限流量，4G。 入境时需要填写出入境卡，然后和护照一起交给海关查看盖章。下面是入境卡中文说明图： 一般情况下，在乘坐航班时常会有工作人员在抵达目的地钱给乘客发放出入境卡，以便乘客提前填好出入境卡，方便出关。护照也很重要，可以在国内出发前复印几份护照一定要放行李箱，不要随身携带。 END - 其他一些实用信息 大使馆/领事馆 中国驻泰国大使馆地址：NO.57, Racgadapisek Road, Bangkok电话：+66-02-2450088领事保护电话：+66-854833327（24小时值班手机），+66-02-2457010（工作日9：00-17：00） 中国驻清迈总领事馆地址：111 Changloh Road, Haiya District, Chiangmai电话：+66-53-280380，+66-53-276125，+66-53-276457 中国驻宋卡总领事馆（近普吉岛、苏梅岛、甲米）地址：9 Sadao Road, Songkhla电话：+66-74-322034领事保护电话：+66-817665560 中国驻宋卡总领馆驻普吉领事办公室电话：+66-76-304219领事保护电话：+66-945956168（中文、泰文），+66-945986859（中文） 中国驻孔敬总领馆地址：142/44 Moo 2，Rob-Bueng Rd.，Nai-Muang， Muang， Khon Kaen电话：+66-43-226873 紧急电话 警察:123/191火警:199救护:2460199领事:022-457010大使馆:022-457044旅游投诉:1155]]></content>
      <categories>
        <category>个人随笔</category>
      </categories>
      <tags>
        <tag>个人随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql数据库group by]]></title>
    <url>%2Fblog%2F20180811%2F%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-20180828%2F</url>
    <content type="text"><![CDATA[Mysql数据库根据多个字段进行分组统计如下图，表order为订单表，字段以及数据如下： 现在想要根据表中的信息，查询每天不同的商户有多少笔订单，以及订单的总金额。需要完成以上查询，就需要进行group by多个字段统计，统计sql如下：12345678910SELECT store_name, DATE_FORMAT(add_time, &apos;%Y-%m-%d&apos;) AS addDate, count(1) AS total, sum(order_money) AS total_moneyFROM `order`GROUP BY DATE_FORMAT(add_time, &apos;%Y-%m-%d&apos;), store_name; 统计查询得到的数据结果如下：]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo获取注册中心的实例bean]]></title>
    <url>%2Fblog%2F20180719%2F%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-20180718%2F</url>
    <content type="text"><![CDATA[开发日记 20180718com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR Data length too large1com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR Data length too large: 11557050, max payload: 8388608 java.io.IOException: Data length too large: 11557050, max payload: 838860 在使用dubbo框架开发的时候，需要做一个导出csv文件的功能，查询大量的数据然后在提供者这边进行处理导出，其中数据达到过20万行以上，几十M的数据，抛出了这样一个异常。遇到服务提供者从数据库查询或者其他地方返回过大的对象，导致报错时，尽管有办法取消这个数据长度的限制，但是这并不符合程序开发的初衷。我们需要将对于数据的处理放在业务层，我在这里做了异步导出，给前端返回的仅仅是一个程序完成的状态，完美的解决了这个问题。 在dubbo消费者服务中写aop方法拦截工具类中的方法尽管服务的提供者和消费者都引入的工具类模块的依赖，但是拦截器的实际拦截的还是那个实际本身所在模块的方法。如果工具类是在消费者service层被使用的，那么在上层模块的拦截器是无法拦截到这个方法的。 在dubbo服务中手动获取注册的提供者的bean在这里犯的错：以为通过SpringContextHolder.getBean()可以获取，是我傻逼了，dubbo中的服务怎么能用spring上下文获取呢。这里我使用dubbo的方式完成了这个功能。1234567891011121314151617181920/** * 获取服务的代理对象 * * @return */public static &lt;T&gt; T getReferenceConfig(String appName,String address,Class&lt;?&gt; interfaceClass) &#123; String key = interfaceClass.getName(); ReferenceConfig&lt;T&gt; referenceConfig = (ReferenceConfig&lt;T&gt;)referenceCache.get(key); if(referenceConfig == null)&#123; referenceConfig = new ReferenceConfig&lt;T&gt;(); referenceConfig.setApplication(application); referenceConfig.setRegistry(getRegistryConfig(appName,address)); referenceConfig.setInterface(interfaceClass); referenceCache.put(key,referenceConfig); &#125; return referenceConfig.get();&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于IDEA再从git或者svn上导入项目时不能加载字模块的问题]]></title>
    <url>%2Fblog%2F20180708%2F%E5%85%B3%E4%BA%8EIDEA%E5%86%8D%E4%BB%8Egit%E6%88%96%E8%80%85svn%E4%B8%8A%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%8D%E8%83%BD%E5%8A%A0%E8%BD%BD%E5%AD%97%E6%A8%A1%E5%9D%97%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于IDEA再从git或者svn上导入项目时不能加载字模块的问题 最近入职新公司，很多东西也都算是要从头学起。在之前公司用的都是eclipse，这边要求用IDEA，其实很早就知道这是一个非常强大的编译器，但平时没有机会使用，现在有机会用这个还是挺开心的。 由于公司使用gitlab，在注册好账号导入代码的时候遇到一个情况，就是直接用IDEA的git工具导入的话会出现，maven项目的子模块无法被识别以及被管理的情况。事实上eclipse也有同样的问题。现在只说下使用IDEA遇到这个情况的解决办法。 有两种解决方式。1、手动将module添加到项目管理： 打开文件选项中的项目结构（快捷键ctrl+alt+shift+s） 选择 模块-加号-导入module，手动将自己需要的模块一一导入进去2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了 从eclipse转到IDEA前几天是最艰难的，因为很多习惯不是说改就能改掉的，工具的使用总得需要一个学习的时间，但是等这段时间过去，后面一定会体会到IDEA的强大。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
        <tag>IDEA</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念即将结束的第一份工作]]></title>
    <url>%2Fblog%2F20180628%2F%E7%BA%AA%E5%BF%B5%E5%8D%B3%E5%B0%86%E7%BB%93%E6%9D%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[纪念即将 结束的第一份工作 我一直都不知道自己想要得到些什么东西 记得高中的时候，身边不管是家人还是老师，总会时刻不停在耳边说着：你需要如何如何学习，考上一个怎样的大学，进入一个怎么样的专业，以后找一个怎样的工作。可是当我听到这些话时总是会很反感。也许是叛逆，也许是这些对于我当时都是些虚无缥缈，很遥远的东西，我没有办法理解自己得到这些东西有什么用。但是虽然忠言不入耳，我还是得按照他们说的做。还好，大学上了一个普通的理工科一本。 当上了大学之后，没有了老师家长在耳边“絮叨”，更不知道自己要干什么了。记得当时参加各种社团，觉得在社团里面干的风风火火很牛逼，甚至课程都不上几节，最严重的时候好几周都不上课。浑浑噩噩的度过了大学的第一年之后，突然因为一个给学校编程培训班试听课凑人数的机会，让自动化专业的我接触到了软件开发这个方向。依然记得当时上课的老师，老范！当他用C语言在电脑上输出一串笑脸字符的时候，我当时的眼睛都亮了，我对和自己一块去凑人数的舍友说，这个人一定以后对我有很大的帮助，我一定要报名他的课程。后来真的觉得我是幸运的，老范是一个很有人格魅力的中年程序员 :) 。也是他让我知道了程序员是做什么的，也是他让我非常期待自己能够成为一个真正的软件开发者。 就这样我跟着老范从计算机基础，学到数据结构与算法，学计算机网络，MySQL，学习设计模式，学C++，后来又在另一个班学Java。计算机硬件方向专业的我，学完了软件专业学生要学的所有课程。终于大三，我找到了西安三星电子研究所的一份实习，写了两个月shell脚本，学习了Linux相关的知识以及自动化测试的东西，后来又在组内用PHP写了个网站，提供给大家进行会议的预定与提醒。现在想想这一切经验都是我的宝贵的财富. 实习结束后，工作却找的不是很顺利，也许是自己的实习经历没有太多做Java开发的东西，导致自己没有什么实际的项目经验。后来，我来了同※※。 或许离开这里是我最正确的选择 在拿到offer来到同※※之前，我觉得我来到了一个很好的大公司。事实上这里也没有很差，除了我所在的部门。同※※是国内最早做股票交易平台的软件公司，目前也有自己的大楼，装修的也很不错，很像一个一线的大型互联网公司。然而，只是很像而已。从一件很平常的事就看得出来：每天饭点，后勤部经理就站在食堂打饭窗口对打饭的员工喊，少打一点少打一点，他们吃不完！ … … 其实我刚来的时候觉得自己可以呆三年的，现在想想真的很抱歉，我得走了。并不是因为上面的“打饭”。我来到这里做的工作都是外包的，在B2B部门。我本来以为大公司的工作流程都很规范，没想到在这里刷新了我的三观哈哈。外包工作什么都得听客户的，乱改需求不说，自己公司的运维根本派不上用场，连tomcat的启动报错都不知道怎么解决，让我们作为开发的去同时做开发、测试、运维、项目经理、产品的活，想想就火大。项目经理把客户电话甩给你，自己沟通去，然后自己潇洒的下班。 唉ε=(′ο｀*)))，不想再说太多了，显得自己好像太小气，都要走了还要diss前公司。但是，我觉得我是真的得走了，而且我还算是忍得时间长的。我们组，比我来得晚，比我走的早的人，超过了10个。才一年啊。作为一个刚毕业一年的程序员，真的心好累。 接下来的路少交点儿朋友，否则离开时会难受 要走了要走了，却又感觉很难受。在这里，我接触过不少傻逼，但是也真的交到很多有趣的朋友。甚至有那种就算离职了，之后也不会断了联系的。在这个城市，原本独自一人的生活由他们，真的不会无聊。 天涯途上谁是客，散席时怎么分？ 也许有些人分开就不会再见，有些人想不见却总会出现在生活里。罢了，以后换到新的公司，不要再走心了。况且，真正值得走心的，也不会很多！ ✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。 ——《行歌》 · 陈鸿宇]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于git pull 拉取不到最新记录]]></title>
    <url>%2Fblog%2F20180531%2F%E5%85%B3%E4%BA%8Egit-pull-%E6%8B%89%E5%8F%96%E4%B8%8D%E5%88%B0%E6%9C%80%E6%96%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[////1234567891011121314151617181920//~~~~~~~~~~~~~~~~~~~~~~o8888888o//~~~~~~~~~~~~~~~~~~~~~~88&quot;~.~&quot;88//~~~~~~~~~~~~~~~~~~~~~~(|~-_-~|)//~~~~~~~~~~~~~~~~~~~~~~0\~~=~~/0//~~~~~~~~~~~~~~~~~~~~___/`---&apos;\___//~~~~~~~~~~~~~~~~~~.&apos;~\\|~~~~~|//~&apos;.//~~~~~~~~~~~~~~~~~/~\\|||~~:~~|||//~\//~~~~~~~~~~~~~~~~/~_|||||~-:-~|||||-~\//~~~~~~~~~~~~~~~|~~~|~\\\~~-~~///~|~~~|//~~~~~~~~~~~~~~~|~\_|~~&apos;&apos;\---/&apos;&apos;~~|_/~|//~~~~~~~~~~~~~~~\~~.-\__~~&apos;-&apos;~~___/-.~///~~~~~~~~~~~~~___&apos;.~.&apos;~~/--.--\~~`.~.&apos;___//~~~~~~~~~~.&quot;&quot;~&apos;&lt;~~`.___\_&lt;|&gt;_/___.&apos;~&gt;&apos;~&quot;&quot;.//~~~~~~~~~|~|~:~~`-~\`.;`\~_~/`;.`/~-~`~:~|~|//~~~~~~~~~\~~\~`_.~~~\_~__\~/__~_/~~~.-`~/~~///~~~~~=====`-.____`.___~\_____/___.-`___.-&apos;=====//~~~~~~~~~~~~~~~~~~~~~~~`=---=&apos;//////~~~~~~~~~~~~~~~~~~~~~~~~~ ////~~~佛祖保佑~~~~~永无BUG////// 使用git pull 获取不到最新的记录，判断应该是某些时候未pull先commit导致的，使用命令：git pull origin master即可解决]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【陈年风楼】VLOG-000001 一个普通的程序员的普通的一天]]></title>
    <url>%2Fblog%2F20180421%2Fvlog-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot微服务搭建]]></title>
    <url>%2Fblog%2F20180327%2Fspring-boot%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本人的csdn传送门 前言 进行web开发的时候Java程序员们难免会碰到那种很小的服务，比如就提供一个生成订单号的接口，或者一个上传文件的服务。而这时我们再去使用SpringMVC这种体量稍大、配置繁琐的框架开发难免会加大工作量，而且是不必要的。这个时候我们就可以选择使用这个微服务框架——springboot进行开发。 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 springboot框架的搭建与简单的REST风格的MVC架构demo首先，建立一个新的maven工程，pom文件主要内容如下：123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 其中核心依赖是 spring-boot-starter-web1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 访问静态资源文件可以加入模板：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 编写Application.java文件，存放于src/main/java这个目录下这里是springboot的核心启动类12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan@EnableAutoConfigurationpublic class Application&#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 事实上，这个时候已经把框架搭建好了，运行以上main方法即可启动这个项目，但是我们现在看不到效果，接下来，就可以像SpringMVC一样加入MVC三层结构的代码了，目录结构如下图： 其中各层代码如下： controller12345678910111213141516171819202122232425262728package com.zhang.controller;import java.util.HashMap;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.servlet.ModelAndView;import com.zhang.entity.Photo;import com.zhang.service.mainService;@RestController@RequestMapping(&quot;/photo&quot;)public class mainController &#123; @Autowired private mainService mainservice; @RequestMapping(&quot;/&quot;) public ModelAndView index(ModelAndView mav)&#123; mav.addObject(&quot;hello&quot;, &quot;这是项目主页，访问根目录到达~~&quot;); mav.setViewName(&quot;index&quot;); return mav; &#125; @RequestMapping(&quot;/getPhoto&quot;) public Object doIt()&#123; Map&lt;String, Photo&gt; map = new HashMap&lt;String, Photo&gt;(); map.put(&quot;photo&quot;, mainservice.getPhotoById(123)); return map; &#125;&#125; service实现类12345678910111213141516171819package com.zhang.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.zhang.dao.mainDao;import com.zhang.entity.Photo;import com.zhang.service.mainService;@Service(&quot;mainservice&quot;)public class mainServiceImpl implements mainService &#123; @Autowired private mainDao maindao; @Override public Photo getPhotoById(int id) &#123; return maindao.getPhotoNameById(id); &#125;&#125; dao实现类12345678910111213141516171819package com.zhang.dao.impl;import org.springframework.stereotype.Repository;import com.zhang.dao.mainDao;import com.zhang.entity.Photo;@Repository(&quot;maindao&quot;)public class mainDaoImpl implements mainDao &#123; @Override public Photo getPhotoNameById(int id) &#123; Photo p = new Photo(); p.setId(123); p.setName(&quot;雪山行纪念照&quot;); return p; &#125;&#125; 实体类photo1234567891011121314151617package com.zhang.entity;public class Photo &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 启动项目 项目默认端口为8080，在浏览器中访问刚才的controller会看到： 如上，一个REST风格的MVC架构的demo项目就搭建完成了。]]></content>
      <categories>
        <category>框架相关</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校招面试【京东、顺丰科技、招银网络科技、去哪儿网】]]></title>
    <url>%2Fblog%2F20160927%2F%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[2017校招过的太惨了，还一度把原因怪罪在实习上，认为自己实习了4个月非Java研发的东西导致自己对于Java没有进行更加深入的学习，其实呢，还是应该怪自己不努力，怪不得其他。*从三星离职之后就开始找一些公众号内推，我是来自非985、211院校的本科生，学的还是自动化专业，偏硬件，实习内容还不是Java开发之类的东西，不知道是由于这些公众号的原因（恶意吸引粉丝）还是自己的简历确实有问题，内推一直不顺利。烦得很。之后又从9月开始海投Java软件开发岗，各种在线笔试。博主的基础（计算机网络操作系统等）本身就不强，C/C++/Java/PHP等还有HTML/CSS/JS/jQuery这些乱七八糟都学，算法和数据结构也学得不是很精，应付不来笔试编程题，感觉面试过的公司好少，妈的工作要找到十月了。 首先说下招银电面： 9月23号晚上八点正在理发染发呢电话就来了，都不预约一下。1、在Java中进行数据库连接并操作数据的步骤？最后需要进行什么操作？2、项目中使用jquery，那么on、bind、live、delegate这几个函数有什么区别？3、一个http请求所包含的数据格式是什么？4、一次http请求的详细处理过程？5、一次struts处理请求从开始到看到页面数据之间都发生了什么，整个详细过程？6、项目中都用到了什么框架？（spring+struts+mybatis）7、在自己的项目中有没有用到并发？如果让你现在考虑给你的项目中考虑并发你会怎么做？你要控制（进行同步）的数据源是哪些？还有几个吧，想不起来了，应该比较简单就没有印象。电面后预约28号下午再面试。 招银现场面===该来的就这样来了9月28号下午，不知道哪里来的自信感觉自己能够在一个半小时之内从长安赶到永宁门，坐地铁还把安远门当成了永宁门，到了安远门叫个优步，打电话让司机快一点，妈的竟然给我取消了，害我最后坐公交去，迟到了半个小时。心态爆炸！！！╮(╯▽╰)╭1、去了在房间里等着，过会儿从酒店房间出来一个，叫我进去面试。先问我要了成绩单和一些证书，感觉招银对于成绩和证书很看重。面试官是三个人，3V1，很紧张有木有。中间坐着老大，然后一个问技术的，一个HR。2、自我介绍3、介绍一下自己的项目4、项目中是使用servlet编写的后台代码，为什么不用开源框架？5、如果要给项目中添加日志，该如何做？6、一个struts请求从输入URL到显示在页面上都经过了哪些过程？7、中间老大看我写着struts1，就问为什么使用struts1而不是struts2，有研究过两者的区别吗？8、给一个string，问如何不使用任何库函数也不转化为数组，如何逆序？就这么多问题，心态爆炸！怀疑人生！阿弥陀佛！ 京东一面： 9月24日一早6点就爬起来了，昨晚一晚上都没睡好。做梦都在想着一些多线程常考的东西，果然第二天就问了。1、了解哪些常用的集合（set、list、map）？说说他们各自的特点（ArrayList和LinkedList等）？2、HashMap、HashTable的区别？HashMap扩容为什么是2倍？如何实现的？3、说一说线程调度机制？对线程池有何理解？哪里会用到线程池？好处是？4、JVM中如果有一个线程挂起了，用什么工具去查找这个线程？5、Java在什么时候会内存溢出？持久代内存溢出是什么情况？6、动态代理的实现？（从动态代理答到了springAOP）7、装饰模式了解吗？它的特点是什么？8、I/O库中都用到了什么设计模式？9、struts的一次请求是如何处理的？10、网络编程？socket？11、数据库索引了解吗？一个表中什么情况适合建立索引？如何去建立数据库索引？12、快速排序的时间复杂度、原理？13、java多态的实现原理？动态绑定底层虚拟机是如何实现的？14、forward和redirect的区别？同样。。。有很多问题没想起来，一面半个多小时，后天二面。。 京东二面： 感觉一面回答的不好，全程面试官问什么我答什么，一点互动都没有，狠狠狠紧张！二面抱着无所谓的心态去的，倒还没有一面紧张。1、了解那些算法和设计模式，说说你都用他们在什么地方？（贪心、回溯、分治、动态规划 || 单例模式、工厂模式、动态代理、装饰模式、适配器模式等，说了说单例工厂动态代理等，再说到JDK动态代理和CGLIB代理的区别，一顿乱侃）2、你的项目中那些都用到了多服务器？分布式了解吗？还问到了跨域请求。在实习的时候开发的网站也是单机吗？（从这儿开始问分布式集群服务器，高并发，这方面没怎么深入学习哎）3、设计一个抢购商品的系统需要考虑到那些问题？4、对于线程池有什么理解？5、消息队列？6、知道红黑树吗？平衡树？有什么区别？算了不写了，想不起来了，估计二面跪了。。。 顺丰技术面： 9月24日下午5点，就是京东一面的下午。。。（除了技术面就是HR）1、简单的自我介绍一下。。。2、介绍自己认为最能体现自己能力的项目，跟着项目引出很多题目，问了个透彻。。。3、觉得自己还有那些方面的能力没有体现出来，可以说一说？（在这里傻逼了，我他喵说我暂时想不起来。因为可能自己的项目有点简单了，面试官还想要看看自己其他的能力，醉醉哒）顺丰科技面试就这样，问了40多分钟，结果问完就让我走了，伤心，怪自己傻逼了。另一个西电的技术面玩就直接HR面了，让我回来等通知，4天了都没有通过不通过的通知，也是厉害。挂了也不让我安心挂！ 去哪儿网 9月29号下午3点好像感觉自己真的是，干什么事情完全不做任何准备的，很多看过的问题，在面试的时候就只能说有印象，答不详细，想抽死自己！1、去哪儿在金沙国际酒店面试，一天内面完，对去哪儿抱了很大希望，因为听学长说这个面试不难，问的比较基础，妈的现在写这段话还是想扇自己。2、刚见到面试官，他拿到简历就说，你是本科生啊？我说哦。。。然后就是自我介绍。。。3、给我了一张纸，在纸上写出自己用过的所有的类名。。。然后他在一边电脑上敲着东西。突然让写自己用过的所有的类的类名，脑子有点儿蒙了。4、说说mysql的引擎吧，说了myisam和innodb以及其区别，这个看过。5、mysql的各种连接是怎么回事？6、说说B树和B+树的区别吧。7、哈希冲突的解决算法？8、说说HashMap的实现原理？9、有什么问题问我？10、还有一些忘记了。。。/(ㄒoㄒ)/~~。。。都是些很简单的问题，妈的就是答得不好不够详细。 总结 ： 菜鸟的求职之路总是艰辛的，校招时间还长，十月份还有几家面试（觉得自己的脸火辣辣的疼。。。），看到人都拿到了很好的Offer，不服啊！哎，语言总是苍白的，只有安心敲代码！！！！！！！！！国庆七天奋发图强，多看看Java并发编程实战那书上的东西吧，问得太多了。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>个人随笔</tag>
        <tag>面试经历</tag>
      </tags>
  </entry>
</search>
