<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo博客文章置顶方式]]></title>
    <url>%2Fblog%2F20180904%2Fhexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[博文置顶目前已经有修改后支持置顶的仓库，可以直接用以下命令安装12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章：123456---title: hexo博客置顶date: 2017-09-08 12:00:25categories: 博客搭建系列top: true--- 到目前为止，置顶功能已经可以实现了。下面可以设置明确的置顶标志：打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，紧接着下一行插入如下代码：12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 至此，博客置顶的方式就全部完成了]]></content>
      <tags>
        <tag>开发日记</tag>
        <tag>博客设置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰国7天6晚自由行攻略]]></title>
    <url>%2Fblog%2F20180904%2F%E6%B3%B0%E5%9B%BD7%E5%A4%A96%E6%99%9A%E8%87%AA%E7%94%B1%E8%A1%8C%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[人生不可能是一场说走就走的旅行，但心怀远方的人，一定要时刻做着说走就走的准备！]]></content>
      <tags>
        <tag>旅行记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发日记-20180828]]></title>
    <url>%2Fblog%2F20180811%2F%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-20180828%2F</url>
    <content type="text"><![CDATA[Mysql数据库根据多个字段进行分组统计如下图，表order为订单表，字段以及数据如下： 现在想要根据表中的信息，查询每天不同的商户有多少笔订单，以及订单的总金额。需要完成以上查询，就需要进行group by多个字段统计，统计sql如下：12345678910SELECT store_name, DATE_FORMAT(add_time, &apos;%Y-%m-%d&apos;) AS addDate, count(1) AS total, sum(order_money) AS total_moneyFROM `order`GROUP BY DATE_FORMAT(add_time, &apos;%Y-%m-%d&apos;), store_name; 统计查询得到的数据结果如下：]]></content>
      <tags>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发日记-20180718]]></title>
    <url>%2Fblog%2F20180719%2F%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-20180718%2F</url>
    <content type="text"><![CDATA[开发日记 20180718com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR Data length too large1com.alibaba.dubbo.remoting.transport.AbstractCodec.checkPayload() ERROR Data length too large: 11557050, max payload: 8388608 java.io.IOException: Data length too large: 11557050, max payload: 838860 在使用dubbo框架开发的时候，需要做一个导出csv文件的功能，查询大量的数据然后在提供者这边进行处理导出，其中数据达到过20万行以上，几十M的数据，抛出了这样一个异常。遇到服务提供者从数据库查询或者其他地方返回过大的对象，导致报错时，尽管有办法取消这个数据长度的限制，但是这并不符合程序开发的初衷。我们需要将对于数据的处理放在业务层，我在这里做了异步导出，给前端返回的仅仅是一个程序完成的状态，完美的解决了这个问题。 在dubbo消费者服务中写aop方法拦截工具类中的方法尽管服务的提供者和消费者都引入的工具类模块的依赖，但是拦截器的实际拦截的还是那个实际本身所在模块的方法。如果工具类是在消费者service层被使用的，那么在上层模块的拦截器是无法拦截到这个方法的。 在dubbo服务中手动获取注册的提供者的bean在这里犯的错：以为通过SpringContextHolder.getBean()可以获取，是我傻逼了，dubbo中的服务怎么能用spring上下文获取呢。这里我使用dubbo的方式完成了这个功能。1234567891011121314151617181920/** * 获取服务的代理对象 * * @return */public static &lt;T&gt; T getReferenceConfig(String appName,String address,Class&lt;?&gt; interfaceClass) &#123; String key = interfaceClass.getName(); ReferenceConfig&lt;T&gt; referenceConfig = (ReferenceConfig&lt;T&gt;)referenceCache.get(key); if(referenceConfig == null)&#123; referenceConfig = new ReferenceConfig&lt;T&gt;(); referenceConfig.setApplication(application); referenceConfig.setRegistry(getRegistryConfig(appName,address)); referenceConfig.setInterface(interfaceClass); referenceCache.put(key,referenceConfig); &#125; return referenceConfig.get();&#125;]]></content>
      <tags>
        <tag>开发日记</tag>
        <tag>dubbo</tag>
        <tag>我的BUGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于IDEA再从git或者svn上导入项目时不能加载字模块的问题]]></title>
    <url>%2Fblog%2F20180708%2F%E5%85%B3%E4%BA%8EIDEA%E5%86%8D%E4%BB%8Egit%E6%88%96%E8%80%85svn%E4%B8%8A%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%97%B6%E4%B8%8D%E8%83%BD%E5%8A%A0%E8%BD%BD%E5%AD%97%E6%A8%A1%E5%9D%97%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于IDEA再从git或者svn上导入项目时不能加载字模块的问题 最近入职新公司，很多东西也都算是要从头学起。在之前公司用的都是eclipse，这边要求用IDEA，其实很早就知道这是一个非常强大的编译器，但平时没有机会使用，现在有机会用这个还是挺开心的。 由于公司使用gitlab，在注册好账号导入代码的时候遇到一个情况，就是直接用IDEA的git工具导入的话会出现，maven项目的子模块无法被识别以及被管理的情况。事实上eclipse也有同样的问题。现在只说下使用IDEA遇到这个情况的解决办法。 有两种解决方式。1、手动将module添加到项目管理： 打开文件选项中的项目结构（快捷键ctrl+alt+shift+s） 选择 模块-加号-导入module，手动将自己需要的模块一一导入进去2、先将项目通过命令行导入到本机，然后通过IDEA的New Project from Existing Sources导入本地项目进来，这个直接就能够对所有模块进行代码管理了 从eclipse转到IDEA前几天是最艰难的，因为很多习惯不是说改就能改掉的，工具的使用总得需要一个学习的时间，但是等这段时间过去，后面一定会体会到IDEA的强大。]]></content>
      <tags>
        <tag>开发日记</tag>
        <tag>IDEA</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念即将结束的第一份工作]]></title>
    <url>%2Fblog%2F20180628%2F%E7%BA%AA%E5%BF%B5%E5%8D%B3%E5%B0%86%E7%BB%93%E6%9D%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[纪念即将 结束的第一份工作 我一直都不知道自己想要得到些什么东西 记得高中的时候，身边不管是家人还是老师，总会时刻不停在耳边说着：你需要如何如何学习，考上一个怎样的大学，进入一个怎么样的专业，以后找一个怎样的工作。可是当我听到这些话时总是会很反感。也许是叛逆，也许是这些对于我当时都是些虚无缥缈，很遥远的东西，我没有办法理解自己得到这些东西有什么用。但是虽然忠言不入耳，我还是得按照他们说的做。还好，大学上了一个普通的理工科一本。 当上了大学之后，没有了老师家长在耳边“絮叨”，更不知道自己要干什么了。记得当时参加各种社团，觉得在社团里面干的风风火火很牛逼，甚至课程都不上几节，最严重的时候好几周都不上课。浑浑噩噩的度过了大学的第一年之后，突然因为一个给学校编程培训班试听课凑人数的机会，让自动化专业的我接触到了软件开发这个方向。依然记得当时上课的老师，老范！当他用C语言在电脑上输出一串笑脸字符的时候，我当时的眼睛都亮了，我对和自己一块去凑人数的舍友说，这个人一定以后对我有很大的帮助，我一定要报名他的课程。后来真的觉得我是幸运的，老范是一个很有人格魅力的中年程序员 :) 。也是他让我知道了程序员是做什么的，也是他让我非常期待自己能够成为一个真正的软件开发者。 就这样我跟着老范从计算机基础，学到数据结构与算法，学计算机网络，MySQL，学习设计模式，学C++，后来又在另一个班学Java。计算机硬件方向专业的我，学完了软件专业学生要学的所有课程。终于大三，我找到了西安三星电子研究所的一份实习，写了两个月shell脚本，学习了Linux相关的知识以及自动化测试的东西，后来又在组内用PHP写了个网站，提供给大家进行会议的预定与提醒。现在想想这一切经验都是我的宝贵的财富. 实习结束后，工作却找的不是很顺利，也许是自己的实习经历没有太多做Java开发的东西，导致自己没有什么实际的项目经验。后来，我来了同※※。 或许离开这里是我最正确的选择 在拿到offer来到同※※之前，我觉得我来到了一个很好的大公司。事实上这里也没有很差，除了我所在的部门。同※※是国内最早做股票交易平台的软件公司，目前也有自己的大楼，装修的也很不错，很像一个一线的大型互联网公司。然而，只是很像而已。从一件很平常的事就看得出来：每天饭点，后勤部经理就站在食堂打饭窗口对打饭的员工喊，少打一点少打一点，他们吃不完！ … … 其实我刚来的时候觉得自己可以呆三年的，现在想想真的很抱歉，我得走了。并不是因为上面的“打饭”。我来到这里做的工作都是外包的，在B2B部门。我本来以为大公司的工作流程都很规范，没想到在这里刷新了我的三观哈哈。外包工作什么都得听客户的，乱改需求不说，自己公司的运维根本派不上用场，连tomcat的启动报错都不知道怎么解决，让我们作为开发的去同时做开发、测试、运维、项目经理、产品的活，想想就火大。项目经理把客户电话甩给你，自己沟通去，然后自己潇洒的下班。 唉ε=(′ο｀*)))，不想再说太多了，显得自己好像太小气，都要走了还要diss前公司。但是，我觉得我是真的得走了，而且我还算是忍得时间长的。我们组，比我来得晚，比我走的早的人，超过了10个。才一年啊。作为一个刚毕业一年的程序员，真的心好累。 接下来的路少交点儿朋友，否则离开时会难受 要走了要走了，却又感觉很难受。在这里，我接触过不少傻逼，但是也真的交到很多有趣的朋友。甚至有那种就算离职了，之后也不会断了联系的。在这个城市，原本独自一人的生活由他们，真的不会无聊。 天涯途上谁是客，散席时怎么分？ 也许有些人分开就不会再见，有些人想不见却总会出现在生活里。罢了，以后换到新的公司，不要再走心了。况且，真正值得走心的，也不会很多！ ✊成长是一场游戏，勇敢的人先开始。跌撞慌张前行，不说回头。 ——《行歌》 · 陈鸿宇]]></content>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot微服务搭建]]></title>
    <url>%2Fblog%2F20180627%2Fspring-boot%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本人的csdn传送门 前言 进行web开发的时候Java程序员们难免会碰到那种很小的服务，比如就提供一个生成订单号的接口，或者一个上传文件的服务。而这时我们再去使用SpringMVC这种体量稍大、配置繁琐的框架开发难免会加大工作量，而且是不必要的。这个时候我们就可以选择使用这个微服务框架——springboot进行开发。 Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 springboot框架的搭建与简单的REST风格的MVC架构demo首先，建立一个新的maven工程，pom文件主要内容如下：123456789101112131415161718192021222324252627282930313233343536373839&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.2.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 其中核心依赖是 spring-boot-starter-web1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 访问静态资源文件可以加入模板：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 编写Application.java文件，存放于src/main/java这个目录下这里是springboot的核心启动类12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan@EnableAutoConfigurationpublic class Application&#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 事实上，这个时候已经把框架搭建好了，运行以上main方法即可启动这个项目，但是我们现在看不到效果，接下来，就可以像SpringMVC一样加入MVC三层结构的代码了，目录结构如下图： 其中各层代码如下： controller12345678910111213141516171819202122232425262728package com.zhang.controller;import java.util.HashMap;import java.util.Map;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.servlet.ModelAndView;import com.zhang.entity.Photo;import com.zhang.service.mainService;@RestController@RequestMapping(&quot;/photo&quot;)public class mainController &#123; @Autowired private mainService mainservice; @RequestMapping(&quot;/&quot;) public ModelAndView index(ModelAndView mav)&#123; mav.addObject(&quot;hello&quot;, &quot;这是项目主页，访问根目录到达~~&quot;); mav.setViewName(&quot;index&quot;); return mav; &#125; @RequestMapping(&quot;/getPhoto&quot;) public Object doIt()&#123; Map&lt;String, Photo&gt; map = new HashMap&lt;String, Photo&gt;(); map.put(&quot;photo&quot;, mainservice.getPhotoById(123)); return map; &#125;&#125; service实现类12345678910111213141516171819package com.zhang.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.zhang.dao.mainDao;import com.zhang.entity.Photo;import com.zhang.service.mainService;@Service(&quot;mainservice&quot;)public class mainServiceImpl implements mainService &#123; @Autowired private mainDao maindao; @Override public Photo getPhotoById(int id) &#123; return maindao.getPhotoNameById(id); &#125;&#125; dao实现类12345678910111213141516171819package com.zhang.dao.impl;import org.springframework.stereotype.Repository;import com.zhang.dao.mainDao;import com.zhang.entity.Photo;@Repository(&quot;maindao&quot;)public class mainDaoImpl implements mainDao &#123; @Override public Photo getPhotoNameById(int id) &#123; Photo p = new Photo(); p.setId(123); p.setName(&quot;雪山行纪念照&quot;); return p; &#125;&#125; 实体类photo1234567891011121314151617package com.zhang.entity;public class Photo &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 启动项目 项目默认端口为8080，在浏览器中访问刚才的controller会看到： 如上，一个REST风格的MVC架构的demo项目就搭建完成了。]]></content>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
</search>
