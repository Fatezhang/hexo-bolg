<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Java 并发编程（一）</title>

    <link href="https://cdn.bootcss.com/reveal.js/3.8.0/css/reveal.css" rel="stylesheet">
    <link href="https://cdn.bootcss.com/reveal.js/1.4.0/css/reset.css" rel="stylesheet">
    <link href="https://cdn.bootcss.com/reveal.js/3.8.0/css/theme/black.css" rel="stylesheet">
    <link href="https://cdn.bootcss.com/reveal.js/3.8.0/lib/css/monokai.css" rel="stylesheet">
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ?
            'https://cdn.bootcss.com/reveal.js/3.8.0/css/print/pdf.css' :
            'https://cdn.bootcss.com/reveal.js/3.8.0/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-markdown>
            # 如何编写一个线程安全的单例？
            ![单身狗](images/dsg.jpg)
        </section>
        <section>
            <section data-markdown>
                ## 什么是线程？
            </section>
            <section data-transition="zoom">
                <img src="images/hkdg.jpg"/>
                <p class="fragment fade-left">线程是操作系统进行运算调度的最小单位。包含在进程之中，属于进程中任务的实际运作单元。</p>
                <p class="fragment fade-right">一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
                <p class="fragment fade-left">线程的实现可以使用内核线程（操作系统内核调度）或用户线程（用户自行调度）或内核线程混合用户线程</p>
                <p class="fragment fade-right">同一个进程中的多个线程，可以共享该进程所拥有的资源，以此可以实现线程中的相互通信</p>
            </section>
        </section>
        <section>
            <section data-markdown>
                ## 多线程的好处？
            </section>
            <section>
                <img src="images/luobin.jpg"/>
                <p class="fragment fade-up">多核多处理器的普及，使得计算机进行多任务处理成为一项必备技能</p>
                <p class="fragment fade-up">计算机的运算能力远大于进行 I/O 操作，网络通信，数据库操作</p>
                <p class="fragment fade-up">将等待计算机进行 I/O 操作（存储、通信）的时间节约出来去同时处理其他任务</p>
                <p class="fragment fade-up">并行处理多个互不依赖的任务</p>
                <p class="fragment fade-up">将复杂的程序架构解耦开，使其设计简单化，不同的线程去处理不同类型的工作</p>
            </section>
        </section>
        <section>
            <section data-markdown>## 什么是线程安全？</section>
            <section data-markdown>
                <script type="text/template">
                    ```java
                    public class NumberMachine {

                        private int number;

                        public int getNextNumber(){
                            return ++number;
                        }
                    }
                    ```
                    ![slt](images/number.png) <!-- .element: class="fragment" data-fragment-index="1" -->
                </script>
            </section>
            <section>
                如果一个对象能够被多个线程访问，那么在使用这个对象的时候就需要注意是否要保证其线程安全，
                当对象中有可变状态的时候，多个线程对其的读取与使用都会相互影响。
                这个时候就需要保证对于对象可变状态的访问，使用一种同步机制进行控制。
                <p class="fragment current-visible">那么什么是线程安全的定义呢？</p>
                <p class="fragment current-visible">可以在多个线程中使用，并且线程间不会出现错误的交互？</p>
                <p class="fragment current-visible">可以同时被多个线程调用，而调用者无需执行额外的操作？</p>
                <p class="fragment fade-up">
                    当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在调用方代码中不需要引入额外的同步或协同，
                    这个类都能够表现出正确的行为，那么就称这个类是线程安全的。
                </p>
            </section>
        </section>
        <section>
            <section data-markdown>
                ## 如何确保一个类是线程安全的？
            </section>
            <section data-markdown>
                <script type="text/template">
                    ```java
                    public class NumberMachine {
                        private final int number = 0;

                        public int getNextNumber() {
                            return number + 1;
                        }
                    }
                    ```
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ```java
                    public class NumberMachine {

                        public int getNextNumber() {
                            int number = 0;
                            return number + 1;
                        }
                    }
                    ```
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ```java
                    public class NumberMachine {
                        private int number;

                        public synchronized int getNextNumber(){
                            return ++number;
                        }
                    }
                    ```
                    ![slt](images/number2.png) <!-- .element: class="fragment" data-fragment-index="1" -->
                </script>
            </section>
            <section>
                <p class="fragment fade-up">不在线程间共享该状态变量</p>
                <p class="fragment fade-up">将状态变量修改为不可变的</p>
                <p class="fragment fade-up">在访问该状态变量的时候使用同步机制</p>
            </section>
        </section>
        <section>
            <section data-markdown>
                ## 出现线程安全问题的本质原因
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### 物理机中的并发问题

                    实际上绝大多数的运算任务都不是简单地靠处理器的“计算”（在寄存器中）就能完成的。处理器至少要与内存交互，如读取运算数据、存储运算结果。
                    这个 I/O 操作很难消除，而由于存储设备与处理器之间的运算速度有着数量级差距，所以现代计算机都会加一层高速缓存作为计算缓冲。
                    但是这样也带来了缓存一致性问题。多处理器系统中，每个处理器都有自己的高速缓存，又使用同一个主内存，那么当多个处理器同时处理数据的时候，
                    同步回主内存时以谁的数据为准？这个时候各个处理器都需要遵循一些协议（MSI, MESI, Dragon, Protocol等），在读写时根据协议来进行操作。<!-- .element: class="fragment" -->

                    除了增加高速缓存之外，处理器会对输入代码进行重排序优化，并在计算之后将乱序结果充组保证该结果与顺序执行的结果是一致的。
                    在 Java 虚拟机中也存在指令重排序。<!-- .element: class="fragment" -->
                </script>
            </section>
            <section data-markdown>
                ![cpu](images/cpuncmx.png)
            </section>
        </section>
        <section>
            <section>
                <h2>Java 内存模型 -- Java Memory Model</h2>
            </section>
            <section data-transition="zoom">
                <p class="fragment fade-up"><img alt="Java 内存结构" src="images/javancjg.png"/></p>
            </section>
            <section id="ttt">
                <p class="fragment fade-up"><img src="images/javancmx.png"/></p>
            </section>
            <section data-markdown>
                <script type="text/template">
                    - Java 内存模型主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存读取这样的底层细节。
                    - Java 内存模型规定了所有的变量都存储在主内存之中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存的副本。<!-- .element: class="fragment" -->
                    - 线程对变量的所有操作都必须在工作内存之中进行，而不能直接读写主内存之中的变量。<!-- .element: class="fragment" -->
                    - 不同的线程之间也无法访问其他线程的工作内存中的变量，线程之间变量值的传递只能通过主内存完成。<!-- .element: class="fragment" -->
                    [如图](#/ttt) <!-- .element: class="fragment" -->
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### 主内存与工作内存的交互协议

                    - lock: 把一个主内存变量标记为线程独占🔒 <!-- .element: class="fragment" -->
                    - unlock: 将处于🔒状态的主内存变量🔓 <!-- .element: class="fragment" -->
                    - read: 读取主内存的变量到工作内存 <!-- .element: class="fragment" -->
                    - load: 将 read 操作读取到的主内存变量放到工作内存的变量副本中 <!-- .element: class="fragment" -->
                    - use: 将工作内存中的变量值传递给执行器 <!-- .element: class="fragment" -->
                    - assign: 将执行完成的结果赋给工作内存的变量 <!-- .element: class="fragment" -->
                    - store: 将工作内存的变量传递到主内存中 <!-- .element: class="fragment" -->
                    - write: 将从 store 操作得到的值写回主内存 <!-- .element: class="fragment" -->
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### 虚拟机执行上述 8 种操作时满足以下规则：

                    - read+load, store+write 成对出现 <!-- .element: class="fragment" -->
                    - 不允许一个线程丢弃它最近的 assign 操作 <!-- .element: class="fragment" -->
                    - 不允许一个线程未 assign 就把变量同步回主内存中 <!-- .element: class="fragment" -->
                    - 不允许在工作内存中直接使用一个未被初始化的变量 <!-- .element: class="fragment" -->
                    - 一个变量同一时刻只允许一条线程对其进行初始化操作，lock 几次就需要 unlock 几次 <!-- .element: class="fragment" -->
                    - 如果对一个变量执行 lock 操作，就会清空工作内存中该变量的值，在执行器使用这个变量前，需要重新 load/assign <!-- .element: class="fragment" -->
                    - 不允许 unlock 一个未被🔒或者被其他线程🔒的变量 <!-- .element: class="fragment" -->
                    - 对一个变量进行 unlock 前，必须先将变量值同步回主内存 <!-- .element: class="fragment" -->
                </script>
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### 实现线程安全的原理

                    ##### 基于 Java 内存模型对于多个线程访问同一个共享变量进行数据一致性控制 <!-- .element: class="fragment" -->

                    |   原子性   |   可见性   |   有序性   |
                    | ---- | ---- | ---- |
                    |   ![](images/yuanzi.jpg)   |   ![](images/kejianxing.jpg)   |   ![](images/youxuxing.jpg)   |

                </script>
            </section>
        </section>
        <section>
            <section><h2>能够实现线程安全的相关的关键字和类</h2></section>
            <section data-markdown>
                <script type="text/template">
                    - synchronized <!-- .element: class="fragment" -->
                    - final <!-- .element: class="fragment" -->
                    - volatile <!-- .element: class="fragment" -->
                    - CAS/Atomic 原子变量 <!-- .element: class="fragment" -->
                    - J.U.C 包 <!-- .element: class="fragment" -->
                        - Lock <!-- .element: class="fragment" -->
                        - ConcurrentHashMap <!-- .element: class="fragment" -->
                        - ... <!-- .element: class="fragment" -->
                    - ... <!-- .element: class="fragment" -->
                </script>
            </section>
        </section>
        <section>
            <section>
                <h2>Happen-Before 原则</h2>

                <code>Happen-Before 原则是判断数据是否存在竞争、线程是否安全的主要依据，依靠以下规则就可以判断并发环境下两个操作之间是否可能存在冲突</code>
            </section>
            <section data-markdown>
                - 程序次序原则：同一个线程内按照程序控制流顺序执行
                - 管程锁定原则：加锁在解锁后执行
                - volatile 原则：对于 volatile 变量的读操作必定发生在其写操作之后
                - 线程启动原则：Thread 的 start() 方法必定发生在该线程执行其他代码之前
                - 线程终止原则：线程终止检测必定发生在其他操作之后
                - 线程中断原则：对线程的 interrupt() 方法先行发生于其中断检测
                - 对象终结原则：对象的初始化完成先行发生于它的 finalize() 方法的开始
                - 传递性：以上先行发生操作具有传递性
            </section>
            <section data-markdown>
                ```java
                public class example {

                    private int value = 0;

                    public int getValue() {
                        return value;
                    }

                    public void setValue(int value) {
                        this.value = value;
                    }
                }
                ```
                ![](images/hpbf.png)
            </section>
        </section>
        <section>
            <section data-markdown>
                ## [编写线程安全的单例类](/blog/20190607/深度分析如何写出一个线程安全的单例)
            </section>
            <section data-markdown>
                <script type="text/template">
                    ### 什么是单例？

                    - 单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。<!-- .element: class="fragment" -->

                    ### 常见的几种单例的写法<!-- .element: class="fragment" -->

                    - 懒汉式
                    - 饿汉式
                    - 静态内部类
                    - 枚举单例
                </script>
            </section>
        </section>
        <section>
            <section>
                <h2>使用 CountDownLatch 进行并发测试</h2>
            </section>
            <section data-markdown>
                ![cdl](images/cdl.png)
            </section>
        </section>
    </div>
</div>
<script src="https://cdn.bootcss.com/reveal.js/3.8.0/js/reveal.js"></script>

<script>
    Reveal.initialize({
        dependencies: [
            {src: 'https://cdn.bootcss.com/reveal.js/3.8.0/plugin/markdown/marked.js'},
            {src: 'https://cdn.bootcss.com/reveal.js/3.7.0/plugin/markdown/markdown.js'},
            {src: 'https://cdn.bootcss.com/reveal.js/3.8.0/plugin/notes/notes.js', async: true},
            {src: 'https://cdn.bootcss.com/reveal.js/3.7.0/plugin/highlight/highlight.js', async: true},
            {src: "https://cdn.bootcss.com/reveal.js/3.8.0/plugin/highlight/highlight.min.js", async: true},
            {src: "https://cdn.bootcss.com/reveal.js/3.8.0/plugin/zoom-js/zoom.min.js", async: true}
        ],
        slideNumber: 'c/t',
        transaction: 'convex',
        width: 1360,
        height: 1280,
        history: true,
        markdown: {
            smartypants: true
        }
    });
</script>
</body>
</html>
